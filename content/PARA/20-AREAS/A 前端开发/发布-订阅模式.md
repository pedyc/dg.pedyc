---
title: 发布-订阅模式
description: 发布-订阅模式是一种消息传递模式，发布者（Publisher）发布消息，订阅者（Subscriber）订阅感兴趣的消息，通过消息代理（Broker）进行解耦。
tags: [前端开发, 设计模式]
date-created: 2025-06-02
date-modified: 2025-06-02
content-type: method
keywords: [发布-订阅模式, Publish-Subscribe Pattern]
para: AREA
related: ["[[设计模式]]", "[[观察者模式]]"]
zettel: permanent
---

## 问题定义

如何在对象之间建立一种松散耦合的通信机制，使得发布者和订阅者之间不需要知道彼此的存在，从而提高系统的灵活性和可扩展性？

## 步骤与流程

1. **创建消息代理（Broker）：** 创建一个消息代理，用于管理发布者和订阅者之间的消息传递。
2. **定义发布者（Publisher）：** 发布者将消息发布到消息代理。
3. **定义订阅者（Subscriber）：** 订阅者向消息代理订阅感兴趣的消息类型。
4. **消息传递：** 当发布者发布消息时，消息代理将消息传递给所有订阅了该消息类型的订阅者。

## 前端示例

```javascript
// 消息代理
class Broker {
  constructor() {
    this.topics = {};
  }

  subscribe(topic, subscriber) {
    if (!this.topics[topic]) {
      this.topics[topic] = [];
    }
    this.topics[topic].push(subscriber);
  }

  publish(topic, data) {
    if (this.topics[topic]) {
      this.topics[topic].forEach(subscriber => subscriber(data));
    }
  }
}

// 发布者
class Publisher {
  constructor(broker) {
    this.broker = broker;
  }

  publish(topic, data) {
    this.broker.publish(topic, data);
  }
}

// 订阅者
class Subscriber {
  constructor(broker, topic, callback) {
    this.broker = broker;
    this.topic = topic;
    this.callback = callback;
    this.broker.subscribe(topic, callback);
  }
}

// 客户端代码
const broker = new Broker();
const publisher = new Publisher(broker);

const subscriber1 = new Subscriber(broker, "topic1", data => {
  console.log("Subscriber 1 received:", data);
});

const subscriber2 = new Subscriber(broker, "topic1", data => {
  console.log("Subscriber 2 received:", data);
});

publisher.publish("topic1", "Hello, subscribers!");
// Output:
// Subscriber 1 received: Hello, subscribers!
// Subscriber 2 received: Hello, subscribers!
```

## 应用场景

1. **事件驱动架构：** 使用发布 - 订阅模式构建事件驱动架构，实现异步通信和解耦。
2. **消息队列：** 使用发布 - 订阅模式实现消息队列，用于处理高并发和异步任务。
3. **实时通信：** 使用发布 - 订阅模式实现实时通信，如聊天应用和在线游戏。
4. **组件通信：** 使用发布 - 订阅模式实现组件之间的通信，提高组件的可重用性和灵活性。
5. **状态管理：** 使用发布 - 订阅模式管理应用程序的状态，当状态发生改变时，通知相关的组件。

## 注意事项

1. **消息丢失：** 在某些情况下，消息可能会丢失，需要考虑消息持久化和重试机制。
2. **消息顺序：** 消息的顺序可能无法保证，需要根据具体需求进行处理。
3. **性能问题：** 如果订阅者数量过多，可能会导致性能问题，需要考虑优化消息传递机制。

## 参考资料

- Refactoring Guru: [https://refactoring.guru/design-patterns/publish-subscribe](https://refactoring.guru/design-patterns/publish-subscribe)
- MDN Web Docs: [https://developer.mozilla.org/](https://developer.mozilla.org/)
