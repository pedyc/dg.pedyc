---
title: 最深叶节点的最近公共祖先
tags: [树, 深度优先搜索, 广度优先搜索, 哈希表, 二叉树]
date-created: 2025-04-04
date-modified: 2025-04-04
---

## 题目

https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/description/?envType=daily-question&envId=2025-04-04

给你一个有根节点 `root` 的二叉树，返回它 _最深的叶节点的最近公共祖先_ 。

回想一下：

- **叶节点** 是二叉树中没有子节点的节点
- 树的根节点的 **深度** 为 `0`，如果某一节点的深度为 `d`，那它的子节点的深度就是 `d+1`
- 如果我们假定 `A` 是一组节点 `S` 的 **最近公共祖先**，`S` 中的每个节点都在以 `A` 为根节点的子树中，且 `A` 的深度达到此条件下可能的最大值。

## 实现

> [!hint]
> 思路：遍历每个字符作为回文中心，向左右扩展寻找最长回文。
> 注意：奇偶情况
> 复杂度分析：
> 	- 时间复杂度：$O(n^2)$
> 	- 空间复杂度：$O(1)$
> 关联资源：[[基础数据结构及常用算法汇总#深度优先搜索]]、[[基础数据结构及常用算法汇总#广度优先搜索]]

```javascript
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
    if (s.length < 2) return s;
    
    let start = 0, maxLength = 1;
    
    // 中心扩展函数
    const expandAroundCenter = (left, right) => {
        while (left >= 0 && right < s.length && s[left] === s[right]) {
            const currentLength = right - left + 1;
            if (currentLength > maxLength) {
                maxLength = currentLength;
                start = left;
            }
            left--;
            right++;
        }
    };
    
    for (let i = 0; i < s.length; i++) {
        expandAroundCenter(i, i);    // 奇数长度回文（中心为单个字符）
        expandAroundCenter(i, i + 1); // 偶数长度回文（中心为两个字符）
    }
    
    return s.slice(start, start + maxLength);
};

// 辅助函数：判断是否为回文（修正版）
var isPalindrome = function(s) {
    return s === s.split('').reverse().join('');
};
```
