"use strict"
;(() => {
  var VA = Object.create
  var ac = Object.defineProperty
  var $A = Object.getOwnPropertyDescriptor
  var XA = Object.getOwnPropertyNames
  var YA = Object.getPrototypeOf,
    KA = Object.prototype.hasOwnProperty
  var d = (r, e) => () => (r && (e = r((r = 0))), e)
  var ga = (r, e) => () => (e || r((e = { exports: {} }).exports, e), e.exports),
    uc = (r, e) => {
      for (var t in e) ac(r, t, { get: e[t], enumerable: !0 })
    },
    jA = (r, e, t, i) => {
      if ((e && typeof e == "object") || typeof e == "function")
        for (let n of XA(e))
          !KA.call(r, n) &&
            n !== t &&
            ac(r, n, { get: () => e[n], enumerable: !(i = $A(e, n)) || i.enumerable })
      return r
    }
  var Un = (r, e, t) => (
    (t = r != null ? VA(YA(r)) : {}),
    jA(e || !r || !r.__esModule ? ac(t, "default", { value: r, enumerable: !0 }) : t, r)
  )
  var lc,
    cc,
    hc = d(() => {
      "use strict"
      ;((lc = class r {
        static instance = null
        CACHE_PREFIXES = { content: "content_", link: "link_", search: "search_" }
        constructor() {}
        static getInstance() {
          return (r.instance || (r.instance = new r()), r.instance)
        }
        processURL(e, t = {}) {
          let {
            removeHash: i = !0,
            normalizePath: n = !0,
            validate: s = !0,
            cacheType: o = "content",
          } = t
          try {
            if (s && !this.isValidURL(e))
              return {
                original: e,
                processed: new URL("about:blank"),
                cacheKey: "",
                isValid: !1,
                error: "Invalid URL format",
              }
            let a = e
            i && (a = a.split("#")[0])
            let u = new URL(a)
            n && (u.pathname = this.normalizePath(u.pathname))
            let l = this.generateCacheKey(u.toString(), o)
            return (
              console.debug(`[URLHandler Debug] Cache Key: ${l}`),
              { original: e, processed: u, cacheKey: l, isValid: !0 }
            )
          } catch (a) {
            return {
              original: e,
              processed: new URL("about:blank"),
              cacheKey: "",
              isValid: !1,
              error: a.message,
            }
          }
        }
        getContentURL(e) {
          let t = this.processURL(e, {
            removeHash: !0,
            normalizePath: !0,
            validate: !0,
            cacheType: "content",
          })
          if (!t.isValid) throw new Error(`Invalid URL: ${e} - ${t.error}`)
          return t.processed
        }
        getCacheKey(e, t = "content") {
          return this.processURL(e, { cacheType: t }).cacheKey
        }
        processBatch(e, t = {}) {
          return e.map((i) => this.processURL(i, t))
        }
        isValidURL(e) {
          if (!e || typeof e != "string" || e.length === 0) return !1
          try {
            return (new URL(e), !0)
          } catch {
            return !1
          }
        }
        normalizePath(e) {
          if (
            (e.endsWith(".md") && (e = e.slice(0, -3)),
            e.endsWith("/index") && (e = e.slice(0, -6)),
            e.endsWith("/") && e.length > 1 && (e = e.slice(0, -1)),
            e === "")
          )
            return "/"
          let t = e.split("/").filter(Boolean),
            i = [],
            n = new Set()
          for (let o of t) n.has(o) || (n.add(o), i.push(o))
          return "/" + i.join("/")
        }
        generateCacheKey(e, t) {
          let i = encodeURIComponent(e)
          return `${this.CACHE_PREFIXES[t]}${i}`
        }
        isInternalLink(e) {
          try {
            return new URL(e).origin === window.location.origin
          } catch {
            return !1
          }
        }
        shouldPreload(e) {
          if (!this.isInternalLink(e)) return !1
          try {
            let t = new URL(e)
            return !(
              [".pdf", ".zip", ".rar", ".7z", ".tar", ".gz"].some((n) =>
                t.pathname.toLowerCase().endsWith(n),
              ) ||
              t.pathname.startsWith("/api/") ||
              t.pathname.startsWith("/admin/") ||
              (t.pathname === window.location.pathname && t.hash)
            )
          } catch {
            return !1
          }
        }
        isSamePage(e) {
          return e.origin === window.location.origin && e.pathname === window.location.pathname
        }
      }),
        (cc = lc.getInstance()))
    })
  var Yr,
    _e,
    NI,
    HI,
    zI,
    WI,
    VI,
    $I,
    Di,
    nm,
    XI,
    YI,
    KI,
    xa = d(() => {
      "use strict"
      hc()
      Kr()
      ;((Yr = (r) =>
        r
          ? r
              .toLowerCase()
              .replace(ie.CONVENTIONS.FORBIDDEN_CHARS, "")
              .replace(/\s+/g, ie.SEPARATOR)
              .replace(/_+/g, ie.SEPARATOR)
              .replace(/^_|_$/g, "")
              .substring(0, ie.CONVENTIONS.MAX_LENGTH)
          : ""),
        (_e = {
          generateContentKey: (r, e) => {
            let t = cc.processURL(r, { cacheType: "content" })
            if (!t.isValid)
              return (
                console.warn(`Invalid URL for cache key generation: ${r}`),
                `${ie.PREFIXES.CONTENT}invalid_${Yr(r)}`
              )
            let i = t.cacheKey
            return e ? `${i}${ie.SEPARATOR}${e}` : i
          },
          generateSearchKey: (r, e) => {
            let t = Yr(r)
            return e
              ? `${ie.PREFIXES.SEARCH}${t}${ie.SEPARATOR}${Yr(e)}`
              : `${ie.PREFIXES.SEARCH}${t}`
          },
          generateUserKey: (r, e) => {
            let t = Yr(r)
            return e ? `${ie.PREFIXES.USER}${e}${ie.SEPARATOR}${t}` : `${ie.PREFIXES.USER}${t}`
          },
          generateFontKey: (r, e) => {
            let t = Yr(r)
            return e ? `${ie.PREFIXES.FONT}${t}${ie.SEPARATOR}${e}` : `${ie.PREFIXES.FONT}${t}`
          },
          generateSystemKey: (r, e) => {
            let t = Yr(r)
            return e
              ? `${ie.PREFIXES.SYSTEM}${t}${ie.SEPARATOR}${Yr(e)}`
              : `${ie.PREFIXES.SYSTEM}${t}`
          },
          identifyType: (r) => {
            let e = Object.entries(ie.PREFIXES)
            for (let [t, i] of e) if (r.startsWith(i)) return t
            return null
          },
          extractOriginalKey: (r) => {
            let e = Object.values(ie.PREFIXES)
            for (let t of e) if (r.startsWith(t)) return r.substring(t.length)
            return r
          },
          generateStorageKey: (r, e) =>
            _e.identifyType(r)
              ? r
              : `${{ MEMORY: ie.PREFIXES.CONTENT, SESSION: ie.PREFIXES.CONTENT }[e] || ie.PREFIXES.CONTENT}${r}`,
          validateKeyFormat: (r) => {
            let e = [],
              t = []
            return (
              (!r || r.length === 0) &&
                (e.push("\u952E\u4E0D\u80FD\u4E3A\u7A7A"),
                t.push("\u63D0\u4F9B\u4E00\u4E2A\u975E\u7A7A\u7684\u952E")),
              r.length > ie.CONVENTIONS.MAX_LENGTH &&
                (e.push(`\u952E\u8FC7\u957F: ${r.length} > ${ie.CONVENTIONS.MAX_LENGTH}`),
                t.push("\u7F29\u77ED\u952E\u540D\u6216\u4F7F\u7528\u54C8\u5E0C\u503C")),
              ie.CONVENTIONS.FORBIDDEN_CHARS.test(r) &&
                (e.push("\u952E\u5305\u542B\u7981\u7528\u5B57\u7B26"),
                t.push("\u79FB\u9664\u952E\u4E2D\u7684\u7279\u6B8A\u5B57\u7B26")),
              _e.identifyType(r) ||
                (e.push("\u952E\u7F3A\u5C11\u5FC5\u9700\u7684\u524D\u7F00"),
                t.push("\u4E3A\u952E\u6DFB\u52A0\u9002\u5F53\u7684\u524D\u7F00")),
              { isValid: e.length === 0, issues: e, suggestions: t }
            )
          },
          parseKey: (r) => {
            let e = _e.identifyType(r),
              t = Object.values(ie.PREFIXES).find((s) => r.startsWith(s)) || null,
              i = _e.extractOriginalKey(r),
              n = _e.validateKeyFormat(r)
            return { original: i, type: e, prefix: t, isValid: n.isValid }
          },
        }),
        ({
          generateContentKey: NI,
          generateSearchKey: HI,
          generateUserKey: zI,
          generateFontKey: WI,
          generateSystemKey: VI,
          identifyType: $I,
          extractOriginalKey: Di,
          generateStorageKey: nm,
          validateKeyFormat: XI,
          parseKey: YI,
        } = _e),
        (KI = {
          identifyType: _e.identifyType,
          extractOriginalKey: _e.extractOriginalKey,
          generateStorageKey: _e.generateStorageKey,
          validateKey: _e.validateKeyFormat,
          parseKey: _e.parseKey,
        }))
    })
  function Pi(r) {
    return om[r] || om.DEFAULT
  }
  var ie,
    om,
    _a,
    ya,
    ZI,
    am,
    QI,
    vr,
    Kr = d(() => {
      "use strict"
      xa()
      ;((ie = {
        PREFIXES: {
          CONTENT: "content_",
          LINK: "link_",
          SEARCH: "search_",
          FONT: "font_",
          USER: "user_",
          SYSTEM: "sys_",
        },
        SEPARATOR: "_",
        CONVENTIONS: { CASE_STYLE: "snake_case", MAX_LENGTH: 100, FORBIDDEN_CHARS: /[^a-z0-9_-]/g },
      }),
        (om = {
          CONTENT: {
            capacity: 200,
            ttl: 15 * 60 * 1e3,
            maxMemoryMB: 30,
            warningThreshold: 160,
            description:
              "\u7EDF\u4E00\u5185\u5BB9\u7F13\u5B58\uFF0C\u652F\u6301\u9875\u9762\u548C\u5F39\u7A97\u5185\u5BB9",
            keyPrefix: ie.PREFIXES.CONTENT,
            cleanupIntervalMs: 3 * 60 * 1e3,
            memoryThreshold: 0.85,
          },
          LINK: {
            capacity: 1e3,
            ttl: 60 * 60 * 1e3,
            maxMemoryMB: 15,
            warningThreshold: 800,
            description: "\u94FE\u63A5\u6709\u6548\u6027\u548C\u5931\u8D25\u94FE\u63A5\u7F13\u5B58",
            keyPrefix: ie.PREFIXES.LINK,
            cleanupIntervalMs: 10 * 60 * 1e3,
            memoryThreshold: 0.8,
          },
          SEARCH: {
            capacity: 500,
            ttl: 60 * 60 * 1e3,
            maxMemoryMB: 50,
            warningThreshold: 400,
            description: "\u641C\u7D22\u7ED3\u679C\u548C\u5185\u5BB9\u9884\u89C8\u7F13\u5B58",
            keyPrefix: ie.PREFIXES.SEARCH,
            cleanupIntervalMs: 5 * 60 * 1e3,
            memoryThreshold: 0.8,
          },
          USER: {
            capacity: 100,
            ttl: 24 * 60 * 60 * 1e3,
            maxMemoryMB: 5,
            warningThreshold: 80,
            description: "\u7528\u6237\u504F\u597D\u548C\u8BBE\u7F6E\u7F13\u5B58",
            keyPrefix: ie.PREFIXES.USER,
            cleanupIntervalMs: 30 * 60 * 1e3,
            memoryThreshold: 0.9,
          },
          SYSTEM: {
            capacity: 200,
            ttl: 60 * 60 * 1e3,
            maxMemoryMB: 10,
            warningThreshold: 160,
            description: "\u7CFB\u7EDF\u7EC4\u4EF6\u548C\u914D\u7F6E\u7F13\u5B58",
            keyPrefix: ie.PREFIXES.SYSTEM,
            cleanupIntervalMs: 15 * 60 * 1e3,
            memoryThreshold: 0.8,
          },
          DEFAULT: {
            capacity: 100,
            ttl: 10 * 60 * 1e3,
            maxMemoryMB: 5,
            warningThreshold: 80,
            description: "\u9ED8\u8BA4\u7F13\u5B58\u914D\u7F6E",
            keyPrefix: ie.PREFIXES.SYSTEM,
            cleanupIntervalMs: 5 * 60 * 1e3,
            memoryThreshold: 0.8,
          },
        }),
        (_a = {
          MEMORY: {
            capacityRatio: 0.6,
            maxSizeKB: 500,
            priority: 3,
            description:
              "\u5185\u5B58\u5C42 - \u6700\u5FEB\u8BBF\u95EE\uFF0C\u5B58\u50A8\u70ED\u6570\u636E",
          },
          SESSION: {
            capacityRatio: 0.2,
            maxSizeKB: 1e3,
            priority: 2,
            description:
              "\u4F1A\u8BDD\u5C42 - \u9875\u9762\u5237\u65B0\u4FDD\u7559\uFF0C\u5B58\u50A8\u91CD\u8981\u6570\u636E",
          },
          LOCAL: {
            capacityRatio: 0.2,
            maxSizeKB: 1e3,
            priority: 2,
            description:
              "\u672C\u5730\u5C42 - \u957F\u671F\u5B58\u50A8\uFF0C\u5B58\u50A8\u957F\u671F\u6570\u636E",
          },
        }),
        (ya = {
          LARGE_CONTENT_SIZE: 1024 * 1024,
          HUGE_CONTENT_SIZE: 5 * 1024 * 1024,
          MAX_MEMORY_USAGE: 50 * 1024 * 1024,
          MEMORY_CLEANUP_THRESHOLD: 0.8,
          SESSION_CLEANUP_THRESHOLD: 0.9,
          MAX_REFERENCE_COUNT: 1e3,
          HASH_COLLISION_THRESHOLD: 10,
        }),
        (ZI = {
          MAX_KEY_LENGTH: 256,
          FORBIDDEN_CHARS: /[\s<>:"/\\|?*]/,
          REQUIRED_PREFIX: !0,
          MIN_CONTENT_LENGTH: 1,
          MAX_CONTENT_LENGTH: 10 * 1024 * 1024,
          KEY_FORMAT_REGEX: /^[a-z0-9_-]+$/,
        }),
        (am = {
          BATCH_SIZE: 10,
          MAX_CONCURRENT_PRELOADS: 3,
          HIT_RATE_WARNING_THRESHOLD: 0.7,
          MEMORY_CHECK_INTERVAL: 30 * 1e3,
          AUTO_CLEANUP_THRESHOLD: 0.9,
          PRELOAD_STRATEGY: { enabled: !0, count: 5, delay: 100 },
          MONITORING: {
            ENABLE_MONITORING: !0,
            MONITOR_INTERVAL: 5 * 60 * 1e3,
            REPORT_INTERVAL: 30 * 60 * 1e3,
            CONSOLE_WARNINGS: !0,
            ENABLE_KEY_VALIDATION: !0,
          },
        }))
      ;((QI = {
        content: _e.generateContentKey,
        search: _e.generateSearchKey,
        font: _e.generateFontKey,
        user: _e.generateUserKey,
        system: _e.generateSystemKey,
      }),
        (vr = {
          ENABLE_MONITORING: !0,
          MONITOR_INTERVAL: 5 * 60 * 1e3,
          REPORT_INTERVAL: 30 * 60 * 1e3,
          CONSOLE_WARNINGS: !0,
          ENABLE_KEY_VALIDATION: !0,
        }))
    })
  var On,
    dc,
    Ln,
    fc = d(() => {
      "use strict"
      Kr()
      ;((On = class {
        constructor(e, t, i = null, n = null) {
          this.key = e
          this.value = t
          this.prev = i
          this.next = n
        }
      }),
        (dc = class {
          constructor(e) {
            this.capacity = e
            ;((this.head = new On("__head__", {})),
              (this.tail = new On("__tail__", {})),
              (this.head.next = this.tail),
              (this.tail.prev = this.head))
          }
          cache = new Map()
          head
          tail
          addToHead(e) {
            ;((e.prev = this.head),
              (e.next = this.head.next),
              (this.head.next.prev = e),
              (this.head.next = e))
          }
          removeNode(e) {
            ;((e.prev.next = e.next), (e.next.prev = e.prev))
          }
          moveToHead(e) {
            ;(this.removeNode(e), this.addToHead(e))
          }
          removeTail() {
            let e = this.tail.prev
            return e === this.head ? null : (this.removeNode(e), e)
          }
          get(e) {
            let t = this.cache.get(e)
            return t ? (this.moveToHead(t), t.value) : null
          }
          set(e, t) {
            let i = this.cache.get(e)
            if (i) return ((i.value = t), this.moveToHead(i), null)
            let n = new On(e, t),
              s = null
            return (
              this.cache.size >= this.capacity &&
                ((s = this.removeTail()), s && this.cache.delete(s.key)),
              this.cache.set(e, n),
              this.addToHead(n),
              s
            )
          }
          delete(e) {
            let t = this.cache.get(e)
            return t ? (this.removeNode(t), this.cache.delete(e), t.value) : null
          }
          has(e) {
            return this.cache.has(e)
          }
          clear() {
            ;(this.cache.clear(), (this.head.next = this.tail), (this.tail.prev = this.head))
          }
          get size() {
            return this.cache.size
          }
          keys() {
            return Array.from(this.cache.keys())
          }
          values() {
            return Array.from(this.cache.values()).map((e) => e.value)
          }
        }),
        (Ln = class {
          cache
          config
          currentMemoryUsage = 0
          totalHits = 0
          totalRequests = 0
          cleanupInterval = null
          constructor(e) {
            let t = Object.fromEntries(Object.entries(e).filter(([, n]) => n !== void 0)),
              i = Pi("DEFAULT")
            ;((this.config = {
              capacity: i.capacity,
              ttl: i.ttl,
              maxMemoryMB: i.maxMemoryMB,
              warningThreshold: i.warningThreshold,
              description: i.description,
              keyPrefix: i.keyPrefix,
              cleanupIntervalMs: i.cleanupIntervalMs,
              memoryThreshold: i.memoryThreshold,
              ...t,
            }),
              (this.cache = new dc(this.config.capacity)),
              this.startPeriodicCleanup())
          }
          estimateSize(e) {
            if (e == null) return 8
            switch (typeof e) {
              case "string":
                return e.length * 2 + 24
              case "number":
                return 8
              case "boolean":
                return 4
              case "bigint":
                return e.toString().length + 16
              case "symbol":
                return 8
              case "function":
                return e.toString().length * 2 + 32
              case "object":
                if (e instanceof Date) return 24
                if (e instanceof RegExp) return e.source.length * 2 + 32
                if (Array.isArray(e)) return e.reduce((t, i) => t + this.estimateSize(i), 24)
                try {
                  return JSON.stringify(e).length * 2 + 32
                } catch {
                  return 1024
                }
              default:
                return 8
            }
          }
          startPeriodicCleanup() {
            typeof window > "u" ||
              (this.stopPeriodicCleanup(),
              (this.cleanupInterval = window.setInterval(() => {
                this.cleanup()
              }, this.config.cleanupIntervalMs)))
          }
          stopPeriodicCleanup() {
            this.cleanupInterval &&
              typeof window < "u" &&
              (clearInterval(this.cleanupInterval), (this.cleanupInterval = null))
          }
          set(e, t, i = 30 * 60 * 1e3) {
            try {
              let n = this.estimateSize(t),
                s = this.config.maxMemoryMB * 1024 * 1024
              if (
                this.currentMemoryUsage + n > s &&
                (this.cleanup(), this.currentMemoryUsage + n > s)
              )
                return (
                  console.warn(
                    `\u7F13\u5B58\u5185\u5B58\u4E0D\u8DB3\uFF0C\u65E0\u6CD5\u6DFB\u52A0\u952E: ${e}\uFF0C\u9700\u8981 ${n} \u5B57\u8282`,
                  ),
                  !1
                )
              let o = { data: t, timestamp: Date.now(), ttl: i, size: n, accessCount: 0 },
                a = this.cache.set(e, o)
              if ((a && (this.currentMemoryUsage -= a.value.size), a))
                this.currentMemoryUsage -= a.value.size
              else {
                let u = this.cache.get(e)
                u && u !== o && (this.currentMemoryUsage -= u.size)
              }
              return ((this.currentMemoryUsage += n), !0)
            } catch (n) {
              return (
                console.error(`\u8BBE\u7F6E\u7F13\u5B58\u9879\u5931\u8D25\uFF0C\u952E: ${e}`, n),
                !1
              )
            }
          }
          get(e) {
            this.totalRequests++
            try {
              let t = this.cache.get(e)
              if (!t) return null
              if (Date.now() - t.timestamp > t.ttl) return (this.delete(e), null)
              let i = { ...t, accessCount: t.accessCount + 1 }
              return (this.cache.set(e, i), this.totalHits++, t.data)
            } catch (t) {
              return (
                console.error(`\u83B7\u53D6\u7F13\u5B58\u9879\u5931\u8D25\uFF0C\u952E: ${e}`, t),
                null
              )
            }
          }
          has(e) {
            try {
              let t = this.cache.get(e)
              return t ? (Date.now() - t.timestamp > t.ttl ? (this.delete(e), !1) : !0) : !1
            } catch (t) {
              return (
                console.error(`\u68C0\u67E5\u7F13\u5B58\u9879\u5931\u8D25\uFF0C\u952E: ${e}`, t),
                !1
              )
            }
          }
          delete(e) {
            try {
              let t = this.cache.delete(e)
              return t ? ((this.currentMemoryUsage -= t.size), !0) : !1
            } catch (t) {
              return (
                console.error(`\u5220\u9664\u7F13\u5B58\u9879\u5931\u8D25\uFF0C\u952E: ${e}`, t),
                !1
              )
            }
          }
          cleanup() {
            try {
              let e = Date.now(),
                t = this.config.maxMemoryMB * 1024 * 1024,
                i = t * this.config.memoryThreshold,
                n = 0,
                s = 0,
                o = []
              for (let a of this.cache.keys()) {
                let u = this.cache.get(a)
                u && e - u.timestamp > u.ttl && o.push(a)
              }
              for (let a of o) {
                let u = this.cache.delete(a)
                u && ((s += u.size), (this.currentMemoryUsage -= u.size), n++)
              }
              if (this.currentMemoryUsage > i) {
                let a = this.cache
                  .values()
                  .map((u, l) => ({
                    key: this.cache.keys()[l],
                    item: u,
                    priority: u.size / Math.max(u.accessCount, 1),
                  }))
                  .sort((u, l) => l.priority - u.priority)
                for (let { key: u } of a) {
                  if (this.currentMemoryUsage <= i) break
                  let l = this.cache.delete(u)
                  l && ((s += l.size), (this.currentMemoryUsage -= l.size), n++)
                }
              }
              n > 0 &&
                console.log(
                  `\u7F13\u5B58\u6E05\u7406\u5B8C\u6210\uFF1A\u79FB\u9664 ${n} \u9879\uFF0C\u91CA\u653E ${(s / 1024).toFixed(2)} KB \u5185\u5B58\uFF0C\u5F53\u524D\u4F7F\u7528\u7387: ${((this.currentMemoryUsage / t) * 100).toFixed(1)}%`,
                )
            } catch (e) {
              console.error("\u7F13\u5B58\u6E05\u7406\u5931\u8D25:", e)
            }
          }
          getStats() {
            let e = this.config.maxMemoryMB * 1024 * 1024,
              t = this.totalRequests > 0 ? this.totalHits / this.totalRequests : 0
            return {
              size: this.cache.size,
              memoryUsage: this.currentMemoryUsage,
              maxMemoryUsage: e,
              memoryUsagePercentage: this.currentMemoryUsage / e,
              hitRate: t,
              keys: this.cache.keys(),
            }
          }
          getConfig() {
            return { ...this.config }
          }
          getItemInfo(e) {
            try {
              let t = this.cache.get(e)
              if (!t) return null
              let i = Date.now() - t.timestamp > t.ttl
              return { ...t, isExpired: i }
            } catch (t) {
              return (
                console.error(
                  `\u83B7\u53D6\u7F13\u5B58\u9879\u4FE1\u606F\u5931\u8D25\uFF0C\u952E: ${e}`,
                  t,
                ),
                null
              )
            }
          }
          clear() {
            try {
              ;(this.cache.clear(),
                (this.currentMemoryUsage = 0),
                (this.totalHits = 0),
                (this.totalRequests = 0),
                console.log("\u7F13\u5B58\u5DF2\u6E05\u7A7A"))
            } catch (e) {
              console.error("\u6E05\u7A7A\u7F13\u5B58\u5931\u8D25:", e)
            }
          }
          destroy() {
            try {
              ;(this.stopPeriodicCleanup(),
                this.clear(),
                console.log("\u7F13\u5B58\u7BA1\u7406\u5668\u5DF2\u9500\u6BC1"))
            } catch (e) {
              console.error("\u9500\u6BC1\u7F13\u5B58\u7BA1\u7406\u5668\u5931\u8D25:", e)
            }
          }
          forceCleanup() {
            this.cleanup()
          }
          resetStats() {
            ;((this.totalHits = 0), (this.totalRequests = 0))
          }
        }))
    })
  var Nn,
    pc = d(() => {
      "use strict"
      Nn = class {
        observers = new Set()
        timers = new Set()
        eventListeners = []
        abortControllers = new Set()
        cleanupTasks = []
        registerIntersectionObserver(e) {
          return (this.observers.add(e), e)
        }
        registerMutationObserver(e) {
          return (this.observers.add(e), e)
        }
        registerResizeObserver(e) {
          return (this.observers.add(e), e)
        }
        registerObserver(e) {
          return (this.observers.add(e), e)
        }
        registerTimer(e) {
          return (this.timers.add(e), e)
        }
        setTimeout(e, t) {
          let i = window.setTimeout(() => {
            ;(this.timers.delete(i), e())
          }, t)
          return this.registerTimer(i)
        }
        setInterval(e, t) {
          let i = window.setInterval(e, t)
          return this.registerTimer(i)
        }
        addEventListener(e, t, i, n) {
          this.eventListeners.some((o) => o.element === e && o.type === t && o.listener === i) ||
            (e.addEventListener(t, i, n),
            this.eventListeners.push({ element: e, type: t, listener: i, options: n }))
        }
        createAbortController() {
          let e = new AbortController()
          return (this.abortControllers.add(e), e)
        }
        registerAbortController(e) {
          return (this.abortControllers.add(e), e)
        }
        removeObserver(e) {
          this.observers.has(e) && (e.disconnect(), this.observers.delete(e))
        }
        removeTimer(e) {
          this.timers.has(e) && (clearTimeout(e), clearInterval(e), this.timers.delete(e))
        }
        clearTimeout(e) {
          this.timers.has(e) && (clearTimeout(e), this.timers.delete(e))
        }
        clearInterval(e) {
          this.timers.has(e) && (clearInterval(e), this.timers.delete(e))
        }
        removeEventListener(e, t, i, n) {
          e.removeEventListener(t, i, n)
          let s = this.eventListeners.findIndex(
            (o) => o.element === e && o.type === t && o.listener === i,
          )
          s !== -1 && this.eventListeners.splice(s, 1)
        }
        abortController(e) {
          this.abortControllers.has(e) && (e.abort(), this.abortControllers.delete(e))
        }
        getStats() {
          let e = {}
          this.observers.forEach((i) => {
            let n = i.constructor.name
            e[n] = (e[n] || 0) + 1
          })
          let t = {}
          return (
            this.eventListeners.forEach(({ type: i }) => {
              t[i] = (t[i] || 0) + 1
            }),
            {
              observers: this.observers.size,
              timers: this.timers.size,
              eventListeners: this.eventListeners.length,
              abortControllers: this.abortControllers.size,
              details: { observerTypes: e, eventTypes: t },
            }
          )
        }
        cleanupObserversAndListeners() {
          ;(this.observers.forEach((e) => {
            try {
              e.disconnect()
            } catch (t) {
              console.error("\u6E05\u7406\u89C2\u5BDF\u5668\u65F6\u51FA\u9519:", t)
            }
          }),
            this.observers.clear(),
            this.timers.forEach((e) => {
              try {
                ;(clearTimeout(e), clearInterval(e))
              } catch (t) {
                console.error("\u6E05\u7406\u5B9A\u65F6\u5668\u65F6\u51FA\u9519:", t)
              }
            }),
            this.timers.clear(),
            this.eventListeners.forEach(({ element: e, type: t, listener: i, options: n }) => {
              try {
                e.removeEventListener(t, i, n)
              } catch (s) {
                console.error("\u6E05\u7406\u4E8B\u4EF6\u76D1\u542C\u5668\u65F6\u51FA\u9519:", s)
              }
            }),
            (this.eventListeners.length = 0),
            this.abortControllers.forEach((e) => {
              try {
                e.abort()
              } catch (t) {
                console.error("\u6E05\u7406 AbortController \u65F6\u51FA\u9519:", t)
              }
            }),
            this.abortControllers.clear())
        }
        cleanupNonCriticalResources() {
          ;(this.observers.forEach((n) => {
            try {
              n.disconnect()
            } catch (s) {
              console.error("\u6E05\u7406\u89C2\u5BDF\u5668\u65F6\u51FA\u9519:", s)
            }
          }),
            this.observers.clear(),
            this.timers.forEach((n) => {
              try {
                ;(clearTimeout(n), clearInterval(n))
              } catch (s) {
                console.error("\u6E05\u7406\u5B9A\u65F6\u5668\u65F6\u51FA\u9519:", s)
              }
            }),
            this.timers.clear())
          let e = ["click", "popstate"],
            t = [window, document],
            i = []
          ;(this.eventListeners.forEach(({ element: n, type: s, listener: o, options: a }) => {
            if (e.includes(s) && t.some((u) => u === n))
              (i.push({ element: n, type: s, listener: o, options: a }),
                console.log(
                  `[SPA DEBUG] \u4FDD\u7559\u5173\u952E\u4E8B\u4EF6\u76D1\u542C\u5668: ${s} on ${n.constructor.name}`,
                ))
            else
              try {
                ;(n.removeEventListener(s, o, a),
                  console.log(
                    `[SPA DEBUG] \u6E05\u7406\u975E\u5173\u952E\u4E8B\u4EF6\u76D1\u542C\u5668: ${s} on ${n.constructor.name}`,
                  ))
              } catch (u) {
                console.error("\u6E05\u7406\u4E8B\u4EF6\u76D1\u542C\u5668\u65F6\u51FA\u9519:", u)
              }
          }),
            (this.eventListeners.length = 0),
            this.eventListeners.push(...i),
            this.abortControllers.forEach((n) => {
              try {
                n.abort()
              } catch (s) {
                console.error("\u6E05\u7406 AbortController \u65F6\u51FA\u9519:", s)
              }
            }),
            this.abortControllers.clear())
        }
        cleanup() {
          ;(this.cleanupObserversAndListeners(),
            this.cleanupTasks.forEach((e) => {
              try {
                e()
              } catch (t) {
                console.error("\u6267\u884C\u6E05\u7406\u4EFB\u52A1\u65F6\u51FA\u9519:", t)
              }
            }),
            (this.cleanupTasks.length = 0))
        }
        addCleanupTask(e) {
          this.cleanupTasks.push(e)
        }
        hasActiveResources() {
          return (
            this.observers.size > 0 ||
            this.timers.size > 0 ||
            this.eventListeners.length > 0 ||
            this.abortControllers.size > 0
          )
        }
        getActiveResourcesDetails() {
          return {
            observers: Array.from(this.observers).map((e) => e.constructor.name),
            timers: Array.from(this.timers),
            eventListeners: this.eventListeners.map(({ element: e, type: t }) => ({
              element: e.constructor.name,
              type: t,
            })),
            abortControllers: this.abortControllers.size,
          }
        }
      }
    })
  var Hn,
    mc = d(() => {
      "use strict"
      Kr()
      Hn = class r {
        static config = Pi("DEFAULT")
        static DEFAULT_QUOTA = ya.MAX_MEMORY_USAGE
        static async checkStorageQuota(e) {
          try {
            if (navigator.storage?.estimate) {
              let i = await navigator.storage.estimate(),
                n = i.usage || 0,
                s = i.quota || this.DEFAULT_QUOTA
              return { used: n, total: s, percentage: s > 0 ? n / s : 0, available: s - n }
            }
          } catch (i) {
            console.warn("\u65E0\u6CD5\u83B7\u53D6\u5B58\u50A8\u914D\u989D\u4FE1\u606F:", i)
          }
          let t = this.calculateStorageSize(e)
          return {
            used: t,
            total: this.DEFAULT_QUOTA,
            percentage: t / this.DEFAULT_QUOTA,
            available: this.DEFAULT_QUOTA - t,
          }
        }
        static calculateStorageSize(e) {
          let t = 0
          try {
            for (let i = 0; i < e.length; i++) {
              let n = e.key(i)
              if (n) {
                let s = e.getItem(n)
                t += (n.length + (s?.length || 0)) * 2
              }
            }
          } catch (i) {
            console.warn("\u65E0\u6CD5\u4F30\u7B97\u5B58\u50A8\u5927\u5C0F:", i)
          }
          return t
        }
        static async safeSetItem(e, t, i) {
          return (await this.checkAndCleanupIfNeeded(e), this.attemptSetItem(e, t, i))
        }
        static async checkAndCleanupIfNeeded(e) {
          try {
            let t = await this.checkStorageQuota(e),
              i = this.config.memoryThreshold || 0.9
            t.percentage > i &&
              (vr.CONSOLE_WARNINGS &&
                console.warn(
                  "\u5B58\u50A8\u914D\u989D\u5373\u5C06\u8017\u5C3D\uFF0C\u6267\u884C\u6E05\u7406...",
                ),
              this.cleanupStorage(e),
              (await this.checkStorageQuota(e)).percentage > i &&
                (vr.CONSOLE_WARNINGS &&
                  console.warn(
                    "\u6E05\u7406\u540E\u914D\u989D\u4ECD\u7136\u4E0D\u8DB3\uFF0C\u6267\u884C\u7D27\u6025\u6E05\u7406...",
                  ),
                this.emergencyCleanup(e)))
          } catch (t) {
            vr.CONSOLE_WARNINGS && console.warn("\u914D\u989D\u68C0\u67E5\u5931\u8D25:", t)
          }
        }
        static attemptSetItem(e, t, i) {
          try {
            return (e.setItem(t, i), !0)
          } catch (n) {
            return n instanceof DOMException && n.name === "QuotaExceededError"
              ? this.handleQuotaExceeded(e, t, i)
              : (console.error("\u8BBE\u7F6E\u5B58\u50A8\u9879\u5931\u8D25:", n), !1)
          }
        }
        static handleQuotaExceeded(e, t, i) {
          ;(console.warn(
            "\u5B58\u50A8\u914D\u989D\u8D85\u9650\uFF0C\u5C1D\u8BD5\u6E05\u7406\u540E\u91CD\u8BD5...",
          ),
            this.cleanupStorage(e))
          try {
            return (e.setItem(t, i), !0)
          } catch {
            ;(console.warn(
              "\u6E05\u7406\u540E\u91CD\u8BD5\u4ECD\u5931\u8D25\uFF0C\u6267\u884C\u7D27\u6025\u6E05\u7406...",
            ),
              this.emergencyCleanup(e))
            try {
              return (e.setItem(t, i), !0)
            } catch (s) {
              return (console.error("\u6700\u7EC8\u8BBE\u7F6E\u5931\u8D25:", s), !1)
            }
          }
        }
        static safeGetItem(e, t) {
          try {
            return e.getItem(t)
          } catch (i) {
            return (console.error("\u83B7\u53D6\u5B58\u50A8\u9879\u5931\u8D25:", i), null)
          }
        }
        static safeRemoveItem(e, t) {
          try {
            e.removeItem(t)
          } catch (i) {
            console.error("\u79FB\u9664\u5B58\u50A8\u9879\u5931\u8D25:", i)
          }
        }
        static cleanupStorage(e) {
          try {
            let t = this.findExpiredKeys(e)
            ;(this.removeKeys(e, t),
              vr.CONSOLE_WARNINGS &&
                t.length > 0 &&
                console.log(`\u6E05\u7406\u4E86 ${t.length} \u4E2A\u8FC7\u671F\u9879\u76EE`))
          } catch (t) {
            vr.CONSOLE_WARNINGS && console.error("\u6E05\u7406\u5B58\u50A8\u5931\u8D25:", t)
          }
        }
        static findExpiredKeys(e) {
          let t = [],
            i = Date.now()
          for (let n = 0; n < e.length; n++) {
            let s = e.key(n)
            if (!s || !Object.values(ie.PREFIXES).some((u) => s.startsWith(u))) continue
            let a = e.getItem(s)
            a && this.isExpiredItem(a, i) && t.push(s)
          }
          return t
        }
        static isExpiredItem(e, t) {
          try {
            let i = JSON.parse(e)
            if (i && typeof i == "object" && i.timestamp) {
              let n = t - i.timestamp,
                s = (this.config.ttl || 24 * 60 * 60) * 1e3
              return n > s
            }
          } catch {
            let i = new Blob([e]).size,
              n = (this.config.maxMemoryMB || ya.LARGE_CONTENT_SIZE / 1024) * 1024
            return i > n
          }
          return !1
        }
        static removeKeys(e, t) {
          t.forEach((i) => {
            try {
              e.removeItem(i)
            } catch (n) {
              console.warn(`\u5220\u9664\u952E ${i} \u5931\u8D25:`, n)
            }
          })
        }
        static emergencyCleanup(e) {
          try {
            let t = [],
              i = this.config.keyPrefix || "sys_"
            for (let s = 0; s < e.length; s++) {
              let o = e.key(s)
              o && o.startsWith(i) && t.push(o)
            }
            let n = Math.ceil(t.length / 2)
            for (let s = 0; s < n; s++) e.removeItem(t[s])
            vr.CONSOLE_WARNINGS &&
              console.warn(
                `\u7D27\u6025\u6E05\u7406\uFF1A\u79FB\u9664\u4E86 ${n} \u4E2A\u5B58\u50A8\u9879`,
              )
          } catch (t) {
            vr.CONSOLE_WARNINGS && console.error("\u7D27\u6025\u6E05\u7406\u5931\u8D25:", t)
          }
        }
        async setSessionItem(e, t) {
          return r.safeSetItem(sessionStorage, e, t)
        }
        getSessionItem(e) {
          return r.safeGetItem(sessionStorage, e)
        }
        removeSessionItem(e) {
          r.safeRemoveItem(sessionStorage, e)
        }
        async setLocalItem(e, t) {
          return r.safeSetItem(localStorage, e, t)
        }
        getLocalItem(e) {
          return r.safeGetItem(localStorage, e)
        }
        removeLocalItem(e) {
          r.safeRemoveItem(localStorage, e)
        }
        async setItem(e, t, i) {
          return e === "local" ? this.setLocalItem(t, i) : this.setSessionItem(t, i)
        }
        getItem(e, t) {
          return e === "local" ? this.getLocalItem(t) : this.getSessionItem(t)
        }
        removeItem(e, t) {
          return e === "local" ? this.removeLocalItem(t) : this.removeSessionItem(t)
        }
        getStorageStats() {
          let e = (t) => {
            let i = 0,
              n = 0,
              s = r.config.keyPrefix || "sys_"
            for (let a = 0; a < t.length; a++) {
              let u = t.key(a)
              if (u && u.startsWith(s)) {
                let l = t.getItem(u)
                l && ((i += new Blob([u + l]).size), n++)
              }
            }
            let o = (r.config.capacity || ya.HUGE_CONTENT_SIZE / (1024 * 1024)) * 1024 * 1024
            return { used: i, available: Math.max(0, o - i), itemCount: n }
          }
          return { localStorage: e(localStorage), sessionStorage: e(sessionStorage) }
        }
        cleanupAllStorage() {
          let e = Date.now(),
            t = (r.config.cleanupIntervalMs || 60) * 60 * 1e3,
            i = parseInt(this.getItem("local", "last_cleanup") || "0")
          e - i < t ||
            (r.cleanupStorage(localStorage),
            r.cleanupStorage(sessionStorage),
            this.setItem("local", "last_cleanup", e.toString()),
            document.dispatchEvent(new CustomEvent("cacheCleared", { detail: {} })))
        }
        cleanup() {
          this.cleanupAllStorage()
        }
        getStats() {
          let e = this.getStorageStats(),
            t = {
              localStorage: {
                used: e.localStorage.used,
                total: e.localStorage.used + e.localStorage.available,
                percentage: e.localStorage.used / (e.localStorage.used + e.localStorage.available),
              },
              sessionStorage: {
                used: e.sessionStorage.used,
                total: e.sessionStorage.used + e.sessionStorage.available,
                percentage:
                  e.sessionStorage.used / (e.sessionStorage.used + e.sessionStorage.available),
              },
            }
          return Promise.resolve(t)
        }
      }
    })
  var zn,
    gc = d(() => {
      "use strict"
      Kr()
      xa()
      zn = class r {
        memoryCache
        storageManager
        referenceMap = new Map()
        contentHashMap = new Map()
        stats = {
          totalRequests: 0,
          memoryHits: 0,
          sessionHits: 0,
          localHits: 0,
          duplicatesAvoided: 0,
        }
        static _initialized = !1
        constructor(e, t) {
          ;(console.log("UnifiedContentCacheManager constructor"),
            (this.memoryCache = e),
            (this.storageManager = t),
            r._initialized ||
              (console.log(
                "[UnifiedCache] Initializing UnifiedContentCacheManager from sessionStorage...",
              ),
              this.initializeFromStorage(),
              (r._initialized = !0)))
        }
        initializeFromStorage() {
          try {
            if (typeof window > "u") {
              console.warn(
                "[UnifiedCache] window \u5BF9\u8C61\u4E0D\u53EF\u7528\uFF0C\u8DF3\u8FC7\u521D\u59CB\u5316\u3002",
              )
              return
            }
            let e = { memory: 0, session: 0, local: 0 },
              t = (i, n, s) => {
                if (!i) {
                  console.warn(
                    `[UnifiedCache] ${s}Storage \u4E0D\u53EF\u7528\uFF0C\u8DF3\u8FC7\u521D\u59CB\u5316\u3002`,
                  )
                  return
                }
                for (let o = 0; o < i.length; o++) {
                  let a = i.key(o)
                  if (!a || !_e.identifyType(a)) continue
                  let l = i.getItem(a)
                  if (!l) continue
                  let c = Di(a)
                  if (!c || this.referenceMap.has(c)) continue
                  let h = {
                    storageLayer: n,
                    storageKey: a,
                    refCount: 0,
                    lastAccessed: Date.now(),
                    size: this.calculateSize(l),
                  }
                  this.referenceMap.set(c, h)
                  let f = this.calculateHash(l)
                  ;(this.contentHashMap.has(f) || this.contentHashMap.set(f, c), e[n]++)
                }
              }
            ;(t(window.sessionStorage, "SESSION", "session"),
              t(window.localStorage, "LOCAL", "local"),
              e.session > 0 || e.local > 0
                ? console.log(
                    `[UnifiedCache] Successfully restored ${e.session} items from sessionStorage and ${e.local} items from localStorage.`,
                  )
                : console.log(
                    "[UnifiedCache] No items found in sessionStorage or localStorage to restore.",
                  ))
          } catch (e) {
            console.warn("[UnifiedCache] Error initializing storage references:", e)
          }
        }
        get(e) {
          this.stats.totalRequests++
          let t = Di(e),
            i = this.referenceMap.get(t)
          if (!i) {
            if (
              (console.log(
                `[UnifiedCache] Cache miss for key: ${e}, originalKey: ${t}. referenceMap size: ${this.referenceMap.size}`,
              ),
              this.referenceMap.size > 0)
            ) {
              let n = Array.from(this.referenceMap.keys())
              console.debug("[UnifiedCache] Available keys in referenceMap:", n)
            }
            if (
              this.referenceMap.size === 0 &&
              typeof window < "u" &&
              window.sessionStorage &&
              window.sessionStorage.length > 0
            ) {
              this.forceReinitializeFromStorage()
              let n = this.referenceMap.get(t)
              if (n) return this.getContentFromReference(t, n)
            }
            return null
          }
          return this.getContentFromReference(t, i)
        }
        getContentFromReference(e, t) {
          ;((t.lastAccessed = Date.now()), t.refCount++)
          let i = null
          switch (t.storageLayer) {
            case "MEMORY":
              ;((i = this.memoryCache.get(t.storageKey) || null), i && this.stats.memoryHits++)
              break
            case "SESSION":
              ;((i = this.storageManager.getSessionItem(t.storageKey)),
                i && this.stats.sessionHits++)
              break
            case "LOCAL":
              ;((i = this.storageManager.getLocalItem(t.storageKey)), i && this.stats.localHits++)
              break
          }
          return (i || this.referenceMap.delete(e), i)
        }
        forceReinitializeFromStorage() {
          ;(this.referenceMap.clear(), this.contentHashMap.clear(), this.initializeFromStorage())
        }
        set(e, t, i = void 0) {
          let n = Di(e),
            s = this.calculateHash(t),
            o = this.contentHashMap.get(s)
          if (o && this.referenceMap.has(o)) {
            let c = this.referenceMap.get(o)
            ;(this.referenceMap.set(n, {
              storageLayer: c.storageLayer,
              storageKey: c.storageKey,
              refCount: 1,
              lastAccessed: Date.now(),
              size: c.size,
            }),
              this.stats.duplicatesAvoided++,
              console.log(`[UnifiedCache] Avoided duplicate storage for ${n}, referencing ${o}`))
            return
          }
          let a = this.selectOptimalLayer(t, i),
            u = nm(e, a)
          if (this.storeContent(u, t, a)) {
            let c = {
              storageLayer: a,
              storageKey: u,
              refCount: 1,
              lastAccessed: Date.now(),
              size: this.calculateSize(t),
            }
            ;(this.referenceMap.set(n, c), this.contentHashMap.set(s, n))
          }
        }
        delete(e) {
          let t = Di(e),
            i = this.referenceMap.get(t)
          if (!i) return !1
          if ((i.refCount--, i.refCount <= 0)) {
            this.deleteFromStorage(i.storageKey, i.storageLayer)
            for (let [n, s] of this.contentHashMap.entries())
              if (s === t) {
                this.contentHashMap.delete(n)
                break
              }
          }
          return (this.referenceMap.delete(t), !0)
        }
        has(e) {
          let t = Di(e)
          return this.referenceMap.has(t)
        }
        clear() {
          ;(this.referenceMap.clear(), this.contentHashMap.clear(), this.memoryCache.clear())
        }
        getStats() {
          let e =
            ((this.stats.memoryHits + this.stats.sessionHits + this.stats.localHits) /
              this.stats.totalRequests) *
            100
          return {
            ...this.stats,
            hitRate: e,
            totalCacheEntries: this.referenceMap.size,
            uniqueContentCount: this.contentHashMap.size,
            memoryUsage: this.calculateTotalMemoryUsage(),
          }
        }
        cleanup() {
          let e = Date.now(),
            t = [],
            i = am.MEMORY_CHECK_INTERVAL
          for (let [n, s] of this.referenceMap.entries()) e - s.lastAccessed > i && t.push(n)
          ;(t.forEach((n) => this.delete(n)),
            t.length > 0 &&
              console.log(`[UnifiedCache] Cleaned up ${t.length} expired cache entries`))
        }
        selectOptimalLayer(e, t) {
          let i = this.calculateSize(e),
            n = _a.MEMORY,
            s = _a.SESSION,
            o = _a.LOCAL,
            a = [t, "MEMORY", "SESSION", "LOCAL"].filter(Boolean),
            u = [...new Set(a)]
          for (let l of u)
            switch (l) {
              case "MEMORY":
                if (i < n.maxSizeKB * 1024) return "MEMORY"
                break
              case "SESSION":
                if (i < s.maxSizeKB * 1024) return "SESSION"
                break
              case "LOCAL":
                if (i < o.maxSizeKB * 1024) return "LOCAL"
                break
            }
          return "MEMORY"
        }
        storeContent(e, t, i) {
          try {
            switch (i) {
              case "MEMORY":
                return (this.memoryCache.set(e, t), !0)
              case "SESSION":
                return (this.storageManager.setSessionItem(e, t), !0)
              case "LOCAL":
                return (this.storageManager.setLocalItem(e, t), !0)
              default:
                return !1
            }
          } catch (n) {
            return (console.warn(`[UnifiedCache] Failed to store content in ${i}:`, n), !1)
          }
        }
        deleteFromStorage(e, t) {
          try {
            switch (t) {
              case "MEMORY":
                this.memoryCache.delete(e)
                break
              case "SESSION":
                this.storageManager.removeSessionItem(e)
                break
              case "LOCAL":
                this.storageManager.removeLocalItem(e)
                break
            }
          } catch (i) {
            console.warn(`[UnifiedCache] Failed to delete from ${t}:`, i)
          }
        }
        calculateHash(e) {
          let t = 0
          for (let i = 0; i < e.length; i++) {
            let n = e.charCodeAt(i)
            ;((t = (t << 5) - t + n), (t = t & t))
          }
          return t.toString(36)
        }
        calculateSize(e) {
          return new Blob([e]).size
        }
        calculateTotalMemoryUsage() {
          let e = 0
          for (let t of this.referenceMap.values()) e += t.size
          return e
        }
        validateCacheKey(e) {
          let t = [],
            i = [],
            n = this.referenceMap.get(e)
          if (!n)
            return (
              t.push(`No reference found for key: ${e}`),
              i.push("Check if the key was properly stored"),
              { isValid: !1, issues: t, suggestions: i }
            )
          let s = !1
          switch (n.storageLayer) {
            case "MEMORY":
              s = this.memoryCache.has(n.storageKey)
              break
            case "SESSION":
              s = this.storageManager.getSessionItem(n.storageKey) !== null
              break
            case "LOCAL":
              s = this.storageManager.getLocalItem(n.storageKey) !== null
              break
          }
          return (
            s ||
              (t.push(`Content not found in ${n.storageLayer} layer with key: ${n.storageKey}`),
              i.push("The reference exists but the actual content is missing")),
            { isValid: s, issues: t, suggestions: i }
          )
        }
        repairCacheReference(e) {
          if (this.validateCacheKey(e).isValid) return !0
          this.referenceMap.delete(e)
          for (let [i, n] of this.contentHashMap.entries())
            if (n === e) {
              this.contentHashMap.delete(i)
              break
            }
          return !1
        }
        getCacheDiagnostics(e) {
          let t = this.referenceMap.get(e),
            i = this.validateCacheKey(e),
            n = {
              memory: this.memoryCache.has(e),
              session: this.storageManager.getSessionItem(e) !== null,
              local: this.storageManager.getLocalItem(e) !== null,
            }
          return {
            key: e,
            reference: t,
            validation: i,
            storageLayerInfo: n,
            availableKeys: Array.from(this.referenceMap.keys()),
          }
        }
        static resetSingleton() {
          r._initialized = !1
        }
      }
    })
  var Wn,
    xc = d(() => {
      "use strict"
      Wn = class {
        managers = new Map()
        register(e, t) {
          this.managers.set(e, t)
        }
        unregister(e) {
          this.managers.delete(e)
        }
        cleanup() {
          this.managers.forEach((e, t) => {
            try {
              e.cleanup()
            } catch (i) {
              console.error(`Error during cleanup of ${t}:`, i)
            }
          })
        }
        getAllStats() {
          let e = {}
          return (
            this.managers.forEach((t, i) => {
              t.getStats && (e[i] = t.getStats())
            }),
            e
          )
        }
        clear() {
          this.managers.clear()
        }
      }
    })
  var _c,
    jr,
    Sr,
    Bt,
    qr,
    ba = d(() => {
      "use strict"
      yc()
      va()
      ;((_c = class {
        _initialized = !1
        _unifiedContentCache = null
        _linkCache = null
        _searchCache = null
        _userCache = null
        _systemCache = null
        _defaultCache = null
        _urlCacheManager = null
        _failedLinksManager = null
        _storageManager = null
        _resourceManager = null
        _cleanupManager = null
        get unifiedContentCache() {
          return (
            this._unifiedContentCache ||
              ((this._unifiedContentCache = yt.createUnifiedContentCacheManager(
                Ri.globalUnifiedContentCache,
              )),
              console.log("[GlobalManagers] Initialized UnifiedContentCacheManager")),
            this._unifiedContentCache
          )
        }
        get linkCache() {
          return (
            this._linkCache ||
              ((this._linkCache = this.createCache("LINK")),
              console.log("[GlobalManagers] Initialized LinkCache")),
            this._linkCache
          )
        }
        get searchCache() {
          return (
            this._searchCache ||
              ((this._searchCache = this.createCache("SEARCH")),
              console.log("[GlobalManagers] Initialized SearchCache")),
            this._searchCache
          )
        }
        get userCache() {
          return (
            this._userCache ||
              ((this._userCache = this.createCache("USER")),
              console.log("[GlobalManagers] Initialized UserCache")),
            this._userCache
          )
        }
        get systemCache() {
          return (
            this._systemCache ||
              ((this._systemCache = this.createCache("SYSTEM")),
              console.log("[GlobalManagers] Initialized SystemCache")),
            this._systemCache
          )
        }
        get defaultCache() {
          return (
            this._defaultCache ||
              ((this._defaultCache = this.createCache("DEFAULT")),
              console.log("[GlobalManagers] Initialized DefaultCache")),
            this._defaultCache
          )
        }
        get urlCacheManager() {
          return (
            this._urlCacheManager ||
              ((this._urlCacheManager = yt.createCacheManager(Ri.urlCacheManager)),
              console.log("[GlobalManagers] Initialized UrlCacheManager")),
            this._urlCacheManager
          )
        }
        get failedLinksManager() {
          return (
            this._failedLinksManager ||
              ((this._failedLinksManager = yt.createCacheManager(Ri.failedLinksManager)),
              console.log("[GlobalManagers] Initialized FailedLinksManager")),
            this._failedLinksManager
          )
        }
        get storageManager() {
          return (
            this._storageManager ||
              ((this._storageManager = yt.createStorageManager(Ri.globalStorageManager)),
              console.log("[GlobalManagers] Initialized StorageManager")),
            this._storageManager
          )
        }
        get resourceManager() {
          return (
            this._resourceManager ||
              ((this._resourceManager = yt.createResourceManager(Ri.globalResourceManager)),
              console.log("[GlobalManagers] Initialized ResourceManager")),
            this._resourceManager
          )
        }
        get cleanupManager() {
          return (
            this._cleanupManager ||
              ((this._cleanupManager = yt.getCleanupManager()),
              console.log("[GlobalManagers] Initialized CleanupManager")),
            this._cleanupManager
          )
        }
        createCache(e) {
          return yt.createCacheManager({ type: "CACHE", identifier: e, config: { cacheType: e } })
        }
        initialize(e = !1) {
          if (this._initialized) {
            console.log("[GlobalManagers] Already initialized, skipping...")
            return
          }
          ;(console.log("[GlobalManagers] Initializing global manager instances..."),
            this.cleanupManager,
            this.unifiedContentCache,
            e &&
              (this.linkCache,
              this.searchCache,
              this.userCache,
              this.systemCache,
              this.defaultCache,
              this.storageManager,
              this.resourceManager,
              this.failedLinksManager,
              this.urlCacheManager,
              console.log("[GlobalManagers] All manager instances preloaded")),
            (this._initialized = !0),
            console.log("[GlobalManagers] Global manager instances initialized"))
        }
        cleanup() {
          ;(console.log("[GlobalManagers] Cleaning up all global manager instances..."),
            yt.cleanup(),
            console.log("[GlobalManagers] All global manager instances cleaned up"))
        }
        destroy() {
          ;(console.log("[GlobalManagers] Destroying all global manager instances..."),
            yt.destroy(),
            (this._initialized = !1),
            Object.keys(this).forEach((e) => {
              e.startsWith("_") && (this[e] = null)
            }),
            (this._initialized = !1),
            console.log("[GlobalManagers] All global manager instances destroyed"))
        }
      }),
        (jr = class {
          static _instance = new _c()
          static get instance() {
            return this._instance
          }
          static initialize(e = !1) {
            this._instance.initialize(e)
          }
          static cleanup() {
            this._instance.cleanup()
          }
          static destroy() {
            this._instance.destroy()
          }
          static getInstance(e, t) {
            switch (e) {
              case "CACHE":
                return this.instance.defaultCache
              case "RESOURCE":
                return this.instance.resourceManager
              case "STORAGE":
                return this.instance.storageManager
              case "UNIFIED_CONTENT_CACHE":
                return this.instance.unifiedContentCache
              case "CLEANUP":
                return this.instance.cleanupManager
              default:
                throw new Error(`[GlobalManagerController] Unknown manager type: ${e}`)
            }
          }
        }),
        (Sr = {
          get instance() {
            return jr.instance.storageManager
          },
        }),
        (Bt = {
          get instance() {
            return jr.instance.resourceManager
          },
        }),
        (qr = {
          get instance() {
            return jr.instance.defaultCache
          },
        }))
    })
  var va = d(() => {
    "use strict"
    ba()
    nr()
  })
  var yt,
    Ri,
    yc = d(() => {
      "use strict"
      fc()
      pc()
      mc()
      gc()
      xc()
      va()
      Kr()
      ba()
      ;((yt = class {
        static instances = new Map()
        static cleanupManager = null
        static _createAndRegisterManager(e, t, i) {
          let n = `${e.type}_${e.identifier || "default"}`
          if (this.instances.has(n)) return this.instances.get(n)
          let s = t()
          return (
            this.instances.set(n, s),
            this.getCleanupManager().register(n, s),
            console.log(`[ManagerFactory] Created ${i}: ${n}`),
            s
          )
        }
        static createCacheManager(e) {
          return this._createAndRegisterManager(
            e,
            () => {
              let t = e.config?.cacheType || "DEFAULT",
                n = {
                  ...Pi(t),
                  ...(e.config?.configOverride || {}),
                  enableMemoryLayer: e.config?.enableMemoryLayer ?? !0,
                  enableSessionLayer: e.config?.enableSessionLayer ?? !1,
                }
              return new Ln(n)
            },
            "CacheManager",
          )
        }
        static createResourceManager(e) {
          return this._createAndRegisterManager(e, () => new Nn(), "ResourceManager")
        }
        static createStorageManager(e) {
          return this._createAndRegisterManager(e, () => new Hn(), "StorageManager")
        }
        static createUnifiedContentCacheManager(e) {
          return this._createAndRegisterManager(
            e,
            () => {
              let t = qr.instance,
                i = Sr.instance
              return new zn(t, i)
            },
            "UnifiedContentCacheManager",
          )
        }
        static getCleanupManager() {
          return (
            this.cleanupManager ||
              ((this.cleanupManager = new Wn()),
              console.log("[ManagerFactory] Created CleanupManager singleton")),
            this.cleanupManager
          )
        }
        static cleanup() {
          ;(console.log("[ManagerFactory] Cleaning up all registered manager instances..."),
            this.instances.forEach((e, t) => {
              if (e && typeof e.cleanup == "function")
                try {
                  ;(e.cleanup(), console.log(`[ManagerFactory] Cleaned up instance: ${t}`))
                } catch (i) {
                  console.error(`[ManagerFactory] Error cleaning up instance ${t}:`, i)
                }
            }),
            console.log("[ManagerFactory] All registered manager instances cleaned up."))
        }
        static destroy() {
          ;(console.log("[ManagerFactory] Destroying all registered manager instances..."),
            this.instances.forEach((e, t) => {
              if (e && typeof e.destroy == "function")
                try {
                  ;(e.destroy(), console.log(`[ManagerFactory] Destroyed instance: ${t}`))
                } catch (i) {
                  console.error(`[ManagerFactory] Error destroying instance ${t}:`, i)
                }
              else if (e && typeof e.cleanup == "function")
                try {
                  ;(e.cleanup(),
                    console.log(`[ManagerFactory] Cleaned up (as destroy) instance: ${t}`))
                } catch (i) {
                  console.error(`[ManagerFactory] Error cleaning up (as destroy) instance ${t}:`, i)
                }
            }),
            this.instances.clear(),
            (this.cleanupManager = null),
            console.log(
              "[ManagerFactory] All registered manager instances destroyed and registry cleared.",
            ))
        }
        static getInstance(e, t = "default") {
          let i = `${e}_${t}`
          return this.instances.get(i) || null
        }
        static hasInstance(e, t = "default") {
          let i = `${e}_${t}`
          return this.instances.has(i)
        }
        static removeInstance(e, t = "default") {
          let i = `${e}_${t}`
          if (this.instances.has(i)) {
            let n = this.instances.get(i)
            if (
              (this.cleanupManager && this.cleanupManager.unregister(i),
              n && typeof n.cleanup == "function")
            )
              try {
                n.cleanup()
              } catch (s) {
                console.error(`[ManagerFactory] Error cleaning up ${i}:`, s)
              }
            return (
              this.instances.delete(i),
              console.log(`[ManagerFactory] Removed instance: ${i}`),
              !0
            )
          }
          return !1
        }
        static getStats() {
          let e = {}
          for (let t of this.instances.keys()) {
            let i = t.split("_")[0]
            e[i] = (e[i] || 0) + 1
          }
          return {
            totalInstances: this.instances.size,
            hasCleanupManager: this.cleanupManager !== null,
            instanceKeys: Array.from(this.instances.keys()),
            instancesByType: e,
          }
        }
      }),
        (Ri = {
          globalCacheManager: {
            type: "CACHE",
            identifier: "global",
            config: { cacheType: "DEFAULT", enableMemoryLayer: !0, enableSessionLayer: !1 },
          },
          urlCacheManager: {
            type: "CACHE",
            identifier: "url",
            config: { cacheType: "LINK", enableMemoryLayer: !0, enableSessionLayer: !1 },
          },
          failedLinksManager: {
            type: "CACHE",
            identifier: "failedLinks",
            config: { cacheType: "LINK", enableMemoryLayer: !1, enableSessionLayer: !0 },
          },
          globalResourceManager: { type: "RESOURCE", identifier: "global" },
          globalStorageManager: { type: "STORAGE", identifier: "global" },
          globalUnifiedContentCache: {
            type: "UNIFIED_CONTENT_CACHE",
            identifier: "global",
            config: { cacheType: "CONTENT", enableMemoryLayer: !0, enableSessionLayer: !0 },
          },
        }))
    })
  var nr = d(() => {
    "use strict"
    fc()
    pc()
    mc()
    gc()
    xc()
    yc()
    ba()
  })
  var bc = d(() => {
    "use strict"
    Kr()
    xa()
    va()
    nr()
  })
  var cm = d(() => {})
  var YG,
    hm = d(() => {
      cm()
      YG = Object.hasOwnProperty
    })
  var fm = ga((jG, dm) => {
    "use strict"
    dm.exports = iD
    function Fi(r) {
      return r instanceof Buffer
        ? Buffer.from(r)
        : new r.constructor(r.buffer.slice(), r.byteOffset, r.length)
    }
    function iD(r) {
      if (((r = r || {}), r.circles)) return nD(r)
      let e = new Map()
      if (
        (e.set(Date, (o) => new Date(o)),
        e.set(Map, (o, a) => new Map(i(Array.from(o), a))),
        e.set(Set, (o, a) => new Set(i(Array.from(o), a))),
        r.constructorHandlers)
      )
        for (let o of r.constructorHandlers) e.set(o[0], o[1])
      let t = null
      return r.proto ? s : n
      function i(o, a) {
        let u = Object.keys(o),
          l = new Array(u.length)
        for (let c = 0; c < u.length; c++) {
          let h = u[c],
            f = o[h]
          typeof f != "object" || f === null
            ? (l[h] = f)
            : f.constructor !== Object && (t = e.get(f.constructor))
              ? (l[h] = t(f, a))
              : ArrayBuffer.isView(f)
                ? (l[h] = Fi(f))
                : (l[h] = a(f))
        }
        return l
      }
      function n(o) {
        if (typeof o != "object" || o === null) return o
        if (Array.isArray(o)) return i(o, n)
        if (o.constructor !== Object && (t = e.get(o.constructor))) return t(o, n)
        let a = {}
        for (let u in o) {
          if (Object.hasOwnProperty.call(o, u) === !1) continue
          let l = o[u]
          typeof l != "object" || l === null
            ? (a[u] = l)
            : l.constructor !== Object && (t = e.get(l.constructor))
              ? (a[u] = t(l, n))
              : ArrayBuffer.isView(l)
                ? (a[u] = Fi(l))
                : (a[u] = n(l))
        }
        return a
      }
      function s(o) {
        if (typeof o != "object" || o === null) return o
        if (Array.isArray(o)) return i(o, s)
        if (o.constructor !== Object && (t = e.get(o.constructor))) return t(o, s)
        let a = {}
        for (let u in o) {
          let l = o[u]
          typeof l != "object" || l === null
            ? (a[u] = l)
            : l.constructor !== Object && (t = e.get(l.constructor))
              ? (a[u] = t(l, s))
              : ArrayBuffer.isView(l)
                ? (a[u] = Fi(l))
                : (a[u] = s(l))
        }
        return a
      }
    }
    function nD(r) {
      let e = [],
        t = [],
        i = new Map()
      if (
        (i.set(Date, (u) => new Date(u)),
        i.set(Map, (u, l) => new Map(s(Array.from(u), l))),
        i.set(Set, (u, l) => new Set(s(Array.from(u), l))),
        r.constructorHandlers)
      )
        for (let u of r.constructorHandlers) i.set(u[0], u[1])
      let n = null
      return r.proto ? a : o
      function s(u, l) {
        let c = Object.keys(u),
          h = new Array(c.length)
        for (let f = 0; f < c.length; f++) {
          let p = c[f],
            m = u[p]
          if (typeof m != "object" || m === null) h[p] = m
          else if (m.constructor !== Object && (n = i.get(m.constructor))) h[p] = n(m, l)
          else if (ArrayBuffer.isView(m)) h[p] = Fi(m)
          else {
            let g = e.indexOf(m)
            g !== -1 ? (h[p] = t[g]) : (h[p] = l(m))
          }
        }
        return h
      }
      function o(u) {
        if (typeof u != "object" || u === null) return u
        if (Array.isArray(u)) return s(u, o)
        if (u.constructor !== Object && (n = i.get(u.constructor))) return n(u, o)
        let l = {}
        ;(e.push(u), t.push(l))
        for (let c in u) {
          if (Object.hasOwnProperty.call(u, c) === !1) continue
          let h = u[c]
          if (typeof h != "object" || h === null) l[c] = h
          else if (h.constructor !== Object && (n = i.get(h.constructor))) l[c] = n(h, o)
          else if (ArrayBuffer.isView(h)) l[c] = Fi(h)
          else {
            let f = e.indexOf(h)
            f !== -1 ? (l[c] = t[f]) : (l[c] = o(h))
          }
        }
        return (e.pop(), t.pop(), l)
      }
      function a(u) {
        if (typeof u != "object" || u === null) return u
        if (Array.isArray(u)) return s(u, a)
        if (u.constructor !== Object && (n = i.get(u.constructor))) return n(u, a)
        let l = {}
        ;(e.push(u), t.push(l))
        for (let c in u) {
          let h = u[c]
          if (typeof h != "object" || h === null) l[c] = h
          else if (h.constructor !== Object && (n = i.get(h.constructor))) l[c] = n(h, a)
          else if (ArrayBuffer.isView(h)) l[c] = Fi(h)
          else {
            let f = e.indexOf(h)
            f !== -1 ? (l[c] = t[f]) : (l[c] = a(h))
          }
        }
        return (e.pop(), t.pop(), l)
      }
    }
  })
  var pm,
    sD,
    mm = d(() => {
      "use strict"
      ;((pm = Un(fm(), 1)), (sD = (0, pm.default)()))
    })
  function Ta(r) {
    return r.document.body.dataset.slug
  }
  function Zr(r) {
    let e = uD(aD(r, "index"), !0)
    return e.length === 0 ? "/" : e
  }
  function oD(r, e) {
    return r === e || r.endsWith("/" + e)
  }
  function aD(r, e) {
    return (oD(r, e) && (r = r.slice(0, -e.length)), r)
  }
  function uD(r, e) {
    return (
      r.startsWith("/") && (r = r.substring(1)),
      !e && r.endsWith("/") && (r = r.slice(0, -1)),
      r
    )
  }
  var $n = d(() => {
    "use strict"
    hm()
    mm()
    nr()
    hc()
  })
  function Ca(r, e) {
    if (!r) return
    function t(n) {
      n.target === this && (n.preventDefault(), n.stopPropagation(), e())
    }
    function i(n) {
      n.key.startsWith("Esc") && (n.preventDefault(), e())
    }
    ;(r?.addEventListener("click", t),
      Bt.instance.addCleanupTask(() => r?.removeEventListener("click", t)),
      document.addEventListener("keydown", i),
      Bt.instance.addCleanupTask(() => document.removeEventListener("keydown", i)))
  }
  function gm(r) {
    for (; r.firstChild; ) r.removeChild(r.firstChild)
  }
  var Ea = d(() => {
    "use strict"
    nr()
  })
  var _,
    vc,
    wa,
    L,
    D = d(() => {
      "use strict"
      ;((_ = ((r) => (
        (r.Application = "application"),
        (r.WebGLPipes = "webgl-pipes"),
        (r.WebGLPipesAdaptor = "webgl-pipes-adaptor"),
        (r.WebGLSystem = "webgl-system"),
        (r.WebGPUPipes = "webgpu-pipes"),
        (r.WebGPUPipesAdaptor = "webgpu-pipes-adaptor"),
        (r.WebGPUSystem = "webgpu-system"),
        (r.CanvasSystem = "canvas-system"),
        (r.CanvasPipesAdaptor = "canvas-pipes-adaptor"),
        (r.CanvasPipes = "canvas-pipes"),
        (r.Asset = "asset"),
        (r.LoadParser = "load-parser"),
        (r.ResolveParser = "resolve-parser"),
        (r.CacheParser = "cache-parser"),
        (r.DetectionParser = "detection-parser"),
        (r.MaskEffect = "mask-effect"),
        (r.BlendMode = "blend-mode"),
        (r.TextureSource = "texture-source"),
        (r.Environment = "environment"),
        (r.ShapeBuilder = "shape-builder"),
        (r.Batcher = "batcher"),
        r
      ))(_ || {})),
        (vc = (r) => {
          if (typeof r == "function" || (typeof r == "object" && r.extension)) {
            if (!r.extension) throw new Error("Extension class must have an extension object")
            r = {
              ...(typeof r.extension != "object" ? { type: r.extension } : r.extension),
              ref: r,
            }
          }
          if (typeof r == "object") r = { ...r }
          else throw new Error("Invalid extension type")
          return (typeof r.type == "string" && (r.type = [r.type]), r)
        }),
        (wa = (r, e) => vc(r).priority ?? e),
        (L = {
          _addHandlers: {},
          _removeHandlers: {},
          _queue: {},
          remove(...r) {
            return (
              r.map(vc).forEach((e) => {
                e.type.forEach((t) => this._removeHandlers[t]?.(e))
              }),
              this
            )
          },
          add(...r) {
            return (
              r.map(vc).forEach((e) => {
                e.type.forEach((t) => {
                  let i = this._addHandlers,
                    n = this._queue
                  i[t] ? i[t]?.(e) : ((n[t] = n[t] || []), n[t]?.push(e))
                })
              }),
              this
            )
          },
          handle(r, e, t) {
            let i = this._addHandlers,
              n = this._removeHandlers
            if (i[r] || n[r]) throw new Error(`Extension type ${r} already has a handler`)
            ;((i[r] = e), (n[r] = t))
            let s = this._queue
            return (s[r] && (s[r]?.forEach((o) => e(o)), delete s[r]), this)
          },
          handleByMap(r, e) {
            return this.handle(
              r,
              (t) => {
                t.name && (e[t.name] = t.ref)
              },
              (t) => {
                t.name && delete e[t.name]
              },
            )
          },
          handleByNamedList(r, e, t = -1) {
            return this.handle(
              r,
              (i) => {
                e.findIndex((s) => s.name === i.name) >= 0 ||
                  (e.push({ name: i.name, value: i.ref }),
                  e.sort((s, o) => wa(o.value, t) - wa(s.value, t)))
              },
              (i) => {
                let n = e.findIndex((s) => s.name === i.name)
                n !== -1 && e.splice(n, 1)
              },
            )
          },
          handleByList(r, e, t = -1) {
            return this.handle(
              r,
              (i) => {
                e.includes(i.ref) || (e.push(i.ref), e.sort((n, s) => wa(s, t) - wa(n, t)))
              },
              (i) => {
                let n = e.indexOf(i.ref)
                n !== -1 && e.splice(n, 1)
              },
            )
          },
          mixin(r, ...e) {
            for (let t of e)
              Object.defineProperties(r.prototype, Object.getOwnPropertyDescriptors(t))
          },
        }))
    })
  var _m = ga((ok, Sc) => {
    "use strict"
    var lD = Object.prototype.hasOwnProperty,
      rt = "~"
    function Xn() {}
    Object.create && ((Xn.prototype = Object.create(null)), new Xn().__proto__ || (rt = !1))
    function cD(r, e, t) {
      ;((this.fn = r), (this.context = e), (this.once = t || !1))
    }
    function xm(r, e, t, i, n) {
      if (typeof t != "function") throw new TypeError("The listener must be a function")
      var s = new cD(t, i || r, n),
        o = rt ? rt + e : e
      return (
        r._events[o]
          ? r._events[o].fn
            ? (r._events[o] = [r._events[o], s])
            : r._events[o].push(s)
          : ((r._events[o] = s), r._eventsCount++),
        r
      )
    }
    function Ma(r, e) {
      --r._eventsCount === 0 ? (r._events = new Xn()) : delete r._events[e]
    }
    function Qe() {
      ;((this._events = new Xn()), (this._eventsCount = 0))
    }
    Qe.prototype.eventNames = function () {
      var e = [],
        t,
        i
      if (this._eventsCount === 0) return e
      for (i in (t = this._events)) lD.call(t, i) && e.push(rt ? i.slice(1) : i)
      return Object.getOwnPropertySymbols ? e.concat(Object.getOwnPropertySymbols(t)) : e
    }
    Qe.prototype.listeners = function (e) {
      var t = rt ? rt + e : e,
        i = this._events[t]
      if (!i) return []
      if (i.fn) return [i.fn]
      for (var n = 0, s = i.length, o = new Array(s); n < s; n++) o[n] = i[n].fn
      return o
    }
    Qe.prototype.listenerCount = function (e) {
      var t = rt ? rt + e : e,
        i = this._events[t]
      return i ? (i.fn ? 1 : i.length) : 0
    }
    Qe.prototype.emit = function (e, t, i, n, s, o) {
      var a = rt ? rt + e : e
      if (!this._events[a]) return !1
      var u = this._events[a],
        l = arguments.length,
        c,
        h
      if (u.fn) {
        switch ((u.once && this.removeListener(e, u.fn, void 0, !0), l)) {
          case 1:
            return (u.fn.call(u.context), !0)
          case 2:
            return (u.fn.call(u.context, t), !0)
          case 3:
            return (u.fn.call(u.context, t, i), !0)
          case 4:
            return (u.fn.call(u.context, t, i, n), !0)
          case 5:
            return (u.fn.call(u.context, t, i, n, s), !0)
          case 6:
            return (u.fn.call(u.context, t, i, n, s, o), !0)
        }
        for (h = 1, c = new Array(l - 1); h < l; h++) c[h - 1] = arguments[h]
        u.fn.apply(u.context, c)
      } else {
        var f = u.length,
          p
        for (h = 0; h < f; h++)
          switch ((u[h].once && this.removeListener(e, u[h].fn, void 0, !0), l)) {
            case 1:
              u[h].fn.call(u[h].context)
              break
            case 2:
              u[h].fn.call(u[h].context, t)
              break
            case 3:
              u[h].fn.call(u[h].context, t, i)
              break
            case 4:
              u[h].fn.call(u[h].context, t, i, n)
              break
            default:
              if (!c) for (p = 1, c = new Array(l - 1); p < l; p++) c[p - 1] = arguments[p]
              u[h].fn.apply(u[h].context, c)
          }
      }
      return !0
    }
    Qe.prototype.on = function (e, t, i) {
      return xm(this, e, t, i, !1)
    }
    Qe.prototype.once = function (e, t, i) {
      return xm(this, e, t, i, !0)
    }
    Qe.prototype.removeListener = function (e, t, i, n) {
      var s = rt ? rt + e : e
      if (!this._events[s]) return this
      if (!t) return (Ma(this, s), this)
      var o = this._events[s]
      if (o.fn) o.fn === t && (!n || o.once) && (!i || o.context === i) && Ma(this, s)
      else {
        for (var a = 0, u = [], l = o.length; a < l; a++)
          (o[a].fn !== t || (n && !o[a].once) || (i && o[a].context !== i)) && u.push(o[a])
        u.length ? (this._events[s] = u.length === 1 ? u[0] : u) : Ma(this, s)
      }
      return this
    }
    Qe.prototype.removeAllListeners = function (e) {
      var t
      return (
        e
          ? ((t = rt ? rt + e : e), this._events[t] && Ma(this, t))
          : ((this._events = new Xn()), (this._eventsCount = 0)),
        this
      )
    }
    Qe.prototype.off = Qe.prototype.removeListener
    Qe.prototype.addListener = Qe.prototype.on
    Qe.prefixed = rt
    Qe.EventEmitter = Qe
    typeof Sc < "u" && (Sc.exports = Qe)
  })
  var ym,
    pe,
    Je = d(() => {
      ;((ym = Un(_m(), 1)), (pe = ym.default))
    })
  var hD,
    sr,
    Ne,
    Ct,
    Mm,
    bm,
    Tc,
    dD,
    Aa,
    Am,
    Dm,
    vm,
    Sm,
    Tm,
    Yn,
    fD,
    pD,
    mD,
    gD,
    wc,
    Cm,
    xD,
    Cc,
    Ec,
    Em,
    Mc,
    It,
    wm,
    Pm,
    Rm = d(() => {
      ;((hD = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) }),
        (sr = function (r) {
          return typeof r == "string" ? r.length > 0 : typeof r == "number"
        }),
        (Ne = function (r, e, t) {
          return (
            e === void 0 && (e = 0),
            t === void 0 && (t = Math.pow(10, e)),
            Math.round(t * r) / t + 0
          )
        }),
        (Ct = function (r, e, t) {
          return (e === void 0 && (e = 0), t === void 0 && (t = 1), r > t ? t : r > e ? r : e)
        }),
        (Mm = function (r) {
          return (r = isFinite(r) ? r % 360 : 0) > 0 ? r : r + 360
        }),
        (bm = function (r) {
          return { r: Ct(r.r, 0, 255), g: Ct(r.g, 0, 255), b: Ct(r.b, 0, 255), a: Ct(r.a) }
        }),
        (Tc = function (r) {
          return { r: Ne(r.r), g: Ne(r.g), b: Ne(r.b), a: Ne(r.a, 3) }
        }),
        (dD = /^#([0-9a-f]{3,8})$/i),
        (Aa = function (r) {
          var e = r.toString(16)
          return e.length < 2 ? "0" + e : e
        }),
        (Am = function (r) {
          var e = r.r,
            t = r.g,
            i = r.b,
            n = r.a,
            s = Math.max(e, t, i),
            o = s - Math.min(e, t, i),
            a = o ? (s === e ? (t - i) / o : s === t ? 2 + (i - e) / o : 4 + (e - t) / o) : 0
          return { h: 60 * (a < 0 ? a + 6 : a), s: s ? (o / s) * 100 : 0, v: (s / 255) * 100, a: n }
        }),
        (Dm = function (r) {
          var e = r.h,
            t = r.s,
            i = r.v,
            n = r.a
          ;((e = (e / 360) * 6), (t /= 100), (i /= 100))
          var s = Math.floor(e),
            o = i * (1 - t),
            a = i * (1 - (e - s) * t),
            u = i * (1 - (1 - e + s) * t),
            l = s % 6
          return {
            r: 255 * [i, a, o, o, u, i][l],
            g: 255 * [u, i, i, a, o, o][l],
            b: 255 * [o, o, u, i, i, a][l],
            a: n,
          }
        }),
        (vm = function (r) {
          return { h: Mm(r.h), s: Ct(r.s, 0, 100), l: Ct(r.l, 0, 100), a: Ct(r.a) }
        }),
        (Sm = function (r) {
          return { h: Ne(r.h), s: Ne(r.s), l: Ne(r.l), a: Ne(r.a, 3) }
        }),
        (Tm = function (r) {
          return Dm(
            ((t = (e = r).s),
            {
              h: e.h,
              s: (t *= ((i = e.l) < 50 ? i : 100 - i) / 100) > 0 ? ((2 * t) / (i + t)) * 100 : 0,
              v: i + t,
              a: e.a,
            }),
          )
          var e, t, i
        }),
        (Yn = function (r) {
          return {
            h: (e = Am(r)).h,
            s:
              (n = ((200 - (t = e.s)) * (i = e.v)) / 100) > 0 && n < 200
                ? ((t * i) / 100 / (n <= 100 ? n : 200 - n)) * 100
                : 0,
            l: n / 2,
            a: e.a,
          }
          var e, t, i, n
        }),
        (fD =
          /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i),
        (pD =
          /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i),
        (mD =
          /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i),
        (gD =
          /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i),
        (wc = {
          string: [
            [
              function (r) {
                var e = dD.exec(r)
                return e
                  ? (r = e[1]).length <= 4
                    ? {
                        r: parseInt(r[0] + r[0], 16),
                        g: parseInt(r[1] + r[1], 16),
                        b: parseInt(r[2] + r[2], 16),
                        a: r.length === 4 ? Ne(parseInt(r[3] + r[3], 16) / 255, 2) : 1,
                      }
                    : r.length === 6 || r.length === 8
                      ? {
                          r: parseInt(r.substr(0, 2), 16),
                          g: parseInt(r.substr(2, 2), 16),
                          b: parseInt(r.substr(4, 2), 16),
                          a: r.length === 8 ? Ne(parseInt(r.substr(6, 2), 16) / 255, 2) : 1,
                        }
                      : null
                  : null
              },
              "hex",
            ],
            [
              function (r) {
                var e = mD.exec(r) || gD.exec(r)
                return e
                  ? e[2] !== e[4] || e[4] !== e[6]
                    ? null
                    : bm({
                        r: Number(e[1]) / (e[2] ? 100 / 255 : 1),
                        g: Number(e[3]) / (e[4] ? 100 / 255 : 1),
                        b: Number(e[5]) / (e[6] ? 100 / 255 : 1),
                        a: e[7] === void 0 ? 1 : Number(e[7]) / (e[8] ? 100 : 1),
                      })
                  : null
              },
              "rgb",
            ],
            [
              function (r) {
                var e = fD.exec(r) || pD.exec(r)
                if (!e) return null
                var t,
                  i,
                  n = vm({
                    h:
                      ((t = e[1]),
                      (i = e[2]),
                      i === void 0 && (i = "deg"),
                      Number(t) * (hD[i] || 1)),
                    s: Number(e[3]),
                    l: Number(e[4]),
                    a: e[5] === void 0 ? 1 : Number(e[5]) / (e[6] ? 100 : 1),
                  })
                return Tm(n)
              },
              "hsl",
            ],
          ],
          object: [
            [
              function (r) {
                var e = r.r,
                  t = r.g,
                  i = r.b,
                  n = r.a,
                  s = n === void 0 ? 1 : n
                return sr(e) && sr(t) && sr(i)
                  ? bm({ r: Number(e), g: Number(t), b: Number(i), a: Number(s) })
                  : null
              },
              "rgb",
            ],
            [
              function (r) {
                var e = r.h,
                  t = r.s,
                  i = r.l,
                  n = r.a,
                  s = n === void 0 ? 1 : n
                if (!sr(e) || !sr(t) || !sr(i)) return null
                var o = vm({ h: Number(e), s: Number(t), l: Number(i), a: Number(s) })
                return Tm(o)
              },
              "hsl",
            ],
            [
              function (r) {
                var e = r.h,
                  t = r.s,
                  i = r.v,
                  n = r.a,
                  s = n === void 0 ? 1 : n
                if (!sr(e) || !sr(t) || !sr(i)) return null
                var o = (function (a) {
                  return { h: Mm(a.h), s: Ct(a.s, 0, 100), v: Ct(a.v, 0, 100), a: Ct(a.a) }
                })({ h: Number(e), s: Number(t), v: Number(i), a: Number(s) })
                return Dm(o)
              },
              "hsv",
            ],
          ],
        }),
        (Cm = function (r, e) {
          for (var t = 0; t < e.length; t++) {
            var i = e[t][0](r)
            if (i) return [i, e[t][1]]
          }
          return [null, void 0]
        }),
        (xD = function (r) {
          return typeof r == "string"
            ? Cm(r.trim(), wc.string)
            : typeof r == "object" && r !== null
              ? Cm(r, wc.object)
              : [null, void 0]
        }),
        (Cc = function (r, e) {
          var t = Yn(r)
          return { h: t.h, s: Ct(t.s + 100 * e, 0, 100), l: t.l, a: t.a }
        }),
        (Ec = function (r) {
          return (299 * r.r + 587 * r.g + 114 * r.b) / 1e3 / 255
        }),
        (Em = function (r, e) {
          var t = Yn(r)
          return { h: t.h, s: t.s, l: Ct(t.l + 100 * e, 0, 100), a: t.a }
        }),
        (Mc = (function () {
          function r(e) {
            ;((this.parsed = xD(e)[0]), (this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 }))
          }
          return (
            (r.prototype.isValid = function () {
              return this.parsed !== null
            }),
            (r.prototype.brightness = function () {
              return Ne(Ec(this.rgba), 2)
            }),
            (r.prototype.isDark = function () {
              return Ec(this.rgba) < 0.5
            }),
            (r.prototype.isLight = function () {
              return Ec(this.rgba) >= 0.5
            }),
            (r.prototype.toHex = function () {
              return (
                (e = Tc(this.rgba)),
                (t = e.r),
                (i = e.g),
                (n = e.b),
                (o = (s = e.a) < 1 ? Aa(Ne(255 * s)) : ""),
                "#" + Aa(t) + Aa(i) + Aa(n) + o
              )
              var e, t, i, n, s, o
            }),
            (r.prototype.toRgb = function () {
              return Tc(this.rgba)
            }),
            (r.prototype.toRgbString = function () {
              return (
                (e = Tc(this.rgba)),
                (t = e.r),
                (i = e.g),
                (n = e.b),
                (s = e.a) < 1
                  ? "rgba(" + t + ", " + i + ", " + n + ", " + s + ")"
                  : "rgb(" + t + ", " + i + ", " + n + ")"
              )
              var e, t, i, n, s
            }),
            (r.prototype.toHsl = function () {
              return Sm(Yn(this.rgba))
            }),
            (r.prototype.toHslString = function () {
              return (
                (e = Sm(Yn(this.rgba))),
                (t = e.h),
                (i = e.s),
                (n = e.l),
                (s = e.a) < 1
                  ? "hsla(" + t + ", " + i + "%, " + n + "%, " + s + ")"
                  : "hsl(" + t + ", " + i + "%, " + n + "%)"
              )
              var e, t, i, n, s
            }),
            (r.prototype.toHsv = function () {
              return ((e = Am(this.rgba)), { h: Ne(e.h), s: Ne(e.s), v: Ne(e.v), a: Ne(e.a, 3) })
              var e
            }),
            (r.prototype.invert = function () {
              return It({ r: 255 - (e = this.rgba).r, g: 255 - e.g, b: 255 - e.b, a: e.a })
              var e
            }),
            (r.prototype.saturate = function (e) {
              return (e === void 0 && (e = 0.1), It(Cc(this.rgba, e)))
            }),
            (r.prototype.desaturate = function (e) {
              return (e === void 0 && (e = 0.1), It(Cc(this.rgba, -e)))
            }),
            (r.prototype.grayscale = function () {
              return It(Cc(this.rgba, -1))
            }),
            (r.prototype.lighten = function (e) {
              return (e === void 0 && (e = 0.1), It(Em(this.rgba, e)))
            }),
            (r.prototype.darken = function (e) {
              return (e === void 0 && (e = 0.1), It(Em(this.rgba, -e)))
            }),
            (r.prototype.rotate = function (e) {
              return (e === void 0 && (e = 15), this.hue(this.hue() + e))
            }),
            (r.prototype.alpha = function (e) {
              return typeof e == "number"
                ? It({ r: (t = this.rgba).r, g: t.g, b: t.b, a: e })
                : Ne(this.rgba.a, 3)
              var t
            }),
            (r.prototype.hue = function (e) {
              var t = Yn(this.rgba)
              return typeof e == "number" ? It({ h: e, s: t.s, l: t.l, a: t.a }) : Ne(t.h)
            }),
            (r.prototype.isEqual = function (e) {
              return this.toHex() === It(e).toHex()
            }),
            r
          )
        })()),
        (It = function (r) {
          return r instanceof Mc ? r : new Mc(r)
        }),
        (wm = []),
        (Pm = function (r) {
          r.forEach(function (e) {
            wm.indexOf(e) < 0 && (e(Mc, wc), wm.push(e))
          })
        }))
    })
  function Fm(r, e) {
    var t = {
        white: "#ffffff",
        bisque: "#ffe4c4",
        blue: "#0000ff",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        azure: "#f0ffff",
        whitesmoke: "#f5f5f5",
        papayawhip: "#ffefd5",
        plum: "#dda0dd",
        blanchedalmond: "#ffebcd",
        black: "#000000",
        gold: "#ffd700",
        goldenrod: "#daa520",
        gainsboro: "#dcdcdc",
        cornsilk: "#fff8dc",
        cornflowerblue: "#6495ed",
        burlywood: "#deb887",
        aquamarine: "#7fffd4",
        beige: "#f5f5dc",
        crimson: "#dc143c",
        cyan: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkkhaki: "#bdb76b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkgrey: "#a9a9a9",
        peachpuff: "#ffdab9",
        darkmagenta: "#8b008b",
        darkred: "#8b0000",
        darkorchid: "#9932cc",
        darkorange: "#ff8c00",
        darkslateblue: "#483d8b",
        gray: "#808080",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        wheat: "#f5deb3",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        ghostwhite: "#f8f8ff",
        darkviolet: "#9400d3",
        magenta: "#ff00ff",
        green: "#008000",
        dodgerblue: "#1e90ff",
        grey: "#808080",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        blueviolet: "#8a2be2",
        forestgreen: "#228b22",
        lawngreen: "#7cfc00",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        fuchsia: "#ff00ff",
        brown: "#a52a2a",
        maroon: "#800000",
        mediumblue: "#0000cd",
        lightcoral: "#f08080",
        darkturquoise: "#00ced1",
        lightcyan: "#e0ffff",
        ivory: "#fffff0",
        lightyellow: "#ffffe0",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        linen: "#faf0e6",
        mediumaquamarine: "#66cdaa",
        lemonchiffon: "#fffacd",
        lime: "#00ff00",
        khaki: "#f0e68c",
        mediumseagreen: "#3cb371",
        limegreen: "#32cd32",
        mediumspringgreen: "#00fa9a",
        lightskyblue: "#87cefa",
        lightblue: "#add8e6",
        midnightblue: "#191970",
        lightpink: "#ffb6c1",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        mintcream: "#f5fffa",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        navajowhite: "#ffdead",
        navy: "#000080",
        mediumvioletred: "#c71585",
        powderblue: "#b0e0e6",
        palegoldenrod: "#eee8aa",
        oldlace: "#fdf5e6",
        paleturquoise: "#afeeee",
        mediumturquoise: "#48d1cc",
        mediumorchid: "#ba55d3",
        rebeccapurple: "#663399",
        lightsteelblue: "#b0c4de",
        mediumslateblue: "#7b68ee",
        thistle: "#d8bfd8",
        tan: "#d2b48c",
        orchid: "#da70d6",
        mediumpurple: "#9370db",
        purple: "#800080",
        pink: "#ffc0cb",
        skyblue: "#87ceeb",
        springgreen: "#00ff7f",
        palegreen: "#98fb98",
        red: "#ff0000",
        yellow: "#ffff00",
        slateblue: "#6a5acd",
        lavenderblush: "#fff0f5",
        peru: "#cd853f",
        palevioletred: "#db7093",
        violet: "#ee82ee",
        teal: "#008080",
        slategray: "#708090",
        slategrey: "#708090",
        aliceblue: "#f0f8ff",
        darkseagreen: "#8fbc8f",
        darkolivegreen: "#556b2f",
        greenyellow: "#adff2f",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        tomato: "#ff6347",
        silver: "#c0c0c0",
        sienna: "#a0522d",
        lavender: "#e6e6fa",
        lightgreen: "#90ee90",
        orange: "#ffa500",
        orangered: "#ff4500",
        steelblue: "#4682b4",
        royalblue: "#4169e1",
        turquoise: "#40e0d0",
        yellowgreen: "#9acd32",
        salmon: "#fa8072",
        saddlebrown: "#8b4513",
        sandybrown: "#f4a460",
        rosybrown: "#bc8f8f",
        darksalmon: "#e9967a",
        lightgoldenrodyellow: "#fafad2",
        snow: "#fffafa",
        lightgrey: "#d3d3d3",
        lightgray: "#d3d3d3",
        dimgray: "#696969",
        dimgrey: "#696969",
        olivedrab: "#6b8e23",
        olive: "#808000",
      },
      i = {}
    for (var n in t) i[t[n]] = n
    var s = {}
    ;((r.prototype.toName = function (o) {
      if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent"
      var a,
        u,
        l = i[this.toHex()]
      if (l) return l
      if (o?.closest) {
        var c = this.toRgb(),
          h = 1 / 0,
          f = "black"
        if (!s.length) for (var p in t) s[p] = new r(t[p]).toRgb()
        for (var m in t) {
          var g =
            ((a = c),
            (u = s[m]),
            Math.pow(a.r - u.r, 2) + Math.pow(a.g - u.g, 2) + Math.pow(a.b - u.b, 2))
          g < h && ((h = g), (f = m))
        }
        return f
      }
    }),
      e.string.push([
        function (o) {
          var a = o.toLowerCase(),
            u = a === "transparent" ? "#0000" : t[a]
          return u ? new r(u).toRgb() : null
        },
        "name",
      ]))
  }
  var Bm = d(() => {})
  var Bi,
    q,
    $e = d(() => {
      Rm()
      Bm()
      Pm([Fm])
      Bi = class Kn {
        constructor(e = 16777215) {
          ;((this._value = null),
            (this._components = new Float32Array(4)),
            this._components.fill(1),
            (this._int = 16777215),
            (this.value = e))
        }
        get red() {
          return this._components[0]
        }
        get green() {
          return this._components[1]
        }
        get blue() {
          return this._components[2]
        }
        get alpha() {
          return this._components[3]
        }
        setValue(e) {
          return ((this.value = e), this)
        }
        set value(e) {
          if (e instanceof Kn)
            ((this._value = this._cloneSource(e._value)),
              (this._int = e._int),
              this._components.set(e._components))
          else {
            if (e === null) throw new Error("Cannot set Color#value to null")
            ;(this._value === null || !this._isSourceEqual(this._value, e)) &&
              ((this._value = this._cloneSource(e)), this._normalize(this._value))
          }
        }
        get value() {
          return this._value
        }
        _cloneSource(e) {
          return typeof e == "string" || typeof e == "number" || e instanceof Number || e === null
            ? e
            : Array.isArray(e) || ArrayBuffer.isView(e)
              ? e.slice(0)
              : typeof e == "object" && e !== null
                ? { ...e }
                : e
        }
        _isSourceEqual(e, t) {
          let i = typeof e
          if (i !== typeof t) return !1
          if (i === "number" || i === "string" || e instanceof Number) return e === t
          if (
            (Array.isArray(e) && Array.isArray(t)) ||
            (ArrayBuffer.isView(e) && ArrayBuffer.isView(t))
          )
            return e.length !== t.length ? !1 : e.every((s, o) => s === t[o])
          if (e !== null && t !== null) {
            let s = Object.keys(e),
              o = Object.keys(t)
            return s.length !== o.length ? !1 : s.every((a) => e[a] === t[a])
          }
          return e === t
        }
        toRgba() {
          let [e, t, i, n] = this._components
          return { r: e, g: t, b: i, a: n }
        }
        toRgb() {
          let [e, t, i] = this._components
          return { r: e, g: t, b: i }
        }
        toRgbaString() {
          let [e, t, i] = this.toUint8RgbArray()
          return `rgba(${e},${t},${i},${this.alpha})`
        }
        toUint8RgbArray(e) {
          let [t, i, n] = this._components
          return (
            this._arrayRgb || (this._arrayRgb = []),
            e || (e = this._arrayRgb),
            (e[0] = Math.round(t * 255)),
            (e[1] = Math.round(i * 255)),
            (e[2] = Math.round(n * 255)),
            e
          )
        }
        toArray(e) {
          ;(this._arrayRgba || (this._arrayRgba = []), e || (e = this._arrayRgba))
          let [t, i, n, s] = this._components
          return ((e[0] = t), (e[1] = i), (e[2] = n), (e[3] = s), e)
        }
        toRgbArray(e) {
          ;(this._arrayRgb || (this._arrayRgb = []), e || (e = this._arrayRgb))
          let [t, i, n] = this._components
          return ((e[0] = t), (e[1] = i), (e[2] = n), e)
        }
        toNumber() {
          return this._int
        }
        toBgrNumber() {
          let [e, t, i] = this.toUint8RgbArray()
          return (i << 16) + (t << 8) + e
        }
        toLittleEndianNumber() {
          let e = this._int
          return (e >> 16) + (e & 65280) + ((e & 255) << 16)
        }
        multiply(e) {
          let [t, i, n, s] = Kn._temp.setValue(e)._components
          return (
            (this._components[0] *= t),
            (this._components[1] *= i),
            (this._components[2] *= n),
            (this._components[3] *= s),
            this._refreshInt(),
            (this._value = null),
            this
          )
        }
        premultiply(e, t = !0) {
          return (
            t &&
              ((this._components[0] *= e), (this._components[1] *= e), (this._components[2] *= e)),
            (this._components[3] = e),
            this._refreshInt(),
            (this._value = null),
            this
          )
        }
        toPremultiplied(e, t = !0) {
          if (e === 1) return (255 << 24) + this._int
          if (e === 0) return t ? 0 : this._int
          let i = (this._int >> 16) & 255,
            n = (this._int >> 8) & 255,
            s = this._int & 255
          return (
            t && ((i = (i * e + 0.5) | 0), (n = (n * e + 0.5) | 0), (s = (s * e + 0.5) | 0)),
            ((e * 255) << 24) + (i << 16) + (n << 8) + s
          )
        }
        toHex() {
          let e = this._int.toString(16)
          return `#${"000000".substring(0, 6 - e.length) + e}`
        }
        toHexa() {
          let t = Math.round(this._components[3] * 255).toString(16)
          return this.toHex() + "00".substring(0, 2 - t.length) + t
        }
        setAlpha(e) {
          return ((this._components[3] = this._clamp(e)), this)
        }
        _normalize(e) {
          let t, i, n, s
          if ((typeof e == "number" || e instanceof Number) && e >= 0 && e <= 16777215) {
            let o = e
            ;((t = ((o >> 16) & 255) / 255),
              (i = ((o >> 8) & 255) / 255),
              (n = (o & 255) / 255),
              (s = 1))
          } else if (
            (Array.isArray(e) || e instanceof Float32Array) &&
            e.length >= 3 &&
            e.length <= 4
          )
            ((e = this._clamp(e)), ([t, i, n, s = 1] = e))
          else if (
            (e instanceof Uint8Array || e instanceof Uint8ClampedArray) &&
            e.length >= 3 &&
            e.length <= 4
          )
            ((e = this._clamp(e, 0, 255)),
              ([t, i, n, s = 255] = e),
              (t /= 255),
              (i /= 255),
              (n /= 255),
              (s /= 255))
          else if (typeof e == "string" || typeof e == "object") {
            if (typeof e == "string") {
              let a = Kn.HEX_PATTERN.exec(e)
              a && (e = `#${a[2]}`)
            }
            let o = It(e)
            o.isValid() &&
              (({ r: t, g: i, b: n, a: s } = o.rgba), (t /= 255), (i /= 255), (n /= 255))
          }
          if (t !== void 0)
            ((this._components[0] = t),
              (this._components[1] = i),
              (this._components[2] = n),
              (this._components[3] = s),
              this._refreshInt())
          else throw new Error(`Unable to convert color ${e}`)
        }
        _refreshInt() {
          this._clamp(this._components)
          let [e, t, i] = this._components
          this._int = ((e * 255) << 16) + ((t * 255) << 8) + ((i * 255) | 0)
        }
        _clamp(e, t = 0, i = 1) {
          return typeof e == "number"
            ? Math.min(Math.max(e, t), i)
            : (e.forEach((n, s) => {
                e[s] = Math.min(Math.max(n, t), i)
              }),
              e)
        }
        static isColorLike(e) {
          return (
            typeof e == "number" ||
            typeof e == "string" ||
            e instanceof Number ||
            e instanceof Kn ||
            Array.isArray(e) ||
            e instanceof Uint8Array ||
            e instanceof Uint8ClampedArray ||
            e instanceof Float32Array ||
            (e.r !== void 0 && e.g !== void 0 && e.b !== void 0) ||
            (e.r !== void 0 && e.g !== void 0 && e.b !== void 0 && e.a !== void 0) ||
            (e.h !== void 0 && e.s !== void 0 && e.l !== void 0) ||
            (e.h !== void 0 && e.s !== void 0 && e.l !== void 0 && e.a !== void 0) ||
            (e.h !== void 0 && e.s !== void 0 && e.v !== void 0) ||
            (e.h !== void 0 && e.s !== void 0 && e.v !== void 0 && e.a !== void 0)
          )
        }
      }
      Bi.shared = new Bi()
      Bi._temp = new Bi()
      Bi.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i
      q = Bi
    })
  var Im,
    Gm = d(() => {
      "use strict"
      Im = { cullArea: null, cullable: !1, cullableChildren: !0 }
    })
  var km,
    Um,
    Om,
    Ac = d(() => {
      "use strict"
      ;((km = Math.PI * 2), (Um = 180 / Math.PI), (Om = Math.PI / 180))
    })
  var re,
    Dc,
    Et = d(() => {
      "use strict"
      ;((re = class r {
        constructor(e = 0, t = 0) {
          ;((this.x = 0), (this.y = 0), (this.x = e), (this.y = t))
        }
        clone() {
          return new r(this.x, this.y)
        }
        copyFrom(e) {
          return (this.set(e.x, e.y), this)
        }
        copyTo(e) {
          return (e.set(this.x, this.y), e)
        }
        equals(e) {
          return e.x === this.x && e.y === this.y
        }
        set(e = 0, t = e) {
          return ((this.x = e), (this.y = t), this)
        }
        toString() {
          return `[pixi.js/math:Point x=${this.x} y=${this.y}]`
        }
        static get shared() {
          return ((Dc.x = 0), (Dc.y = 0), Dc)
        }
      }),
        (Dc = new re()))
    })
  var F,
    _D,
    yD,
    se = d(() => {
      Ac()
      Et()
      ;((F = class r {
        constructor(e = 1, t = 0, i = 0, n = 1, s = 0, o = 0) {
          ;((this.array = null),
            (this.a = e),
            (this.b = t),
            (this.c = i),
            (this.d = n),
            (this.tx = s),
            (this.ty = o))
        }
        fromArray(e) {
          ;((this.a = e[0]),
            (this.b = e[1]),
            (this.c = e[3]),
            (this.d = e[4]),
            (this.tx = e[2]),
            (this.ty = e[5]))
        }
        set(e, t, i, n, s, o) {
          return (
            (this.a = e),
            (this.b = t),
            (this.c = i),
            (this.d = n),
            (this.tx = s),
            (this.ty = o),
            this
          )
        }
        toArray(e, t) {
          this.array || (this.array = new Float32Array(9))
          let i = t || this.array
          return (
            e
              ? ((i[0] = this.a),
                (i[1] = this.b),
                (i[2] = 0),
                (i[3] = this.c),
                (i[4] = this.d),
                (i[5] = 0),
                (i[6] = this.tx),
                (i[7] = this.ty),
                (i[8] = 1))
              : ((i[0] = this.a),
                (i[1] = this.c),
                (i[2] = this.tx),
                (i[3] = this.b),
                (i[4] = this.d),
                (i[5] = this.ty),
                (i[6] = 0),
                (i[7] = 0),
                (i[8] = 1)),
            i
          )
        }
        apply(e, t) {
          t = t || new re()
          let i = e.x,
            n = e.y
          return (
            (t.x = this.a * i + this.c * n + this.tx),
            (t.y = this.b * i + this.d * n + this.ty),
            t
          )
        }
        applyInverse(e, t) {
          t = t || new re()
          let i = this.a,
            n = this.b,
            s = this.c,
            o = this.d,
            a = this.tx,
            u = this.ty,
            l = 1 / (i * o + s * -n),
            c = e.x,
            h = e.y
          return (
            (t.x = o * l * c + -s * l * h + (u * s - a * o) * l),
            (t.y = i * l * h + -n * l * c + (-u * i + a * n) * l),
            t
          )
        }
        translate(e, t) {
          return ((this.tx += e), (this.ty += t), this)
        }
        scale(e, t) {
          return (
            (this.a *= e),
            (this.d *= t),
            (this.c *= e),
            (this.b *= t),
            (this.tx *= e),
            (this.ty *= t),
            this
          )
        }
        rotate(e) {
          let t = Math.cos(e),
            i = Math.sin(e),
            n = this.a,
            s = this.c,
            o = this.tx
          return (
            (this.a = n * t - this.b * i),
            (this.b = n * i + this.b * t),
            (this.c = s * t - this.d * i),
            (this.d = s * i + this.d * t),
            (this.tx = o * t - this.ty * i),
            (this.ty = o * i + this.ty * t),
            this
          )
        }
        append(e) {
          let t = this.a,
            i = this.b,
            n = this.c,
            s = this.d
          return (
            (this.a = e.a * t + e.b * n),
            (this.b = e.a * i + e.b * s),
            (this.c = e.c * t + e.d * n),
            (this.d = e.c * i + e.d * s),
            (this.tx = e.tx * t + e.ty * n + this.tx),
            (this.ty = e.tx * i + e.ty * s + this.ty),
            this
          )
        }
        appendFrom(e, t) {
          let i = e.a,
            n = e.b,
            s = e.c,
            o = e.d,
            a = e.tx,
            u = e.ty,
            l = t.a,
            c = t.b,
            h = t.c,
            f = t.d
          return (
            (this.a = i * l + n * h),
            (this.b = i * c + n * f),
            (this.c = s * l + o * h),
            (this.d = s * c + o * f),
            (this.tx = a * l + u * h + t.tx),
            (this.ty = a * c + u * f + t.ty),
            this
          )
        }
        setTransform(e, t, i, n, s, o, a, u, l) {
          return (
            (this.a = Math.cos(a + l) * s),
            (this.b = Math.sin(a + l) * s),
            (this.c = -Math.sin(a - u) * o),
            (this.d = Math.cos(a - u) * o),
            (this.tx = e - (i * this.a + n * this.c)),
            (this.ty = t - (i * this.b + n * this.d)),
            this
          )
        }
        prepend(e) {
          let t = this.tx
          if (e.a !== 1 || e.b !== 0 || e.c !== 0 || e.d !== 1) {
            let i = this.a,
              n = this.c
            ;((this.a = i * e.a + this.b * e.c),
              (this.b = i * e.b + this.b * e.d),
              (this.c = n * e.a + this.d * e.c),
              (this.d = n * e.b + this.d * e.d))
          }
          return (
            (this.tx = t * e.a + this.ty * e.c + e.tx),
            (this.ty = t * e.b + this.ty * e.d + e.ty),
            this
          )
        }
        decompose(e) {
          let t = this.a,
            i = this.b,
            n = this.c,
            s = this.d,
            o = e.pivot,
            a = -Math.atan2(-n, s),
            u = Math.atan2(i, t),
            l = Math.abs(a + u)
          return (
            l < 1e-5 || Math.abs(km - l) < 1e-5
              ? ((e.rotation = u), (e.skew.x = e.skew.y = 0))
              : ((e.rotation = 0), (e.skew.x = a), (e.skew.y = u)),
            (e.scale.x = Math.sqrt(t * t + i * i)),
            (e.scale.y = Math.sqrt(n * n + s * s)),
            (e.position.x = this.tx + (o.x * t + o.y * n)),
            (e.position.y = this.ty + (o.x * i + o.y * s)),
            e
          )
        }
        invert() {
          let e = this.a,
            t = this.b,
            i = this.c,
            n = this.d,
            s = this.tx,
            o = e * n - t * i
          return (
            (this.a = n / o),
            (this.b = -t / o),
            (this.c = -i / o),
            (this.d = e / o),
            (this.tx = (i * this.ty - n * s) / o),
            (this.ty = -(e * this.ty - t * s) / o),
            this
          )
        }
        isIdentity() {
          return (
            this.a === 1 &&
            this.b === 0 &&
            this.c === 0 &&
            this.d === 1 &&
            this.tx === 0 &&
            this.ty === 0
          )
        }
        identity() {
          return (
            (this.a = 1),
            (this.b = 0),
            (this.c = 0),
            (this.d = 1),
            (this.tx = 0),
            (this.ty = 0),
            this
          )
        }
        clone() {
          let e = new r()
          return (
            (e.a = this.a),
            (e.b = this.b),
            (e.c = this.c),
            (e.d = this.d),
            (e.tx = this.tx),
            (e.ty = this.ty),
            e
          )
        }
        copyTo(e) {
          return (
            (e.a = this.a),
            (e.b = this.b),
            (e.c = this.c),
            (e.d = this.d),
            (e.tx = this.tx),
            (e.ty = this.ty),
            e
          )
        }
        copyFrom(e) {
          return (
            (this.a = e.a),
            (this.b = e.b),
            (this.c = e.c),
            (this.d = e.d),
            (this.tx = e.tx),
            (this.ty = e.ty),
            this
          )
        }
        equals(e) {
          return (
            e.a === this.a &&
            e.b === this.b &&
            e.c === this.c &&
            e.d === this.d &&
            e.tx === this.tx &&
            e.ty === this.ty
          )
        }
        toString() {
          return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`
        }
        static get IDENTITY() {
          return yD.identity()
        }
        static get shared() {
          return _D.identity()
        }
      }),
        (_D = new F()),
        (yD = new F()))
    })
  var Xe,
    Da = d(() => {
      "use strict"
      Xe = class r {
        constructor(e, t, i) {
          ;((this._x = t || 0), (this._y = i || 0), (this._observer = e))
        }
        clone(e) {
          return new r(e ?? this._observer, this._x, this._y)
        }
        set(e = 0, t = e) {
          return (
            (this._x !== e || this._y !== t) &&
              ((this._x = e), (this._y = t), this._observer._onUpdate(this)),
            this
          )
        }
        copyFrom(e) {
          return (
            (this._x !== e.x || this._y !== e.y) &&
              ((this._x = e.x), (this._y = e.y), this._observer._onUpdate(this)),
            this
          )
        }
        copyTo(e) {
          return (e.set(this._x, this._y), e)
        }
        equals(e) {
          return e.x === this._x && e.y === this._y
        }
        toString() {
          return `[pixi.js/math:ObservablePoint x=0 y=0 scope=${this._observer}]`
        }
        get x() {
          return this._x
        }
        set x(e) {
          this._x !== e && ((this._x = e), this._observer._onUpdate(this))
        }
        get y() {
          return this._y
        }
        set y(e) {
          this._y !== e && ((this._y = e), this._observer._onUpdate(this))
        }
      }
    })
  function te(r = "default") {
    return (Pc[r] === void 0 && (Pc[r] = -1), ++Pc[r])
  }
  var Pc,
    Ye = d(() => {
      "use strict"
      Pc = { default: -1 }
    })
  function z(r, e, t = 3) {
    if (Lm[e]) return
    let i = new Error().stack
    ;(typeof i > "u"
      ? console.warn(
          "PixiJS Deprecation Warning: ",
          `${e}
Deprecated since v${r}`,
        )
      : ((i = i
          .split(
            `
`,
          )
          .splice(t).join(`
`)),
        console.groupCollapsed
          ? (console.groupCollapsed(
              "%cPixiJS Deprecation Warning: %c%s",
              "color:#614108;background:#fffbe6",
              "font-weight:normal;color:#614108;background:#fffbe6",
              `${e}
Deprecated since v${r}`,
            ),
            console.warn(i),
            console.groupEnd())
          : (console.warn(
              "PixiJS Deprecation Warning: ",
              `${e}
Deprecated since v${r}`,
            ),
            console.warn(i))),
      (Lm[e] = !0))
  }
  var Lm,
    K,
    Nm,
    Te = d(() => {
      "use strict"
      ;((Lm = {}), (K = "8.0.0"), (Nm = "8.3.4"))
    })
  var Qr,
    Rc = d(() => {
      "use strict"
      Qr = class {
        constructor(e, t) {
          ;((this._pool = []),
            (this._count = 0),
            (this._index = 0),
            (this._classType = e),
            t && this.prepopulate(t))
        }
        prepopulate(e) {
          for (let t = 0; t < e; t++) this._pool[this._index++] = new this._classType()
          this._count += e
        }
        get(e) {
          let t
          return (
            this._index > 0 ? (t = this._pool[--this._index]) : (t = new this._classType()),
            t.init?.(e),
            t
          )
        }
        return(e) {
          ;(e.reset?.(), (this._pool[this._index++] = e))
        }
        get totalSize() {
          return this._count
        }
        get totalFree() {
          return this._index
        }
        get totalUsed() {
          return this._count - this._index
        }
        clear() {
          ;((this._pool.length = 0), (this._index = 0))
        }
      }
    })
  var Fc,
    j,
    it = d(() => {
      Rc()
      ;((Fc = class {
        constructor() {
          this._poolsByClass = new Map()
        }
        prepopulate(e, t) {
          this.getPool(e).prepopulate(t)
        }
        get(e, t) {
          return this.getPool(e).get(t)
        }
        return(e) {
          this.getPool(e.constructor).return(e)
        }
        getPool(e) {
          return (
            this._poolsByClass.has(e) || this._poolsByClass.set(e, new Qr(e)),
            this._poolsByClass.get(e)
          )
        }
        stats() {
          let e = {}
          return (
            this._poolsByClass.forEach((t) => {
              let i = e[t._classType.name] ? t._classType.name + t._classType.ID : t._classType.name
              e[i] = { free: t.totalFree, used: t.totalUsed, size: t.totalSize }
            }),
            e
          )
        }
      }),
        (j = new Fc()))
    })
  var Hm,
    zm = d(() => {
      Te()
      Hm = {
        get isCachedAsTexture() {
          return !!this.renderGroup?.isCachedAsTexture
        },
        cacheAsTexture(r) {
          typeof r == "boolean" && r === !1
            ? this.disableRenderGroup()
            : (this.enableRenderGroup(), this.renderGroup.enableCacheAsTexture(r === !0 ? {} : r))
        },
        updateCacheTexture() {
          this.renderGroup?.updateCacheTexture()
        },
        get cacheAsBitmap() {
          return this.isCachedAsTexture
        },
        set cacheAsBitmap(r) {
          ;(z("v8.6.0", "cacheAsBitmap is deprecated, use cacheAsTexture instead."),
            this.cacheAsTexture(r))
        },
      }
    })
  function Pa(r, e, t) {
    let i = r.length,
      n
    if (e >= i || t === 0) return
    t = e + t > i ? i - e : t
    let s = i - t
    for (n = e; n < s; ++n) r[n] = r[n + t]
    r.length = s
  }
  var Bc = d(() => {
    "use strict"
  })
  var Wm,
    Vm = d(() => {
      Bc()
      Te()
      Wm = {
        allowChildren: !0,
        removeChildren(r = 0, e) {
          let t = e ?? this.children.length,
            i = t - r,
            n = []
          if (i > 0 && i <= t) {
            for (let o = t - 1; o >= r; o--) {
              let a = this.children[o]
              a && (n.push(a), (a.parent = null))
            }
            Pa(this.children, r, t)
            let s = this.renderGroup || this.parentRenderGroup
            s && s.removeChildren(n)
            for (let o = 0; o < n.length; ++o) {
              let a = n[o]
              ;(a.parentRenderLayer?.detach(a),
                this.emit("childRemoved", a, this, o),
                n[o].emit("removed", this))
            }
            return (n.length > 0 && this._didViewChangeTick++, n)
          } else if (i === 0 && this.children.length === 0) return n
          throw new RangeError("removeChildren: numeric values are outside the acceptable range.")
        },
        removeChildAt(r) {
          let e = this.getChildAt(r)
          return this.removeChild(e)
        },
        getChildAt(r) {
          if (r < 0 || r >= this.children.length)
            throw new Error(`getChildAt: Index (${r}) does not exist.`)
          return this.children[r]
        },
        setChildIndex(r, e) {
          if (e < 0 || e >= this.children.length)
            throw new Error(`The index ${e} supplied is out of bounds ${this.children.length}`)
          ;(this.getChildIndex(r), this.addChildAt(r, e))
        },
        getChildIndex(r) {
          let e = this.children.indexOf(r)
          if (e === -1) throw new Error("The supplied Container must be a child of the caller")
          return e
        },
        addChildAt(r, e) {
          this.allowChildren ||
            z(K, "addChildAt: Only Containers will be allowed to add children in v8.0.0")
          let { children: t } = this
          if (e < 0 || e > t.length)
            throw new Error(`${r}addChildAt: The index ${e} supplied is out of bounds ${t.length}`)
          if (r.parent) {
            let n = r.parent.children.indexOf(r)
            if (r.parent === this && n === e) return r
            n !== -1 && r.parent.children.splice(n, 1)
          }
          ;(e === t.length ? t.push(r) : t.splice(e, 0, r),
            (r.parent = this),
            (r.didChange = !0),
            (r._updateFlags = 15))
          let i = this.renderGroup || this.parentRenderGroup
          return (
            i && i.addChild(r),
            this.sortableChildren && (this.sortDirty = !0),
            this.emit("childAdded", r, this, e),
            r.emit("added", this),
            r
          )
        },
        swapChildren(r, e) {
          if (r === e) return
          let t = this.getChildIndex(r),
            i = this.getChildIndex(e)
          ;((this.children[t] = e), (this.children[i] = r))
          let n = this.renderGroup || this.parentRenderGroup
          ;(n && (n.structureDidChange = !0), this._didContainerChangeTick++)
        },
        removeFromParent() {
          this.parent?.removeChild(this)
        },
        reparentChild(...r) {
          return r.length === 1
            ? this.reparentChildAt(r[0], this.children.length)
            : (r.forEach((e) => this.reparentChildAt(e, this.children.length)), r[0])
        },
        reparentChildAt(r, e) {
          if (r.parent === this) return (this.setChildIndex(r, e), r)
          let t = r.worldTransform.clone()
          ;(r.removeFromParent(), this.addChildAt(r, e))
          let i = this.worldTransform.clone()
          return (i.invert(), t.prepend(i), r.setFromMatrix(t), r)
        },
      }
    })
  var $m,
    Xm = d(() => {
      "use strict"
      $m = {
        collectRenderables(r, e, t) {
          ;(this.parentRenderLayer && this.parentRenderLayer !== t) ||
            this.globalDisplayStatus < 7 ||
            !this.includeInBuild ||
            (this.sortableChildren && this.sortChildren(),
            this.isSimple
              ? this.collectRenderablesSimple(r, e, t)
              : this.renderGroup
                ? e.renderPipes.renderGroup.addRenderGroup(this.renderGroup, r)
                : this.collectRenderablesWithEffects(r, e, t))
        },
        collectRenderablesSimple(r, e, t) {
          let i = this.children,
            n = i.length
          for (let s = 0; s < n; s++) i[s].collectRenderables(r, e, t)
        },
        collectRenderablesWithEffects(r, e, t) {
          let { renderPipes: i } = e
          for (let n = 0; n < this.effects.length; n++) {
            let s = this.effects[n]
            i[s.pipe].push(s, this, r)
          }
          this.collectRenderablesSimple(r, e, t)
          for (let n = this.effects.length - 1; n >= 0; n--) {
            let s = this.effects[n]
            i[s.pipe].pop(s, this, r)
          }
        },
      }
    })
  var or,
    Ra = d(() => {
      "use strict"
      or = class {
        constructor() {
          ;((this.pipe = "filter"), (this.priority = 1))
        }
        destroy() {
          for (let e = 0; e < this.filters.length; e++) this.filters[e].destroy()
          ;((this.filters = null), (this.filterArea = null))
        }
      }
    })
  var Ic,
    Fa,
    Ym = d(() => {
      D()
      it()
      ;((Ic = class {
        constructor() {
          ;((this._effectClasses = []), (this._tests = []), (this._initialized = !1))
        }
        init() {
          this._initialized ||
            ((this._initialized = !0),
            this._effectClasses.forEach((e) => {
              this.add({ test: e.test, maskClass: e })
            }))
        }
        add(e) {
          this._tests.push(e)
        }
        getMaskEffect(e) {
          this._initialized || this.init()
          for (let t = 0; t < this._tests.length; t++) {
            let i = this._tests[t]
            if (i.test(e)) return j.get(i.maskClass, e)
          }
          return e
        }
        returnMaskEffect(e) {
          j.return(e)
        }
      }),
        (Fa = new Ic()))
      L.handleByList(_.MaskEffect, Fa._effectClasses)
    })
  var Km,
    jm = d(() => {
      Ra()
      Ym()
      Km = {
        _maskEffect: null,
        _maskOptions: { inverse: !1 },
        _filterEffect: null,
        effects: [],
        _markStructureAsChanged() {
          let r = this.renderGroup || this.parentRenderGroup
          r && (r.structureDidChange = !0)
        },
        addEffect(r) {
          this.effects.indexOf(r) === -1 &&
            (this.effects.push(r),
            this.effects.sort((t, i) => t.priority - i.priority),
            this._markStructureAsChanged(),
            this._updateIsSimple())
        },
        removeEffect(r) {
          let e = this.effects.indexOf(r)
          e !== -1 &&
            (this.effects.splice(e, 1), this._markStructureAsChanged(), this._updateIsSimple())
        },
        set mask(r) {
          let e = this._maskEffect
          e?.mask !== r &&
            (e && (this.removeEffect(e), Fa.returnMaskEffect(e), (this._maskEffect = null)),
            r != null &&
              ((this._maskEffect = Fa.getMaskEffect(r)), this.addEffect(this._maskEffect)))
        },
        setMask(r) {
          ;((this._maskOptions = { ...this._maskOptions, ...r }),
            r.mask && (this.mask = r.mask),
            this._markStructureAsChanged())
        },
        get mask() {
          return this._maskEffect?.mask
        },
        set filters(r) {
          !Array.isArray(r) && r && (r = [r])
          let e = this._filterEffect || (this._filterEffect = new or())
          r = r
          let t = r?.length > 0,
            i = e.filters?.length > 0,
            n = t !== i
          ;((r = Array.isArray(r) ? r.slice(0) : r),
            (e.filters = Object.freeze(r)),
            n && (t ? this.addEffect(e) : (this.removeEffect(e), (e.filters = r ?? null))))
        },
        get filters() {
          return this._filterEffect?.filters
        },
        set filterArea(r) {
          ;(this._filterEffect || (this._filterEffect = new or()),
            (this._filterEffect.filterArea = r))
        },
        get filterArea() {
          return this._filterEffect?.filterArea
        },
      }
    })
  var qm,
    Zm = d(() => {
      Te()
      qm = {
        label: null,
        get name() {
          return (
            z(K, "Container.name property has been removed, use Container.label instead"),
            this.label
          )
        },
        set name(r) {
          ;(z(K, "Container.name property has been removed, use Container.label instead"),
            (this.label = r))
        },
        getChildByName(r, e = !1) {
          return this.getChildByLabel(r, e)
        },
        getChildByLabel(r, e = !1) {
          let t = this.children
          for (let i = 0; i < t.length; i++) {
            let n = t[i]
            if (n.label === r || (r instanceof RegExp && r.test(n.label))) return n
          }
          if (e)
            for (let i = 0; i < t.length; i++) {
              let s = t[i].getChildByLabel(r, !0)
              if (s) return s
            }
          return null
        },
        getChildrenByLabel(r, e = !1, t = []) {
          let i = this.children
          for (let n = 0; n < i.length; n++) {
            let s = i[n]
            ;(s.label === r || (r instanceof RegExp && r.test(s.label))) && t.push(s)
          }
          if (e) for (let n = 0; n < i.length; n++) i[n].getChildrenByLabel(r, !0, t)
          return t
        },
      }
    })
  var Ba,
    ee,
    Ke = d(() => {
      Et()
      ;((Ba = [new re(), new re(), new re(), new re()]),
        (ee = class r {
          constructor(e = 0, t = 0, i = 0, n = 0) {
            ;((this.type = "rectangle"),
              (this.x = Number(e)),
              (this.y = Number(t)),
              (this.width = Number(i)),
              (this.height = Number(n)))
          }
          get left() {
            return this.x
          }
          get right() {
            return this.x + this.width
          }
          get top() {
            return this.y
          }
          get bottom() {
            return this.y + this.height
          }
          isEmpty() {
            return this.left === this.right || this.top === this.bottom
          }
          static get EMPTY() {
            return new r(0, 0, 0, 0)
          }
          clone() {
            return new r(this.x, this.y, this.width, this.height)
          }
          copyFromBounds(e) {
            return (
              (this.x = e.minX),
              (this.y = e.minY),
              (this.width = e.maxX - e.minX),
              (this.height = e.maxY - e.minY),
              this
            )
          }
          copyFrom(e) {
            return (
              (this.x = e.x),
              (this.y = e.y),
              (this.width = e.width),
              (this.height = e.height),
              this
            )
          }
          copyTo(e) {
            return (e.copyFrom(this), e)
          }
          contains(e, t) {
            return this.width <= 0 || this.height <= 0
              ? !1
              : e >= this.x && e < this.x + this.width && t >= this.y && t < this.y + this.height
          }
          strokeContains(e, t, i, n = 0.5) {
            let { width: s, height: o } = this
            if (s <= 0 || o <= 0) return !1
            let a = this.x,
              u = this.y,
              l = i * (1 - n),
              c = i - l,
              h = a - l,
              f = a + s + l,
              p = u - l,
              m = u + o + l,
              g = a + c,
              x = a + s - c,
              y = u + c,
              v = u + o - c
            return e >= h && e <= f && t >= p && t <= m && !(e > g && e < x && t > y && t < v)
          }
          intersects(e, t) {
            if (!t) {
              let B = this.x < e.x ? e.x : this.x
              if ((this.right > e.right ? e.right : this.right) <= B) return !1
              let G = this.y < e.y ? e.y : this.y
              return (this.bottom > e.bottom ? e.bottom : this.bottom) > G
            }
            let i = this.left,
              n = this.right,
              s = this.top,
              o = this.bottom
            if (n <= i || o <= s) return !1
            let a = Ba[0].set(e.left, e.top),
              u = Ba[1].set(e.left, e.bottom),
              l = Ba[2].set(e.right, e.top),
              c = Ba[3].set(e.right, e.bottom)
            if (l.x <= a.x || u.y <= a.y) return !1
            let h = Math.sign(t.a * t.d - t.b * t.c)
            if (
              h === 0 ||
              (t.apply(a, a),
              t.apply(u, u),
              t.apply(l, l),
              t.apply(c, c),
              Math.max(a.x, u.x, l.x, c.x) <= i ||
                Math.min(a.x, u.x, l.x, c.x) >= n ||
                Math.max(a.y, u.y, l.y, c.y) <= s ||
                Math.min(a.y, u.y, l.y, c.y) >= o)
            )
              return !1
            let f = h * (u.y - a.y),
              p = h * (a.x - u.x),
              m = f * i + p * s,
              g = f * n + p * s,
              x = f * i + p * o,
              y = f * n + p * o
            if (
              Math.max(m, g, x, y) <= f * a.x + p * a.y ||
              Math.min(m, g, x, y) >= f * c.x + p * c.y
            )
              return !1
            let v = h * (a.y - l.y),
              S = h * (l.x - a.x),
              b = v * i + S * s,
              M = v * n + S * s,
              C = v * i + S * o,
              w = v * n + S * o
            return !(
              Math.max(b, M, C, w) <= v * a.x + S * a.y || Math.min(b, M, C, w) >= v * c.x + S * c.y
            )
          }
          pad(e = 0, t = e) {
            return (
              (this.x -= e),
              (this.y -= t),
              (this.width += e * 2),
              (this.height += t * 2),
              this
            )
          }
          fit(e) {
            let t = Math.max(this.x, e.x),
              i = Math.min(this.x + this.width, e.x + e.width),
              n = Math.max(this.y, e.y),
              s = Math.min(this.y + this.height, e.y + e.height)
            return (
              (this.x = t),
              (this.width = Math.max(i - t, 0)),
              (this.y = n),
              (this.height = Math.max(s - n, 0)),
              this
            )
          }
          ceil(e = 1, t = 0.001) {
            let i = Math.ceil((this.x + this.width - t) * e) / e,
              n = Math.ceil((this.y + this.height - t) * e) / e
            return (
              (this.x = Math.floor((this.x + t) * e) / e),
              (this.y = Math.floor((this.y + t) * e) / e),
              (this.width = i - this.x),
              (this.height = n - this.y),
              this
            )
          }
          enlarge(e) {
            let t = Math.min(this.x, e.x),
              i = Math.max(this.x + this.width, e.x + e.width),
              n = Math.min(this.y, e.y),
              s = Math.max(this.y + this.height, e.y + e.height)
            return ((this.x = t), (this.width = i - t), (this.y = n), (this.height = s - n), this)
          }
          getBounds(e) {
            return (e || (e = new r()), e.copyFrom(this), e)
          }
          containsRect(e) {
            if (this.width <= 0 || this.height <= 0) return !1
            let t = e.x,
              i = e.y,
              n = e.x + e.width,
              s = e.y + e.height
            return (
              t >= this.x &&
              t < this.x + this.width &&
              i >= this.y &&
              i < this.y + this.height &&
              n >= this.x &&
              n < this.x + this.width &&
              s >= this.y &&
              s < this.y + this.height
            )
          }
          toString() {
            return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`
          }
        }))
    })
  var Qm,
    de,
    lt = d(() => {
      se()
      Ke()
      ;((Qm = new F()),
        (de = class r {
          constructor(e = 1 / 0, t = 1 / 0, i = -1 / 0, n = -1 / 0) {
            ;((this.minX = 1 / 0),
              (this.minY = 1 / 0),
              (this.maxX = -1 / 0),
              (this.maxY = -1 / 0),
              (this.matrix = Qm),
              (this.minX = e),
              (this.minY = t),
              (this.maxX = i),
              (this.maxY = n))
          }
          isEmpty() {
            return this.minX > this.maxX || this.minY > this.maxY
          }
          get rectangle() {
            this._rectangle || (this._rectangle = new ee())
            let e = this._rectangle
            return (
              this.minX > this.maxX || this.minY > this.maxY
                ? ((e.x = 0), (e.y = 0), (e.width = 0), (e.height = 0))
                : e.copyFromBounds(this),
              e
            )
          }
          clear() {
            return (
              (this.minX = 1 / 0),
              (this.minY = 1 / 0),
              (this.maxX = -1 / 0),
              (this.maxY = -1 / 0),
              (this.matrix = Qm),
              this
            )
          }
          set(e, t, i, n) {
            ;((this.minX = e), (this.minY = t), (this.maxX = i), (this.maxY = n))
          }
          addFrame(e, t, i, n, s) {
            s || (s = this.matrix)
            let o = s.a,
              a = s.b,
              u = s.c,
              l = s.d,
              c = s.tx,
              h = s.ty,
              f = this.minX,
              p = this.minY,
              m = this.maxX,
              g = this.maxY,
              x = o * e + u * t + c,
              y = a * e + l * t + h
            ;(x < f && (f = x),
              y < p && (p = y),
              x > m && (m = x),
              y > g && (g = y),
              (x = o * i + u * t + c),
              (y = a * i + l * t + h),
              x < f && (f = x),
              y < p && (p = y),
              x > m && (m = x),
              y > g && (g = y),
              (x = o * e + u * n + c),
              (y = a * e + l * n + h),
              x < f && (f = x),
              y < p && (p = y),
              x > m && (m = x),
              y > g && (g = y),
              (x = o * i + u * n + c),
              (y = a * i + l * n + h),
              x < f && (f = x),
              y < p && (p = y),
              x > m && (m = x),
              y > g && (g = y),
              (this.minX = f),
              (this.minY = p),
              (this.maxX = m),
              (this.maxY = g))
          }
          addRect(e, t) {
            this.addFrame(e.x, e.y, e.x + e.width, e.y + e.height, t)
          }
          addBounds(e, t) {
            this.addFrame(e.minX, e.minY, e.maxX, e.maxY, t)
          }
          addBoundsMask(e) {
            ;((this.minX = this.minX > e.minX ? this.minX : e.minX),
              (this.minY = this.minY > e.minY ? this.minY : e.minY),
              (this.maxX = this.maxX < e.maxX ? this.maxX : e.maxX),
              (this.maxY = this.maxY < e.maxY ? this.maxY : e.maxY))
          }
          applyMatrix(e) {
            let t = this.minX,
              i = this.minY,
              n = this.maxX,
              s = this.maxY,
              { a: o, b: a, c: u, d: l, tx: c, ty: h } = e,
              f = o * t + u * i + c,
              p = a * t + l * i + h
            ;((this.minX = f),
              (this.minY = p),
              (this.maxX = f),
              (this.maxY = p),
              (f = o * n + u * i + c),
              (p = a * n + l * i + h),
              (this.minX = f < this.minX ? f : this.minX),
              (this.minY = p < this.minY ? p : this.minY),
              (this.maxX = f > this.maxX ? f : this.maxX),
              (this.maxY = p > this.maxY ? p : this.maxY),
              (f = o * t + u * s + c),
              (p = a * t + l * s + h),
              (this.minX = f < this.minX ? f : this.minX),
              (this.minY = p < this.minY ? p : this.minY),
              (this.maxX = f > this.maxX ? f : this.maxX),
              (this.maxY = p > this.maxY ? p : this.maxY),
              (f = o * n + u * s + c),
              (p = a * n + l * s + h),
              (this.minX = f < this.minX ? f : this.minX),
              (this.minY = p < this.minY ? p : this.minY),
              (this.maxX = f > this.maxX ? f : this.maxX),
              (this.maxY = p > this.maxY ? p : this.maxY))
          }
          fit(e) {
            return (
              this.minX < e.left && (this.minX = e.left),
              this.maxX > e.right && (this.maxX = e.right),
              this.minY < e.top && (this.minY = e.top),
              this.maxY > e.bottom && (this.maxY = e.bottom),
              this
            )
          }
          fitBounds(e, t, i, n) {
            return (
              this.minX < e && (this.minX = e),
              this.maxX > t && (this.maxX = t),
              this.minY < i && (this.minY = i),
              this.maxY > n && (this.maxY = n),
              this
            )
          }
          pad(e, t = e) {
            return ((this.minX -= e), (this.maxX += e), (this.minY -= t), (this.maxY += t), this)
          }
          ceil() {
            return (
              (this.minX = Math.floor(this.minX)),
              (this.minY = Math.floor(this.minY)),
              (this.maxX = Math.ceil(this.maxX)),
              (this.maxY = Math.ceil(this.maxY)),
              this
            )
          }
          clone() {
            return new r(this.minX, this.minY, this.maxX, this.maxY)
          }
          scale(e, t = e) {
            return ((this.minX *= e), (this.minY *= t), (this.maxX *= e), (this.maxY *= t), this)
          }
          get x() {
            return this.minX
          }
          set x(e) {
            let t = this.maxX - this.minX
            ;((this.minX = e), (this.maxX = e + t))
          }
          get y() {
            return this.minY
          }
          set y(e) {
            let t = this.maxY - this.minY
            ;((this.minY = e), (this.maxY = e + t))
          }
          get width() {
            return this.maxX - this.minX
          }
          set width(e) {
            this.maxX = this.minX + e
          }
          get height() {
            return this.maxY - this.minY
          }
          set height(e) {
            this.maxY = this.minY + e
          }
          get left() {
            return this.minX
          }
          get right() {
            return this.maxX
          }
          get top() {
            return this.minY
          }
          get bottom() {
            return this.maxY
          }
          get isPositive() {
            return this.maxX - this.minX > 0 && this.maxY - this.minY > 0
          }
          get isValid() {
            return this.minX + this.minY !== 1 / 0
          }
          addVertexData(e, t, i, n) {
            let s = this.minX,
              o = this.minY,
              a = this.maxX,
              u = this.maxY
            n || (n = this.matrix)
            let l = n.a,
              c = n.b,
              h = n.c,
              f = n.d,
              p = n.tx,
              m = n.ty
            for (let g = t; g < i; g += 2) {
              let x = e[g],
                y = e[g + 1],
                v = l * x + h * y + p,
                S = c * x + f * y + m
              ;((s = v < s ? v : s), (o = S < o ? S : o), (a = v > a ? v : a), (u = S > u ? S : u))
            }
            ;((this.minX = s), (this.minY = o), (this.maxX = a), (this.maxY = u))
          }
          containsPoint(e, t) {
            return this.minX <= e && this.minY <= t && this.maxX >= e && this.maxY >= t
          }
          toString() {
            return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`
          }
          copyFrom(e) {
            return (
              (this.minX = e.minX),
              (this.minY = e.minY),
              (this.maxX = e.maxX),
              (this.maxY = e.maxY),
              this
            )
          }
        }))
    })
  var Be,
    bt,
    Jr = d(() => {
      se()
      Rc()
      lt()
      ;((Be = new Qr(F)), (bt = new Qr(de)))
    })
  var bD,
    Jm,
    eg = d(() => {
      se()
      lt()
      Jr()
      ;((bD = new F()),
        (Jm = {
          getFastGlobalBounds(r, e) {
            ;(e || (e = new de()),
              e.clear(),
              this._getGlobalBoundsRecursive(!!r, e, this.parentRenderLayer),
              e.isValid || e.set(0, 0, 0, 0))
            let t = this.renderGroup || this.parentRenderGroup
            return (e.applyMatrix(t.worldTransform), e)
          },
          _getGlobalBoundsRecursive(r, e, t) {
            let i = e
            if (
              (r && this.parentRenderLayer && this.parentRenderLayer !== t) ||
              this.localDisplayStatus !== 7 ||
              !this.measurable
            )
              return
            let n = !!this.effects.length
            if (((this.renderGroup || n) && (i = bt.get().clear()), this.boundsArea))
              e.addRect(this.boundsArea, this.worldTransform)
            else {
              if (this.renderPipeId) {
                let o = this.bounds
                i.addFrame(o.minX, o.minY, o.maxX, o.maxY, this.groupTransform)
              }
              let s = this.children
              for (let o = 0; o < s.length; o++) s[o]._getGlobalBoundsRecursive(r, i, t)
            }
            if (n) {
              let s = !1,
                o = this.renderGroup || this.parentRenderGroup
              for (let a = 0; a < this.effects.length; a++)
                this.effects[a].addBounds &&
                  (s || ((s = !0), i.applyMatrix(o.worldTransform)),
                  this.effects[a].addBounds(i, !0))
              ;(s &&
                (i.applyMatrix(o.worldTransform.copyTo(bD).invert()),
                e.addBounds(i, this.relativeGroupTransform)),
                e.addBounds(i),
                bt.return(i))
            } else this.renderGroup && (e.addBounds(i, this.relativeGroupTransform), bt.return(i))
          },
        }))
    })
  function Ii(r, e, t) {
    t.clear()
    let i, n
    return (
      r.parent
        ? e
          ? (i = r.parent.worldTransform)
          : ((n = Be.get().identity()), (i = Ia(r, n)))
        : (i = F.IDENTITY),
      tg(r, t, i, e),
      n && Be.return(n),
      t.isValid || t.set(0, 0, 0, 0),
      t
    )
  }
  function tg(r, e, t, i) {
    if (!r.visible || !r.measurable) return
    let n
    i
      ? (n = r.worldTransform)
      : (r.updateLocalTransform(), (n = Be.get()), n.appendFrom(r.localTransform, t))
    let s = e,
      o = !!r.effects.length
    if ((o && (e = bt.get().clear()), r.boundsArea)) e.addRect(r.boundsArea, n)
    else {
      r.bounds && ((e.matrix = n), e.addBounds(r.bounds))
      for (let a = 0; a < r.children.length; a++) tg(r.children[a], e, n, i)
    }
    if (o) {
      for (let a = 0; a < r.effects.length; a++) r.effects[a].addBounds?.(e)
      ;(s.addBounds(e, F.IDENTITY), bt.return(e))
    }
    i || Be.return(n)
  }
  function Ia(r, e) {
    let t = r.parent
    return (t && (Ia(t, e), t.updateLocalTransform(), e.append(t.localTransform)), e)
  }
  var jn = d(() => {
    se()
    Jr()
  })
  function Ga(r, e) {
    if (r === 16777215 || !e) return e
    if (e === 16777215 || !r) return r
    let t = (r >> 16) & 255,
      i = (r >> 8) & 255,
      n = r & 255,
      s = (e >> 16) & 255,
      o = (e >> 8) & 255,
      a = e & 255,
      u = ((t * s) / 255) | 0,
      l = ((i * o) / 255) | 0,
      c = ((n * a) / 255) | 0
    return (u << 16) + (l << 8) + c
  }
  var Gc = d(() => {
    "use strict"
  })
  function Gi(r, e) {
    return r === rg ? e : e === rg ? r : Ga(r, e)
  }
  var rg,
    kc = d(() => {
      Gc()
      rg = 16777215
    })
  function qn(r) {
    return ((r & 255) << 16) + (r & 65280) + ((r >> 16) & 255)
  }
  var ig,
    ng = d(() => {
      jn()
      Jr()
      kc()
      ig = {
        getGlobalAlpha(r) {
          if (r)
            return this.renderGroup
              ? this.renderGroup.worldAlpha
              : this.parentRenderGroup
                ? this.parentRenderGroup.worldAlpha * this.alpha
                : this.alpha
          let e = this.alpha,
            t = this.parent
          for (; t; ) ((e *= t.alpha), (t = t.parent))
          return e
        },
        getGlobalTransform(r, e) {
          if (e) return r.copyFrom(this.worldTransform)
          this.updateLocalTransform()
          let t = Ia(this, Be.get().identity())
          return (r.appendFrom(this.localTransform, t), Be.return(t), r)
        },
        getGlobalTint(r) {
          if (r)
            return this.renderGroup
              ? qn(this.renderGroup.worldColor)
              : this.parentRenderGroup
                ? qn(Gi(this.localColor, this.parentRenderGroup.worldColor))
                : this.tint
          let e = this.localColor,
            t = this.parent
          for (; t; ) ((e = Gi(e, t.localColor)), (t = t.parent))
          return qn(e)
        },
      }
    })
  function H(...r) {
    Uc !== sg &&
      (Uc++,
      Uc === sg
        ? console.warn(
            "PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.",
          )
        : console.warn("PixiJS Warning: ", ...r))
  }
  var Uc,
    sg,
    be = d(() => {
      "use strict"
      ;((Uc = 0), (sg = 500))
    })
  function ki(r, e, t) {
    return (e.clear(), t || (t = F.IDENTITY), og(r, e, t, r, !0), e.isValid || e.set(0, 0, 0, 0), e)
  }
  function og(r, e, t, i, n) {
    let s
    if (n) ((s = Be.get()), (s = t.copyTo(s)))
    else {
      if (!r.visible || !r.measurable) return
      r.updateLocalTransform()
      let u = r.localTransform
      ;((s = Be.get()), s.appendFrom(u, t))
    }
    let o = e,
      a = !!r.effects.length
    if ((a && (e = bt.get().clear()), r.boundsArea)) e.addRect(r.boundsArea, s)
    else {
      r.renderPipeId && ((e.matrix = s), e.addBounds(r.bounds))
      let u = r.children
      for (let l = 0; l < u.length; l++) og(u[l], e, s, i, !1)
    }
    if (a) {
      for (let u = 0; u < r.effects.length; u++) r.effects[u].addLocalBounds?.(e, i)
      ;(o.addBounds(e, F.IDENTITY), bt.return(e))
    }
    Be.return(s)
  }
  var ka = d(() => {
    se()
    Jr()
  })
  function Oc(r, e) {
    let t = r.children
    for (let i = 0; i < t.length; i++) {
      let n = t[i],
        s = n.uid,
        o = ((n._didViewChangeTick & 65535) << 16) | (n._didContainerChangeTick & 65535),
        a = e.index
      ;((e.data[a] !== s || e.data[a + 1] !== o) &&
        ((e.data[e.index] = s), (e.data[e.index + 1] = o), (e.didChange = !0)),
        (e.index = a + 2),
        n.children.length && Oc(n, e))
    }
    return e.didChange
  }
  var ag = d(() => {
    "use strict"
  })
  var vD,
    ug,
    lg = d(() => {
      se()
      lt()
      jn()
      ka()
      ag()
      ;((vD = new F()),
        (ug = {
          _localBoundsCacheId: -1,
          _localBoundsCacheData: null,
          _setWidth(r, e) {
            let t = Math.sign(this.scale.x) || 1
            e !== 0 ? (this.scale.x = (r / e) * t) : (this.scale.x = t)
          },
          _setHeight(r, e) {
            let t = Math.sign(this.scale.y) || 1
            e !== 0 ? (this.scale.y = (r / e) * t) : (this.scale.y = t)
          },
          getLocalBounds() {
            this._localBoundsCacheData ||
              (this._localBoundsCacheData = {
                data: [],
                index: 1,
                didChange: !1,
                localBounds: new de(),
              })
            let r = this._localBoundsCacheData
            return (
              (r.index = 1),
              (r.didChange = !1),
              r.data[0] !== this._didViewChangeTick &&
                ((r.didChange = !0), (r.data[0] = this._didViewChangeTick)),
              Oc(this, r),
              r.didChange && ki(this, r.localBounds, vD),
              r.localBounds
            )
          },
          getBounds(r, e) {
            return Ii(this, r, e || new de())
          },
        }))
    })
  var cg,
    hg = d(() => {
      "use strict"
      cg = {
        _onRender: null,
        set onRender(r) {
          let e = this.renderGroup || this.parentRenderGroup
          if (!r) {
            ;(this._onRender && e?.removeOnRender(this), (this._onRender = null))
            return
          }
          ;(this._onRender || e?.addOnRender(this), (this._onRender = r))
        },
        get onRender() {
          return this._onRender
        },
      }
    })
  function SD(r, e) {
    return r._zIndex - e._zIndex
  }
  var dg,
    fg = d(() => {
      "use strict"
      dg = {
        _zIndex: 0,
        sortDirty: !1,
        sortableChildren: !1,
        get zIndex() {
          return this._zIndex
        },
        set zIndex(r) {
          this._zIndex !== r && ((this._zIndex = r), this.depthOfChildModified())
        },
        depthOfChildModified() {
          ;(this.parent && ((this.parent.sortableChildren = !0), (this.parent.sortDirty = !0)),
            this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0))
        },
        sortChildren() {
          this.sortDirty && ((this.sortDirty = !1), this.children.sort(SD))
        },
      }
    })
  var pg,
    mg = d(() => {
      Et()
      Jr()
      pg = {
        getGlobalPosition(r = new re(), e = !1) {
          return (
            this.parent
              ? this.parent.toGlobal(this._position, r, e)
              : ((r.x = this._position.x), (r.y = this._position.y)),
            r
          )
        },
        toGlobal(r, e, t = !1) {
          let i = this.getGlobalTransform(Be.get(), t)
          return ((e = i.apply(r, e)), Be.return(i), e)
        },
        toLocal(r, e, t, i) {
          e && (r = e.toGlobal(r, t, i))
          let n = this.getGlobalTransform(Be.get(), i)
          return ((t = n.applyInverse(r, t)), Be.return(n), t)
        },
      }
    })
  var Ui,
    Lc = d(() => {
      Ye()
      Ui = class {
        constructor() {
          ;((this.uid = te("instructionSet")),
            (this.instructions = []),
            (this.instructionSize = 0),
            (this.renderables = []),
            (this.gcTick = 0))
        }
        reset() {
          this.instructionSize = 0
        }
        add(e) {
          this.instructions[this.instructionSize++] = e
        }
        log() {
          ;((this.instructions.length = this.instructionSize),
            console.table(this.instructions, ["type", "action"]))
        }
      }
    })
  function ar(r) {
    return (
      (r += r === 0 ? 1 : 0),
      --r,
      (r |= r >>> 1),
      (r |= r >>> 2),
      (r |= r >>> 4),
      (r |= r >>> 8),
      (r |= r >>> 16),
      r + 1
    )
  }
  function Nc(r) {
    return !(r & (r - 1)) && !!r
  }
  var Zn = d(() => {
    "use strict"
  })
  function Ua(r) {
    let e = {}
    for (let t in r) r[t] !== void 0 && (e[t] = r[t])
    return e
  }
  var Hc = d(() => {
    "use strict"
  })
  function TD(r) {
    let e = gg[r]
    return (e === void 0 && (gg[r] = te("resource")), e)
  }
  var gg,
    xg,
    Oa,
    zc = d(() => {
      Je()
      Ye()
      Te()
      gg = Object.create(null)
      xg = class _g extends pe {
        constructor(e = {}) {
          ;(super(),
            (this._resourceType = "textureSampler"),
            (this._touched = 0),
            (this._maxAnisotropy = 1),
            (this.destroyed = !1),
            (e = { ..._g.defaultOptions, ...e }),
            (this.addressMode = e.addressMode),
            (this.addressModeU = e.addressModeU ?? this.addressModeU),
            (this.addressModeV = e.addressModeV ?? this.addressModeV),
            (this.addressModeW = e.addressModeW ?? this.addressModeW),
            (this.scaleMode = e.scaleMode),
            (this.magFilter = e.magFilter ?? this.magFilter),
            (this.minFilter = e.minFilter ?? this.minFilter),
            (this.mipmapFilter = e.mipmapFilter ?? this.mipmapFilter),
            (this.lodMinClamp = e.lodMinClamp),
            (this.lodMaxClamp = e.lodMaxClamp),
            (this.compare = e.compare),
            (this.maxAnisotropy = e.maxAnisotropy ?? 1))
        }
        set addressMode(e) {
          ;((this.addressModeU = e), (this.addressModeV = e), (this.addressModeW = e))
        }
        get addressMode() {
          return this.addressModeU
        }
        set wrapMode(e) {
          ;(z(K, "TextureStyle.wrapMode is now TextureStyle.addressMode"), (this.addressMode = e))
        }
        get wrapMode() {
          return this.addressMode
        }
        set scaleMode(e) {
          ;((this.magFilter = e), (this.minFilter = e), (this.mipmapFilter = e))
        }
        get scaleMode() {
          return this.magFilter
        }
        set maxAnisotropy(e) {
          ;((this._maxAnisotropy = Math.min(e, 16)),
            this._maxAnisotropy > 1 && (this.scaleMode = "linear"))
        }
        get maxAnisotropy() {
          return this._maxAnisotropy
        }
        get _resourceId() {
          return this._sharedResourceId || this._generateResourceId()
        }
        update() {
          ;(this.emit("change", this), (this._sharedResourceId = null))
        }
        _generateResourceId() {
          let e = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`
          return ((this._sharedResourceId = TD(e)), this._resourceId)
        }
        destroy() {
          ;((this.destroyed = !0),
            this.emit("destroy", this),
            this.emit("change", this),
            this.removeAllListeners())
        }
      }
      xg.defaultOptions = { addressMode: "clamp-to-edge", scaleMode: "linear" }
      Oa = xg
    })
  var yg,
    ce,
    ct = d(() => {
      Je()
      Zn()
      Hc()
      Ye()
      zc()
      yg = class bg extends pe {
        constructor(e = {}) {
          ;(super(),
            (this.options = e),
            (this.uid = te("textureSource")),
            (this._resourceType = "textureSource"),
            (this._resourceId = te("resource")),
            (this.uploadMethodId = "unknown"),
            (this._resolution = 1),
            (this.pixelWidth = 1),
            (this.pixelHeight = 1),
            (this.width = 1),
            (this.height = 1),
            (this.sampleCount = 1),
            (this.mipLevelCount = 1),
            (this.autoGenerateMipmaps = !1),
            (this.format = "rgba8unorm"),
            (this.dimension = "2d"),
            (this.antialias = !1),
            (this._touched = 0),
            (this._batchTick = -1),
            (this._textureBindLocation = -1),
            (e = { ...bg.defaultOptions, ...e }),
            (this.label = e.label ?? ""),
            (this.resource = e.resource),
            (this.autoGarbageCollect = e.autoGarbageCollect),
            (this._resolution = e.resolution),
            e.width
              ? (this.pixelWidth = e.width * this._resolution)
              : (this.pixelWidth = this.resource ? (this.resourceWidth ?? 1) : 1),
            e.height
              ? (this.pixelHeight = e.height * this._resolution)
              : (this.pixelHeight = this.resource ? (this.resourceHeight ?? 1) : 1),
            (this.width = this.pixelWidth / this._resolution),
            (this.height = this.pixelHeight / this._resolution),
            (this.format = e.format),
            (this.dimension = e.dimensions),
            (this.mipLevelCount = e.mipLevelCount),
            (this.autoGenerateMipmaps = e.autoGenerateMipmaps),
            (this.sampleCount = e.sampleCount),
            (this.antialias = e.antialias),
            (this.alphaMode = e.alphaMode),
            (this.style = new Oa(Ua(e))),
            (this.destroyed = !1),
            this._refreshPOT())
        }
        get source() {
          return this
        }
        get style() {
          return this._style
        }
        set style(e) {
          this.style !== e &&
            (this._style?.off("change", this._onStyleChange, this),
            (this._style = e),
            this._style?.on("change", this._onStyleChange, this),
            this._onStyleChange())
        }
        get addressMode() {
          return this._style.addressMode
        }
        set addressMode(e) {
          this._style.addressMode = e
        }
        get repeatMode() {
          return this._style.addressMode
        }
        set repeatMode(e) {
          this._style.addressMode = e
        }
        get magFilter() {
          return this._style.magFilter
        }
        set magFilter(e) {
          this._style.magFilter = e
        }
        get minFilter() {
          return this._style.minFilter
        }
        set minFilter(e) {
          this._style.minFilter = e
        }
        get mipmapFilter() {
          return this._style.mipmapFilter
        }
        set mipmapFilter(e) {
          this._style.mipmapFilter = e
        }
        get lodMinClamp() {
          return this._style.lodMinClamp
        }
        set lodMinClamp(e) {
          this._style.lodMinClamp = e
        }
        get lodMaxClamp() {
          return this._style.lodMaxClamp
        }
        set lodMaxClamp(e) {
          this._style.lodMaxClamp = e
        }
        _onStyleChange() {
          this.emit("styleChange", this)
        }
        update() {
          if (this.resource) {
            let e = this._resolution
            if (this.resize(this.resourceWidth / e, this.resourceHeight / e)) return
          }
          this.emit("update", this)
        }
        destroy() {
          ;((this.destroyed = !0),
            this.emit("destroy", this),
            this.emit("change", this),
            this._style && (this._style.destroy(), (this._style = null)),
            (this.uploadMethodId = null),
            (this.resource = null),
            this.removeAllListeners())
        }
        unload() {
          ;((this._resourceId = te("resource")),
            this.emit("change", this),
            this.emit("unload", this))
        }
        get resourceWidth() {
          let { resource: e } = this
          return e.naturalWidth || e.videoWidth || e.displayWidth || e.width
        }
        get resourceHeight() {
          let { resource: e } = this
          return e.naturalHeight || e.videoHeight || e.displayHeight || e.height
        }
        get resolution() {
          return this._resolution
        }
        set resolution(e) {
          this._resolution !== e &&
            ((this._resolution = e),
            (this.width = this.pixelWidth / e),
            (this.height = this.pixelHeight / e))
        }
        resize(e, t, i) {
          ;(i || (i = this._resolution), e || (e = this.width), t || (t = this.height))
          let n = Math.round(e * i),
            s = Math.round(t * i)
          return (
            (this.width = n / i),
            (this.height = s / i),
            (this._resolution = i),
            this.pixelWidth === n && this.pixelHeight === s
              ? !1
              : (this._refreshPOT(),
                (this.pixelWidth = n),
                (this.pixelHeight = s),
                this.emit("resize", this),
                (this._resourceId = te("resource")),
                this.emit("change", this),
                !0)
          )
        }
        updateMipmaps() {
          this.autoGenerateMipmaps && this.mipLevelCount > 1 && this.emit("updateMipmaps", this)
        }
        set wrapMode(e) {
          this._style.wrapMode = e
        }
        get wrapMode() {
          return this._style.wrapMode
        }
        set scaleMode(e) {
          this._style.scaleMode = e
        }
        get scaleMode() {
          return this._style.scaleMode
        }
        _refreshPOT() {
          this.isPowerOfTwo = Nc(this.pixelWidth) && Nc(this.pixelHeight)
        }
        static test(e) {
          throw new Error("Unimplemented")
        }
      }
      yg.defaultOptions = {
        resolution: 1,
        format: "bgra8unorm",
        alphaMode: "premultiply-alpha-on-upload",
        dimensions: "2d",
        mipLevelCount: 1,
        autoGenerateMipmaps: !1,
        sampleCount: 1,
        antialias: !1,
        autoGarbageCollect: !1,
      }
      ce = yg
    })
  function CD() {
    for (let r = 0; r < 16; r++) {
      let e = []
      Wc.push(e)
      for (let t = 0; t < 16; t++) {
        let i = La(ei[r] * ei[t] + ri[r] * ti[t]),
          n = La(ti[r] * ei[t] + ii[r] * ti[t]),
          s = La(ei[r] * ri[t] + ri[r] * ii[t]),
          o = La(ti[r] * ri[t] + ii[r] * ii[t])
        for (let a = 0; a < 16; a++)
          if (ei[a] === i && ti[a] === n && ri[a] === s && ii[a] === o) {
            e.push(a)
            break
          }
      }
    }
    for (let r = 0; r < 16; r++) {
      let e = new F()
      ;(e.set(ei[r], ti[r], ri[r], ii[r], 0, 0), vg.push(e))
    }
  }
  var ei,
    ti,
    ri,
    ii,
    Wc,
    vg,
    La,
    ve,
    Sg = d(() => {
      se()
      ;((ei = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1]),
        (ti = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1]),
        (ri = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1]),
        (ii = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1]),
        (Wc = []),
        (vg = []),
        (La = Math.sign))
      CD()
      ve = {
        E: 0,
        SE: 1,
        S: 2,
        SW: 3,
        W: 4,
        NW: 5,
        N: 6,
        NE: 7,
        MIRROR_VERTICAL: 8,
        MAIN_DIAGONAL: 10,
        MIRROR_HORIZONTAL: 12,
        REVERSE_DIAGONAL: 14,
        uX: (r) => ei[r],
        uY: (r) => ti[r],
        vX: (r) => ri[r],
        vY: (r) => ii[r],
        inv: (r) => (r & 8 ? r & 15 : -r & 7),
        add: (r, e) => Wc[r][e],
        sub: (r, e) => Wc[r][ve.inv(e)],
        rotate180: (r) => r ^ 4,
        isVertical: (r) => (r & 3) === 2,
        byDirection: (r, e) =>
          Math.abs(r) * 2 <= Math.abs(e)
            ? e >= 0
              ? ve.S
              : ve.N
            : Math.abs(e) * 2 <= Math.abs(r)
              ? r > 0
                ? ve.E
                : ve.W
              : e > 0
                ? r > 0
                  ? ve.SE
                  : ve.SW
                : r > 0
                  ? ve.NE
                  : ve.NW,
        matrixAppendRotationInv: (r, e, t = 0, i = 0) => {
          let n = vg[ve.inv(e)]
          ;((n.tx = t), (n.ty = i), r.append(n))
        },
      }
    })
  var Vc,
    Tg = d(() => {
      "use strict"
      Vc = () => {}
    })
  var ni,
    $c = d(() => {
      D()
      ct()
      ni = class extends ce {
        constructor(e) {
          let t = e.resource || new Float32Array(e.width * e.height * 4),
            i = e.format
          ;(i ||
            (t instanceof Float32Array
              ? (i = "rgba32float")
              : t instanceof Int32Array || t instanceof Uint32Array
                ? (i = "rgba32uint")
                : t instanceof Int16Array || t instanceof Uint16Array
                  ? (i = "rgba16uint")
                  : (t instanceof Int8Array, (i = "bgra8unorm"))),
            super({ ...e, resource: t, format: i }),
            (this.uploadMethodId = "buffer"))
        }
        static test(e) {
          return (
            e instanceof Int8Array ||
            e instanceof Uint8Array ||
            e instanceof Uint8ClampedArray ||
            e instanceof Int16Array ||
            e instanceof Uint16Array ||
            e instanceof Int32Array ||
            e instanceof Uint32Array ||
            e instanceof Float32Array
          )
        }
      }
      ni.extension = _.TextureSource
    })
  var Cg,
    Oi,
    Xc = d(() => {
      se()
      ;((Cg = new F()),
        (Oi = class {
          constructor(e, t) {
            ;((this.mapCoord = new F()),
              (this.uClampFrame = new Float32Array(4)),
              (this.uClampOffset = new Float32Array(2)),
              (this._textureID = -1),
              (this._updateID = 0),
              (this.clampOffset = 0),
              typeof t > "u" ? (this.clampMargin = e.width < 10 ? 0 : 0.5) : (this.clampMargin = t),
              (this.isSimple = !1),
              (this.texture = e))
          }
          get texture() {
            return this._texture
          }
          set texture(e) {
            this.texture !== e &&
              (this._texture?.removeListener("update", this.update, this),
              (this._texture = e),
              this._texture.addListener("update", this.update, this),
              this.update())
          }
          multiplyUvs(e, t) {
            t === void 0 && (t = e)
            let i = this.mapCoord
            for (let n = 0; n < e.length; n += 2) {
              let s = e[n],
                o = e[n + 1]
              ;((t[n] = s * i.a + o * i.c + i.tx), (t[n + 1] = s * i.b + o * i.d + i.ty))
            }
            return t
          }
          update() {
            let e = this._texture
            this._updateID++
            let t = e.uvs
            this.mapCoord.set(t.x1 - t.x0, t.y1 - t.y0, t.x3 - t.x0, t.y3 - t.y0, t.x0, t.y0)
            let i = e.orig,
              n = e.trim
            n &&
              (Cg.set(
                i.width / n.width,
                0,
                0,
                i.height / n.height,
                -n.x / n.width,
                -n.y / n.height,
              ),
              this.mapCoord.append(Cg))
            let s = e.source,
              o = this.uClampFrame,
              a = this.clampMargin / s._resolution,
              u = this.clampOffset / s._resolution
            return (
              (o[0] = (e.frame.x + a + u) / s.width),
              (o[1] = (e.frame.y + a + u) / s.height),
              (o[2] = (e.frame.x + e.frame.width - a + u) / s.width),
              (o[3] = (e.frame.y + e.frame.height - a + u) / s.height),
              (this.uClampOffset[0] = this.clampOffset / s.pixelWidth),
              (this.uClampOffset[1] = this.clampOffset / s.pixelHeight),
              (this.isSimple =
                e.frame.width === s.width && e.frame.height === s.height && e.rotate === 0),
              !0
            )
          }
        }))
    })
  var I,
    ge = d(() => {
      Je()
      Sg()
      Ke()
      Ye()
      Te()
      Tg()
      $c()
      ct()
      Xc()
      I = class extends pe {
        constructor({
          source: e,
          label: t,
          frame: i,
          orig: n,
          trim: s,
          defaultAnchor: o,
          defaultBorders: a,
          rotate: u,
          dynamic: l,
        } = {}) {
          if (
            (super(),
            (this.uid = te("texture")),
            (this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 }),
            (this.frame = new ee()),
            (this.noFrame = !1),
            (this.dynamic = !1),
            (this.isTexture = !0),
            (this.label = t),
            (this.source = e?.source ?? new ce()),
            (this.noFrame = !i),
            i)
          )
            this.frame.copyFrom(i)
          else {
            let { width: c, height: h } = this._source
            ;((this.frame.width = c), (this.frame.height = h))
          }
          ;((this.orig = n || this.frame),
            (this.trim = s),
            (this.rotate = u ?? 0),
            (this.defaultAnchor = o),
            (this.defaultBorders = a),
            (this.destroyed = !1),
            (this.dynamic = l || !1),
            this.updateUvs())
        }
        set source(e) {
          ;(this._source && this._source.off("resize", this.update, this),
            (this._source = e),
            e.on("resize", this.update, this),
            this.emit("update", this))
        }
        get source() {
          return this._source
        }
        get textureMatrix() {
          return (this._textureMatrix || (this._textureMatrix = new Oi(this)), this._textureMatrix)
        }
        get width() {
          return this.orig.width
        }
        get height() {
          return this.orig.height
        }
        updateUvs() {
          let { uvs: e, frame: t } = this,
            { width: i, height: n } = this._source,
            s = t.x / i,
            o = t.y / n,
            a = t.width / i,
            u = t.height / n,
            l = this.rotate
          if (l) {
            let c = a / 2,
              h = u / 2,
              f = s + c,
              p = o + h
            ;((l = ve.add(l, ve.NW)),
              (e.x0 = f + c * ve.uX(l)),
              (e.y0 = p + h * ve.uY(l)),
              (l = ve.add(l, 2)),
              (e.x1 = f + c * ve.uX(l)),
              (e.y1 = p + h * ve.uY(l)),
              (l = ve.add(l, 2)),
              (e.x2 = f + c * ve.uX(l)),
              (e.y2 = p + h * ve.uY(l)),
              (l = ve.add(l, 2)),
              (e.x3 = f + c * ve.uX(l)),
              (e.y3 = p + h * ve.uY(l)))
          } else
            ((e.x0 = s),
              (e.y0 = o),
              (e.x1 = s + a),
              (e.y1 = o),
              (e.x2 = s + a),
              (e.y2 = o + u),
              (e.x3 = s),
              (e.y3 = o + u))
        }
        destroy(e = !1) {
          ;(this._source && e && (this._source.destroy(), (this._source = null)),
            (this._textureMatrix = null),
            (this.destroyed = !0),
            this.emit("destroy", this),
            this.removeAllListeners())
        }
        update() {
          ;(this.noFrame &&
            ((this.frame.width = this._source.width), (this.frame.height = this._source.height)),
            this.updateUvs(),
            this.emit("update", this))
        }
        get baseTexture() {
          return (z(K, "Texture.baseTexture is now Texture.source"), this._source)
        }
      }
      I.EMPTY = new I({ label: "EMPTY", source: new ce({ label: "EMPTY" }) })
      I.EMPTY.destroy = Vc
      I.WHITE = new I({
        source: new ni({
          resource: new Uint8Array([255, 255, 255, 255]),
          width: 1,
          height: 1,
          alphaMode: "premultiply-alpha-on-upload",
          label: "WHITE",
        }),
        label: "WHITE",
      })
      I.WHITE.destroy = Vc
    })
  var ED,
    Yc,
    Ce,
    Tr = d(() => {
      Zn()
      ct()
      ge()
      ;((ED = 0),
        (Yc = class {
          constructor(e) {
            ;((this._poolKeyHash = Object.create(null)),
              (this._texturePool = {}),
              (this.textureOptions = e || {}),
              (this.enableFullScreen = !1))
          }
          createTexture(e, t, i) {
            let n = new ce({
              ...this.textureOptions,
              width: e,
              height: t,
              resolution: 1,
              antialias: i,
              autoGarbageCollect: !1,
            })
            return new I({ source: n, label: `texturePool_${ED++}` })
          }
          getOptimalTexture(e, t, i = 1, n) {
            let s = Math.ceil(e * i - 1e-6),
              o = Math.ceil(t * i - 1e-6)
            ;((s = ar(s)), (o = ar(o)))
            let a = (s << 17) + (o << 1) + (n ? 1 : 0)
            this._texturePool[a] || (this._texturePool[a] = [])
            let u = this._texturePool[a].pop()
            return (
              u || (u = this.createTexture(s, o, n)),
              (u.source._resolution = i),
              (u.source.width = s / i),
              (u.source.height = o / i),
              (u.source.pixelWidth = s),
              (u.source.pixelHeight = o),
              (u.frame.x = 0),
              (u.frame.y = 0),
              (u.frame.width = e),
              (u.frame.height = t),
              u.updateUvs(),
              (this._poolKeyHash[u.uid] = a),
              u
            )
          }
          getSameSizeTexture(e, t = !1) {
            let i = e.source
            return this.getOptimalTexture(e.width, e.height, i._resolution, t)
          }
          returnTexture(e) {
            let t = this._poolKeyHash[e.uid]
            this._texturePool[t].push(e)
          }
          clear(e) {
            if (((e = e !== !1), e))
              for (let t in this._texturePool) {
                let i = this._texturePool[t]
                if (i) for (let n = 0; n < i.length; n++) i[n].destroy(!0)
              }
            this._texturePool = {}
          }
        }),
        (Ce = new Yc()))
    })
  var Na,
    Eg = d(() => {
      se()
      Lc()
      Tr()
      Na = class {
        constructor() {
          ;((this.renderPipeId = "renderGroup"),
            (this.root = null),
            (this.canBundle = !1),
            (this.renderGroupParent = null),
            (this.renderGroupChildren = []),
            (this.worldTransform = new F()),
            (this.worldColorAlpha = 4294967295),
            (this.worldColor = 16777215),
            (this.worldAlpha = 1),
            (this.childrenToUpdate = Object.create(null)),
            (this.updateTick = 0),
            (this.gcTick = 0),
            (this.childrenRenderablesToUpdate = { list: [], index: 0 }),
            (this.structureDidChange = !0),
            (this.instructionSet = new Ui()),
            (this._onRenderContainers = []),
            (this.textureNeedsUpdate = !0),
            (this.isCachedAsTexture = !1),
            (this._matrixDirty = 7))
        }
        init(e) {
          ;((this.root = e), e._onRender && this.addOnRender(e), (e.didChange = !0))
          let t = e.children
          for (let i = 0; i < t.length; i++) {
            let n = t[i]
            ;((n._updateFlags = 15), this.addChild(n))
          }
        }
        enableCacheAsTexture(e = {}) {
          ;((this.textureOptions = e),
            (this.isCachedAsTexture = !0),
            (this.textureNeedsUpdate = !0))
        }
        disableCacheAsTexture() {
          ;((this.isCachedAsTexture = !1),
            this.texture && (Ce.returnTexture(this.texture), (this.texture = null)))
        }
        updateCacheTexture() {
          this.textureNeedsUpdate = !0
        }
        reset() {
          this.renderGroupChildren.length = 0
          for (let e in this.childrenToUpdate) {
            let t = this.childrenToUpdate[e]
            ;(t.list.fill(null), (t.index = 0))
          }
          ;((this.childrenRenderablesToUpdate.index = 0),
            this.childrenRenderablesToUpdate.list.fill(null),
            (this.root = null),
            (this.updateTick = 0),
            (this.structureDidChange = !0),
            (this._onRenderContainers.length = 0),
            (this.renderGroupParent = null),
            this.disableCacheAsTexture())
        }
        get localTransform() {
          return this.root.localTransform
        }
        addRenderGroupChild(e) {
          ;(e.renderGroupParent && e.renderGroupParent._removeRenderGroupChild(e),
            (e.renderGroupParent = this),
            this.renderGroupChildren.push(e))
        }
        _removeRenderGroupChild(e) {
          let t = this.renderGroupChildren.indexOf(e)
          ;(t > -1 && this.renderGroupChildren.splice(t, 1), (e.renderGroupParent = null))
        }
        addChild(e) {
          if (
            ((this.structureDidChange = !0),
            (e.parentRenderGroup = this),
            (e.updateTick = -1),
            e.parent === this.root
              ? (e.relativeRenderGroupDepth = 1)
              : (e.relativeRenderGroupDepth = e.parent.relativeRenderGroupDepth + 1),
            (e.didChange = !0),
            this.onChildUpdate(e),
            e.renderGroup)
          ) {
            this.addRenderGroupChild(e.renderGroup)
            return
          }
          e._onRender && this.addOnRender(e)
          let t = e.children
          for (let i = 0; i < t.length; i++) this.addChild(t[i])
        }
        removeChild(e) {
          if (
            ((this.structureDidChange = !0),
            e._onRender && (e.renderGroup || this.removeOnRender(e)),
            (e.parentRenderGroup = null),
            e.renderGroup)
          ) {
            this._removeRenderGroupChild(e.renderGroup)
            return
          }
          let t = e.children
          for (let i = 0; i < t.length; i++) this.removeChild(t[i])
        }
        removeChildren(e) {
          for (let t = 0; t < e.length; t++) this.removeChild(e[t])
        }
        onChildUpdate(e) {
          let t = this.childrenToUpdate[e.relativeRenderGroupDepth]
          ;(t || (t = this.childrenToUpdate[e.relativeRenderGroupDepth] = { index: 0, list: [] }),
            (t.list[t.index++] = e))
        }
        updateRenderable(e) {
          e.globalDisplayStatus < 7 ||
            (this.instructionSet.renderPipes[e.renderPipeId].updateRenderable(e),
            (e.didViewUpdate = !1))
        }
        onChildViewUpdate(e) {
          this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = e
        }
        get isRenderable() {
          return this.root.localDisplayStatus === 7 && this.worldAlpha > 0
        }
        addOnRender(e) {
          this._onRenderContainers.push(e)
        }
        removeOnRender(e) {
          this._onRenderContainers.splice(this._onRenderContainers.indexOf(e), 1)
        }
        runOnRender(e) {
          for (let t = 0; t < this._onRenderContainers.length; t++)
            this._onRenderContainers[t]._onRender(e)
        }
        destroy() {
          ;(this.disableCacheAsTexture(),
            (this.renderGroupParent = null),
            (this.root = null),
            (this.childrenRenderablesToUpdate = null),
            (this.childrenToUpdate = null),
            (this.renderGroupChildren = null),
            (this._onRenderContainers = null),
            (this.instructionSet = null))
        }
        getChildren(e = []) {
          let t = this.root.children
          for (let i = 0; i < t.length; i++) this._getChildren(t[i], e)
          return e
        }
        _getChildren(e, t = []) {
          if ((t.push(e), e.renderGroup)) return t
          let i = e.children
          for (let n = 0; n < i.length; n++) this._getChildren(i[n], t)
          return t
        }
        invalidateMatrices() {
          this._matrixDirty = 7
        }
        get inverseWorldTransform() {
          return (this._matrixDirty & 1) === 0
            ? this._inverseWorldTransform
            : ((this._matrixDirty &= -2),
              this._inverseWorldTransform || (this._inverseWorldTransform = new F()),
              this._inverseWorldTransform.copyFrom(this.worldTransform).invert())
        }
        get textureOffsetInverseTransform() {
          return (this._matrixDirty & 2) === 0
            ? this._textureOffsetInverseTransform
            : ((this._matrixDirty &= -3),
              this._textureOffsetInverseTransform ||
                (this._textureOffsetInverseTransform = new F()),
              this._textureOffsetInverseTransform
                .copyFrom(this.inverseWorldTransform)
                .translate(-this._textureBounds.x, -this._textureBounds.y))
        }
        get inverseParentTextureTransform() {
          if ((this._matrixDirty & 4) === 0) return this._inverseParentTextureTransform
          this._matrixDirty &= -5
          let e = this._parentCacheAsTextureRenderGroup
          return e
            ? (this._inverseParentTextureTransform ||
                (this._inverseParentTextureTransform = new F()),
              this._inverseParentTextureTransform
                .copyFrom(this.worldTransform)
                .prepend(e.inverseWorldTransform)
                .translate(-e._textureBounds.x, -e._textureBounds.y))
            : this.worldTransform
        }
        get cacheToLocalTransform() {
          return this._parentCacheAsTextureRenderGroup
            ? this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform
            : null
        }
      }
    })
  function wg(r, e, t = {}) {
    for (let i in e) !t[i] && e[i] !== void 0 && (r[i] = e[i])
  }
  var Mg = d(() => {
    "use strict"
  })
  var Kc,
    jc,
    qc,
    Li,
    Qn,
    si,
    xe,
    Gt = d(() => {
      Je()
      $e()
      Gm()
      D()
      se()
      Ac()
      Da()
      Ye()
      Te()
      it()
      zm()
      Vm()
      Xm()
      jm()
      Zm()
      eg()
      ng()
      lg()
      hg()
      fg()
      mg()
      Eg()
      Mg()
      ;((Kc = new Xe(null)),
        (jc = new Xe(null)),
        (qc = new Xe(null, 1, 1)),
        (Li = 1),
        (Qn = 2),
        (si = 4),
        (xe = class r extends pe {
          constructor(e = {}) {
            ;(super(),
              (this.uid = te("renderable")),
              (this._updateFlags = 15),
              (this.renderGroup = null),
              (this.parentRenderGroup = null),
              (this.parentRenderGroupIndex = 0),
              (this.didChange = !1),
              (this.didViewUpdate = !1),
              (this.relativeRenderGroupDepth = 0),
              (this.children = []),
              (this.parent = null),
              (this.includeInBuild = !0),
              (this.measurable = !0),
              (this.isSimple = !0),
              (this.updateTick = -1),
              (this.localTransform = new F()),
              (this.relativeGroupTransform = new F()),
              (this.groupTransform = this.relativeGroupTransform),
              (this.destroyed = !1),
              (this._position = new Xe(this, 0, 0)),
              (this._scale = qc),
              (this._pivot = jc),
              (this._skew = Kc),
              (this._cx = 1),
              (this._sx = 0),
              (this._cy = 0),
              (this._sy = 1),
              (this._rotation = 0),
              (this.localColor = 16777215),
              (this.localAlpha = 1),
              (this.groupAlpha = 1),
              (this.groupColor = 16777215),
              (this.groupColorAlpha = 4294967295),
              (this.localBlendMode = "inherit"),
              (this.groupBlendMode = "normal"),
              (this.localDisplayStatus = 7),
              (this.globalDisplayStatus = 7),
              (this._didContainerChangeTick = 0),
              (this._didViewChangeTick = 0),
              (this._didLocalTransformChangeId = -1),
              (this.effects = []),
              wg(this, e, { children: !0, parent: !0, effects: !0 }),
              e.children?.forEach((t) => this.addChild(t)),
              e.parent?.addChild(this))
          }
          static mixin(e) {
            ;(z("8.8.0", "Container.mixin is deprecated, please use extensions.mixin instead."),
              L.mixin(r, e))
          }
          set _didChangeId(e) {
            ;((this._didViewChangeTick = (e >> 12) & 4095),
              (this._didContainerChangeTick = e & 4095))
          }
          get _didChangeId() {
            return (this._didContainerChangeTick & 4095) | ((this._didViewChangeTick & 4095) << 12)
          }
          addChild(...e) {
            if (
              (this.allowChildren ||
                z(K, "addChild: Only Containers will be allowed to add children in v8.0.0"),
              e.length > 1)
            ) {
              for (let n = 0; n < e.length; n++) this.addChild(e[n])
              return e[0]
            }
            let t = e[0],
              i = this.renderGroup || this.parentRenderGroup
            return t.parent === this
              ? (this.children.splice(this.children.indexOf(t), 1),
                this.children.push(t),
                i && (i.structureDidChange = !0),
                t)
              : (t.parent && t.parent.removeChild(t),
                this.children.push(t),
                this.sortableChildren && (this.sortDirty = !0),
                (t.parent = this),
                (t.didChange = !0),
                (t._updateFlags = 15),
                i && i.addChild(t),
                this.emit("childAdded", t, this, this.children.length - 1),
                t.emit("added", this),
                this._didViewChangeTick++,
                t._zIndex !== 0 && t.depthOfChildModified(),
                t)
          }
          removeChild(...e) {
            if (e.length > 1) {
              for (let n = 0; n < e.length; n++) this.removeChild(e[n])
              return e[0]
            }
            let t = e[0],
              i = this.children.indexOf(t)
            return (
              i > -1 &&
                (this._didViewChangeTick++,
                this.children.splice(i, 1),
                this.renderGroup
                  ? this.renderGroup.removeChild(t)
                  : this.parentRenderGroup && this.parentRenderGroup.removeChild(t),
                t.parentRenderLayer && t.parentRenderLayer.detach(t),
                (t.parent = null),
                this.emit("childRemoved", t, this, i),
                t.emit("removed", this)),
              t
            )
          }
          _onUpdate(e) {
            ;(e && e === this._skew && this._updateSkew(),
              this._didContainerChangeTick++,
              !this.didChange &&
                ((this.didChange = !0),
                this.parentRenderGroup && this.parentRenderGroup.onChildUpdate(this)))
          }
          set isRenderGroup(e) {
            !!this.renderGroup !== e && (e ? this.enableRenderGroup() : this.disableRenderGroup())
          }
          get isRenderGroup() {
            return !!this.renderGroup
          }
          enableRenderGroup() {
            if (this.renderGroup) return
            let e = this.parentRenderGroup
            ;(e?.removeChild(this),
              (this.renderGroup = j.get(Na, this)),
              (this.groupTransform = F.IDENTITY),
              e?.addChild(this),
              this._updateIsSimple())
          }
          disableRenderGroup() {
            if (!this.renderGroup) return
            let e = this.parentRenderGroup
            ;(e?.removeChild(this),
              j.return(this.renderGroup),
              (this.renderGroup = null),
              (this.groupTransform = this.relativeGroupTransform),
              e?.addChild(this),
              this._updateIsSimple())
          }
          _updateIsSimple() {
            this.isSimple = !this.renderGroup && this.effects.length === 0
          }
          get worldTransform() {
            return (
              this._worldTransform || (this._worldTransform = new F()),
              this.renderGroup
                ? this._worldTransform.copyFrom(this.renderGroup.worldTransform)
                : this.parentRenderGroup &&
                  this._worldTransform.appendFrom(
                    this.relativeGroupTransform,
                    this.parentRenderGroup.worldTransform,
                  ),
              this._worldTransform
            )
          }
          get x() {
            return this._position.x
          }
          set x(e) {
            this._position.x = e
          }
          get y() {
            return this._position.y
          }
          set y(e) {
            this._position.y = e
          }
          get position() {
            return this._position
          }
          set position(e) {
            this._position.copyFrom(e)
          }
          get rotation() {
            return this._rotation
          }
          set rotation(e) {
            this._rotation !== e && ((this._rotation = e), this._onUpdate(this._skew))
          }
          get angle() {
            return this.rotation * Um
          }
          set angle(e) {
            this.rotation = e * Om
          }
          get pivot() {
            return (this._pivot === jc && (this._pivot = new Xe(this, 0, 0)), this._pivot)
          }
          set pivot(e) {
            ;(this._pivot === jc && (this._pivot = new Xe(this, 0, 0)),
              typeof e == "number" ? this._pivot.set(e) : this._pivot.copyFrom(e))
          }
          get skew() {
            return (this._skew === Kc && (this._skew = new Xe(this, 0, 0)), this._skew)
          }
          set skew(e) {
            ;(this._skew === Kc && (this._skew = new Xe(this, 0, 0)), this._skew.copyFrom(e))
          }
          get scale() {
            return (this._scale === qc && (this._scale = new Xe(this, 1, 1)), this._scale)
          }
          set scale(e) {
            ;(this._scale === qc && (this._scale = new Xe(this, 0, 0)),
              typeof e == "number" ? this._scale.set(e) : this._scale.copyFrom(e))
          }
          get width() {
            return Math.abs(this.scale.x * this.getLocalBounds().width)
          }
          set width(e) {
            let t = this.getLocalBounds().width
            this._setWidth(e, t)
          }
          get height() {
            return Math.abs(this.scale.y * this.getLocalBounds().height)
          }
          set height(e) {
            let t = this.getLocalBounds().height
            this._setHeight(e, t)
          }
          getSize(e) {
            e || (e = {})
            let t = this.getLocalBounds()
            return (
              (e.width = Math.abs(this.scale.x * t.width)),
              (e.height = Math.abs(this.scale.y * t.height)),
              e
            )
          }
          setSize(e, t) {
            let i = this.getLocalBounds()
            ;(typeof e == "object" ? ((t = e.height ?? e.width), (e = e.width)) : (t ?? (t = e)),
              e !== void 0 && this._setWidth(e, i.width),
              t !== void 0 && this._setHeight(t, i.height))
          }
          _updateSkew() {
            let e = this._rotation,
              t = this._skew
            ;((this._cx = Math.cos(e + t._y)),
              (this._sx = Math.sin(e + t._y)),
              (this._cy = -Math.sin(e - t._x)),
              (this._sy = Math.cos(e - t._x)))
          }
          updateTransform(e) {
            return (
              this.position.set(
                typeof e.x == "number" ? e.x : this.position.x,
                typeof e.y == "number" ? e.y : this.position.y,
              ),
              this.scale.set(
                typeof e.scaleX == "number" ? e.scaleX || 1 : this.scale.x,
                typeof e.scaleY == "number" ? e.scaleY || 1 : this.scale.y,
              ),
              (this.rotation = typeof e.rotation == "number" ? e.rotation : this.rotation),
              this.skew.set(
                typeof e.skewX == "number" ? e.skewX : this.skew.x,
                typeof e.skewY == "number" ? e.skewY : this.skew.y,
              ),
              this.pivot.set(
                typeof e.pivotX == "number" ? e.pivotX : this.pivot.x,
                typeof e.pivotY == "number" ? e.pivotY : this.pivot.y,
              ),
              this
            )
          }
          setFromMatrix(e) {
            e.decompose(this)
          }
          updateLocalTransform() {
            let e = this._didContainerChangeTick
            if (this._didLocalTransformChangeId === e) return
            this._didLocalTransformChangeId = e
            let t = this.localTransform,
              i = this._scale,
              n = this._pivot,
              s = this._position,
              o = i._x,
              a = i._y,
              u = n._x,
              l = n._y
            ;((t.a = this._cx * o),
              (t.b = this._sx * o),
              (t.c = this._cy * a),
              (t.d = this._sy * a),
              (t.tx = s._x - (u * t.a + l * t.c)),
              (t.ty = s._y - (u * t.b + l * t.d)))
          }
          set alpha(e) {
            e !== this.localAlpha &&
              ((this.localAlpha = e), (this._updateFlags |= Li), this._onUpdate())
          }
          get alpha() {
            return this.localAlpha
          }
          set tint(e) {
            let i = q.shared.setValue(e ?? 16777215).toBgrNumber()
            i !== this.localColor &&
              ((this.localColor = i), (this._updateFlags |= Li), this._onUpdate())
          }
          get tint() {
            return qn(this.localColor)
          }
          set blendMode(e) {
            this.localBlendMode !== e &&
              (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0),
              (this._updateFlags |= Qn),
              (this.localBlendMode = e),
              this._onUpdate())
          }
          get blendMode() {
            return this.localBlendMode
          }
          get visible() {
            return !!(this.localDisplayStatus & 2)
          }
          set visible(e) {
            let t = e ? 2 : 0
            ;(this.localDisplayStatus & 2) !== t &&
              (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0),
              (this._updateFlags |= si),
              (this.localDisplayStatus ^= 2),
              this._onUpdate())
          }
          get culled() {
            return !(this.localDisplayStatus & 4)
          }
          set culled(e) {
            let t = e ? 0 : 4
            ;(this.localDisplayStatus & 4) !== t &&
              (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0),
              (this._updateFlags |= si),
              (this.localDisplayStatus ^= 4),
              this._onUpdate())
          }
          get renderable() {
            return !!(this.localDisplayStatus & 1)
          }
          set renderable(e) {
            let t = e ? 1 : 0
            ;(this.localDisplayStatus & 1) !== t &&
              ((this._updateFlags |= si),
              (this.localDisplayStatus ^= 1),
              this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0),
              this._onUpdate())
          }
          get isRenderable() {
            return this.localDisplayStatus === 7 && this.groupAlpha > 0
          }
          destroy(e = !1) {
            if (this.destroyed) return
            this.destroyed = !0
            let t
            if (
              (this.children.length && (t = this.removeChildren(0, this.children.length)),
              this.removeFromParent(),
              (this.parent = null),
              (this._maskEffect = null),
              (this._filterEffect = null),
              (this.effects = null),
              (this._position = null),
              (this._scale = null),
              (this._pivot = null),
              (this._skew = null),
              this.emit("destroyed", this),
              this.removeAllListeners(),
              (typeof e == "boolean" ? e : e?.children) && t)
            )
              for (let n = 0; n < t.length; ++n) t[n].destroy(e)
            ;(this.renderGroup?.destroy(), (this.renderGroup = null))
          }
        }))
      L.mixin(xe, Wm, Jm, pg, cg, ug, Km, qm, dg, Im, Hm, ig, $m)
    })
  var Cr,
    Ha = d(() => {
      Et()
      Cr = class r {
        constructor(e) {
          ;((this.bubbles = !0),
            (this.cancelBubble = !0),
            (this.cancelable = !1),
            (this.composed = !1),
            (this.defaultPrevented = !1),
            (this.eventPhase = r.prototype.NONE),
            (this.propagationStopped = !1),
            (this.propagationImmediatelyStopped = !1),
            (this.layer = new re()),
            (this.page = new re()),
            (this.NONE = 0),
            (this.CAPTURING_PHASE = 1),
            (this.AT_TARGET = 2),
            (this.BUBBLING_PHASE = 3),
            (this.manager = e))
        }
        get layerX() {
          return this.layer.x
        }
        get layerY() {
          return this.layer.y
        }
        get pageX() {
          return this.page.x
        }
        get pageY() {
          return this.page.y
        }
        get data() {
          return this
        }
        composedPath() {
          return (
            this.manager &&
              (!this.path || this.path[this.path.length - 1] !== this.target) &&
              (this.path = this.target ? this.manager.propagationPath(this.target) : []),
            this.path
          )
        }
        initEvent(e, t, i) {
          throw new Error(
            "initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.",
          )
        }
        initUIEvent(e, t, i, n, s) {
          throw new Error(
            "initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.",
          )
        }
        preventDefault() {
          ;(this.nativeEvent instanceof Event &&
            this.nativeEvent.cancelable &&
            this.nativeEvent.preventDefault(),
            (this.defaultPrevented = !0))
        }
        stopImmediatePropagation() {
          this.propagationImmediatelyStopped = !0
        }
        stopPropagation() {
          this.propagationStopped = !0
        }
      }
    })
  function wD(r) {
    return function (e) {
      return e.test(r)
    }
  }
  function Jn(r) {
    var e = { userAgent: "", platform: "", maxTouchPoints: 0 }
    !r && typeof navigator < "u"
      ? (e = {
          userAgent: navigator.userAgent,
          platform: navigator.platform,
          maxTouchPoints: navigator.maxTouchPoints || 0,
        })
      : typeof r == "string"
        ? (e.userAgent = r)
        : r &&
          r.userAgent &&
          (e = {
            userAgent: r.userAgent,
            platform: r.platform,
            maxTouchPoints: r.maxTouchPoints || 0,
          })
    var t = e.userAgent,
      i = t.split("[FBAN")
    ;(typeof i[1] < "u" && (t = i[0]), (i = t.split("Twitter")), typeof i[1] < "u" && (t = i[0]))
    var n = wD(t),
      s = {
        apple: {
          phone: n(Zc) && !n(ur),
          ipod: n(Ag),
          tablet: !n(Zc) && (n(Dg) || Og(e)) && !n(ur),
          universal: n(Pg),
          device: (n(Zc) || n(Ag) || n(Dg) || n(Pg) || Og(e)) && !n(ur),
        },
        amazon: { phone: n(Ni), tablet: !n(Ni) && n(za), device: n(Ni) || n(za) },
        android: {
          phone: (!n(ur) && n(Ni)) || (!n(ur) && n(Qc)),
          tablet: !n(ur) && !n(Ni) && !n(Qc) && (n(za) || n(Rg)),
          device: (!n(ur) && (n(Ni) || n(za) || n(Qc) || n(Rg))) || n(/\bokhttp\b/i),
        },
        windows: { phone: n(ur), tablet: n(Fg), device: n(ur) || n(Fg) },
        other: {
          blackberry: n(Bg),
          blackberry10: n(Ig),
          opera: n(Gg),
          firefox: n(Ug),
          chrome: n(kg),
          device: n(Bg) || n(Ig) || n(Gg) || n(Ug) || n(kg),
        },
        any: !1,
        phone: !1,
        tablet: !1,
      }
    return (
      (s.any = s.apple.device || s.android.device || s.windows.device || s.other.device),
      (s.phone = s.apple.phone || s.android.phone || s.windows.phone),
      (s.tablet = s.apple.tablet || s.android.tablet || s.windows.tablet),
      s
    )
  }
  var Zc,
    Ag,
    Dg,
    Pg,
    Qc,
    Rg,
    Ni,
    za,
    ur,
    Fg,
    Bg,
    Ig,
    Gg,
    kg,
    Ug,
    Og,
    Jc = d(() => {
      ;((Zc = /iPhone/i),
        (Ag = /iPod/i),
        (Dg = /iPad/i),
        (Pg = /\biOS-universal(?:.+)Mac\b/i),
        (Qc = /\bAndroid(?:.+)Mobile\b/i),
        (Rg = /Android/i),
        (Ni = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i),
        (za = /Silk/i),
        (ur = /Windows Phone/i),
        (Fg = /\bWindows(?:.+)ARM\b/i),
        (Bg = /BlackBerry/i),
        (Ig = /BB10/i),
        (Gg = /Opera Mini/i),
        (kg = /\b(CriOS|Chrome)(?:.+)Mobile/i),
        (Ug = /Mobile(?:.+)Firefox\b/i),
        (Og = function (r) {
          return (
            typeof r < "u" &&
            r.platform === "MacIntel" &&
            typeof r.maxTouchPoints == "number" &&
            r.maxTouchPoints > 1 &&
            typeof MSStream > "u"
          )
        }))
    })
  var Lg = d(() => {
    Jc()
    Jc()
  })
  var MD,
    Ng,
    Hg = d(() => {
      Lg()
      ;((MD = Jn.default ?? Jn), (Ng = MD(globalThis.navigator)))
    })
  var AD,
    Wa,
    DD,
    PD,
    zg,
    Wg,
    RD,
    FD,
    BD,
    eh,
    $g,
    Xg = d(() => {
      Ha()
      D()
      Hg()
      Bc()
      ;((AD = 9),
        (Wa = 100),
        (DD = 0),
        (PD = 0),
        (zg = 2),
        (Wg = 1),
        (RD = -1e3),
        (FD = -1e3),
        (BD = 2),
        (eh = class Vg {
          constructor(e, t = Ng) {
            ;((this._mobileInfo = t),
              (this.debug = !1),
              (this._activateOnTab = !0),
              (this._deactivateOnMouseMove = !0),
              (this._isActive = !1),
              (this._isMobileAccessibility = !1),
              (this._div = null),
              (this._pool = []),
              (this._renderId = 0),
              (this._children = []),
              (this._androidUpdateCount = 0),
              (this._androidUpdateFrequency = 500),
              (this._hookDiv = null),
              (t.tablet || t.phone) && this._createTouchHook(),
              (this._renderer = e))
          }
          get isActive() {
            return this._isActive
          }
          get isMobileAccessibility() {
            return this._isMobileAccessibility
          }
          get hookDiv() {
            return this._hookDiv
          }
          _createTouchHook() {
            let e = document.createElement("button")
            ;((e.style.width = `${Wg}px`),
              (e.style.height = `${Wg}px`),
              (e.style.position = "absolute"),
              (e.style.top = `${RD}px`),
              (e.style.left = `${FD}px`),
              (e.style.zIndex = BD.toString()),
              (e.style.backgroundColor = "#FF0000"),
              (e.title = "select to enable accessibility for this content"),
              e.addEventListener("focus", () => {
                ;((this._isMobileAccessibility = !0), this._activate(), this._destroyTouchHook())
              }),
              document.body.appendChild(e),
              (this._hookDiv = e))
          }
          _destroyTouchHook() {
            this._hookDiv && (document.body.removeChild(this._hookDiv), (this._hookDiv = null))
          }
          _activate() {
            if (this._isActive) return
            ;((this._isActive = !0),
              this._div ||
                ((this._div = document.createElement("div")),
                (this._div.style.width = `${Wa}px`),
                (this._div.style.height = `${Wa}px`),
                (this._div.style.position = "absolute"),
                (this._div.style.top = `${DD}px`),
                (this._div.style.left = `${PD}px`),
                (this._div.style.zIndex = zg.toString()),
                (this._div.style.pointerEvents = "none")),
              this._activateOnTab &&
                ((this._onKeyDown = this._onKeyDown.bind(this)),
                globalThis.addEventListener("keydown", this._onKeyDown, !1)),
              this._deactivateOnMouseMove &&
                ((this._onMouseMove = this._onMouseMove.bind(this)),
                globalThis.document.addEventListener("mousemove", this._onMouseMove, !0)))
            let e = this._renderer.view.canvas
            if (e.parentNode) (e.parentNode.appendChild(this._div), this._initAccessibilitySetup())
            else {
              let t = new MutationObserver(() => {
                e.parentNode &&
                  (e.parentNode.appendChild(this._div),
                  t.disconnect(),
                  this._initAccessibilitySetup())
              })
              t.observe(document.body, { childList: !0, subtree: !0 })
            }
          }
          _initAccessibilitySetup() {
            ;(this._renderer.runners.postrender.add(this),
              this._renderer.lastObjectRendered &&
                this._updateAccessibleObjects(this._renderer.lastObjectRendered))
          }
          _deactivate() {
            if (!(!this._isActive || this._isMobileAccessibility)) {
              ;((this._isActive = !1),
                globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0),
                this._activateOnTab && globalThis.addEventListener("keydown", this._onKeyDown, !1),
                this._renderer.runners.postrender.remove(this))
              for (let e of this._children)
                (e._accessibleDiv &&
                  e._accessibleDiv.parentNode &&
                  (e._accessibleDiv.parentNode.removeChild(e._accessibleDiv),
                  (e._accessibleDiv = null)),
                  (e._accessibleActive = !1))
              ;(this._pool.forEach((e) => {
                e.parentNode && e.parentNode.removeChild(e)
              }),
                this._div && this._div.parentNode && this._div.parentNode.removeChild(this._div),
                (this._pool = []),
                (this._children = []))
            }
          }
          _updateAccessibleObjects(e) {
            if (!e.visible || !e.accessibleChildren) return
            e.accessible &&
              (e._accessibleActive || this._addChild(e), (e._renderId = this._renderId))
            let t = e.children
            if (t) for (let i = 0; i < t.length; i++) this._updateAccessibleObjects(t[i])
          }
          init(e) {
            let i = {
              accessibilityOptions: { ...Vg.defaultOptions, ...(e?.accessibilityOptions || {}) },
            }
            ;((this.debug = i.accessibilityOptions.debug),
              (this._activateOnTab = i.accessibilityOptions.activateOnTab),
              (this._deactivateOnMouseMove = i.accessibilityOptions.deactivateOnMouseMove),
              i.accessibilityOptions.enabledByDefault
                ? this._activate()
                : this._activateOnTab &&
                  ((this._onKeyDown = this._onKeyDown.bind(this)),
                  globalThis.addEventListener("keydown", this._onKeyDown, !1)),
              this._renderer.runners.postrender.remove(this))
          }
          postrender() {
            let e = performance.now()
            if (
              (this._mobileInfo.android.device && e < this._androidUpdateCount) ||
              ((this._androidUpdateCount = e + this._androidUpdateFrequency),
              !this._renderer.renderingToScreen || !this._renderer.view.canvas)
            )
              return
            let t = new Set()
            if (this._renderer.lastObjectRendered) {
              this._updateAccessibleObjects(this._renderer.lastObjectRendered)
              for (let i of this._children)
                i._renderId === this._renderId && t.add(this._children.indexOf(i))
            }
            for (let i = this._children.length - 1; i >= 0; i--) {
              let n = this._children[i]
              t.has(i) ||
                (n._accessibleDiv &&
                  n._accessibleDiv.parentNode &&
                  (n._accessibleDiv.parentNode.removeChild(n._accessibleDiv),
                  this._pool.push(n._accessibleDiv),
                  (n._accessibleDiv = null)),
                (n._accessibleActive = !1),
                Pa(this._children, i, 1))
            }
            if (this._renderer.renderingToScreen) {
              let { x: i, y: n, width: s, height: o } = this._renderer.screen,
                a = this._div
              ;((a.style.left = `${i}px`),
                (a.style.top = `${n}px`),
                (a.style.width = `${s}px`),
                (a.style.height = `${o}px`))
            }
            for (let i = 0; i < this._children.length; i++) {
              let n = this._children[i]
              if (!n._accessibleActive || !n._accessibleDiv) continue
              let s = n._accessibleDiv,
                o = n.hitArea || n.getBounds().rectangle
              if (n.hitArea) {
                let a = n.worldTransform,
                  u = this._renderer.resolution,
                  l = this._renderer.resolution
                ;((s.style.left = `${(a.tx + o.x * a.a) * u}px`),
                  (s.style.top = `${(a.ty + o.y * a.d) * l}px`),
                  (s.style.width = `${o.width * a.a * u}px`),
                  (s.style.height = `${o.height * a.d * l}px`))
              } else {
                this._capHitArea(o)
                let a = this._renderer.resolution,
                  u = this._renderer.resolution
                ;((s.style.left = `${o.x * a}px`),
                  (s.style.top = `${o.y * u}px`),
                  (s.style.width = `${o.width * a}px`),
                  (s.style.height = `${o.height * u}px`))
              }
            }
            this._renderId++
          }
          _updateDebugHTML(e) {
            e.innerHTML = `type: ${e.type}</br> title : ${e.title}</br> tabIndex: ${e.tabIndex}`
          }
          _capHitArea(e) {
            ;(e.x < 0 && ((e.width += e.x), (e.x = 0)), e.y < 0 && ((e.height += e.y), (e.y = 0)))
            let { width: t, height: i } = this._renderer
            ;(e.x + e.width > t && (e.width = t - e.x), e.y + e.height > i && (e.height = i - e.y))
          }
          _addChild(e) {
            let t = this._pool.pop()
            ;(t ||
              (e.accessibleType === "button"
                ? (t = document.createElement("button"))
                : ((t = document.createElement(e.accessibleType)),
                  (t.style.cssText = `
                        color: transparent;
                        pointer-events: none;
                        padding: 0;
                        margin: 0;
                        border: 0;
                        outline: 0;
                        background: transparent;
                        box-sizing: border-box;
                        user-select: none;
                        -webkit-user-select: none;
                        -moz-user-select: none;
                        -ms-user-select: none;
                    `),
                  e.accessibleText && (t.innerText = e.accessibleText)),
              (t.style.width = `${Wa}px`),
              (t.style.height = `${Wa}px`),
              (t.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent"),
              (t.style.position = "absolute"),
              (t.style.zIndex = zg.toString()),
              (t.style.borderStyle = "none"),
              navigator.userAgent.toLowerCase().includes("chrome")
                ? t.setAttribute("aria-live", "off")
                : t.setAttribute("aria-live", "polite"),
              navigator.userAgent.match(/rv:.*Gecko\//)
                ? t.setAttribute("aria-relevant", "additions")
                : t.setAttribute("aria-relevant", "text"),
              t.addEventListener("click", this._onClick.bind(this)),
              t.addEventListener("focus", this._onFocus.bind(this)),
              t.addEventListener("focusout", this._onFocusOut.bind(this))),
              (t.style.pointerEvents = e.accessiblePointerEvents),
              (t.type = e.accessibleType),
              e.accessibleTitle && e.accessibleTitle !== null
                ? (t.title = e.accessibleTitle)
                : (!e.accessibleHint || e.accessibleHint === null) &&
                  (t.title = `container ${e.tabIndex}`),
              e.accessibleHint &&
                e.accessibleHint !== null &&
                t.setAttribute("aria-label", e.accessibleHint),
              this.debug && this._updateDebugHTML(t),
              (e._accessibleActive = !0),
              (e._accessibleDiv = t),
              (t.container = e),
              this._children.push(e),
              this._div.appendChild(e._accessibleDiv),
              e.interactive && (e._accessibleDiv.tabIndex = e.tabIndex))
          }
          _dispatchEvent(e, t) {
            let { container: i } = e.target,
              n = this._renderer.events.rootBoundary,
              s = Object.assign(new Cr(n), { target: i })
            ;((n.rootTarget = this._renderer.lastObjectRendered),
              t.forEach((o) => n.dispatchEvent(s, o)))
          }
          _onClick(e) {
            this._dispatchEvent(e, ["click", "pointertap", "tap"])
          }
          _onFocus(e) {
            ;(e.target.getAttribute("aria-live") || e.target.setAttribute("aria-live", "assertive"),
              this._dispatchEvent(e, ["mouseover"]))
          }
          _onFocusOut(e) {
            ;(e.target.getAttribute("aria-live") || e.target.setAttribute("aria-live", "polite"),
              this._dispatchEvent(e, ["mouseout"]))
          }
          _onKeyDown(e) {
            e.keyCode !== AD || !this._activateOnTab || this._activate()
          }
          _onMouseMove(e) {
            ;(e.movementX === 0 && e.movementY === 0) || this._deactivate()
          }
          destroy() {
            ;(this._deactivate(),
              this._destroyTouchHook(),
              (this._div = null),
              (this._pool = null),
              (this._children = null),
              (this._renderer = null),
              this._activateOnTab && globalThis.removeEventListener("keydown", this._onKeyDown))
          }
          setAccessibilityEnabled(e) {
            e ? this._activate() : this._deactivate()
          }
        }))
      eh.extension = { type: [_.WebGLSystem, _.WebGPUSystem], name: "accessibility" }
      eh.defaultOptions = {
        enabledByDefault: !1,
        debug: !1,
        activateOnTab: !0,
        deactivateOnMouseMove: !0,
      }
      $g = eh
    })
  var Yg,
    Kg = d(() => {
      "use strict"
      Yg = {
        accessible: !1,
        accessibleTitle: null,
        accessibleHint: null,
        tabIndex: 0,
        _accessibleActive: !1,
        _accessibleDiv: null,
        accessibleType: "button",
        accessibleText: null,
        accessiblePointerEvents: "auto",
        accessibleChildren: !0,
        _renderId: -1,
      }
    })
  var jg = d(() => {
    D()
    Gt()
    Xg()
    Kg()
    L.add($g)
    L.mixin(xe, Yg)
  })
  var es,
    qg = d(() => {
      D()
      es = class {
        static init(e) {
          ;(Object.defineProperty(this, "resizeTo", {
            set(t) {
              ;(globalThis.removeEventListener("resize", this.queueResize),
                (this._resizeTo = t),
                t && (globalThis.addEventListener("resize", this.queueResize), this.resize()))
            },
            get() {
              return this._resizeTo
            },
          }),
            (this.queueResize = () => {
              this._resizeTo &&
                (this._cancelResize(),
                (this._resizeId = requestAnimationFrame(() => this.resize())))
            }),
            (this._cancelResize = () => {
              this._resizeId && (cancelAnimationFrame(this._resizeId), (this._resizeId = null))
            }),
            (this.resize = () => {
              if (!this._resizeTo) return
              this._cancelResize()
              let t, i
              if (this._resizeTo === globalThis.window)
                ((t = globalThis.innerWidth), (i = globalThis.innerHeight))
              else {
                let { clientWidth: n, clientHeight: s } = this._resizeTo
                ;((t = n), (i = s))
              }
              ;(this.renderer.resize(t, i), this.render())
            }),
            (this._resizeId = null),
            (this._resizeTo = null),
            (this.resizeTo = e.resizeTo || null))
        }
        static destroy() {
          ;(globalThis.removeEventListener("resize", this.queueResize),
            this._cancelResize(),
            (this._cancelResize = null),
            (this.queueResize = null),
            (this.resizeTo = null),
            (this.resize = null))
        }
      }
      es.extension = _.Application
    })
  var Er,
    Va = d(() => {
      "use strict"
      Er = ((r) => (
        (r[(r.INTERACTION = 50)] = "INTERACTION"),
        (r[(r.HIGH = 25)] = "HIGH"),
        (r[(r.NORMAL = 0)] = "NORMAL"),
        (r[(r.LOW = -25)] = "LOW"),
        (r[(r.UTILITY = -50)] = "UTILITY"),
        r
      ))(Er || {})
    })
  var Hi,
    Zg = d(() => {
      "use strict"
      Hi = class {
        constructor(e, t = null, i = 0, n = !1) {
          ;((this.next = null),
            (this.previous = null),
            (this._destroyed = !1),
            (this._fn = e),
            (this._context = t),
            (this.priority = i),
            (this._once = n))
        }
        match(e, t = null) {
          return this._fn === e && this._context === t
        }
        emit(e) {
          this._fn && (this._context ? this._fn.call(this._context, e) : this._fn(e))
          let t = this.next
          return (this._once && this.destroy(!0), this._destroyed && (this.next = null), t)
        }
        connect(e) {
          ;((this.previous = e),
            e.next && (e.next.previous = this),
            (this.next = e.next),
            (e.next = this))
        }
        destroy(e = !1) {
          ;((this._destroyed = !0),
            (this._fn = null),
            (this._context = null),
            this.previous && (this.previous.next = this.next),
            this.next && (this.next.previous = this.previous))
          let t = this.next
          return ((this.next = e ? null : t), (this.previous = null), t)
        }
      }
    })
  var Qg,
    ht,
    ts = d(() => {
      Va()
      Zg()
      Qg = class vt {
        constructor() {
          ;((this.autoStart = !1),
            (this.deltaTime = 1),
            (this.lastTime = -1),
            (this.speed = 1),
            (this.started = !1),
            (this._requestId = null),
            (this._maxElapsedMS = 100),
            (this._minElapsedMS = 0),
            (this._protected = !1),
            (this._lastFrame = -1),
            (this._head = new Hi(null, null, 1 / 0)),
            (this.deltaMS = 1 / vt.targetFPMS),
            (this.elapsedMS = 1 / vt.targetFPMS),
            (this._tick = (e) => {
              ;((this._requestId = null),
                this.started &&
                  (this.update(e),
                  this.started &&
                    this._requestId === null &&
                    this._head.next &&
                    (this._requestId = requestAnimationFrame(this._tick))))
            }))
        }
        _requestIfNeeded() {
          this._requestId === null &&
            this._head.next &&
            ((this.lastTime = performance.now()),
            (this._lastFrame = this.lastTime),
            (this._requestId = requestAnimationFrame(this._tick)))
        }
        _cancelIfNeeded() {
          this._requestId !== null &&
            (cancelAnimationFrame(this._requestId), (this._requestId = null))
        }
        _startIfPossible() {
          this.started ? this._requestIfNeeded() : this.autoStart && this.start()
        }
        add(e, t, i = Er.NORMAL) {
          return this._addListener(new Hi(e, t, i))
        }
        addOnce(e, t, i = Er.NORMAL) {
          return this._addListener(new Hi(e, t, i, !0))
        }
        _addListener(e) {
          let t = this._head.next,
            i = this._head
          if (!t) e.connect(i)
          else {
            for (; t; ) {
              if (e.priority > t.priority) {
                e.connect(i)
                break
              }
              ;((i = t), (t = t.next))
            }
            e.previous || e.connect(i)
          }
          return (this._startIfPossible(), this)
        }
        remove(e, t) {
          let i = this._head.next
          for (; i; ) i.match(e, t) ? (i = i.destroy()) : (i = i.next)
          return (this._head.next || this._cancelIfNeeded(), this)
        }
        get count() {
          if (!this._head) return 0
          let e = 0,
            t = this._head
          for (; (t = t.next); ) e++
          return e
        }
        start() {
          this.started || ((this.started = !0), this._requestIfNeeded())
        }
        stop() {
          this.started && ((this.started = !1), this._cancelIfNeeded())
        }
        destroy() {
          if (!this._protected) {
            this.stop()
            let e = this._head.next
            for (; e; ) e = e.destroy(!0)
            ;(this._head.destroy(), (this._head = null))
          }
        }
        update(e = performance.now()) {
          let t
          if (e > this.lastTime) {
            if (
              ((t = this.elapsedMS = e - this.lastTime),
              t > this._maxElapsedMS && (t = this._maxElapsedMS),
              (t *= this.speed),
              this._minElapsedMS)
            ) {
              let s = (e - this._lastFrame) | 0
              if (s < this._minElapsedMS) return
              this._lastFrame = e - (s % this._minElapsedMS)
            }
            ;((this.deltaMS = t), (this.deltaTime = this.deltaMS * vt.targetFPMS))
            let i = this._head,
              n = i.next
            for (; n; ) n = n.emit(this)
            i.next || this._cancelIfNeeded()
          } else this.deltaTime = this.deltaMS = this.elapsedMS = 0
          this.lastTime = e
        }
        get FPS() {
          return 1e3 / this.elapsedMS
        }
        get minFPS() {
          return 1e3 / this._maxElapsedMS
        }
        set minFPS(e) {
          let t = Math.min(this.maxFPS, e),
            i = Math.min(Math.max(0, t) / 1e3, vt.targetFPMS)
          this._maxElapsedMS = 1 / i
        }
        get maxFPS() {
          return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0
        }
        set maxFPS(e) {
          if (e === 0) this._minElapsedMS = 0
          else {
            let t = Math.max(this.minFPS, e)
            this._minElapsedMS = 1 / (t / 1e3)
          }
        }
        static get shared() {
          if (!vt._shared) {
            let e = (vt._shared = new vt())
            ;((e.autoStart = !0), (e._protected = !0))
          }
          return vt._shared
        }
        static get system() {
          if (!vt._system) {
            let e = (vt._system = new vt())
            ;((e.autoStart = !0), (e._protected = !0))
          }
          return vt._system
        }
      }
      Qg.targetFPMS = 0.06
      ht = Qg
    })
  var rs,
    Jg = d(() => {
      D()
      Va()
      ts()
      rs = class {
        static init(e) {
          ;((e = Object.assign({ autoStart: !0, sharedTicker: !1 }, e)),
            Object.defineProperty(this, "ticker", {
              set(t) {
                ;(this._ticker && this._ticker.remove(this.render, this),
                  (this._ticker = t),
                  t && t.add(this.render, this, Er.LOW))
              },
              get() {
                return this._ticker
              },
            }),
            (this.stop = () => {
              this._ticker.stop()
            }),
            (this.start = () => {
              this._ticker.start()
            }),
            (this._ticker = null),
            (this.ticker = e.sharedTicker ? ht.shared : new ht()),
            e.autoStart && this.start())
        }
        static destroy() {
          if (this._ticker) {
            let e = this._ticker
            ;((this.ticker = null), e.destroy())
          }
        }
      }
      rs.extension = _.Application
    })
  var th = d(() => {
    D()
    qg()
    Jg()
    L.add(es)
    L.add(rs)
  })
  var rh,
    Vt,
    ih = d(() => {
      Va()
      ts()
      ;((rh = class {
        constructor() {
          ;((this.interactionFrequency = 10),
            (this._deltaTime = 0),
            (this._didMove = !1),
            (this._tickerAdded = !1),
            (this._pauseUpdate = !0))
        }
        init(e) {
          ;(this.removeTickerListener(),
            (this.events = e),
            (this.interactionFrequency = 10),
            (this._deltaTime = 0),
            (this._didMove = !1),
            (this._tickerAdded = !1),
            (this._pauseUpdate = !0))
        }
        get pauseUpdate() {
          return this._pauseUpdate
        }
        set pauseUpdate(e) {
          this._pauseUpdate = e
        }
        addTickerListener() {
          this._tickerAdded ||
            !this.domElement ||
            (ht.system.add(this._tickerUpdate, this, Er.INTERACTION), (this._tickerAdded = !0))
        }
        removeTickerListener() {
          this._tickerAdded &&
            (ht.system.remove(this._tickerUpdate, this), (this._tickerAdded = !1))
        }
        pointerMoved() {
          this._didMove = !0
        }
        _update() {
          if (!this.domElement || this._pauseUpdate) return
          if (this._didMove) {
            this._didMove = !1
            return
          }
          let e = this.events._rootPointerEvent
          ;(this.events.supportsTouchEvents && e.pointerType === "touch") ||
            globalThis.document.dispatchEvent(
              new PointerEvent("pointermove", {
                clientX: e.clientX,
                clientY: e.clientY,
                pointerType: e.pointerType,
                pointerId: e.pointerId,
              }),
            )
        }
        _tickerUpdate(e) {
          ;((this._deltaTime += e.deltaTime),
            !(this._deltaTime < this.interactionFrequency) &&
              ((this._deltaTime = 0), this._update()))
        }
      }),
        (Vt = new rh()))
    })
  var lr,
    $a = d(() => {
      Et()
      Ha()
      lr = class extends Cr {
        constructor() {
          ;(super(...arguments),
            (this.client = new re()),
            (this.movement = new re()),
            (this.offset = new re()),
            (this.global = new re()),
            (this.screen = new re()))
        }
        get clientX() {
          return this.client.x
        }
        get clientY() {
          return this.client.y
        }
        get x() {
          return this.clientX
        }
        get y() {
          return this.clientY
        }
        get movementX() {
          return this.movement.x
        }
        get movementY() {
          return this.movement.y
        }
        get offsetX() {
          return this.offset.x
        }
        get offsetY() {
          return this.offset.y
        }
        get globalX() {
          return this.global.x
        }
        get globalY() {
          return this.global.y
        }
        get screenX() {
          return this.screen.x
        }
        get screenY() {
          return this.screen.y
        }
        getLocalPosition(e, t, i) {
          return e.worldTransform.applyInverse(i || this.global, t)
        }
        getModifierState(e) {
          return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(e)
        }
        initMouseEvent(e, t, i, n, s, o, a, u, l, c, h, f, p, m, g) {
          throw new Error("Method not implemented.")
        }
      }
    })
  var nt,
    nh = d(() => {
      $a()
      nt = class extends lr {
        constructor() {
          ;(super(...arguments), (this.width = 0), (this.height = 0), (this.isPrimary = !1))
        }
        getCoalescedEvents() {
          return this.type === "pointermove" ||
            this.type === "mousemove" ||
            this.type === "touchmove"
            ? [this]
            : []
        }
        getPredictedEvents() {
          throw new Error("getPredictedEvents is not supported!")
        }
      }
    })
  var $t,
    sh = d(() => {
      $a()
      $t = class extends lr {
        constructor() {
          ;(super(...arguments),
            (this.DOM_DELTA_PIXEL = 0),
            (this.DOM_DELTA_LINE = 1),
            (this.DOM_DELTA_PAGE = 2))
        }
      }
      $t.DOM_DELTA_PIXEL = 0
      $t.DOM_DELTA_LINE = 1
      $t.DOM_DELTA_PAGE = 2
    })
  var ID,
    GD,
    is,
    Xa,
    ex = d(() => {
      Je()
      Et()
      be()
      ih()
      $a()
      nh()
      sh()
      ;((ID = 2048),
        (GD = new re()),
        (is = new re()),
        (Xa = class {
          constructor(e) {
            ;((this.dispatch = new pe()),
              (this.moveOnAll = !1),
              (this.enableGlobalMoveEvents = !0),
              (this.mappingState = { trackingData: {} }),
              (this.eventPool = new Map()),
              (this._allInteractiveElements = []),
              (this._hitElements = []),
              (this._isPointerMoveEvent = !1),
              (this.rootTarget = e),
              (this.hitPruneFn = this.hitPruneFn.bind(this)),
              (this.hitTestFn = this.hitTestFn.bind(this)),
              (this.mapPointerDown = this.mapPointerDown.bind(this)),
              (this.mapPointerMove = this.mapPointerMove.bind(this)),
              (this.mapPointerOut = this.mapPointerOut.bind(this)),
              (this.mapPointerOver = this.mapPointerOver.bind(this)),
              (this.mapPointerUp = this.mapPointerUp.bind(this)),
              (this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this)),
              (this.mapWheel = this.mapWheel.bind(this)),
              (this.mappingTable = {}),
              this.addEventMapping("pointerdown", this.mapPointerDown),
              this.addEventMapping("pointermove", this.mapPointerMove),
              this.addEventMapping("pointerout", this.mapPointerOut),
              this.addEventMapping("pointerleave", this.mapPointerOut),
              this.addEventMapping("pointerover", this.mapPointerOver),
              this.addEventMapping("pointerup", this.mapPointerUp),
              this.addEventMapping("pointerupoutside", this.mapPointerUpOutside),
              this.addEventMapping("wheel", this.mapWheel))
          }
          addEventMapping(e, t) {
            ;(this.mappingTable[e] || (this.mappingTable[e] = []),
              this.mappingTable[e].push({ fn: t, priority: 0 }),
              this.mappingTable[e].sort((i, n) => i.priority - n.priority))
          }
          dispatchEvent(e, t) {
            ;((e.propagationStopped = !1),
              (e.propagationImmediatelyStopped = !1),
              this.propagate(e, t),
              this.dispatch.emit(t || e.type, e))
          }
          mapEvent(e) {
            if (!this.rootTarget) return
            let t = this.mappingTable[e.type]
            if (t) for (let i = 0, n = t.length; i < n; i++) t[i].fn(e)
            else H(`[EventBoundary]: Event mapping not defined for ${e.type}`)
          }
          hitTest(e, t) {
            Vt.pauseUpdate = !0
            let n =
                this._isPointerMoveEvent && this.enableGlobalMoveEvents
                  ? "hitTestMoveRecursive"
                  : "hitTestRecursive",
              s = this[n](
                this.rootTarget,
                this.rootTarget.eventMode,
                GD.set(e, t),
                this.hitTestFn,
                this.hitPruneFn,
              )
            return s && s[0]
          }
          propagate(e, t) {
            if (!e.target) return
            let i = e.composedPath()
            e.eventPhase = e.CAPTURING_PHASE
            for (let n = 0, s = i.length - 1; n < s; n++)
              if (
                ((e.currentTarget = i[n]),
                this.notifyTarget(e, t),
                e.propagationStopped || e.propagationImmediatelyStopped)
              )
                return
            if (
              ((e.eventPhase = e.AT_TARGET),
              (e.currentTarget = e.target),
              this.notifyTarget(e, t),
              !(e.propagationStopped || e.propagationImmediatelyStopped))
            ) {
              e.eventPhase = e.BUBBLING_PHASE
              for (let n = i.length - 2; n >= 0; n--)
                if (
                  ((e.currentTarget = i[n]),
                  this.notifyTarget(e, t),
                  e.propagationStopped || e.propagationImmediatelyStopped)
                )
                  return
            }
          }
          all(e, t, i = this._allInteractiveElements) {
            if (i.length === 0) return
            e.eventPhase = e.BUBBLING_PHASE
            let n = Array.isArray(t) ? t : [t]
            for (let s = i.length - 1; s >= 0; s--)
              n.forEach((o) => {
                ;((e.currentTarget = i[s]), this.notifyTarget(e, o))
              })
          }
          propagationPath(e) {
            let t = [e]
            for (let i = 0; i < ID && e !== this.rootTarget && e.parent; i++) {
              if (!e.parent) throw new Error("Cannot find propagation path to disconnected target")
              ;(t.push(e.parent), (e = e.parent))
            }
            return (t.reverse(), t)
          }
          hitTestMoveRecursive(e, t, i, n, s, o = !1) {
            let a = !1
            if (this._interactivePrune(e)) return null
            if (
              ((e.eventMode === "dynamic" || t === "dynamic") && (Vt.pauseUpdate = !1),
              e.interactiveChildren && e.children)
            ) {
              let c = e.children
              for (let h = c.length - 1; h >= 0; h--) {
                let f = c[h],
                  p = this.hitTestMoveRecursive(
                    f,
                    this._isInteractive(t) ? t : f.eventMode,
                    i,
                    n,
                    s,
                    o || s(e, i),
                  )
                if (p) {
                  if (p.length > 0 && !p[p.length - 1].parent) continue
                  let m = e.isInteractive()
                  ;((p.length > 0 || m) && (m && this._allInteractiveElements.push(e), p.push(e)),
                    this._hitElements.length === 0 && (this._hitElements = p),
                    (a = !0))
                }
              }
            }
            let u = this._isInteractive(t),
              l = e.isInteractive()
            return (
              l && l && this._allInteractiveElements.push(e),
              o || this._hitElements.length > 0
                ? null
                : a
                  ? this._hitElements
                  : u && !s(e, i) && n(e, i)
                    ? l
                      ? [e]
                      : []
                    : null
            )
          }
          hitTestRecursive(e, t, i, n, s) {
            if (this._interactivePrune(e) || s(e, i)) return null
            if (
              ((e.eventMode === "dynamic" || t === "dynamic") && (Vt.pauseUpdate = !1),
              e.interactiveChildren && e.children)
            ) {
              let u = e.children,
                l = i
              for (let c = u.length - 1; c >= 0; c--) {
                let h = u[c],
                  f = this.hitTestRecursive(h, this._isInteractive(t) ? t : h.eventMode, l, n, s)
                if (f) {
                  if (f.length > 0 && !f[f.length - 1].parent) continue
                  let p = e.isInteractive()
                  return ((f.length > 0 || p) && f.push(e), f)
                }
              }
            }
            let o = this._isInteractive(t),
              a = e.isInteractive()
            return o && n(e, i) ? (a ? [e] : []) : null
          }
          _isInteractive(e) {
            return e === "static" || e === "dynamic"
          }
          _interactivePrune(e) {
            return (
              !e ||
              !e.visible ||
              !e.renderable ||
              !e.measurable ||
              e.eventMode === "none" ||
              (e.eventMode === "passive" && !e.interactiveChildren)
            )
          }
          hitPruneFn(e, t) {
            if (
              e.hitArea &&
              (e.worldTransform.applyInverse(t, is), !e.hitArea.contains(is.x, is.y))
            )
              return !0
            if (e.effects && e.effects.length)
              for (let i = 0; i < e.effects.length; i++) {
                let n = e.effects[i]
                if (n.containsPoint && !n.containsPoint(t, this.hitTestFn)) return !0
              }
            return !1
          }
          hitTestFn(e, t) {
            return e.hitArea
              ? !0
              : e?.containsPoint
                ? (e.worldTransform.applyInverse(t, is), e.containsPoint(is))
                : !1
          }
          notifyTarget(e, t) {
            if (!e.currentTarget.isInteractive()) return
            t ?? (t = e.type)
            let i = `on${t}`
            e.currentTarget[i]?.(e)
            let n =
              e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${t}capture` : t
            ;(this._notifyListeners(e, n),
              e.eventPhase === e.AT_TARGET && this._notifyListeners(e, t))
          }
          mapPointerDown(e) {
            if (!(e instanceof nt)) {
              H("EventBoundary cannot map a non-pointer event as a pointer event")
              return
            }
            let t = this.createPointerEvent(e)
            if ((this.dispatchEvent(t, "pointerdown"), t.pointerType === "touch"))
              this.dispatchEvent(t, "touchstart")
            else if (t.pointerType === "mouse" || t.pointerType === "pen") {
              let n = t.button === 2
              this.dispatchEvent(t, n ? "rightdown" : "mousedown")
            }
            let i = this.trackingData(e.pointerId)
            ;((i.pressTargetsByButton[e.button] = t.composedPath()), this.freeEvent(t))
          }
          mapPointerMove(e) {
            if (!(e instanceof nt)) {
              H("EventBoundary cannot map a non-pointer event as a pointer event")
              return
            }
            ;((this._allInteractiveElements.length = 0),
              (this._hitElements.length = 0),
              (this._isPointerMoveEvent = !0))
            let t = this.createPointerEvent(e)
            this._isPointerMoveEvent = !1
            let i = t.pointerType === "mouse" || t.pointerType === "pen",
              n = this.trackingData(e.pointerId),
              s = this.findMountedTarget(n.overTargets)
            if (n.overTargets?.length > 0 && s !== t.target) {
              let u = e.type === "mousemove" ? "mouseout" : "pointerout",
                l = this.createPointerEvent(e, u, s)
              if (
                (this.dispatchEvent(l, "pointerout"),
                i && this.dispatchEvent(l, "mouseout"),
                !t.composedPath().includes(s))
              ) {
                let c = this.createPointerEvent(e, "pointerleave", s)
                for (c.eventPhase = c.AT_TARGET; c.target && !t.composedPath().includes(c.target); )
                  ((c.currentTarget = c.target),
                    this.notifyTarget(c),
                    i && this.notifyTarget(c, "mouseleave"),
                    (c.target = c.target.parent))
                this.freeEvent(c)
              }
              this.freeEvent(l)
            }
            if (s !== t.target) {
              let u = e.type === "mousemove" ? "mouseover" : "pointerover",
                l = this.clonePointerEvent(t, u)
              ;(this.dispatchEvent(l, "pointerover"), i && this.dispatchEvent(l, "mouseover"))
              let c = s?.parent
              for (; c && c !== this.rootTarget.parent && c !== t.target; ) c = c.parent
              if (!c || c === this.rootTarget.parent) {
                let f = this.clonePointerEvent(t, "pointerenter")
                for (
                  f.eventPhase = f.AT_TARGET;
                  f.target && f.target !== s && f.target !== this.rootTarget.parent;

                )
                  ((f.currentTarget = f.target),
                    this.notifyTarget(f),
                    i && this.notifyTarget(f, "mouseenter"),
                    (f.target = f.target.parent))
                this.freeEvent(f)
              }
              this.freeEvent(l)
            }
            let o = [],
              a = this.enableGlobalMoveEvents ?? !0
            ;(this.moveOnAll ? o.push("pointermove") : this.dispatchEvent(t, "pointermove"),
              a && o.push("globalpointermove"),
              t.pointerType === "touch" &&
                (this.moveOnAll ? o.splice(1, 0, "touchmove") : this.dispatchEvent(t, "touchmove"),
                a && o.push("globaltouchmove")),
              i &&
                (this.moveOnAll ? o.splice(1, 0, "mousemove") : this.dispatchEvent(t, "mousemove"),
                a && o.push("globalmousemove"),
                (this.cursor = t.target?.cursor)),
              o.length > 0 && this.all(t, o),
              (this._allInteractiveElements.length = 0),
              (this._hitElements.length = 0),
              (n.overTargets = t.composedPath()),
              this.freeEvent(t))
          }
          mapPointerOver(e) {
            if (!(e instanceof nt)) {
              H("EventBoundary cannot map a non-pointer event as a pointer event")
              return
            }
            let t = this.trackingData(e.pointerId),
              i = this.createPointerEvent(e),
              n = i.pointerType === "mouse" || i.pointerType === "pen"
            ;(this.dispatchEvent(i, "pointerover"),
              n && this.dispatchEvent(i, "mouseover"),
              i.pointerType === "mouse" && (this.cursor = i.target?.cursor))
            let s = this.clonePointerEvent(i, "pointerenter")
            for (s.eventPhase = s.AT_TARGET; s.target && s.target !== this.rootTarget.parent; )
              ((s.currentTarget = s.target),
                this.notifyTarget(s),
                n && this.notifyTarget(s, "mouseenter"),
                (s.target = s.target.parent))
            ;((t.overTargets = i.composedPath()), this.freeEvent(i), this.freeEvent(s))
          }
          mapPointerOut(e) {
            if (!(e instanceof nt)) {
              H("EventBoundary cannot map a non-pointer event as a pointer event")
              return
            }
            let t = this.trackingData(e.pointerId)
            if (t.overTargets) {
              let i = e.pointerType === "mouse" || e.pointerType === "pen",
                n = this.findMountedTarget(t.overTargets),
                s = this.createPointerEvent(e, "pointerout", n)
              ;(this.dispatchEvent(s), i && this.dispatchEvent(s, "mouseout"))
              let o = this.createPointerEvent(e, "pointerleave", n)
              for (o.eventPhase = o.AT_TARGET; o.target && o.target !== this.rootTarget.parent; )
                ((o.currentTarget = o.target),
                  this.notifyTarget(o),
                  i && this.notifyTarget(o, "mouseleave"),
                  (o.target = o.target.parent))
              ;((t.overTargets = null), this.freeEvent(s), this.freeEvent(o))
            }
            this.cursor = null
          }
          mapPointerUp(e) {
            if (!(e instanceof nt)) {
              H("EventBoundary cannot map a non-pointer event as a pointer event")
              return
            }
            let t = performance.now(),
              i = this.createPointerEvent(e)
            if ((this.dispatchEvent(i, "pointerup"), i.pointerType === "touch"))
              this.dispatchEvent(i, "touchend")
            else if (i.pointerType === "mouse" || i.pointerType === "pen") {
              let a = i.button === 2
              this.dispatchEvent(i, a ? "rightup" : "mouseup")
            }
            let n = this.trackingData(e.pointerId),
              s = this.findMountedTarget(n.pressTargetsByButton[e.button]),
              o = s
            if (s && !i.composedPath().includes(s)) {
              let a = s
              for (; a && !i.composedPath().includes(a); ) {
                if (
                  ((i.currentTarget = a),
                  this.notifyTarget(i, "pointerupoutside"),
                  i.pointerType === "touch")
                )
                  this.notifyTarget(i, "touchendoutside")
                else if (i.pointerType === "mouse" || i.pointerType === "pen") {
                  let u = i.button === 2
                  this.notifyTarget(i, u ? "rightupoutside" : "mouseupoutside")
                }
                a = a.parent
              }
              ;(delete n.pressTargetsByButton[e.button], (o = a))
            }
            if (o) {
              let a = this.clonePointerEvent(i, "click")
              ;((a.target = o),
                (a.path = null),
                n.clicksByButton[e.button] ||
                  (n.clicksByButton[e.button] = { clickCount: 0, target: a.target, timeStamp: t }))
              let u = n.clicksByButton[e.button]
              if (
                (u.target === a.target && t - u.timeStamp < 200
                  ? ++u.clickCount
                  : (u.clickCount = 1),
                (u.target = a.target),
                (u.timeStamp = t),
                (a.detail = u.clickCount),
                a.pointerType === "mouse")
              ) {
                let l = a.button === 2
                this.dispatchEvent(a, l ? "rightclick" : "click")
              } else a.pointerType === "touch" && this.dispatchEvent(a, "tap")
              ;(this.dispatchEvent(a, "pointertap"), this.freeEvent(a))
            }
            this.freeEvent(i)
          }
          mapPointerUpOutside(e) {
            if (!(e instanceof nt)) {
              H("EventBoundary cannot map a non-pointer event as a pointer event")
              return
            }
            let t = this.trackingData(e.pointerId),
              i = this.findMountedTarget(t.pressTargetsByButton[e.button]),
              n = this.createPointerEvent(e)
            if (i) {
              let s = i
              for (; s; )
                ((n.currentTarget = s),
                  this.notifyTarget(n, "pointerupoutside"),
                  n.pointerType === "touch"
                    ? this.notifyTarget(n, "touchendoutside")
                    : (n.pointerType === "mouse" || n.pointerType === "pen") &&
                      this.notifyTarget(n, n.button === 2 ? "rightupoutside" : "mouseupoutside"),
                  (s = s.parent))
              delete t.pressTargetsByButton[e.button]
            }
            this.freeEvent(n)
          }
          mapWheel(e) {
            if (!(e instanceof $t)) {
              H("EventBoundary cannot map a non-wheel event as a wheel event")
              return
            }
            let t = this.createWheelEvent(e)
            ;(this.dispatchEvent(t), this.freeEvent(t))
          }
          findMountedTarget(e) {
            if (!e) return null
            let t = e[0]
            for (let i = 1; i < e.length && e[i].parent === t; i++) t = e[i]
            return t
          }
          createPointerEvent(e, t, i) {
            let n = this.allocateEvent(nt)
            return (
              this.copyPointerData(e, n),
              this.copyMouseData(e, n),
              this.copyData(e, n),
              (n.nativeEvent = e.nativeEvent),
              (n.originalEvent = e),
              (n.target = i ?? this.hitTest(n.global.x, n.global.y) ?? this._hitElements[0]),
              typeof t == "string" && (n.type = t),
              n
            )
          }
          createWheelEvent(e) {
            let t = this.allocateEvent($t)
            return (
              this.copyWheelData(e, t),
              this.copyMouseData(e, t),
              this.copyData(e, t),
              (t.nativeEvent = e.nativeEvent),
              (t.originalEvent = e),
              (t.target = this.hitTest(t.global.x, t.global.y)),
              t
            )
          }
          clonePointerEvent(e, t) {
            let i = this.allocateEvent(nt)
            return (
              (i.nativeEvent = e.nativeEvent),
              (i.originalEvent = e.originalEvent),
              this.copyPointerData(e, i),
              this.copyMouseData(e, i),
              this.copyData(e, i),
              (i.target = e.target),
              (i.path = e.composedPath().slice()),
              (i.type = t ?? i.type),
              i
            )
          }
          copyWheelData(e, t) {
            ;((t.deltaMode = e.deltaMode),
              (t.deltaX = e.deltaX),
              (t.deltaY = e.deltaY),
              (t.deltaZ = e.deltaZ))
          }
          copyPointerData(e, t) {
            e instanceof nt &&
              t instanceof nt &&
              ((t.pointerId = e.pointerId),
              (t.width = e.width),
              (t.height = e.height),
              (t.isPrimary = e.isPrimary),
              (t.pointerType = e.pointerType),
              (t.pressure = e.pressure),
              (t.tangentialPressure = e.tangentialPressure),
              (t.tiltX = e.tiltX),
              (t.tiltY = e.tiltY),
              (t.twist = e.twist))
          }
          copyMouseData(e, t) {
            e instanceof lr &&
              t instanceof lr &&
              ((t.altKey = e.altKey),
              (t.button = e.button),
              (t.buttons = e.buttons),
              t.client.copyFrom(e.client),
              (t.ctrlKey = e.ctrlKey),
              (t.metaKey = e.metaKey),
              t.movement.copyFrom(e.movement),
              t.screen.copyFrom(e.screen),
              (t.shiftKey = e.shiftKey),
              t.global.copyFrom(e.global))
          }
          copyData(e, t) {
            ;((t.isTrusted = e.isTrusted),
              (t.srcElement = e.srcElement),
              (t.timeStamp = performance.now()),
              (t.type = e.type),
              (t.detail = e.detail),
              (t.view = e.view),
              (t.which = e.which),
              t.layer.copyFrom(e.layer),
              t.page.copyFrom(e.page))
          }
          trackingData(e) {
            return (
              this.mappingState.trackingData[e] ||
                (this.mappingState.trackingData[e] = {
                  pressTargetsByButton: {},
                  clicksByButton: {},
                  overTarget: null,
                }),
              this.mappingState.trackingData[e]
            )
          }
          allocateEvent(e) {
            this.eventPool.has(e) || this.eventPool.set(e, [])
            let t = this.eventPool.get(e).pop() || new e(this)
            return (
              (t.eventPhase = t.NONE),
              (t.currentTarget = null),
              (t.defaultPrevented = !1),
              (t.path = null),
              (t.target = null),
              t
            )
          }
          freeEvent(e) {
            if (e.manager !== this)
              throw new Error("It is illegal to free an event not managed by this EventBoundary!")
            let t = e.constructor
            ;(this.eventPool.has(t) || this.eventPool.set(t, []), this.eventPool.get(t).push(e))
          }
          _notifyListeners(e, t) {
            let i = e.currentTarget._events[t]
            if (i)
              if ("fn" in i)
                (i.once && e.currentTarget.removeListener(t, i.fn, void 0, !0),
                  i.fn.call(i.context, e))
              else
                for (let n = 0, s = i.length; n < s && !e.propagationImmediatelyStopped; n++)
                  (i[n].once && e.currentTarget.removeListener(t, i[n].fn, void 0, !0),
                    i[n].fn.call(i[n].context, e))
          }
        }))
    })
  var kD,
    UD,
    ah,
    Ya,
    uh = d(() => {
      D()
      ex()
      ih()
      nh()
      sh()
      ;((kD = 1),
        (UD = {
          touchstart: "pointerdown",
          touchend: "pointerup",
          touchendoutside: "pointerupoutside",
          touchmove: "pointermove",
          touchcancel: "pointercancel",
        }),
        (ah = class oh {
          constructor(e) {
            ;((this.supportsTouchEvents = "ontouchstart" in globalThis),
              (this.supportsPointerEvents = !!globalThis.PointerEvent),
              (this.domElement = null),
              (this.resolution = 1),
              (this.renderer = e),
              (this.rootBoundary = new Xa(null)),
              Vt.init(this),
              (this.autoPreventDefault = !0),
              (this._eventsAdded = !1),
              (this._rootPointerEvent = new nt(null)),
              (this._rootWheelEvent = new $t(null)),
              (this.cursorStyles = { default: "inherit", pointer: "pointer" }),
              (this.features = new Proxy(
                { ...oh.defaultEventFeatures },
                {
                  set: (t, i, n) => (
                    i === "globalMove" && (this.rootBoundary.enableGlobalMoveEvents = n),
                    (t[i] = n),
                    !0
                  ),
                },
              )),
              (this._onPointerDown = this._onPointerDown.bind(this)),
              (this._onPointerMove = this._onPointerMove.bind(this)),
              (this._onPointerUp = this._onPointerUp.bind(this)),
              (this._onPointerOverOut = this._onPointerOverOut.bind(this)),
              (this.onWheel = this.onWheel.bind(this)))
          }
          static get defaultEventMode() {
            return this._defaultEventMode
          }
          init(e) {
            let { canvas: t, resolution: i } = this.renderer
            ;(this.setTargetElement(t),
              (this.resolution = i),
              (oh._defaultEventMode = e.eventMode ?? "passive"),
              Object.assign(this.features, e.eventFeatures ?? {}),
              (this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove))
          }
          resolutionChange(e) {
            this.resolution = e
          }
          destroy() {
            ;(this.setTargetElement(null), (this.renderer = null), (this._currentCursor = null))
          }
          setCursor(e) {
            e || (e = "default")
            let t = !0
            if (
              (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (t = !1),
              this._currentCursor === e)
            )
              return
            this._currentCursor = e
            let i = this.cursorStyles[e]
            if (i)
              switch (typeof i) {
                case "string":
                  t && (this.domElement.style.cursor = i)
                  break
                case "function":
                  i(e)
                  break
                case "object":
                  t && Object.assign(this.domElement.style, i)
                  break
              }
            else
              t &&
                typeof e == "string" &&
                !Object.prototype.hasOwnProperty.call(this.cursorStyles, e) &&
                (this.domElement.style.cursor = e)
          }
          get pointer() {
            return this._rootPointerEvent
          }
          _onPointerDown(e) {
            if (!this.features.click) return
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered
            let t = this._normalizeToPointerData(e)
            this.autoPreventDefault &&
              t[0].isNormalized &&
              (e.cancelable || !("cancelable" in e)) &&
              e.preventDefault()
            for (let i = 0, n = t.length; i < n; i++) {
              let s = t[i],
                o = this._bootstrapEvent(this._rootPointerEvent, s)
              this.rootBoundary.mapEvent(o)
            }
            this.setCursor(this.rootBoundary.cursor)
          }
          _onPointerMove(e) {
            if (!this.features.move) return
            ;((this.rootBoundary.rootTarget = this.renderer.lastObjectRendered), Vt.pointerMoved())
            let t = this._normalizeToPointerData(e)
            for (let i = 0, n = t.length; i < n; i++) {
              let s = this._bootstrapEvent(this._rootPointerEvent, t[i])
              this.rootBoundary.mapEvent(s)
            }
            this.setCursor(this.rootBoundary.cursor)
          }
          _onPointerUp(e) {
            if (!this.features.click) return
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered
            let t = e.target
            e.composedPath && e.composedPath().length > 0 && (t = e.composedPath()[0])
            let i = t !== this.domElement ? "outside" : "",
              n = this._normalizeToPointerData(e)
            for (let s = 0, o = n.length; s < o; s++) {
              let a = this._bootstrapEvent(this._rootPointerEvent, n[s])
              ;((a.type += i), this.rootBoundary.mapEvent(a))
            }
            this.setCursor(this.rootBoundary.cursor)
          }
          _onPointerOverOut(e) {
            if (!this.features.click) return
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered
            let t = this._normalizeToPointerData(e)
            for (let i = 0, n = t.length; i < n; i++) {
              let s = this._bootstrapEvent(this._rootPointerEvent, t[i])
              this.rootBoundary.mapEvent(s)
            }
            this.setCursor(this.rootBoundary.cursor)
          }
          onWheel(e) {
            if (!this.features.wheel) return
            let t = this.normalizeWheelEvent(e)
            ;((this.rootBoundary.rootTarget = this.renderer.lastObjectRendered),
              this.rootBoundary.mapEvent(t))
          }
          setTargetElement(e) {
            ;(this._removeEvents(), (this.domElement = e), (Vt.domElement = e), this._addEvents())
          }
          _addEvents() {
            if (this._eventsAdded || !this.domElement) return
            Vt.addTickerListener()
            let e = this.domElement.style
            ;(e &&
              (globalThis.navigator.msPointerEnabled
                ? ((e.msContentZooming = "none"), (e.msTouchAction = "none"))
                : this.supportsPointerEvents && (e.touchAction = "none")),
              this.supportsPointerEvents
                ? (globalThis.document.addEventListener("pointermove", this._onPointerMove, !0),
                  this.domElement.addEventListener("pointerdown", this._onPointerDown, !0),
                  this.domElement.addEventListener("pointerleave", this._onPointerOverOut, !0),
                  this.domElement.addEventListener("pointerover", this._onPointerOverOut, !0),
                  globalThis.addEventListener("pointerup", this._onPointerUp, !0))
                : (globalThis.document.addEventListener("mousemove", this._onPointerMove, !0),
                  this.domElement.addEventListener("mousedown", this._onPointerDown, !0),
                  this.domElement.addEventListener("mouseout", this._onPointerOverOut, !0),
                  this.domElement.addEventListener("mouseover", this._onPointerOverOut, !0),
                  globalThis.addEventListener("mouseup", this._onPointerUp, !0),
                  this.supportsTouchEvents &&
                    (this.domElement.addEventListener("touchstart", this._onPointerDown, !0),
                    this.domElement.addEventListener("touchend", this._onPointerUp, !0),
                    this.domElement.addEventListener("touchmove", this._onPointerMove, !0))),
              this.domElement.addEventListener("wheel", this.onWheel, { passive: !0, capture: !0 }),
              (this._eventsAdded = !0))
          }
          _removeEvents() {
            if (!this._eventsAdded || !this.domElement) return
            Vt.removeTickerListener()
            let e = this.domElement.style
            ;(e &&
              (globalThis.navigator.msPointerEnabled
                ? ((e.msContentZooming = ""), (e.msTouchAction = ""))
                : this.supportsPointerEvents && (e.touchAction = "")),
              this.supportsPointerEvents
                ? (globalThis.document.removeEventListener("pointermove", this._onPointerMove, !0),
                  this.domElement.removeEventListener("pointerdown", this._onPointerDown, !0),
                  this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, !0),
                  this.domElement.removeEventListener("pointerover", this._onPointerOverOut, !0),
                  globalThis.removeEventListener("pointerup", this._onPointerUp, !0))
                : (globalThis.document.removeEventListener("mousemove", this._onPointerMove, !0),
                  this.domElement.removeEventListener("mousedown", this._onPointerDown, !0),
                  this.domElement.removeEventListener("mouseout", this._onPointerOverOut, !0),
                  this.domElement.removeEventListener("mouseover", this._onPointerOverOut, !0),
                  globalThis.removeEventListener("mouseup", this._onPointerUp, !0),
                  this.supportsTouchEvents &&
                    (this.domElement.removeEventListener("touchstart", this._onPointerDown, !0),
                    this.domElement.removeEventListener("touchend", this._onPointerUp, !0),
                    this.domElement.removeEventListener("touchmove", this._onPointerMove, !0))),
              this.domElement.removeEventListener("wheel", this.onWheel, !0),
              (this.domElement = null),
              (this._eventsAdded = !1))
          }
          mapPositionToPoint(e, t, i) {
            let n = this.domElement.isConnected
                ? this.domElement.getBoundingClientRect()
                : {
                    x: 0,
                    y: 0,
                    width: this.domElement.width,
                    height: this.domElement.height,
                    left: 0,
                    top: 0,
                  },
              s = 1 / this.resolution
            ;((e.x = (t - n.left) * (this.domElement.width / n.width) * s),
              (e.y = (i - n.top) * (this.domElement.height / n.height) * s))
          }
          _normalizeToPointerData(e) {
            let t = []
            if (this.supportsTouchEvents && e instanceof TouchEvent)
              for (let i = 0, n = e.changedTouches.length; i < n; i++) {
                let s = e.changedTouches[i]
                ;(typeof s.button > "u" && (s.button = 0),
                  typeof s.buttons > "u" && (s.buttons = 1),
                  typeof s.isPrimary > "u" &&
                    (s.isPrimary = e.touches.length === 1 && e.type === "touchstart"),
                  typeof s.width > "u" && (s.width = s.radiusX || 1),
                  typeof s.height > "u" && (s.height = s.radiusY || 1),
                  typeof s.tiltX > "u" && (s.tiltX = 0),
                  typeof s.tiltY > "u" && (s.tiltY = 0),
                  typeof s.pointerType > "u" && (s.pointerType = "touch"),
                  typeof s.pointerId > "u" && (s.pointerId = s.identifier || 0),
                  typeof s.pressure > "u" && (s.pressure = s.force || 0.5),
                  typeof s.twist > "u" && (s.twist = 0),
                  typeof s.tangentialPressure > "u" && (s.tangentialPressure = 0),
                  typeof s.layerX > "u" && (s.layerX = s.offsetX = s.clientX),
                  typeof s.layerY > "u" && (s.layerY = s.offsetY = s.clientY),
                  (s.isNormalized = !0),
                  (s.type = e.type),
                  t.push(s))
              }
            else if (
              !globalThis.MouseEvent ||
              (e instanceof MouseEvent &&
                (!this.supportsPointerEvents || !(e instanceof globalThis.PointerEvent)))
            ) {
              let i = e
              ;(typeof i.isPrimary > "u" && (i.isPrimary = !0),
                typeof i.width > "u" && (i.width = 1),
                typeof i.height > "u" && (i.height = 1),
                typeof i.tiltX > "u" && (i.tiltX = 0),
                typeof i.tiltY > "u" && (i.tiltY = 0),
                typeof i.pointerType > "u" && (i.pointerType = "mouse"),
                typeof i.pointerId > "u" && (i.pointerId = kD),
                typeof i.pressure > "u" && (i.pressure = 0.5),
                typeof i.twist > "u" && (i.twist = 0),
                typeof i.tangentialPressure > "u" && (i.tangentialPressure = 0),
                (i.isNormalized = !0),
                t.push(i))
            } else t.push(e)
            return t
          }
          normalizeWheelEvent(e) {
            let t = this._rootWheelEvent
            return (
              this._transferMouseData(t, e),
              (t.deltaX = e.deltaX),
              (t.deltaY = e.deltaY),
              (t.deltaZ = e.deltaZ),
              (t.deltaMode = e.deltaMode),
              this.mapPositionToPoint(t.screen, e.clientX, e.clientY),
              t.global.copyFrom(t.screen),
              t.offset.copyFrom(t.screen),
              (t.nativeEvent = e),
              (t.type = e.type),
              t
            )
          }
          _bootstrapEvent(e, t) {
            return (
              (e.originalEvent = null),
              (e.nativeEvent = t),
              (e.pointerId = t.pointerId),
              (e.width = t.width),
              (e.height = t.height),
              (e.isPrimary = t.isPrimary),
              (e.pointerType = t.pointerType),
              (e.pressure = t.pressure),
              (e.tangentialPressure = t.tangentialPressure),
              (e.tiltX = t.tiltX),
              (e.tiltY = t.tiltY),
              (e.twist = t.twist),
              this._transferMouseData(e, t),
              this.mapPositionToPoint(e.screen, t.clientX, t.clientY),
              e.global.copyFrom(e.screen),
              e.offset.copyFrom(e.screen),
              (e.isTrusted = t.isTrusted),
              e.type === "pointerleave" && (e.type = "pointerout"),
              e.type.startsWith("mouse") && (e.type = e.type.replace("mouse", "pointer")),
              e.type.startsWith("touch") && (e.type = UD[e.type] || e.type),
              e
            )
          }
          _transferMouseData(e, t) {
            ;((e.isTrusted = t.isTrusted),
              (e.srcElement = t.srcElement),
              (e.timeStamp = performance.now()),
              (e.type = t.type),
              (e.altKey = t.altKey),
              (e.button = t.button),
              (e.buttons = t.buttons),
              (e.client.x = t.clientX),
              (e.client.y = t.clientY),
              (e.ctrlKey = t.ctrlKey),
              (e.metaKey = t.metaKey),
              (e.movement.x = t.movementX),
              (e.movement.y = t.movementY),
              (e.page.x = t.pageX),
              (e.page.y = t.pageY),
              (e.relatedTarget = null),
              (e.shiftKey = t.shiftKey))
          }
        }))
      ah.extension = {
        name: "events",
        type: [_.WebGLSystem, _.CanvasSystem, _.WebGPUSystem],
        priority: -1,
      }
      ah.defaultEventFeatures = { move: !0, globalMove: !0, click: !0, wheel: !0 }
      Ya = ah
    })
  var tx,
    rx = d(() => {
      uh()
      Ha()
      tx = {
        onclick: null,
        onmousedown: null,
        onmouseenter: null,
        onmouseleave: null,
        onmousemove: null,
        onglobalmousemove: null,
        onmouseout: null,
        onmouseover: null,
        onmouseup: null,
        onmouseupoutside: null,
        onpointercancel: null,
        onpointerdown: null,
        onpointerenter: null,
        onpointerleave: null,
        onpointermove: null,
        onglobalpointermove: null,
        onpointerout: null,
        onpointerover: null,
        onpointertap: null,
        onpointerup: null,
        onpointerupoutside: null,
        onrightclick: null,
        onrightdown: null,
        onrightup: null,
        onrightupoutside: null,
        ontap: null,
        ontouchcancel: null,
        ontouchend: null,
        ontouchendoutside: null,
        ontouchmove: null,
        onglobaltouchmove: null,
        ontouchstart: null,
        onwheel: null,
        get interactive() {
          return this.eventMode === "dynamic" || this.eventMode === "static"
        },
        set interactive(r) {
          this.eventMode = r ? "static" : "passive"
        },
        _internalEventMode: void 0,
        get eventMode() {
          return this._internalEventMode ?? Ya.defaultEventMode
        },
        set eventMode(r) {
          this._internalEventMode = r
        },
        isInteractive() {
          return this.eventMode === "static" || this.eventMode === "dynamic"
        },
        interactiveChildren: !0,
        hitArea: null,
        addEventListener(r, e, t) {
          let i = (typeof t == "boolean" && t) || (typeof t == "object" && t.capture),
            n = typeof t == "object" ? t.signal : void 0,
            s = typeof t == "object" ? t.once === !0 : !1,
            o = typeof e == "function" ? void 0 : e
          r = i ? `${r}capture` : r
          let a = typeof e == "function" ? e : e.handleEvent,
            u = this
          ;(n &&
            n.addEventListener("abort", () => {
              u.off(r, a, o)
            }),
            s ? u.once(r, a, o) : u.on(r, a, o))
        },
        removeEventListener(r, e, t) {
          let i = (typeof t == "boolean" && t) || (typeof t == "object" && t.capture),
            n = typeof e == "function" ? void 0 : e
          ;((r = i ? `${r}capture` : r),
            (e = typeof e == "function" ? e : e.handleEvent),
            this.off(r, e, n))
        },
        dispatchEvent(r) {
          if (!(r instanceof Cr))
            throw new Error("Container cannot propagate events outside of the Federated Events API")
          return (
            (r.defaultPrevented = !1),
            (r.path = null),
            (r.target = this),
            r.manager.dispatchEvent(r),
            !r.defaultPrevented
          )
        },
      }
    })
  var ix = d(() => {
    D()
    Gt()
    uh()
    rx()
    L.add(Ya)
    L.mixin(xe, tx)
  })
  var ns,
    nx = d(() => {
      D()
      ns = class {
        constructor(e) {
          ;((this._destroyRenderableBound = this.destroyRenderable.bind(this)),
            (this._attachedDomElements = []),
            (this._renderer = e),
            this._renderer.runners.postrender.add(this),
            (this._domElement = document.createElement("div")),
            (this._domElement.style.position = "absolute"),
            (this._domElement.style.top = "0"),
            (this._domElement.style.left = "0"),
            (this._domElement.style.pointerEvents = "none"),
            (this._domElement.style.zIndex = "1000"))
        }
        addRenderable(e, t) {
          this._attachedDomElements.includes(e) ||
            (this._attachedDomElements.push(e), e.on("destroyed", this._destroyRenderableBound))
        }
        updateRenderable(e) {}
        validateRenderable(e) {
          return !0
        }
        destroyRenderable(e) {
          let t = this._attachedDomElements.indexOf(e)
          ;(t !== -1 && this._attachedDomElements.splice(t, 1),
            e.off("destroyed", this._destroyRenderableBound))
        }
        postrender() {
          let e = this._attachedDomElements
          if (e.length === 0) {
            this._domElement.remove()
            return
          }
          let t = this._renderer.view.canvas
          ;(this._domElement.parentNode !== t.parentNode &&
            t.parentNode?.appendChild(this._domElement),
            (this._domElement.style.transform = `translate(${t.offsetLeft}px, ${t.offsetTop}px)`))
          for (let i = 0; i < e.length; i++) {
            let n = e[i],
              s = n.element
            if (!n.parent || n.globalDisplayStatus < 7) (s.remove(), e.splice(i, 1), i--)
            else {
              this._domElement.contains(s) ||
                ((s.style.position = "absolute"),
                (s.style.pointerEvents = "auto"),
                this._domElement.appendChild(s))
              let o = n.worldTransform,
                a = n._anchor,
                u = n.width * a.x,
                l = n.height * a.y
              ;((s.style.transformOrigin = `${u}px ${l}px`),
                (s.style.transform = `matrix(${o.a}, ${o.b}, ${o.c}, ${o.d}, ${o.tx - u}, ${o.ty - l})`),
                (s.style.opacity = n.groupAlpha.toString()))
            }
          }
        }
        destroy() {
          this._renderer.runners.postrender.remove(this)
          for (let e = 0; e < this._attachedDomElements.length; e++) {
            let t = this._attachedDomElements[e]
            ;(t.off("destroyed", this._destroyRenderableBound), t.element.remove())
          }
          ;((this._attachedDomElements.length = 0),
            this._domElement.remove(),
            (this._renderer = null))
        }
      }
      ns.extension = { type: [_.WebGLPipes, _.WebGPUPipes, _.CanvasPipes], name: "dom" }
    })
  var wr,
    Ka = d(() => {
      lt()
      Gt()
      wr = class extends xe {
        constructor(e) {
          ;(super(e),
            (this.canBundle = !0),
            (this.allowChildren = !1),
            (this._roundPixels = 0),
            (this._lastUsed = -1),
            (this._bounds = new de(0, 1, 0, 0)),
            (this._boundsDirty = !0))
        }
        get bounds() {
          return this._boundsDirty
            ? (this.updateBounds(), (this._boundsDirty = !1), this._bounds)
            : this._bounds
        }
        get roundPixels() {
          return !!this._roundPixels
        }
        set roundPixels(e) {
          this._roundPixels = e ? 1 : 0
        }
        containsPoint(e) {
          let t = this.bounds,
            { x: i, y: n } = e
          return i >= t.minX && i <= t.maxX && n >= t.minY && n <= t.maxY
        }
        onViewUpdate() {
          if ((this._didViewChangeTick++, (this._boundsDirty = !0), this.didViewUpdate)) return
          this.didViewUpdate = !0
          let e = this.renderGroup || this.parentRenderGroup
          e && e.onChildViewUpdate(this)
        }
        destroy(e) {
          ;(super.destroy(e), (this._bounds = null))
        }
        collectRenderablesSimple(e, t, i) {
          let { renderPipes: n, renderableGC: s } = t
          ;(n.blendMode.setBlendMode(this, this.groupBlendMode, e),
            n[this.renderPipeId].addRenderable(this, e),
            s.addRenderable(this),
            (this.didViewUpdate = !1))
          let a = this.children,
            u = a.length
          for (let l = 0; l < u; l++) a[l].collectRenderables(e, t, i)
        }
      }
    })
  var sx = d(() => {
    D()
    nx()
    L.add(ns)
  })
  var lh,
    ox = d(() => {
      "use strict"
      lh = ((r) => (
        (r[(r.Low = 0)] = "Low"),
        (r[(r.Normal = 1)] = "Normal"),
        (r[(r.High = 2)] = "High"),
        r
      ))(lh || {})
    })
  var ax,
    ux = d(() => {
      "use strict"
      ax = {
        createCanvas: (r, e) => {
          let t = document.createElement("canvas")
          return ((t.width = r), (t.height = e), t)
        },
        getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
        getWebGLRenderingContext: () => WebGLRenderingContext,
        getNavigator: () => navigator,
        getBaseUrl: () => document.baseURI ?? window.location.href,
        getFontFaceSet: () => document.fonts,
        fetch: (r, e) => fetch(r, e),
        parseXML: (r) => new DOMParser().parseFromString(r, "text/xml"),
      }
    })
  var lx,
    Z,
    Ie = d(() => {
      ux()
      ;((lx = ax),
        (Z = {
          get() {
            return lx
          },
          set(r) {
            lx = r
          },
        }))
    })
  function kt(r) {
    if (typeof r != "string")
      throw new TypeError(`Path must be a string. Received ${JSON.stringify(r)}`)
  }
  function ss(r) {
    return r.split("?")[0].split("#")[0]
  }
  function OD(r) {
    return r.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
  }
  function LD(r, e, t) {
    return r.replace(new RegExp(OD(e), "g"), t)
  }
  function ND(r, e) {
    let t = "",
      i = 0,
      n = -1,
      s = 0,
      o = -1
    for (let a = 0; a <= r.length; ++a) {
      if (a < r.length) o = r.charCodeAt(a)
      else {
        if (o === 47) break
        o = 47
      }
      if (o === 47) {
        if (!(n === a - 1 || s === 1))
          if (n !== a - 1 && s === 2) {
            if (
              t.length < 2 ||
              i !== 2 ||
              t.charCodeAt(t.length - 1) !== 46 ||
              t.charCodeAt(t.length - 2) !== 46
            ) {
              if (t.length > 2) {
                let u = t.lastIndexOf("/")
                if (u !== t.length - 1) {
                  ;(u === -1
                    ? ((t = ""), (i = 0))
                    : ((t = t.slice(0, u)), (i = t.length - 1 - t.lastIndexOf("/"))),
                    (n = a),
                    (s = 0))
                  continue
                }
              } else if (t.length === 2 || t.length === 1) {
                ;((t = ""), (i = 0), (n = a), (s = 0))
                continue
              }
            }
            e && (t.length > 0 ? (t += "/..") : (t = ".."), (i = 2))
          } else
            (t.length > 0 ? (t += `/${r.slice(n + 1, a)}`) : (t = r.slice(n + 1, a)),
              (i = a - n - 1))
        ;((n = a), (s = 0))
      } else o === 46 && s !== -1 ? ++s : (s = -1)
    }
    return t
  }
  var oi,
    ch = d(() => {
      Ie()
      oi = {
        toPosix(r) {
          return LD(r, "\\", "/")
        },
        isUrl(r) {
          return /^https?:/.test(this.toPosix(r))
        },
        isDataUrl(r) {
          return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(
            r,
          )
        },
        isBlobUrl(r) {
          return r.startsWith("blob:")
        },
        hasProtocol(r) {
          return /^[^/:]+:/.test(this.toPosix(r))
        },
        getProtocol(r) {
          ;(kt(r), (r = this.toPosix(r)))
          let e = /^file:\/\/\//.exec(r)
          if (e) return e[0]
          let t = /^[^/:]+:\/{0,2}/.exec(r)
          return t ? t[0] : ""
        },
        toAbsolute(r, e, t) {
          if ((kt(r), this.isDataUrl(r) || this.isBlobUrl(r))) return r
          let i = ss(this.toPosix(e ?? Z.get().getBaseUrl())),
            n = ss(this.toPosix(t ?? this.rootname(i)))
          return (
            (r = this.toPosix(r)),
            r.startsWith("/") ? oi.join(n, r.slice(1)) : this.isAbsolute(r) ? r : this.join(i, r)
          )
        },
        normalize(r) {
          if ((kt(r), r.length === 0)) return "."
          if (this.isDataUrl(r) || this.isBlobUrl(r)) return r
          r = this.toPosix(r)
          let e = "",
            t = r.startsWith("/")
          this.hasProtocol(r) && ((e = this.rootname(r)), (r = r.slice(e.length)))
          let i = r.endsWith("/")
          return ((r = ND(r, !1)), r.length > 0 && i && (r += "/"), t ? `/${r}` : e + r)
        },
        isAbsolute(r) {
          return (kt(r), (r = this.toPosix(r)), this.hasProtocol(r) ? !0 : r.startsWith("/"))
        },
        join(...r) {
          if (r.length === 0) return "."
          let e
          for (let t = 0; t < r.length; ++t) {
            let i = r[t]
            if ((kt(i), i.length > 0))
              if (e === void 0) e = i
              else {
                let n = r[t - 1] ?? ""
                this.joinExtensions.includes(this.extname(n).toLowerCase())
                  ? (e += `/../${i}`)
                  : (e += `/${i}`)
              }
          }
          return e === void 0 ? "." : this.normalize(e)
        },
        dirname(r) {
          if ((kt(r), r.length === 0)) return "."
          r = this.toPosix(r)
          let e = r.charCodeAt(0),
            t = e === 47,
            i = -1,
            n = !0,
            s = this.getProtocol(r),
            o = r
          r = r.slice(s.length)
          for (let a = r.length - 1; a >= 1; --a)
            if (((e = r.charCodeAt(a)), e === 47)) {
              if (!n) {
                i = a
                break
              }
            } else n = !1
          return i === -1
            ? t
              ? "/"
              : this.isUrl(o)
                ? s + r
                : s
            : t && i === 1
              ? "//"
              : s + r.slice(0, i)
        },
        rootname(r) {
          ;(kt(r), (r = this.toPosix(r)))
          let e = ""
          if ((r.startsWith("/") ? (e = "/") : (e = this.getProtocol(r)), this.isUrl(r))) {
            let t = r.indexOf("/", e.length)
            ;(t !== -1 ? (e = r.slice(0, t)) : (e = r), e.endsWith("/") || (e += "/"))
          }
          return e
        },
        basename(r, e) {
          ;(kt(r), e && kt(e), (r = ss(this.toPosix(r))))
          let t = 0,
            i = -1,
            n = !0,
            s
          if (e !== void 0 && e.length > 0 && e.length <= r.length) {
            if (e.length === r.length && e === r) return ""
            let o = e.length - 1,
              a = -1
            for (s = r.length - 1; s >= 0; --s) {
              let u = r.charCodeAt(s)
              if (u === 47) {
                if (!n) {
                  t = s + 1
                  break
                }
              } else
                (a === -1 && ((n = !1), (a = s + 1)),
                  o >= 0 && (u === e.charCodeAt(o) ? --o === -1 && (i = s) : ((o = -1), (i = a))))
            }
            return (t === i ? (i = a) : i === -1 && (i = r.length), r.slice(t, i))
          }
          for (s = r.length - 1; s >= 0; --s)
            if (r.charCodeAt(s) === 47) {
              if (!n) {
                t = s + 1
                break
              }
            } else i === -1 && ((n = !1), (i = s + 1))
          return i === -1 ? "" : r.slice(t, i)
        },
        extname(r) {
          ;(kt(r), (r = ss(this.toPosix(r))))
          let e = -1,
            t = 0,
            i = -1,
            n = !0,
            s = 0
          for (let o = r.length - 1; o >= 0; --o) {
            let a = r.charCodeAt(o)
            if (a === 47) {
              if (!n) {
                t = o + 1
                break
              }
              continue
            }
            ;(i === -1 && ((n = !1), (i = o + 1)),
              a === 46 ? (e === -1 ? (e = o) : s !== 1 && (s = 1)) : e !== -1 && (s = -1))
          }
          return e === -1 || i === -1 || s === 0 || (s === 1 && e === i - 1 && e === t + 1)
            ? ""
            : r.slice(e, i)
        },
        parse(r) {
          kt(r)
          let e = { root: "", dir: "", base: "", ext: "", name: "" }
          if (r.length === 0) return e
          r = ss(this.toPosix(r))
          let t = r.charCodeAt(0),
            i = this.isAbsolute(r),
            n,
            s = ""
          ;((e.root = this.rootname(r)), i || this.hasProtocol(r) ? (n = 1) : (n = 0))
          let o = -1,
            a = 0,
            u = -1,
            l = !0,
            c = r.length - 1,
            h = 0
          for (; c >= n; --c) {
            if (((t = r.charCodeAt(c)), t === 47)) {
              if (!l) {
                a = c + 1
                break
              }
              continue
            }
            ;(u === -1 && ((l = !1), (u = c + 1)),
              t === 46 ? (o === -1 ? (o = c) : h !== 1 && (h = 1)) : o !== -1 && (h = -1))
          }
          return (
            o === -1 || u === -1 || h === 0 || (h === 1 && o === u - 1 && o === a + 1)
              ? u !== -1 &&
                (a === 0 && i
                  ? (e.base = e.name = r.slice(1, u))
                  : (e.base = e.name = r.slice(a, u)))
              : (a === 0 && i
                  ? ((e.name = r.slice(1, o)), (e.base = r.slice(1, u)))
                  : ((e.name = r.slice(a, o)), (e.base = r.slice(a, u))),
                (e.ext = r.slice(o, u))),
            (e.dir = this.dirname(r)),
            s && (e.dir = s + e.dir),
            e
          )
        },
        sep: "/",
        delimiter: ":",
        joinExtensions: [".html"],
      }
    })
  var Mr,
    hh = d(() => {
      "use strict"
      Mr = (r, e, t = !1) => (
        Array.isArray(r) || (r = [r]),
        e ? r.map((i) => (typeof i == "string" || t ? e(i) : i)) : r
      )
    })
  function cx(r, e, t, i, n) {
    let s = e[t]
    for (let o = 0; o < s.length; o++) {
      let a = s[o]
      t < e.length - 1 ? cx(r.replace(i[t], a), e, t + 1, i, n) : n.push(r.replace(i[t], a))
    }
  }
  function hx(r) {
    let e = /\{(.*?)\}/g,
      t = r.match(e),
      i = []
    if (t) {
      let n = []
      ;(t.forEach((s) => {
        let o = s.substring(1, s.length - 1).split(",")
        n.push(o)
      }),
        cx(r, n, 0, t, i))
    } else i.push(r)
    return i
  }
  var dx = d(() => {
    "use strict"
  })
  var dh,
    fx = d(() => {
      "use strict"
      dh = (r) => !Array.isArray(r)
    })
  function HD(r) {
    return r.split(".").pop().split("?").shift().split("#").shift()
  }
  var os,
    px = d(() => {
      be()
      ch()
      hh()
      dx()
      fx()
      os = class {
        constructor() {
          ;((this._defaultBundleIdentifierOptions = {
            connector: "-",
            createBundleAssetId: (e, t) => `${e}${this._bundleIdConnector}${t}`,
            extractAssetIdFromBundle: (e, t) => t.replace(`${e}${this._bundleIdConnector}`, ""),
          }),
            (this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector),
            (this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId),
            (this._extractAssetIdFromBundle =
              this._defaultBundleIdentifierOptions.extractAssetIdFromBundle),
            (this._assetMap = {}),
            (this._preferredOrder = []),
            (this._parsers = []),
            (this._resolverHash = {}),
            (this._bundles = {}))
        }
        setBundleIdentifier(e) {
          if (
            ((this._bundleIdConnector = e.connector ?? this._bundleIdConnector),
            (this._createBundleAssetId = e.createBundleAssetId ?? this._createBundleAssetId),
            (this._extractAssetIdFromBundle =
              e.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle),
            this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !==
              "bar")
          )
            throw new Error("[Resolver] GenerateBundleAssetId are not working correctly")
        }
        prefer(...e) {
          ;(e.forEach((t) => {
            ;(this._preferredOrder.push(t), t.priority || (t.priority = Object.keys(t.params)))
          }),
            (this._resolverHash = {}))
        }
        set basePath(e) {
          this._basePath = e
        }
        get basePath() {
          return this._basePath
        }
        set rootPath(e) {
          this._rootPath = e
        }
        get rootPath() {
          return this._rootPath
        }
        get parsers() {
          return this._parsers
        }
        reset() {
          ;(this.setBundleIdentifier(this._defaultBundleIdentifierOptions),
            (this._assetMap = {}),
            (this._preferredOrder = []),
            (this._resolverHash = {}),
            (this._rootPath = null),
            (this._basePath = null),
            (this._manifest = null),
            (this._bundles = {}),
            (this._defaultSearchParams = null))
        }
        setDefaultSearchParams(e) {
          if (typeof e == "string") this._defaultSearchParams = e
          else {
            let t = e
            this._defaultSearchParams = Object.keys(t)
              .map((i) => `${encodeURIComponent(i)}=${encodeURIComponent(t[i])}`)
              .join("&")
          }
        }
        getAlias(e) {
          let { alias: t, src: i } = e
          return Mr(
            t || i,
            (s) =>
              typeof s == "string"
                ? s
                : Array.isArray(s)
                  ? s.map((o) => o?.src ?? o)
                  : s?.src
                    ? s.src
                    : s,
            !0,
          )
        }
        addManifest(e) {
          ;(this._manifest && H("[Resolver] Manifest already exists, this will be overwritten"),
            (this._manifest = e),
            e.bundles.forEach((t) => {
              this.addBundle(t.name, t.assets)
            }))
        }
        addBundle(e, t) {
          let i = [],
            n = t
          ;(Array.isArray(t) ||
            (n = Object.entries(t).map(([s, o]) =>
              typeof o == "string" || Array.isArray(o) ? { alias: s, src: o } : { alias: s, ...o },
            )),
            n.forEach((s) => {
              let o = s.src,
                a = s.alias,
                u
              if (typeof a == "string") {
                let l = this._createBundleAssetId(e, a)
                ;(i.push(l), (u = [a, l]))
              } else {
                let l = a.map((c) => this._createBundleAssetId(e, c))
                ;(i.push(...l), (u = [...a, ...l]))
              }
              this.add({ ...s, alias: u, src: o })
            }),
            (this._bundles[e] = i))
        }
        add(e) {
          let t = []
          Array.isArray(e) ? t.push(...e) : t.push(e)
          let i
          ;((i = (s) => {
            this.hasKey(s) && H(`[Resolver] already has key: ${s} overwriting`)
          }),
            Mr(t).forEach((s) => {
              let { src: o } = s,
                { data: a, format: u, loadParser: l } = s,
                c = Mr(o).map((p) => (typeof p == "string" ? hx(p) : Array.isArray(p) ? p : [p])),
                h = this.getAlias(s)
              Array.isArray(h) ? h.forEach(i) : i(h)
              let f = []
              ;(c.forEach((p) => {
                p.forEach((m) => {
                  let g = {}
                  if (typeof m != "object") {
                    g.src = m
                    for (let x = 0; x < this._parsers.length; x++) {
                      let y = this._parsers[x]
                      if (y.test(m)) {
                        g = y.parse(m)
                        break
                      }
                    }
                  } else
                    ((a = m.data ?? a),
                      (u = m.format ?? u),
                      (l = m.loadParser ?? l),
                      (g = { ...g, ...m }))
                  if (!h) throw new Error(`[Resolver] alias is undefined for this asset: ${g.src}`)
                  ;((g = this._buildResolvedAsset(g, {
                    aliases: h,
                    data: a,
                    format: u,
                    loadParser: l,
                  })),
                    f.push(g))
                })
              }),
                h.forEach((p) => {
                  this._assetMap[p] = f
                }))
            }))
        }
        resolveBundle(e) {
          let t = dh(e)
          e = Mr(e)
          let i = {}
          return (
            e.forEach((n) => {
              let s = this._bundles[n]
              if (s) {
                let o = this.resolve(s),
                  a = {}
                for (let u in o) {
                  let l = o[u]
                  a[this._extractAssetIdFromBundle(n, u)] = l
                }
                i[n] = a
              }
            }),
            t ? i[e[0]] : i
          )
        }
        resolveUrl(e) {
          let t = this.resolve(e)
          if (typeof e != "string") {
            let i = {}
            for (let n in t) i[n] = t[n].src
            return i
          }
          return t.src
        }
        resolve(e) {
          let t = dh(e)
          e = Mr(e)
          let i = {}
          return (
            e.forEach((n) => {
              if (!this._resolverHash[n])
                if (this._assetMap[n]) {
                  let s = this._assetMap[n],
                    o = this._getPreferredOrder(s)
                  ;(o?.priority.forEach((a) => {
                    o.params[a].forEach((u) => {
                      let l = s.filter((c) => (c[a] ? c[a] === u : !1))
                      l.length && (s = l)
                    })
                  }),
                    (this._resolverHash[n] = s[0]))
                } else this._resolverHash[n] = this._buildResolvedAsset({ alias: [n], src: n }, {})
              i[n] = this._resolverHash[n]
            }),
            t ? i[e[0]] : i
          )
        }
        hasKey(e) {
          return !!this._assetMap[e]
        }
        hasBundle(e) {
          return !!this._bundles[e]
        }
        _getPreferredOrder(e) {
          for (let t = 0; t < e.length; t++) {
            let i = e[t],
              n = this._preferredOrder.find((s) => s.params.format.includes(i.format))
            if (n) return n
          }
          return this._preferredOrder[0]
        }
        _appendDefaultSearchParams(e) {
          if (!this._defaultSearchParams) return e
          let t = /\?/.test(e) ? "&" : "?"
          return `${e}${t}${this._defaultSearchParams}`
        }
        _buildResolvedAsset(e, t) {
          let { aliases: i, data: n, loadParser: s, format: o } = t
          return (
            (this._basePath || this._rootPath) &&
              (e.src = oi.toAbsolute(e.src, this._basePath, this._rootPath)),
            (e.alias = i ?? e.alias ?? [e.src]),
            (e.src = this._appendDefaultSearchParams(e.src)),
            (e.data = { ...(n || {}), ...e.data }),
            (e.loadParser = s ?? e.loadParser),
            (e.format = o ?? e.format ?? HD(e.src)),
            e
          )
        }
      }
      os.RETINA_PREFIX = /@([0-9\.]+)x/
    })
  var fh,
    mx = d(() => {
      "use strict"
      fh = (r, e) => {
        let t = e.split("?")[1]
        return (t && (r += `?${t}`), r)
      }
    })
  var gx,
    ph,
    xx = d(() => {
      Ke()
      ge()
      gx = class as {
        constructor(e, t) {
          ;((this.linkedSheets = []),
            (this._texture = e instanceof I ? e : null),
            (this.textureSource = e.source),
            (this.textures = {}),
            (this.animations = {}),
            (this.data = t))
          let i = parseFloat(t.meta.scale)
          ;(i
            ? ((this.resolution = i), (e.source.resolution = this.resolution))
            : (this.resolution = e.source._resolution),
            (this._frames = this.data.frames),
            (this._frameKeys = Object.keys(this._frames)),
            (this._batchIndex = 0),
            (this._callback = null))
        }
        parse() {
          return new Promise((e) => {
            ;((this._callback = e),
              (this._batchIndex = 0),
              this._frameKeys.length <= as.BATCH_SIZE
                ? (this._processFrames(0), this._processAnimations(), this._parseComplete())
                : this._nextBatch())
          })
        }
        _processFrames(e) {
          let t = e,
            i = as.BATCH_SIZE
          for (; t - e < i && t < this._frameKeys.length; ) {
            let n = this._frameKeys[t],
              s = this._frames[n],
              o = s.frame
            if (o) {
              let a = null,
                u = null,
                l = s.trimmed !== !1 && s.sourceSize ? s.sourceSize : s.frame,
                c = new ee(
                  0,
                  0,
                  Math.floor(l.w) / this.resolution,
                  Math.floor(l.h) / this.resolution,
                )
              ;(s.rotated
                ? (a = new ee(
                    Math.floor(o.x) / this.resolution,
                    Math.floor(o.y) / this.resolution,
                    Math.floor(o.h) / this.resolution,
                    Math.floor(o.w) / this.resolution,
                  ))
                : (a = new ee(
                    Math.floor(o.x) / this.resolution,
                    Math.floor(o.y) / this.resolution,
                    Math.floor(o.w) / this.resolution,
                    Math.floor(o.h) / this.resolution,
                  )),
                s.trimmed !== !1 &&
                  s.spriteSourceSize &&
                  (u = new ee(
                    Math.floor(s.spriteSourceSize.x) / this.resolution,
                    Math.floor(s.spriteSourceSize.y) / this.resolution,
                    Math.floor(o.w) / this.resolution,
                    Math.floor(o.h) / this.resolution,
                  )),
                (this.textures[n] = new I({
                  source: this.textureSource,
                  frame: a,
                  orig: c,
                  trim: u,
                  rotate: s.rotated ? 2 : 0,
                  defaultAnchor: s.anchor,
                  defaultBorders: s.borders,
                  label: n.toString(),
                })))
            }
            t++
          }
        }
        _processAnimations() {
          let e = this.data.animations || {}
          for (let t in e) {
            this.animations[t] = []
            for (let i = 0; i < e[t].length; i++) {
              let n = e[t][i]
              this.animations[t].push(this.textures[n])
            }
          }
        }
        _parseComplete() {
          let e = this._callback
          ;((this._callback = null), (this._batchIndex = 0), e.call(this, this.textures))
        }
        _nextBatch() {
          ;(this._processFrames(this._batchIndex * as.BATCH_SIZE),
            this._batchIndex++,
            setTimeout(() => {
              this._batchIndex * as.BATCH_SIZE < this._frameKeys.length
                ? this._nextBatch()
                : (this._processAnimations(), this._parseComplete())
            }, 0))
        }
        destroy(e = !1) {
          for (let t in this.textures) this.textures[t].destroy()
          ;((this._frames = null),
            (this._frameKeys = null),
            (this.data = null),
            (this.textures = null),
            e && (this._texture?.destroy(), this.textureSource.destroy()),
            (this._texture = null),
            (this.textureSource = null),
            (this.linkedSheets = []))
        }
      }
      gx.BATCH_SIZE = 1e3
      ph = gx
    })
  function _x(r, e, t) {
    let i = {}
    if (
      (r.forEach((n) => {
        i[n] = e
      }),
      Object.keys(e.textures).forEach((n) => {
        i[n] = e.textures[n]
      }),
      !t)
    ) {
      let n = oi.dirname(r[0])
      e.linkedSheets.forEach((s, o) => {
        let a = _x([`${n}/${e.data.meta.related_multi_packs[o]}`], s, !0)
        Object.assign(i, a)
      })
    }
    return i
  }
  var zD,
    yx,
    bx = d(() => {
      ox()
      px()
      mx()
      D()
      ge()
      ch()
      xx()
      zD = [
        "jpg",
        "png",
        "jpeg",
        "avif",
        "webp",
        "basis",
        "etc2",
        "bc7",
        "bc6h",
        "bc5",
        "bc4",
        "bc3",
        "bc2",
        "bc1",
        "eac",
        "astc",
      ]
      yx = {
        extension: _.Asset,
        cache: { test: (r) => r instanceof ph, getCacheableAssets: (r, e) => _x(r, e, !1) },
        resolver: {
          extension: { type: _.ResolveParser, name: "resolveSpritesheet" },
          test: (r) => {
            let t = r.split("?")[0].split("."),
              i = t.pop(),
              n = t.pop()
            return i === "json" && zD.includes(n)
          },
          parse: (r) => {
            let e = r.split(".")
            return {
              resolution: parseFloat(os.RETINA_PREFIX.exec(r)?.[1] ?? "1"),
              format: e[e.length - 2],
              src: r,
            }
          },
        },
        loader: {
          name: "spritesheetLoader",
          extension: { type: _.LoadParser, priority: lh.Normal, name: "spritesheetLoader" },
          async testParse(r, e) {
            return oi.extname(e.src).toLowerCase() === ".json" && !!r.frames
          },
          async parse(r, e, t) {
            let { texture: i, imageFilename: n, textureOptions: s } = e?.data ?? {},
              o = oi.dirname(e.src)
            o && o.lastIndexOf("/") !== o.length - 1 && (o += "/")
            let a
            if (i instanceof I) a = i
            else {
              let c = fh(o + (n ?? r.meta.image), e.src)
              a = (await t.load([{ src: c, data: s }]))[c]
            }
            let u = new ph(a.source, r)
            await u.parse()
            let l = r?.meta?.related_multi_packs
            if (Array.isArray(l)) {
              let c = []
              for (let f of l) {
                if (typeof f != "string") continue
                let p = o + f
                e.data?.ignoreMultiPack ||
                  ((p = fh(p, e.src)),
                  c.push(t.load({ src: p, data: { textureOptions: s, ignoreMultiPack: !0 } })))
              }
              let h = await Promise.all(c)
              ;((u.linkedSheets = h),
                h.forEach((f) => {
                  f.linkedSheets = [u].concat(u.linkedSheets.filter((p) => p !== f))
                }))
            }
            return u
          },
          async unload(r, e, t) {
            ;(await t.unload(r.textureSource._sourceOrigin), r.destroy(!1))
          },
        },
      }
    })
  var ja = d(() => {
    D()
    bx()
    L.add(yx)
  })
  function qa(r, e, t) {
    let { width: i, height: n } = t.orig,
      s = t.trim
    if (s) {
      let o = s.width,
        a = s.height
      ;((r.minX = s.x - e._x * i),
        (r.maxX = r.minX + o),
        (r.minY = s.y - e._y * n),
        (r.maxY = r.minY + a))
    } else
      ((r.minX = -e._x * i), (r.maxX = r.minX + i), (r.minY = -e._y * n), (r.maxY = r.minY + n))
  }
  var mh = d(() => {
    "use strict"
  })
  var ai,
    gh = d(() => {
      Da()
      ge()
      mh()
      Te()
      Ka()
      ai = class r extends wr {
        constructor(e = I.EMPTY) {
          e instanceof I && (e = { texture: e })
          let { texture: t = I.EMPTY, anchor: i, roundPixels: n, width: s, height: o, ...a } = e
          ;(super({ label: "Sprite", ...a }),
            (this.renderPipeId = "sprite"),
            (this.batched = !0),
            (this._visualBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }),
            (this._anchor = new Xe({
              _onUpdate: () => {
                this.onViewUpdate()
              },
            })),
            i ? (this.anchor = i) : t.defaultAnchor && (this.anchor = t.defaultAnchor),
            (this.texture = t),
            (this.allowChildren = !1),
            (this.roundPixels = n ?? !1),
            s !== void 0 && (this.width = s),
            o !== void 0 && (this.height = o))
        }
        static from(e, t = !1) {
          return e instanceof I ? new r(e) : new r(I.from(e, t))
        }
        set texture(e) {
          e || (e = I.EMPTY)
          let t = this._texture
          t !== e &&
            (t && t.dynamic && t.off("update", this.onViewUpdate, this),
            e.dynamic && e.on("update", this.onViewUpdate, this),
            (this._texture = e),
            this._width && this._setWidth(this._width, this._texture.orig.width),
            this._height && this._setHeight(this._height, this._texture.orig.height),
            this.onViewUpdate())
        }
        get texture() {
          return this._texture
        }
        get visualBounds() {
          return (qa(this._visualBounds, this._anchor, this._texture), this._visualBounds)
        }
        get sourceBounds() {
          return (
            z("8.6.1", "Sprite.sourceBounds is deprecated, use visualBounds instead."),
            this.visualBounds
          )
        }
        updateBounds() {
          let e = this._anchor,
            t = this._texture,
            i = this._bounds,
            { width: n, height: s } = t.orig
          ;((i.minX = -e._x * n),
            (i.maxX = i.minX + n),
            (i.minY = -e._y * s),
            (i.maxY = i.minY + s))
        }
        destroy(e = !1) {
          if ((super.destroy(e), typeof e == "boolean" ? e : e?.texture)) {
            let i = typeof e == "boolean" ? e : e?.textureSource
            this._texture.destroy(i)
          }
          ;((this._texture = null),
            (this._visualBounds = null),
            (this._bounds = null),
            (this._anchor = null))
        }
        get anchor() {
          return this._anchor
        }
        set anchor(e) {
          typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e)
        }
        get width() {
          return Math.abs(this.scale.x) * this._texture.orig.width
        }
        set width(e) {
          ;(this._setWidth(e, this._texture.orig.width), (this._width = e))
        }
        get height() {
          return Math.abs(this.scale.y) * this._texture.orig.height
        }
        set height(e) {
          ;(this._setHeight(e, this._texture.orig.height), (this._height = e))
        }
        getSize(e) {
          return (
            e || (e = {}),
            (e.width = Math.abs(this.scale.x) * this._texture.orig.width),
            (e.height = Math.abs(this.scale.y) * this._texture.orig.height),
            e
          )
        }
        setSize(e, t) {
          ;(typeof e == "object" ? ((t = e.height ?? e.width), (e = e.width)) : (t ?? (t = e)),
            e !== void 0 && this._setWidth(e, this._texture.orig.width),
            t !== void 0 && this._setHeight(t, this._texture.orig.height))
        }
      }
    })
  function Za(r, e, t) {
    let i = WD
    ;((r.measurable = !0), Ii(r, t, i), e.addBoundsMask(i), (r.measurable = !1))
  }
  var WD,
    xh = d(() => {
      lt()
      jn()
      WD = new de()
    })
  function Qa(r, e, t) {
    let i = bt.get()
    r.measurable = !0
    let n = Be.get().identity(),
      s = vx(r, t, n)
    ;(ki(r, i, s), (r.measurable = !1), e.addBoundsMask(i), Be.return(n), bt.return(i))
  }
  function vx(r, e, t) {
    return r
      ? (r !== e && (vx(r.parent, e, t), r.updateLocalTransform(), t.append(r.localTransform)), t)
      : (H("Mask bounds, renderable is not inside the root container"), t)
  }
  var _h = d(() => {
    ka()
    Jr()
    be()
  })
  var us,
    Sx = d(() => {
      D()
      gh()
      xh()
      _h()
      us = class {
        constructor(e) {
          ;((this.priority = 0),
            (this.inverse = !1),
            (this.pipe = "alphaMask"),
            e?.mask && this.init(e.mask))
        }
        init(e) {
          ;((this.mask = e),
            (this.renderMaskToTexture = !(e instanceof ai)),
            (this.mask.renderable = this.renderMaskToTexture),
            (this.mask.includeInBuild = !this.renderMaskToTexture),
            (this.mask.measurable = !1))
        }
        reset() {
          ;((this.mask.measurable = !0), (this.mask = null))
        }
        addBounds(e, t) {
          this.inverse || Za(this.mask, e, t)
        }
        addLocalBounds(e, t) {
          Qa(this.mask, e, t)
        }
        containsPoint(e, t) {
          let i = this.mask
          return t(i, e)
        }
        destroy() {
          this.reset()
        }
        static test(e) {
          return e instanceof ai
        }
      }
      us.extension = _.MaskEffect
    })
  var ls,
    Tx = d(() => {
      D()
      ls = class {
        constructor(e) {
          ;((this.priority = 0), (this.pipe = "colorMask"), e?.mask && this.init(e.mask))
        }
        init(e) {
          this.mask = e
        }
        destroy() {}
        static test(e) {
          return typeof e == "number"
        }
      }
      ls.extension = _.MaskEffect
    })
  var cs,
    Cx = d(() => {
      D()
      Gt()
      xh()
      _h()
      cs = class {
        constructor(e) {
          ;((this.priority = 0), (this.pipe = "stencilMask"), e?.mask && this.init(e.mask))
        }
        init(e) {
          ;((this.mask = e), (this.mask.includeInBuild = !1), (this.mask.measurable = !1))
        }
        reset() {
          ;((this.mask.measurable = !0), (this.mask.includeInBuild = !0), (this.mask = null))
        }
        addBounds(e, t) {
          Za(this.mask, e, t)
        }
        addLocalBounds(e, t) {
          Qa(this.mask, e, t)
        }
        containsPoint(e, t) {
          let i = this.mask
          return t(i, e)
        }
        destroy() {
          this.reset()
        }
        static test(e) {
          return e instanceof xe
        }
      }
      cs.extension = _.MaskEffect
    })
  var et,
    zi = d(() => {
      Ie()
      D()
      ct()
      et = class extends ce {
        constructor(e) {
          ;(e.resource || (e.resource = Z.get().createCanvas()),
            e.width || ((e.width = e.resource.width), e.autoDensity || (e.width /= e.resolution)),
            e.height ||
              ((e.height = e.resource.height), e.autoDensity || (e.height /= e.resolution)),
            super(e),
            (this.uploadMethodId = "image"),
            (this.autoDensity = e.autoDensity),
            this.resizeCanvas(),
            (this.transparent = !!e.transparent))
        }
        resizeCanvas() {
          ;(this.autoDensity &&
            "style" in this.resource &&
            ((this.resource.style.width = `${this.width}px`),
            (this.resource.style.height = `${this.height}px`)),
            (this.resource.width !== this.pixelWidth ||
              this.resource.height !== this.pixelHeight) &&
              ((this.resource.width = this.pixelWidth), (this.resource.height = this.pixelHeight)))
        }
        resize(e = this.width, t = this.height, i = this._resolution) {
          let n = super.resize(e, t, i)
          return (n && this.resizeCanvas(), n)
        }
        static test(e) {
          return (
            (globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement) ||
            (globalThis.OffscreenCanvas && e instanceof OffscreenCanvas)
          )
        }
        get context2D() {
          return this._context2D || (this._context2D = this.resource.getContext("2d"))
        }
      }
      et.extension = _.TextureSource
    })
  var Xt,
    Ja = d(() => {
      Ie()
      D()
      be()
      ct()
      Xt = class extends ce {
        constructor(e) {
          if (e.resource && globalThis.HTMLImageElement && e.resource instanceof HTMLImageElement) {
            let t = Z.get().createCanvas(e.resource.width, e.resource.height)
            ;(t.getContext("2d").drawImage(e.resource, 0, 0, e.resource.width, e.resource.height),
              (e.resource = t),
              H(
                "ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.",
              ))
          }
          ;(super(e), (this.uploadMethodId = "image"), (this.autoGarbageCollect = !0))
        }
        static test(e) {
          return (
            (globalThis.HTMLImageElement && e instanceof HTMLImageElement) ||
            (typeof ImageBitmap < "u" && e instanceof ImageBitmap) ||
            (globalThis.VideoFrame && e instanceof VideoFrame)
          )
        }
      }
      Xt.extension = _.TextureSource
    })
  async function Ex() {
    return (
      yh ??
        (yh = (async () => {
          let e = document.createElement("canvas").getContext("webgl")
          if (!e) return "premultiply-alpha-on-upload"
          let t = await new Promise((o) => {
            let a = document.createElement("video")
            ;((a.onloadeddata = () => o(a)),
              (a.onerror = () => o(null)),
              (a.autoplay = !1),
              (a.crossOrigin = "anonymous"),
              (a.preload = "auto"),
              (a.src =
                "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM="),
              a.load())
          })
          if (!t) return "premultiply-alpha-on-upload"
          let i = e.createTexture()
          e.bindTexture(e.TEXTURE_2D, i)
          let n = e.createFramebuffer()
          ;(e.bindFramebuffer(e.FRAMEBUFFER, n),
            e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, i, 0),
            e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
            e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE),
            e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t))
          let s = new Uint8Array(4)
          return (
            e.readPixels(0, 0, 1, 1, e.RGBA, e.UNSIGNED_BYTE, s),
            e.deleteFramebuffer(n),
            e.deleteTexture(i),
            e.getExtension("WEBGL_lose_context")?.loseContext(),
            s[0] <= s[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload"
          )
        })()),
      yh
    )
  }
  var yh,
    wx = d(() => {
      "use strict"
    })
  var eu,
    Ax,
    Dx = d(() => {
      D()
      ts()
      wx()
      ct()
      eu = class Mx extends ce {
        constructor(e) {
          ;(super(e),
            (this.isReady = !1),
            (this.uploadMethodId = "video"),
            (e = { ...Mx.defaultOptions, ...e }),
            (this._autoUpdate = !0),
            (this._isConnectedToTicker = !1),
            (this._updateFPS = e.updateFPS || 0),
            (this._msToNextUpdate = 0),
            (this.autoPlay = e.autoPlay !== !1),
            (this.alphaMode = e.alphaMode ?? "premultiply-alpha-on-upload"),
            (this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this)),
            (this._videoFrameRequestCallbackHandle = null),
            (this._load = null),
            (this._resolve = null),
            (this._reject = null),
            (this._onCanPlay = this._onCanPlay.bind(this)),
            (this._onCanPlayThrough = this._onCanPlayThrough.bind(this)),
            (this._onError = this._onError.bind(this)),
            (this._onPlayStart = this._onPlayStart.bind(this)),
            (this._onPlayStop = this._onPlayStop.bind(this)),
            (this._onSeeked = this._onSeeked.bind(this)),
            e.autoLoad !== !1 && this.load())
        }
        updateFrame() {
          if (!this.destroyed) {
            if (this._updateFPS) {
              let e = ht.shared.elapsedMS * this.resource.playbackRate
              this._msToNextUpdate = Math.floor(this._msToNextUpdate - e)
            }
            ;((!this._updateFPS || this._msToNextUpdate <= 0) &&
              (this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0),
              this.isValid && this.update())
          }
        }
        _videoFrameRequestCallback() {
          ;(this.updateFrame(),
            this.destroyed
              ? (this._videoFrameRequestCallbackHandle = null)
              : (this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
                  this._videoFrameRequestCallback,
                )))
        }
        get isValid() {
          return !!this.resource.videoWidth && !!this.resource.videoHeight
        }
        async load() {
          if (this._load) return this._load
          let e = this.resource,
            t = this.options
          return (
            (e.readyState === e.HAVE_ENOUGH_DATA || e.readyState === e.HAVE_FUTURE_DATA) &&
              e.width &&
              e.height &&
              (e.complete = !0),
            e.addEventListener("play", this._onPlayStart),
            e.addEventListener("pause", this._onPlayStop),
            e.addEventListener("seeked", this._onSeeked),
            this._isSourceReady()
              ? this._mediaReady()
              : (t.preload || e.addEventListener("canplay", this._onCanPlay),
                e.addEventListener("canplaythrough", this._onCanPlayThrough),
                e.addEventListener("error", this._onError, !0)),
            (this.alphaMode = await Ex()),
            (this._load = new Promise((i, n) => {
              this.isValid
                ? i(this)
                : ((this._resolve = i),
                  (this._reject = n),
                  t.preloadTimeoutMs !== void 0 &&
                    (this._preloadTimeout = setTimeout(() => {
                      this._onError(
                        new ErrorEvent(`Preload exceeded timeout of ${t.preloadTimeoutMs}ms`),
                      )
                    })),
                  e.load())
            })),
            this._load
          )
        }
        _onError(e) {
          ;(this.resource.removeEventListener("error", this._onError, !0),
            this.emit("error", e),
            this._reject && (this._reject(e), (this._reject = null), (this._resolve = null)))
        }
        _isSourcePlaying() {
          let e = this.resource
          return !e.paused && !e.ended
        }
        _isSourceReady() {
          return this.resource.readyState > 2
        }
        _onPlayStart() {
          ;(this.isValid || this._mediaReady(), this._configureAutoUpdate())
        }
        _onPlayStop() {
          this._configureAutoUpdate()
        }
        _onSeeked() {
          this._autoUpdate &&
            !this._isSourcePlaying() &&
            ((this._msToNextUpdate = 0), this.updateFrame(), (this._msToNextUpdate = 0))
        }
        _onCanPlay() {
          ;(this.resource.removeEventListener("canplay", this._onCanPlay), this._mediaReady())
        }
        _onCanPlayThrough() {
          ;(this.resource.removeEventListener("canplaythrough", this._onCanPlay),
            this._preloadTimeout &&
              (clearTimeout(this._preloadTimeout), (this._preloadTimeout = void 0)),
            this._mediaReady())
        }
        _mediaReady() {
          let e = this.resource
          ;(this.isValid && ((this.isReady = !0), this.resize(e.videoWidth, e.videoHeight)),
            (this._msToNextUpdate = 0),
            this.updateFrame(),
            (this._msToNextUpdate = 0),
            this._resolve && (this._resolve(this), (this._resolve = null), (this._reject = null)),
            this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && this.resource.play())
        }
        destroy() {
          this._configureAutoUpdate()
          let e = this.resource
          ;(e &&
            (e.removeEventListener("play", this._onPlayStart),
            e.removeEventListener("pause", this._onPlayStop),
            e.removeEventListener("seeked", this._onSeeked),
            e.removeEventListener("canplay", this._onCanPlay),
            e.removeEventListener("canplaythrough", this._onCanPlayThrough),
            e.removeEventListener("error", this._onError, !0),
            e.pause(),
            (e.src = ""),
            e.load()),
            super.destroy())
        }
        get autoUpdate() {
          return this._autoUpdate
        }
        set autoUpdate(e) {
          e !== this._autoUpdate && ((this._autoUpdate = e), this._configureAutoUpdate())
        }
        get updateFPS() {
          return this._updateFPS
        }
        set updateFPS(e) {
          e !== this._updateFPS && ((this._updateFPS = e), this._configureAutoUpdate())
        }
        _configureAutoUpdate() {
          this._autoUpdate && this._isSourcePlaying()
            ? !this._updateFPS && this.resource.requestVideoFrameCallback
              ? (this._isConnectedToTicker &&
                  (ht.shared.remove(this.updateFrame, this),
                  (this._isConnectedToTicker = !1),
                  (this._msToNextUpdate = 0)),
                this._videoFrameRequestCallbackHandle === null &&
                  (this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
                    this._videoFrameRequestCallback,
                  )))
              : (this._videoFrameRequestCallbackHandle !== null &&
                  (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle),
                  (this._videoFrameRequestCallbackHandle = null)),
                this._isConnectedToTicker ||
                  (ht.shared.add(this.updateFrame, this),
                  (this._isConnectedToTicker = !0),
                  (this._msToNextUpdate = 0)))
            : (this._videoFrameRequestCallbackHandle !== null &&
                (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle),
                (this._videoFrameRequestCallbackHandle = null)),
              this._isConnectedToTicker &&
                (ht.shared.remove(this.updateFrame, this),
                (this._isConnectedToTicker = !1),
                (this._msToNextUpdate = 0)))
        }
        static test(e) {
          return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement
        }
      }
      eu.extension = _.TextureSource
      eu.defaultOptions = {
        ...ce.defaultOptions,
        autoLoad: !0,
        autoPlay: !0,
        updateFPS: 0,
        crossorigin: !0,
        loop: !1,
        muted: !0,
        playsinline: !0,
        preload: !1,
      }
      eu.MIME_TYPES = { ogv: "video/ogg", mov: "video/quicktime", m4v: "video/mp4" }
      Ax = eu
    })
  var bh,
    Ge,
    hs = d(() => {
      be()
      hh()
      ;((bh = class {
        constructor() {
          ;((this._parsers = []), (this._cache = new Map()), (this._cacheMap = new Map()))
        }
        reset() {
          ;(this._cacheMap.clear(), this._cache.clear())
        }
        has(e) {
          return this._cache.has(e)
        }
        get(e) {
          let t = this._cache.get(e)
          return (t || H(`[Assets] Asset id ${e} was not found in the Cache`), t)
        }
        set(e, t) {
          let i = Mr(e),
            n
          for (let u = 0; u < this.parsers.length; u++) {
            let l = this.parsers[u]
            if (l.test(t)) {
              n = l.getCacheableAssets(i, t)
              break
            }
          }
          let s = new Map(Object.entries(n || {}))
          n ||
            i.forEach((u) => {
              s.set(u, t)
            })
          let o = [...s.keys()],
            a = { cacheKeys: o, keys: i }
          ;(i.forEach((u) => {
            this._cacheMap.set(u, a)
          }),
            o.forEach((u) => {
              let l = n ? n[u] : t
              ;(this._cache.has(u) && this._cache.get(u) !== l && H("[Cache] already has key:", u),
                this._cache.set(u, s.get(u)))
            }))
        }
        remove(e) {
          if (!this._cacheMap.has(e)) {
            H(`[Assets] Asset id ${e} was not found in the Cache`)
            return
          }
          let t = this._cacheMap.get(e)
          ;(t.cacheKeys.forEach((n) => {
            this._cache.delete(n)
          }),
            t.keys.forEach((n) => {
              this._cacheMap.delete(n)
            }))
        }
        get parsers() {
          return this._parsers
        }
      }),
        (Ge = new bh()))
    })
  function Px(r = {}) {
    let e = r && r.resource,
      t = e ? r.resource : r,
      i = e ? r : { resource: r }
    for (let n = 0; n < vh.length; n++) {
      let s = vh[n]
      if (s.test(t)) return new s(i)
    }
    throw new Error(`Could not find a source type for resource: ${i.resource}`)
  }
  function Rx(r = {}, e = !1) {
    let t = r && r.resource,
      i = t ? r.resource : r,
      n = t ? r : { resource: r }
    if (!e && Ge.has(i)) return Ge.get(i)
    let s = new I({ source: Px(n) })
    return (
      s.on("destroy", () => {
        Ge.has(i) && Ge.remove(i)
      }),
      e || Ge.set(i, s),
      s
    )
  }
  function Fx(r, e = !1) {
    return typeof r == "string" ? Ge.get(r) : r instanceof ce ? new I({ source: r }) : Rx(r, e)
  }
  var vh,
    Sh = d(() => {
      hs()
      D()
      ct()
      ge()
      vh = []
      L.handleByList(_.TextureSource, vh)
      I.from = Fx
      ce.from = Px
    })
  var tu = d(() => {
    D()
    Sx()
    Tx()
    Cx()
    $c()
    zi()
    Ja()
    Dx()
    Sh()
    L.add(us, ls, cs, Ax, Xt, et, ni)
  })
  var He,
    Ar = d(() => {
      "use strict"
      He = class {
        constructor(e) {
          ;((this.resources = Object.create(null)), (this._dirty = !0))
          let t = 0
          for (let i in e) {
            let n = e[i]
            this.setResource(n, t++)
          }
          this._updateKey()
        }
        _updateKey() {
          if (!this._dirty) return
          this._dirty = !1
          let e = [],
            t = 0
          for (let i in this.resources) e[t++] = this.resources[i]._resourceId
          this._key = e.join("|")
        }
        setResource(e, t) {
          let i = this.resources[t]
          e !== i &&
            (i && e.off?.("change", this.onResourceChange, this),
            e.on?.("change", this.onResourceChange, this),
            (this.resources[t] = e),
            (this._dirty = !0))
        }
        getResource(e) {
          return this.resources[e]
        }
        _touch(e) {
          let t = this.resources
          for (let i in t) t[i]._touched = e
        }
        destroy() {
          let e = this.resources
          for (let t in e) e[t].off?.("change", this.onResourceChange, this)
          this.resources = null
        }
        onResourceChange(e) {
          if (((this._dirty = !0), e.destroyed)) {
            let t = this.resources
            for (let i in t) t[i] === e && (t[i] = null)
          } else this._updateKey()
        }
      }
    })
  function iu() {
    return (
      (!ru || ru?.isContextLost()) && (ru = Z.get().createCanvas().getContext("webgl", {})),
      ru
    )
  }
  var ru,
    Th = d(() => {
      Ie()
    })
  function $D(r) {
    let e = ""
    for (let t = 0; t < r; ++t)
      (t > 0 &&
        (e += `
else `),
        t < r - 1 && (e += `if(test == ${t}.0){}`))
    return e
  }
  function Bx(r, e) {
    if (r === 0) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`")
    let t = e.createShader(e.FRAGMENT_SHADER)
    try {
      for (;;) {
        let i = VD.replace(/%forloop%/gi, $D(r))
        if ((e.shaderSource(t, i), e.compileShader(t), !e.getShaderParameter(t, e.COMPILE_STATUS)))
          r = (r / 2) | 0
        else break
      }
    } finally {
      e.deleteShader(t)
    }
    return r
  }
  var VD,
    Ix = d(() => {
      "use strict"
      VD = [
        "precision mediump float;",
        "void main(void){",
        "float test = 0.1;",
        "%forloop%",
        "gl_FragColor = vec4(0.0);",
        "}",
      ].join(`
`)
    })
  function wt() {
    if (Wi) return Wi
    let r = iu()
    return (
      (Wi = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS)),
      (Wi = Bx(Wi, r)),
      r.getExtension("WEBGL_lose_context")?.loseContext(),
      Wi
    )
  }
  var Wi,
    ui = d(() => {
      Th()
      Ix()
      Wi = null
    })
  function Vi(r, e) {
    let t = 2166136261
    for (let i = 0; i < e; i++) ((t ^= r[i].uid), (t = Math.imul(t, 16777619)), (t >>>= 0))
    return Gx[t] || XD(r, e, t)
  }
  function XD(r, e, t) {
    let i = {},
      n = 0
    Ch || (Ch = wt())
    for (let o = 0; o < Ch; o++) {
      let a = o < e ? r[o] : I.EMPTY.source
      ;((i[n++] = a.source), (i[n++] = a.style))
    }
    let s = new He(i)
    return ((Gx[t] = s), s)
  }
  var Gx,
    Ch,
    nu = d(() => {
      Ar()
      ge()
      ui()
      Gx = {}
      Ch = 0
    })
  var Yt,
    Eh = d(() => {
      "use strict"
      Yt = class {
        constructor(e) {
          ;(typeof e == "number"
            ? (this.rawBinaryData = new ArrayBuffer(e))
            : e instanceof Uint8Array
              ? (this.rawBinaryData = e.buffer)
              : (this.rawBinaryData = e),
            (this.uint32View = new Uint32Array(this.rawBinaryData)),
            (this.float32View = new Float32Array(this.rawBinaryData)),
            (this.size = this.rawBinaryData.byteLength))
        }
        get int8View() {
          return (
            this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)),
            this._int8View
          )
        }
        get uint8View() {
          return (
            this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)),
            this._uint8View
          )
        }
        get int16View() {
          return (
            this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)),
            this._int16View
          )
        }
        get int32View() {
          return (
            this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)),
            this._int32View
          )
        }
        get float64View() {
          return (
            this._float64Array || (this._float64Array = new Float64Array(this.rawBinaryData)),
            this._float64Array
          )
        }
        get bigUint64View() {
          return (
            this._bigUint64Array || (this._bigUint64Array = new BigUint64Array(this.rawBinaryData)),
            this._bigUint64Array
          )
        }
        view(e) {
          return this[`${e}View`]
        }
        destroy() {
          ;((this.rawBinaryData = null),
            (this._int8View = null),
            (this._uint8View = null),
            (this._int16View = null),
            (this.uint16View = null),
            (this._int32View = null),
            (this.uint32View = null),
            (this.float32View = null))
        }
        static sizeOf(e) {
          switch (e) {
            case "int8":
            case "uint8":
              return 1
            case "int16":
            case "uint16":
              return 2
            case "int32":
            case "uint32":
            case "float32":
              return 4
            default:
              throw new Error(`${e} isn't a valid view type`)
          }
        }
      }
    })
  function ds(r, e) {
    let t = (r.byteLength / 8) | 0,
      i = new Float64Array(r, 0, t)
    new Float64Array(e, 0, t).set(i)
    let s = r.byteLength - t * 8
    if (s > 0) {
      let o = new Uint8Array(r, t * 8, s)
      new Uint8Array(e, t * 8, s).set(o)
    }
  }
  var wh = d(() => {
    "use strict"
  })
  var kx,
    ye,
    li = d(() => {
      "use strict"
      ;((kx = { normal: "normal-npm", add: "add-npm", screen: "screen-npm" }),
        (ye = ((r) => (
          (r[(r.DISABLED = 0)] = "DISABLED"),
          (r[(r.RENDERING_MASK_ADD = 1)] = "RENDERING_MASK_ADD"),
          (r[(r.MASK_ACTIVE = 2)] = "MASK_ACTIVE"),
          (r[(r.INVERSE_MASK_ACTIVE = 3)] = "INVERSE_MASK_ACTIVE"),
          (r[(r.RENDERING_MASK_REMOVE = 4)] = "RENDERING_MASK_REMOVE"),
          (r[(r.NONE = 5)] = "NONE"),
          r
        ))(ye || {})))
    })
  function cr(r, e) {
    return (e.alphaMode === "no-premultiply-alpha" && kx[r]) || r
  }
  var fs = d(() => {
    li()
  })
  var su,
    Ux = d(() => {
      "use strict"
      su = class {
        constructor() {
          ;((this.ids = Object.create(null)), (this.textures = []), (this.count = 0))
        }
        clear() {
          for (let e = 0; e < this.count; e++) {
            let t = this.textures[e]
            ;((this.textures[e] = null), (this.ids[t.uid] = null))
          }
          this.count = 0
        }
      }
    })
  function Ox() {
    return Ah > 0 ? Nx[--Ah] : new Mh()
  }
  function Lx(r) {
    Nx[Ah++] = r
  }
  var Mh,
    Nx,
    Ah,
    ps,
    Hx,
    zx,
    Wx = d(() => {
      Ye()
      Eh()
      wh()
      fs()
      ui()
      Ux()
      ;((Mh = class {
        constructor() {
          ;((this.renderPipeId = "batch"),
            (this.action = "startBatch"),
            (this.start = 0),
            (this.size = 0),
            (this.textures = new su()),
            (this.blendMode = "normal"),
            (this.topology = "triangle-strip"),
            (this.canBundle = !0))
        }
        destroy() {
          ;((this.textures = null),
            (this.gpuBindGroup = null),
            (this.bindGroup = null),
            (this.batcher = null))
        }
      }),
        (Nx = []),
        (Ah = 0))
      ;((ps = 0),
        (Hx = class ou {
          constructor(e = {}) {
            ;((this.uid = te("batcher")),
              (this.dirty = !0),
              (this.batchIndex = 0),
              (this.batches = []),
              (this._elements = []),
              (ou.defaultOptions.maxTextures = ou.defaultOptions.maxTextures ?? wt()),
              (e = { ...ou.defaultOptions, ...e }))
            let { maxTextures: t, attributesInitialSize: i, indicesInitialSize: n } = e
            ;((this.attributeBuffer = new Yt(i * 4)),
              (this.indexBuffer = new Uint16Array(n)),
              (this.maxTextures = t))
          }
          begin() {
            ;((this.elementSize = 0),
              (this.elementStart = 0),
              (this.indexSize = 0),
              (this.attributeSize = 0))
            for (let e = 0; e < this.batchIndex; e++) Lx(this.batches[e])
            ;((this.batchIndex = 0),
              (this._batchIndexStart = 0),
              (this._batchIndexSize = 0),
              (this.dirty = !0))
          }
          add(e) {
            ;((this._elements[this.elementSize++] = e),
              (e._indexStart = this.indexSize),
              (e._attributeStart = this.attributeSize),
              (e._batcher = this),
              (this.indexSize += e.indexSize),
              (this.attributeSize += e.attributeSize * this.vertexSize))
          }
          checkAndUpdateTexture(e, t) {
            let i = e._batch.textures.ids[t._source.uid]
            return !i && i !== 0 ? !1 : ((e._textureId = i), (e.texture = t), !0)
          }
          updateElement(e) {
            this.dirty = !0
            let t = this.attributeBuffer
            e.packAsQuad
              ? this.packQuadAttributes(
                  e,
                  t.float32View,
                  t.uint32View,
                  e._attributeStart,
                  e._textureId,
                )
              : this.packAttributes(e, t.float32View, t.uint32View, e._attributeStart, e._textureId)
          }
          break(e) {
            let t = this._elements
            if (!t[this.elementStart]) return
            let i = Ox(),
              n = i.textures
            n.clear()
            let s = t[this.elementStart],
              o = cr(s.blendMode, s.texture._source),
              a = s.topology
            ;(this.attributeSize * 4 > this.attributeBuffer.size &&
              this._resizeAttributeBuffer(this.attributeSize * 4),
              this.indexSize > this.indexBuffer.length && this._resizeIndexBuffer(this.indexSize))
            let u = this.attributeBuffer.float32View,
              l = this.attributeBuffer.uint32View,
              c = this.indexBuffer,
              h = this._batchIndexSize,
              f = this._batchIndexStart,
              p = "startBatch",
              m = this.maxTextures
            for (let g = this.elementStart; g < this.elementSize; ++g) {
              let x = t[g]
              t[g] = null
              let v = x.texture._source,
                S = cr(x.blendMode, v),
                b = o !== S || a !== x.topology
              if (v._batchTick === ps && !b) {
                ;((x._textureId = v._textureBindLocation),
                  (h += x.indexSize),
                  x.packAsQuad
                    ? (this.packQuadAttributes(x, u, l, x._attributeStart, x._textureId),
                      this.packQuadIndex(c, x._indexStart, x._attributeStart / this.vertexSize))
                    : (this.packAttributes(x, u, l, x._attributeStart, x._textureId),
                      this.packIndex(x, c, x._indexStart, x._attributeStart / this.vertexSize)),
                  (x._batch = i))
                continue
              }
              ;((v._batchTick = ps),
                (n.count >= m || b) &&
                  (this._finishBatch(i, f, h - f, n, o, a, e, p),
                  (p = "renderBatch"),
                  (f = h),
                  (o = S),
                  (a = x.topology),
                  (i = Ox()),
                  (n = i.textures),
                  n.clear(),
                  ++ps),
                (x._textureId = v._textureBindLocation = n.count),
                (n.ids[v.uid] = n.count),
                (n.textures[n.count++] = v),
                (x._batch = i),
                (h += x.indexSize),
                x.packAsQuad
                  ? (this.packQuadAttributes(x, u, l, x._attributeStart, x._textureId),
                    this.packQuadIndex(c, x._indexStart, x._attributeStart / this.vertexSize))
                  : (this.packAttributes(x, u, l, x._attributeStart, x._textureId),
                    this.packIndex(x, c, x._indexStart, x._attributeStart / this.vertexSize)))
            }
            ;(n.count > 0 && (this._finishBatch(i, f, h - f, n, o, a, e, p), (f = h), ++ps),
              (this.elementStart = this.elementSize),
              (this._batchIndexStart = f),
              (this._batchIndexSize = h))
          }
          _finishBatch(e, t, i, n, s, o, a, u) {
            ;((e.gpuBindGroup = null),
              (e.bindGroup = null),
              (e.action = u),
              (e.batcher = this),
              (e.textures = n),
              (e.blendMode = s),
              (e.topology = o),
              (e.start = t),
              (e.size = i),
              ++ps,
              (this.batches[this.batchIndex++] = e),
              a.add(e))
          }
          finish(e) {
            this.break(e)
          }
          ensureAttributeBuffer(e) {
            e * 4 <= this.attributeBuffer.size || this._resizeAttributeBuffer(e * 4)
          }
          ensureIndexBuffer(e) {
            e <= this.indexBuffer.length || this._resizeIndexBuffer(e)
          }
          _resizeAttributeBuffer(e) {
            let t = Math.max(e, this.attributeBuffer.size * 2),
              i = new Yt(t)
            ;(ds(this.attributeBuffer.rawBinaryData, i.rawBinaryData), (this.attributeBuffer = i))
          }
          _resizeIndexBuffer(e) {
            let t = this.indexBuffer,
              i = Math.max(e, t.length * 1.5)
            i += i % 2
            let n = i > 65535 ? new Uint32Array(i) : new Uint16Array(i)
            if (n.BYTES_PER_ELEMENT !== t.BYTES_PER_ELEMENT)
              for (let s = 0; s < t.length; s++) n[s] = t[s]
            else ds(t.buffer, n.buffer)
            this.indexBuffer = n
          }
          packQuadIndex(e, t, i) {
            ;((e[t] = i + 0),
              (e[t + 1] = i + 1),
              (e[t + 2] = i + 2),
              (e[t + 3] = i + 0),
              (e[t + 4] = i + 2),
              (e[t + 5] = i + 3))
          }
          packIndex(e, t, i, n) {
            let s = e.indices,
              o = e.indexSize,
              a = e.indexOffset,
              u = e.attributeOffset
            for (let l = 0; l < o; l++) t[i++] = n + s[l + a] - u
          }
          destroy() {
            for (let e = 0; e < this.batches.length; e++) Lx(this.batches[e])
            this.batches = null
            for (let e = 0; e < this._elements.length; e++) this._elements[e]._batch = null
            ;((this._elements = null),
              (this.indexBuffer = null),
              this.attributeBuffer.destroy(),
              (this.attributeBuffer = null))
          }
        }))
      Hx.defaultOptions = { maxTextures: null, attributesInitialSize: 4, indicesInitialSize: 6 }
      zx = Hx
    })
  var Q,
    hr = d(() => {
      "use strict"
      Q = ((r) => (
        (r[(r.MAP_READ = 1)] = "MAP_READ"),
        (r[(r.MAP_WRITE = 2)] = "MAP_WRITE"),
        (r[(r.COPY_SRC = 4)] = "COPY_SRC"),
        (r[(r.COPY_DST = 8)] = "COPY_DST"),
        (r[(r.INDEX = 16)] = "INDEX"),
        (r[(r.VERTEX = 32)] = "VERTEX"),
        (r[(r.UNIFORM = 64)] = "UNIFORM"),
        (r[(r.STORAGE = 128)] = "STORAGE"),
        (r[(r.INDIRECT = 256)] = "INDIRECT"),
        (r[(r.QUERY_RESOLVE = 512)] = "QUERY_RESOLVE"),
        (r[(r.STATIC = 1024)] = "STATIC"),
        r
      ))(Q || {})
    })
  var Ae,
    Dr = d(() => {
      Je()
      Ye()
      hr()
      Ae = class extends pe {
        constructor(e) {
          let { data: t, size: i } = e,
            { usage: n, label: s, shrinkToFit: o } = e
          ;(super(),
            (this.uid = te("buffer")),
            (this._resourceType = "buffer"),
            (this._resourceId = te("resource")),
            (this._touched = 0),
            (this._updateID = 1),
            (this._dataInt32 = null),
            (this.shrinkToFit = !0),
            (this.destroyed = !1),
            t instanceof Array && (t = new Float32Array(t)),
            (this._data = t),
            i ?? (i = t?.byteLength))
          let a = !!t
          ;((this.descriptor = { size: i, usage: n, mappedAtCreation: a, label: s }),
            (this.shrinkToFit = o ?? !0))
        }
        get data() {
          return this._data
        }
        set data(e) {
          this.setDataWithSize(e, e.length, !0)
        }
        get dataInt32() {
          return (
            this._dataInt32 || (this._dataInt32 = new Int32Array(this.data.buffer)),
            this._dataInt32
          )
        }
        get static() {
          return !!(this.descriptor.usage & Q.STATIC)
        }
        set static(e) {
          e ? (this.descriptor.usage |= Q.STATIC) : (this.descriptor.usage &= ~Q.STATIC)
        }
        setDataWithSize(e, t, i) {
          if ((this._updateID++, (this._updateSize = t * e.BYTES_PER_ELEMENT), this._data === e)) {
            i && this.emit("update", this)
            return
          }
          let n = this._data
          if (((this._data = e), (this._dataInt32 = null), !n || n.length !== e.length)) {
            !this.shrinkToFit && n && e.byteLength < n.byteLength
              ? i && this.emit("update", this)
              : ((this.descriptor.size = e.byteLength),
                (this._resourceId = te("resource")),
                this.emit("change", this))
            return
          }
          i && this.emit("update", this)
        }
        update(e) {
          ;((this._updateSize = e ?? this._updateSize), this._updateID++, this.emit("update", this))
        }
        destroy() {
          ;((this.destroyed = !0),
            this.emit("destroy", this),
            this.emit("change", this),
            (this._data = null),
            (this.descriptor = null),
            this.removeAllListeners())
        }
      }
    })
  function Dh(r, e) {
    if (!(r instanceof Ae)) {
      let t = e ? Q.INDEX : Q.VERTEX
      ;(r instanceof Array &&
        (e
          ? ((r = new Uint32Array(r)), (t = Q.INDEX | Q.COPY_DST))
          : ((r = new Float32Array(r)), (t = Q.VERTEX | Q.COPY_DST))),
        (r = new Ae({ data: r, label: e ? "index-mesh-buffer" : "vertex-mesh-buffer", usage: t })))
    }
    return r
  }
  var Vx = d(() => {
    Dr()
    hr()
  })
  function $x(r, e, t) {
    let i = r.getAttribute(e)
    if (!i) return ((t.minX = 0), (t.minY = 0), (t.maxX = 0), (t.maxY = 0), t)
    let n = i.buffer.data,
      s = 1 / 0,
      o = 1 / 0,
      a = -1 / 0,
      u = -1 / 0,
      l = n.BYTES_PER_ELEMENT,
      c = (i.offset || 0) / l,
      h = (i.stride || 2 * 4) / l
    for (let f = c; f < n.length; f += h) {
      let p = n[f],
        m = n[f + 1]
      ;(p > a && (a = p), m > u && (u = m), p < s && (s = p), m < o && (o = m))
    }
    return ((t.minX = s), (t.minY = o), (t.maxX = a), (t.maxY = u), t)
  }
  var Xx = d(() => {
    "use strict"
  })
  function YD(r) {
    return (
      (r instanceof Ae || Array.isArray(r) || r.BYTES_PER_ELEMENT) && (r = { buffer: r }),
      (r.buffer = Dh(r.buffer, !1)),
      r
    )
  }
  var Mt,
    $i = d(() => {
      Je()
      lt()
      Ye()
      Dr()
      Vx()
      Xx()
      Mt = class extends pe {
        constructor(e = {}) {
          ;(super(),
            (this.uid = te("geometry")),
            (this._layoutKey = 0),
            (this.instanceCount = 1),
            (this._bounds = new de()),
            (this._boundsDirty = !0))
          let { attributes: t, indexBuffer: i, topology: n } = e
          if (((this.buffers = []), (this.attributes = {}), t))
            for (let s in t) this.addAttribute(s, t[s])
          ;((this.instanceCount = e.instanceCount ?? 1),
            i && this.addIndex(i),
            (this.topology = n || "triangle-list"))
        }
        onBufferUpdate() {
          ;((this._boundsDirty = !0), this.emit("update", this))
        }
        getAttribute(e) {
          return this.attributes[e]
        }
        getIndex() {
          return this.indexBuffer
        }
        getBuffer(e) {
          return this.getAttribute(e).buffer
        }
        getSize() {
          for (let e in this.attributes) {
            let t = this.attributes[e]
            return t.buffer.data.length / (t.stride / 4 || t.size)
          }
          return 0
        }
        addAttribute(e, t) {
          let i = YD(t)
          ;(this.buffers.indexOf(i.buffer) === -1 &&
            (this.buffers.push(i.buffer),
            i.buffer.on("update", this.onBufferUpdate, this),
            i.buffer.on("change", this.onBufferUpdate, this)),
            (this.attributes[e] = i))
        }
        addIndex(e) {
          ;((this.indexBuffer = Dh(e, !0)), this.buffers.push(this.indexBuffer))
        }
        get bounds() {
          return this._boundsDirty
            ? ((this._boundsDirty = !1), $x(this, "aPosition", this._bounds))
            : this._bounds
        }
        destroy(e = !1) {
          ;(this.emit("destroy", this),
            this.removeAllListeners(),
            e && this.buffers.forEach((t) => t.destroy()),
            (this.attributes = null),
            (this.buffers = null),
            (this.indexBuffer = null),
            (this._bounds = null))
        }
      }
    })
  var KD,
    jD,
    au,
    Yx = d(() => {
      Dr()
      hr()
      $i()
      ;((KD = new Float32Array(1)),
        (jD = new Uint32Array(1)),
        (au = class extends Mt {
          constructor() {
            let t = new Ae({
                data: KD,
                label: "attribute-batch-buffer",
                usage: Q.VERTEX | Q.COPY_DST,
                shrinkToFit: !1,
              }),
              i = new Ae({
                data: jD,
                label: "index-batch-buffer",
                usage: Q.INDEX | Q.COPY_DST,
                shrinkToFit: !1,
              }),
              n = 6 * 4
            super({
              attributes: {
                aPosition: { buffer: t, format: "float32x2", stride: n, offset: 0 },
                aUV: { buffer: t, format: "float32x2", stride: n, offset: 2 * 4 },
                aColor: { buffer: t, format: "unorm8x4", stride: n, offset: 4 * 4 },
                aTextureIdAndRound: { buffer: t, format: "uint16x2", stride: n, offset: 5 * 4 },
              },
              indexBuffer: i,
            })
          }
        }))
    })
  function dr(r, e) {
    let t = Kx[r]
    return (t === void 0 && (Ph[e] === void 0 && (Ph[e] = 1), (Kx[r] = t = Ph[e]++)), t)
  }
  var Ph,
    Kx,
    ms = d(() => {
      "use strict"
      ;((Ph = Object.create(null)), (Kx = Object.create(null)))
    })
  function jx() {
    if (!uu) {
      uu = "mediump"
      let r = iu()
      r &&
        r.getShaderPrecisionFormat &&
        (uu = r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision
          ? "highp"
          : "mediump")
    }
    return uu
  }
  var uu,
    qx = d(() => {
      Th()
    })
  function Zx(r, e, t) {
    return e
      ? r
      : t
        ? ((r = r.replace("out vec4 finalColor;", "")),
          `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${r}
        `)
        : `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${r}
        `
  }
  var Qx = d(() => {
    "use strict"
  })
  function Jx(r, e, t) {
    let i = t ? e.maxSupportedFragmentPrecision : e.maxSupportedVertexPrecision
    if (r.substring(0, 9) !== "precision") {
      let n = t ? e.requestedFragmentPrecision : e.requestedVertexPrecision
      return (
        n === "highp" && i !== "highp" && (n = "mediump"),
        `precision ${n} float;
${r}`
      )
    } else if (i !== "highp" && r.substring(0, 15) === "precision highp")
      return r.replace("precision highp", "precision mediump")
    return r
  }
  var e_ = d(() => {
    "use strict"
  })
  function t_(r, e) {
    return e
      ? `#version 300 es
${r}`
      : r
  }
  var r_ = d(() => {
    "use strict"
  })
  function i_(r, { name: e = "pixi-program" }, t = !0) {
    ;((e = e.replace(/\s+/g, "-")), (e += t ? "-fragment" : "-vertex"))
    let i = t ? qD : ZD
    return (
      i[e] ? (i[e]++, (e += `-${i[e]}`)) : (i[e] = 1),
      r.indexOf("#define SHADER_NAME") !== -1
        ? r
        : `${`#define SHADER_NAME ${e}`}
${r}`
    )
  }
  var qD,
    ZD,
    n_ = d(() => {
      "use strict"
      ;((qD = {}), (ZD = {}))
    })
  function s_(r, e) {
    return e ? r.replace("#version 300 es", "") : r
  }
  var o_ = d(() => {
    "use strict"
  })
  var Rh,
    Fh,
    a_,
    At,
    ci = d(() => {
      ms()
      qx()
      Qx()
      e_()
      r_()
      n_()
      o_()
      ;((Rh = {
        stripVersion: s_,
        ensurePrecision: Jx,
        addProgramDefines: Zx,
        setProgramName: i_,
        insertVersion: t_,
      }),
        (Fh = Object.create(null)),
        (a_ = class Bh {
          constructor(e) {
            e = { ...Bh.defaultOptions, ...e }
            let t = e.fragment.indexOf("#version 300 es") !== -1,
              i = {
                stripVersion: t,
                ensurePrecision: {
                  requestedFragmentPrecision: e.preferredFragmentPrecision,
                  requestedVertexPrecision: e.preferredVertexPrecision,
                  maxSupportedVertexPrecision: "highp",
                  maxSupportedFragmentPrecision: jx(),
                },
                setProgramName: { name: e.name },
                addProgramDefines: t,
                insertVersion: t,
              },
              n = e.fragment,
              s = e.vertex
            ;(Object.keys(Rh).forEach((o) => {
              let a = i[o]
              ;((n = Rh[o](n, a, !0)), (s = Rh[o](s, a, !1)))
            }),
              (this.fragment = n),
              (this.vertex = s),
              (this.transformFeedbackVaryings = e.transformFeedbackVaryings),
              (this._key = dr(`${this.vertex}:${this.fragment}`, "gl-program")))
          }
          destroy() {
            ;((this.fragment = null),
              (this.vertex = null),
              (this._attributeData = null),
              (this._uniformData = null),
              (this._uniformBlockData = null),
              (this.transformFeedbackVaryings = null))
          }
          static from(e) {
            let t = `${e.vertex}:${e.fragment}`
            return (Fh[t] || (Fh[t] = new Bh(e)), Fh[t])
          }
        }))
      a_.defaultOptions = {
        preferredVertexPrecision: "highp",
        preferredFragmentPrecision: "mediump",
      }
      At = a_
    })
  function dt(r) {
    return u_[r] ?? u_.float32
  }
  var u_,
    hi = d(() => {
      "use strict"
      u_ = {
        uint8x2: { size: 2, stride: 2, normalised: !1 },
        uint8x4: { size: 4, stride: 4, normalised: !1 },
        sint8x2: { size: 2, stride: 2, normalised: !1 },
        sint8x4: { size: 4, stride: 4, normalised: !1 },
        unorm8x2: { size: 2, stride: 2, normalised: !0 },
        unorm8x4: { size: 4, stride: 4, normalised: !0 },
        snorm8x2: { size: 2, stride: 2, normalised: !0 },
        snorm8x4: { size: 4, stride: 4, normalised: !0 },
        uint16x2: { size: 2, stride: 4, normalised: !1 },
        uint16x4: { size: 4, stride: 8, normalised: !1 },
        sint16x2: { size: 2, stride: 4, normalised: !1 },
        sint16x4: { size: 4, stride: 8, normalised: !1 },
        unorm16x2: { size: 2, stride: 4, normalised: !0 },
        unorm16x4: { size: 4, stride: 8, normalised: !0 },
        snorm16x2: { size: 2, stride: 4, normalised: !0 },
        snorm16x4: { size: 4, stride: 8, normalised: !0 },
        float16x2: { size: 2, stride: 4, normalised: !1 },
        float16x4: { size: 4, stride: 8, normalised: !1 },
        float32: { size: 1, stride: 4, normalised: !1 },
        float32x2: { size: 2, stride: 8, normalised: !1 },
        float32x3: { size: 3, stride: 12, normalised: !1 },
        float32x4: { size: 4, stride: 16, normalised: !1 },
        uint32: { size: 1, stride: 4, normalised: !1 },
        uint32x2: { size: 2, stride: 8, normalised: !1 },
        uint32x3: { size: 3, stride: 12, normalised: !1 },
        uint32x4: { size: 4, stride: 16, normalised: !1 },
        sint32: { size: 1, stride: 4, normalised: !1 },
        sint32x2: { size: 2, stride: 8, normalised: !1 },
        sint32x3: { size: 3, stride: 12, normalised: !1 },
        sint32x4: { size: 4, stride: 16, normalised: !1 },
      }
    })
  function l_({ source: r, entryPoint: e }) {
    let t = {},
      i = r.indexOf(`fn ${e}`)
    if (i !== -1) {
      let n = r.indexOf("->", i)
      if (n !== -1) {
        let s = r.substring(i, n),
          o = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g,
          a
        for (; (a = o.exec(s)) !== null; ) {
          let u = QD[a[3]] ?? "float32"
          t[a[2]] = {
            location: parseInt(a[1], 10),
            format: u,
            stride: dt(u).stride,
            offset: 0,
            instance: !1,
            start: 0,
          }
        }
      }
    }
    return t
  }
  var QD,
    c_ = d(() => {
      hi()
      QD = {
        f32: "float32",
        "vec2<f32>": "float32x2",
        "vec3<f32>": "float32x3",
        "vec4<f32>": "float32x4",
        vec2f: "float32x2",
        vec3f: "float32x3",
        vec4f: "float32x4",
        i32: "sint32",
        "vec2<i32>": "sint32x2",
        "vec3<i32>": "sint32x3",
        "vec4<i32>": "sint32x4",
        u32: "uint32",
        "vec2<u32>": "uint32x2",
        "vec3<u32>": "uint32x3",
        "vec4<u32>": "uint32x4",
        bool: "uint32",
        "vec2<bool>": "uint32x2",
        "vec3<bool>": "uint32x3",
        "vec4<bool>": "uint32x4",
      }
    })
  function lu(r) {
    let e = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g,
      t = /@group\((\d+)\)/,
      i = /@binding\((\d+)\)/,
      n = /var(<[^>]+>)? (\w+)/,
      s = /:\s*(\w+)/,
      o = /struct\s+(\w+)\s*{([^}]+)}/g,
      a = /(\w+)\s*:\s*([\w\<\>]+)/g,
      u = /struct\s+(\w+)/,
      l = r
        .match(e)
        ?.map((h) => ({
          group: parseInt(h.match(t)[1], 10),
          binding: parseInt(h.match(i)[1], 10),
          name: h.match(n)[2],
          isUniform: h.match(n)[1] === "<uniform>",
          type: h.match(s)[1],
        }))
    if (!l) return { groups: [], structs: [] }
    let c =
      r
        .match(o)
        ?.map((h) => {
          let f = h.match(u)[1],
            p = h.match(a).reduce((m, g) => {
              let [x, y] = g.split(":")
              return ((m[x.trim()] = y.trim()), m)
            }, {})
          return p ? { name: f, members: p } : null
        })
        .filter(({ name: h }) => l.some((f) => f.type === h)) ?? []
    return { groups: l, structs: c }
  }
  var h_ = d(() => {
    "use strict"
  })
  var Xi,
    d_ = d(() => {
      "use strict"
      Xi = ((r) => (
        (r[(r.VERTEX = 1)] = "VERTEX"),
        (r[(r.FRAGMENT = 2)] = "FRAGMENT"),
        (r[(r.COMPUTE = 4)] = "COMPUTE"),
        r
      ))(Xi || {})
    })
  function f_({ groups: r }) {
    let e = []
    for (let t = 0; t < r.length; t++) {
      let i = r[t]
      ;(e[i.group] || (e[i.group] = []),
        i.isUniform
          ? e[i.group].push({
              binding: i.binding,
              visibility: Xi.VERTEX | Xi.FRAGMENT,
              buffer: { type: "uniform" },
            })
          : i.type === "sampler"
            ? e[i.group].push({
                binding: i.binding,
                visibility: Xi.FRAGMENT,
                sampler: { type: "filtering" },
              })
            : i.type === "texture_2d" &&
              e[i.group].push({
                binding: i.binding,
                visibility: Xi.FRAGMENT,
                texture: { sampleType: "float", viewDimension: "2d", multisampled: !1 },
              }))
    }
    return e
  }
  var p_ = d(() => {
    d_()
  })
  function m_({ groups: r }) {
    let e = []
    for (let t = 0; t < r.length; t++) {
      let i = r[t]
      ;(e[i.group] || (e[i.group] = {}), (e[i.group][i.name] = i.binding))
    }
    return e
  }
  var g_ = d(() => {
    "use strict"
  })
  function x_(r, e) {
    let t = new Set(),
      i = new Set(),
      n = [...r.structs, ...e.structs].filter((o) => (t.has(o.name) ? !1 : (t.add(o.name), !0))),
      s = [...r.groups, ...e.groups].filter((o) => {
        let a = `${o.name}-${o.binding}`
        return i.has(a) ? !1 : (i.add(a), !0)
      })
    return { structs: n, groups: s }
  }
  var __ = d(() => {
    "use strict"
  })
  var Ih,
    Dt,
    Yi = d(() => {
      ms()
      c_()
      h_()
      p_()
      g_()
      __()
      ;((Ih = Object.create(null)),
        (Dt = class r {
          constructor(e) {
            ;((this._layoutKey = 0), (this._attributeLocationsKey = 0))
            let { fragment: t, vertex: i, layout: n, gpuLayout: s, name: o } = e
            if (((this.name = o), (this.fragment = t), (this.vertex = i), t.source === i.source)) {
              let a = lu(t.source)
              this.structsAndGroups = a
            } else {
              let a = lu(i.source),
                u = lu(t.source)
              this.structsAndGroups = x_(a, u)
            }
            ;((this.layout = n ?? m_(this.structsAndGroups)),
              (this.gpuLayout = s ?? f_(this.structsAndGroups)),
              (this.autoAssignGlobalUniforms = this.layout[0]?.globalUniforms !== void 0),
              (this.autoAssignLocalUniforms = this.layout[1]?.localUniforms !== void 0),
              this._generateProgramKey())
          }
          _generateProgramKey() {
            let { vertex: e, fragment: t } = this,
              i = e.source + t.source + e.entryPoint + t.entryPoint
            this._layoutKey = dr(i, "program")
          }
          get attributeData() {
            return (
              this._attributeData ?? (this._attributeData = l_(this.vertex)),
              this._attributeData
            )
          }
          destroy() {
            ;((this.gpuLayout = null),
              (this.layout = null),
              (this.structsAndGroups = null),
              (this.fragment = null),
              (this.vertex = null))
          }
          static from(e) {
            let t = `${e.vertex.source}:${e.fragment.source}:${e.fragment.entryPoint}:${e.vertex.entryPoint}`
            return (Ih[t] || (Ih[t] = new r(e)), Ih[t])
          }
        }))
    })
  function Gh(r, e, t) {
    if (r)
      for (let i in r) {
        let n = i.toLocaleLowerCase(),
          s = e[n]
        if (s) {
          let o = r[i]
          ;(i === "header" &&
            (o = o.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "")),
            t && s.push(`//----${t}----//`),
            s.push(o))
        } else H(`${i} placement hook does not exist in shader`)
      }
  }
  var y_ = d(() => {
    be()
  })
  function kh(r) {
    let e = {}
    return (
      (r.match(JD)?.map((i) => i.replace(/[{()}]/g, "")) ?? []).forEach((i) => {
        e[i] = []
      }),
      e
    )
  }
  var JD,
    b_ = d(() => {
      "use strict"
      JD = /\{\{(.*?)\}\}/g
    })
  function v_(r, e) {
    let t,
      i = /@in\s+([^;]+);/g
    for (; (t = i.exec(r)) !== null; ) e.push(t[1])
  }
  function Uh(r, e, t = !1) {
    let i = []
    ;(v_(e, i),
      r.forEach((a) => {
        a.header && v_(a.header, i)
      }))
    let n = i
    t && n.sort()
    let s = n.map((a, u) => `       @location(${u}) ${a},`).join(`
`),
      o = e.replace(/@in\s+[^;]+;\s*/g, "")
    return (
      (o = o.replace(
        "{{in}}",
        `
${s}
`,
      )),
      o
    )
  }
  var S_ = d(() => {
    "use strict"
  })
  function T_(r, e) {
    let t,
      i = /@out\s+([^;]+);/g
    for (; (t = i.exec(r)) !== null; ) e.push(t[1])
  }
  function eP(r) {
    let t = /\b(\w+)\s*:/g.exec(r)
    return t ? t[1] : ""
  }
  function tP(r) {
    let e = /@.*?\s+/g
    return r.replace(e, "")
  }
  function C_(r, e) {
    let t = []
    ;(T_(e, t),
      r.forEach((u) => {
        u.header && T_(u.header, t)
      }))
    let i = 0,
      n = t.sort().map((u) => (u.indexOf("builtin") > -1 ? u : `@location(${i++}) ${u}`)).join(`,
`),
      s = t.sort().map((u) => `       var ${tP(u)};`).join(`
`),
      o = `return VSOutput(
            ${t.sort().map((u) => ` ${eP(u)}`).join(`,
`)});`,
      a = e.replace(/@out\s+[^;]+;\s*/g, "")
    return (
      (a = a.replace(
        "{{struct}}",
        `
${n}
`,
      )),
      (a = a.replace(
        "{{start}}",
        `
${s}
`,
      )),
      (a = a.replace(
        "{{return}}",
        `
${o}
`,
      )),
      a
    )
  }
  var E_ = d(() => {
    "use strict"
  })
  function Oh(r, e) {
    let t = r
    for (let i in e) {
      let n = e[i]
      n.join(`
`).length
        ? (t = t.replace(
            `{{${i}}}`,
            `//-----${i} START-----//
${n.join(`
`)}
//----${i} FINISH----//`,
          ))
        : (t = t.replace(`{{${i}}}`, ""))
    }
    return t
  }
  var w_ = d(() => {
    "use strict"
  })
  function M_({ template: r, bits: e }) {
    let t = D_(r, e)
    if (Pr[t]) return Pr[t]
    let { vertex: i, fragment: n } = iP(r, e)
    return ((Pr[t] = P_(i, n, e)), Pr[t])
  }
  function A_({ template: r, bits: e }) {
    let t = D_(r, e)
    return (Pr[t] || (Pr[t] = P_(r.vertex, r.fragment, e)), Pr[t])
  }
  function iP(r, e) {
    let t = e.map((o) => o.vertex).filter((o) => !!o),
      i = e.map((o) => o.fragment).filter((o) => !!o),
      n = Uh(t, r.vertex, !0)
    n = C_(t, n)
    let s = Uh(i, r.fragment, !0)
    return { vertex: n, fragment: s }
  }
  function D_(r, e) {
    return (
      e
        .map((t) => (Lh.has(t) || Lh.set(t, rP++), Lh.get(t)))
        .sort((t, i) => t - i)
        .join("-") +
      r.vertex +
      r.fragment
    )
  }
  function P_(r, e, t) {
    let i = kh(r),
      n = kh(e)
    return (
      t.forEach((s) => {
        ;(Gh(s.vertex, i, s.name), Gh(s.fragment, n, s.name))
      }),
      { vertex: Oh(r, i), fragment: Oh(e, n) }
    )
  }
  var Pr,
    Lh,
    rP,
    R_ = d(() => {
      y_()
      b_()
      S_()
      E_()
      w_()
      ;((Pr = Object.create(null)), (Lh = new Map()), (rP = 0))
    })
  var F_,
    B_,
    I_,
    G_,
    k_ = d(() => {
      "use strict"
      ;((F_ = `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`),
        (B_ = `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`),
        (I_ = `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`),
        (G_ = `
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
        
        {{end}}
    }
`))
    })
  var U_,
    O_,
    L_ = d(() => {
      "use strict"
      ;((U_ = {
        name: "global-uniforms-bit",
        vertex: {
          header: `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `,
        },
      }),
        (O_ = {
          name: "global-uniforms-bit",
          vertex: {
            header: `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `,
          },
        }))
    })
  function Kt({ bits: r, name: e }) {
    let t = M_({ template: { fragment: B_, vertex: F_ }, bits: [U_, ...r] })
    return Dt.from({
      name: e,
      vertex: { source: t.vertex, entryPoint: "main" },
      fragment: { source: t.fragment, entryPoint: "main" },
    })
  }
  function jt({ bits: r, name: e }) {
    return new At({ name: e, ...A_({ template: { vertex: I_, fragment: G_ }, bits: [O_, ...r] }) })
  }
  var Rr = d(() => {
    ci()
    Yi()
    R_()
    k_()
    L_()
  })
  var Ki,
    ji,
    gs = d(() => {
      "use strict"
      ;((Ki = {
        name: "color-bit",
        vertex: {
          header: `
            @in aColor: vec4<f32>;
        `,
          main: `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `,
        },
      }),
        (ji = {
          name: "color-bit",
          vertex: {
            header: `
            in vec4 aColor;
        `,
            main: `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `,
          },
        }))
    })
  function nP(r) {
    let e = []
    if (r === 1)
      (e.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"),
        e.push("@group(1) @binding(1) var textureSampler1: sampler;"))
    else {
      let t = 0
      for (let i = 0; i < r; i++)
        (e.push(`@group(1) @binding(${t++}) var textureSource${i + 1}: texture_2d<f32>;`),
          e.push(`@group(1) @binding(${t++}) var textureSampler${i + 1}: sampler;`))
    }
    return e.join(`
`)
  }
  function sP(r) {
    let e = []
    if (r === 1)
      e.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);")
    else {
      e.push("switch vTextureId {")
      for (let t = 0; t < r; t++)
        (t === r - 1 ? e.push("  default:{") : e.push(`  case ${t}:{`),
          e.push(
            `      outColor = textureSampleGrad(textureSource${t + 1}, textureSampler${t + 1}, vUV, uvDx, uvDy);`,
          ),
          e.push("      break;}"))
      e.push("}")
    }
    return e.join(`
`)
  }
  function qi(r) {
    return (
      Nh[r] ||
        (Nh[r] = {
          name: "texture-batch-bit",
          vertex: {
            header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
            main: `
                vTextureId = aTextureIdAndRound.y;
            `,
            end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `,
          },
          fragment: {
            header: `
                @in @interpolate(flat) vTextureId: u32;

                ${nP(r)}
            `,
            main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${sP(r)}
            `,
          },
        }),
      Nh[r]
    )
  }
  function oP(r) {
    let e = []
    for (let t = 0; t < r; t++)
      (t > 0 && e.push("else"),
        t < r - 1 && e.push(`if(vTextureId < ${t}.5)`),
        e.push("{"),
        e.push(`	outColor = texture(uTextures[${t}], vUV);`),
        e.push("}"))
    return e.join(`
`)
  }
  function Zi(r) {
    return (
      Hh[r] ||
        (Hh[r] = {
          name: "texture-batch-bit",
          vertex: {
            header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
            main: `
                vTextureId = aTextureIdAndRound.y;
            `,
            end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `,
          },
          fragment: {
            header: `
                in float vTextureId;

                uniform sampler2D uTextures[${r}];

            `,
            main: `

                ${oP(r)}
            `,
          },
        }),
      Hh[r]
    )
  }
  var Nh,
    Hh,
    xs = d(() => {
      "use strict"
      Nh = {}
      Hh = {}
    })
  var qt,
    Zt,
    Fr = d(() => {
      "use strict"
      ;((qt = {
        name: "round-pixels-bit",
        vertex: {
          header: `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `,
        },
      }),
        (Zt = {
          name: "round-pixels-bit",
          vertex: {
            header: `   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `,
          },
        }))
    })
  var zh,
    N_,
    H_ = d(() => {
      "use strict"
      ;((zh = [
        "f32",
        "i32",
        "vec2<f32>",
        "vec3<f32>",
        "vec4<f32>",
        "mat2x2<f32>",
        "mat3x3<f32>",
        "mat4x4<f32>",
        "mat3x2<f32>",
        "mat4x2<f32>",
        "mat2x3<f32>",
        "mat4x3<f32>",
        "mat2x4<f32>",
        "mat3x4<f32>",
        "vec2<i32>",
        "vec3<i32>",
        "vec4<i32>",
      ]),
        (N_ = zh.reduce((r, e) => ((r[e] = !0), r), {})))
    })
  function z_(r, e) {
    switch (r) {
      case "f32":
        return 0
      case "vec2<f32>":
        return new Float32Array(2 * e)
      case "vec3<f32>":
        return new Float32Array(3 * e)
      case "vec4<f32>":
        return new Float32Array(4 * e)
      case "mat2x2<f32>":
        return new Float32Array([1, 0, 0, 1])
      case "mat3x3<f32>":
        return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1])
      case "mat4x4<f32>":
        return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
    }
    return null
  }
  var W_ = d(() => {
    "use strict"
  })
  var V_,
    fe,
    st = d(() => {
      Ye()
      ms()
      H_()
      W_()
      V_ = class $_ {
        constructor(e, t) {
          ;((this._touched = 0),
            (this.uid = te("uniform")),
            (this._resourceType = "uniformGroup"),
            (this._resourceId = te("resource")),
            (this.isUniformGroup = !0),
            (this._dirtyId = 0),
            (this.destroyed = !1),
            (t = { ...$_.defaultOptions, ...t }),
            (this.uniformStructures = e))
          let i = {}
          for (let n in e) {
            let s = e[n]
            if (((s.name = n), (s.size = s.size ?? 1), !N_[s.type]))
              throw new Error(
                `Uniform type ${s.type} is not supported. Supported uniform types are: ${zh.join(", ")}`,
              )
            ;(s.value ?? (s.value = z_(s.type, s.size)), (i[n] = s.value))
          }
          ;((this.uniforms = i),
            (this._dirtyId = 1),
            (this.ubo = t.ubo),
            (this.isStatic = t.isStatic),
            (this._signature = dr(
              Object.keys(i)
                .map((n) => `${n}-${e[n].type}`)
                .join("-"),
              "uniform-group",
            )))
        }
        update() {
          this._dirtyId++
        }
      }
      V_.defaultOptions = { ubo: !1, isStatic: !1 }
      fe = V_
    })
  function Qi(r) {
    let e = X_[r]
    if (e) return e
    let t = new Int32Array(r)
    for (let i = 0; i < r; i++) t[i] = i
    return (
      (e = X_[r] = new fe({ uTextures: { value: t, type: "i32", size: r } }, { isStatic: !0 })),
      e
    )
  }
  var X_,
    cu = d(() => {
      st()
      X_ = {}
    })
  var ke,
    Qt = d(() => {
      "use strict"
      ke = ((r) => (
        (r[(r.WEBGL = 1)] = "WEBGL"),
        (r[(r.WEBGPU = 2)] = "WEBGPU"),
        (r[(r.BOTH = 3)] = "BOTH"),
        r
      ))(ke || {})
    })
  var De,
    Ut = d(() => {
      Je()
      Ye()
      ci()
      Ar()
      Yi()
      Qt()
      st()
      De = class r extends pe {
        constructor(e) {
          ;(super(),
            (this.uid = te("shader")),
            (this._uniformBindMap = Object.create(null)),
            (this._ownedBindGroups = []))
          let {
            gpuProgram: t,
            glProgram: i,
            groups: n,
            resources: s,
            compatibleRenderers: o,
            groupMap: a,
          } = e
          ;((this.gpuProgram = t),
            (this.glProgram = i),
            o === void 0 && ((o = 0), t && (o |= ke.WEBGPU), i && (o |= ke.WEBGL)),
            (this.compatibleRenderers = o))
          let u = {}
          if ((!s && !n && (s = {}), s && n))
            throw new Error("[Shader] Cannot have both resources and groups")
          if (!t && n && !a)
            throw new Error(
              "[Shader] No group map or WebGPU shader provided - consider using resources instead.",
            )
          if (!t && n && a)
            for (let l in a)
              for (let c in a[l]) {
                let h = a[l][c]
                u[h] = { group: l, binding: c, name: h }
              }
          else if (t && n && !a) {
            let l = t.structsAndGroups.groups
            ;((a = {}),
              l.forEach((c) => {
                ;((a[c.group] = a[c.group] || {}),
                  (a[c.group][c.binding] = c.name),
                  (u[c.name] = c))
              }))
          } else if (s) {
            ;((n = {}),
              (a = {}),
              t &&
                t.structsAndGroups.groups.forEach((h) => {
                  ;((a[h.group] = a[h.group] || {}),
                    (a[h.group][h.binding] = h.name),
                    (u[h.name] = h))
                }))
            let l = 0
            for (let c in s)
              u[c] ||
                (n[99] || ((n[99] = new He()), this._ownedBindGroups.push(n[99])),
                (u[c] = { group: 99, binding: l, name: c }),
                (a[99] = a[99] || {}),
                (a[99][l] = c),
                l++)
            for (let c in s) {
              let h = c,
                f = s[c]
              !f.source && !f._resourceType && (f = new fe(f))
              let p = u[h]
              p &&
                (n[p.group] || ((n[p.group] = new He()), this._ownedBindGroups.push(n[p.group])),
                n[p.group].setResource(f, p.binding))
            }
          }
          ;((this.groups = n),
            (this._uniformBindMap = a),
            (this.resources = this._buildResourceAccessor(n, u)))
        }
        addResource(e, t, i) {
          var n, s
          ;((n = this._uniformBindMap)[t] || (n[t] = {}),
            (s = this._uniformBindMap[t])[i] || (s[i] = e),
            this.groups[t] ||
              ((this.groups[t] = new He()), this._ownedBindGroups.push(this.groups[t])))
        }
        _buildResourceAccessor(e, t) {
          let i = {}
          for (let n in t) {
            let s = t[n]
            Object.defineProperty(i, s.name, {
              get() {
                return e[s.group].getResource(s.binding)
              },
              set(o) {
                e[s.group].setResource(o, s.binding)
              },
            })
          }
          return i
        }
        destroy(e = !1) {
          ;(this.emit("destroy", this),
            e && (this.gpuProgram?.destroy(), this.glProgram?.destroy()),
            (this.gpuProgram = null),
            (this.glProgram = null),
            this.removeAllListeners(),
            (this._uniformBindMap = null),
            this._ownedBindGroups.forEach((t) => {
              t.destroy()
            }),
            (this._ownedBindGroups = null),
            (this.resources = null),
            (this.groups = null))
        }
        static from(e) {
          let { gpu: t, gl: i, ...n } = e,
            s,
            o
          return (
            t && (s = Dt.from(t)),
            i && (o = At.from(i)),
            new r({ gpuProgram: s, glProgram: o, ...n })
          )
        }
      }
    })
  var hu,
    Y_ = d(() => {
      Rr()
      gs()
      xs()
      Fr()
      cu()
      Ut()
      hu = class extends De {
        constructor(e) {
          let t = jt({ name: "batch", bits: [ji, Zi(e), Zt] }),
            i = Kt({ name: "batch", bits: [Ki, qi(e), qt] })
          super({ glProgram: t, gpuProgram: i, resources: { batchSamplers: Qi(e) } })
        }
      }
    })
  var K_,
    j_,
    _s,
    Wh = d(() => {
      D()
      Wx()
      Yx()
      Y_()
      ;((K_ = null),
        (j_ = class q_ extends zx {
          constructor() {
            ;(super(...arguments),
              (this.geometry = new au()),
              (this.shader = K_ || (K_ = new hu(this.maxTextures))),
              (this.name = q_.extension.name),
              (this.vertexSize = 6))
          }
          packAttributes(e, t, i, n, s) {
            let o = (s << 16) | (e.roundPixels & 65535),
              a = e.transform,
              u = a.a,
              l = a.b,
              c = a.c,
              h = a.d,
              f = a.tx,
              p = a.ty,
              { positions: m, uvs: g } = e,
              x = e.color,
              y = e.attributeOffset,
              v = y + e.attributeSize
            for (let S = y; S < v; S++) {
              let b = S * 2,
                M = m[b],
                C = m[b + 1]
              ;((t[n++] = u * M + c * C + f),
                (t[n++] = h * C + l * M + p),
                (t[n++] = g[b]),
                (t[n++] = g[b + 1]),
                (i[n++] = x),
                (i[n++] = o))
            }
          }
          packQuadAttributes(e, t, i, n, s) {
            let o = e.texture,
              a = e.transform,
              u = a.a,
              l = a.b,
              c = a.c,
              h = a.d,
              f = a.tx,
              p = a.ty,
              m = e.bounds,
              g = m.maxX,
              x = m.minX,
              y = m.maxY,
              v = m.minY,
              S = o.uvs,
              b = e.color,
              M = (s << 16) | (e.roundPixels & 65535)
            ;((t[n + 0] = u * x + c * v + f),
              (t[n + 1] = h * v + l * x + p),
              (t[n + 2] = S.x0),
              (t[n + 3] = S.y0),
              (i[n + 4] = b),
              (i[n + 5] = M),
              (t[n + 6] = u * g + c * v + f),
              (t[n + 7] = h * v + l * g + p),
              (t[n + 8] = S.x1),
              (t[n + 9] = S.y1),
              (i[n + 10] = b),
              (i[n + 11] = M),
              (t[n + 12] = u * g + c * y + f),
              (t[n + 13] = h * y + l * g + p),
              (t[n + 14] = S.x2),
              (t[n + 15] = S.y2),
              (i[n + 16] = b),
              (i[n + 17] = M),
              (t[n + 18] = u * x + c * y + f),
              (t[n + 19] = h * y + l * x + p),
              (t[n + 20] = S.x3),
              (t[n + 21] = S.y3),
              (i[n + 22] = b),
              (i[n + 23] = M))
          }
        }))
      j_.extension = { type: [_.Batcher], name: "default" }
      _s = j_
    })
  function Z_(r, e, t, i, n, s, o, a = null) {
    let u = 0
    ;((t *= e), (n *= s))
    let l = a.a,
      c = a.b,
      h = a.c,
      f = a.d,
      p = a.tx,
      m = a.ty
    for (; u < o; ) {
      let g = r[t],
        x = r[t + 1]
      ;((i[n] = l * g + h * x + p), (i[n + 1] = c * g + f * x + m), (n += s), (t += e), u++)
    }
  }
  function Q_(r, e, t, i) {
    let n = 0
    for (e *= t; n < i; ) ((r[e] = 0), (r[e + 1] = 0), (e += t), n++)
  }
  var J_ = d(() => {
    "use strict"
  })
  function Vh(r, e, t, i, n) {
    let s = e.a,
      o = e.b,
      a = e.c,
      u = e.d,
      l = e.tx,
      c = e.ty
    ;(t || (t = 0), i || (i = 2), n || (n = r.length / i - t))
    let h = t * i
    for (let f = 0; f < n; f++) {
      let p = r[h],
        m = r[h + 1]
      ;((r[h] = s * p + a * m + l), (r[h + 1] = o * p + u * m + c), (h += i))
    }
  }
  var ey = d(() => {
    "use strict"
  })
  var aP,
    di,
    $h = d(() => {
      se()
      Gc()
      ;((aP = new F()),
        (di = class {
          constructor() {
            ;((this.packAsQuad = !1),
              (this.batcherName = "default"),
              (this.topology = "triangle-list"),
              (this.applyTransform = !0),
              (this.roundPixels = 0),
              (this._batcher = null),
              (this._batch = null))
          }
          get uvs() {
            return this.geometryData.uvs
          }
          get positions() {
            return this.geometryData.vertices
          }
          get indices() {
            return this.geometryData.indices
          }
          get blendMode() {
            return this.applyTransform ? this.renderable.groupBlendMode : "normal"
          }
          get color() {
            let e = this.baseColor,
              t = (e >> 16) | (e & 65280) | ((e & 255) << 16),
              i = this.renderable
            return i
              ? Ga(t, i.groupColor) + ((this.alpha * i.groupAlpha * 255) << 24)
              : t + ((this.alpha * 255) << 24)
          }
          get transform() {
            return this.renderable?.groupTransform || aP
          }
          copyTo(e) {
            ;((e.indexOffset = this.indexOffset),
              (e.indexSize = this.indexSize),
              (e.attributeOffset = this.attributeOffset),
              (e.attributeSize = this.attributeSize),
              (e.baseColor = this.baseColor),
              (e.alpha = this.alpha),
              (e.texture = this.texture),
              (e.geometryData = this.geometryData),
              (e.topology = this.topology))
          }
          reset() {
            ;((this.applyTransform = !0),
              (this.renderable = null),
              (this.topology = "triangle-list"))
          }
        }))
    })
  var Ji,
    ty,
    ry,
    iy = d(() => {
      D()
      ;((Ji = {
        extension: { type: _.ShapeBuilder, name: "circle" },
        build(r, e) {
          let t, i, n, s, o, a
          if (r.type === "circle") {
            let b = r
            ;((t = b.x), (i = b.y), (o = a = b.radius), (n = s = 0))
          } else if (r.type === "ellipse") {
            let b = r
            ;((t = b.x), (i = b.y), (o = b.halfWidth), (a = b.halfHeight), (n = s = 0))
          } else {
            let b = r,
              M = b.width / 2,
              C = b.height / 2
            ;((t = b.x + M),
              (i = b.y + C),
              (o = a = Math.max(0, Math.min(b.radius, Math.min(M, C)))),
              (n = M - o),
              (s = C - a))
          }
          if (!(o >= 0 && a >= 0 && n >= 0 && s >= 0)) return e
          let u = Math.ceil(2.3 * Math.sqrt(o + a)),
            l = u * 8 + (n ? 4 : 0) + (s ? 4 : 0)
          if (l === 0) return e
          if (u === 0)
            return (
              (e[0] = e[6] = t + n),
              (e[1] = e[3] = i + s),
              (e[2] = e[4] = t - n),
              (e[5] = e[7] = i - s),
              e
            )
          let c = 0,
            h = u * 4 + (n ? 2 : 0) + 2,
            f = h,
            p = l,
            m = n + o,
            g = s,
            x = t + m,
            y = t - m,
            v = i + g
          if (((e[c++] = x), (e[c++] = v), (e[--h] = v), (e[--h] = y), s)) {
            let b = i - g
            ;((e[f++] = y), (e[f++] = b), (e[--p] = b), (e[--p] = x))
          }
          for (let b = 1; b < u; b++) {
            let M = (Math.PI / 2) * (b / u),
              C = n + Math.cos(M) * o,
              w = s + Math.sin(M) * a,
              B = t + C,
              O = t - C,
              G = i + w,
              A = i - w
            ;((e[c++] = B),
              (e[c++] = G),
              (e[--h] = G),
              (e[--h] = O),
              (e[f++] = O),
              (e[f++] = A),
              (e[--p] = A),
              (e[--p] = B))
          }
          ;((m = n), (g = s + a), (x = t + m), (y = t - m), (v = i + g))
          let S = i - g
          return (
            (e[c++] = x),
            (e[c++] = v),
            (e[--p] = S),
            (e[--p] = x),
            n && ((e[c++] = y), (e[c++] = v), (e[--p] = S), (e[--p] = y)),
            e
          )
        },
        triangulate(r, e, t, i, n, s) {
          if (r.length === 0) return
          let o = 0,
            a = 0
          for (let c = 0; c < r.length; c += 2) ((o += r[c]), (a += r[c + 1]))
          ;((o /= r.length / 2), (a /= r.length / 2))
          let u = i
          ;((e[u * t] = o), (e[u * t + 1] = a))
          let l = u++
          for (let c = 0; c < r.length; c += 2)
            ((e[u * t] = r[c]),
              (e[u * t + 1] = r[c + 1]),
              c > 0 && ((n[s++] = u), (n[s++] = l), (n[s++] = u - 1)),
              u++)
          ;((n[s++] = l + 1), (n[s++] = l), (n[s++] = u - 1))
        },
      }),
        (ty = { ...Ji, extension: { ...Ji.extension, name: "ellipse" } }),
        (ry = { ...Ji, extension: { ...Ji.extension, name: "roundedRectangle" } }))
    })
  function ny(r) {
    let e = r.length
    if (e < 6) return 1
    let t = 0
    for (let i = 0, n = r[e - 2], s = r[e - 1]; i < e; i += 2) {
      let o = r[i],
        a = r[i + 1]
      ;((t += (o - n) * (a + s)), (n = o), (s = a))
    }
    return t < 0 ? -1 : 1
  }
  var sy = d(() => {
    "use strict"
  })
  function oy(r, e, t, i, n, s, o, a) {
    let u = r - t * n,
      l = e - i * n,
      c = r + t * s,
      h = e + i * s,
      f,
      p
    o ? ((f = i), (p = -t)) : ((f = -i), (p = t))
    let m = u + f,
      g = l + p,
      x = c + f,
      y = h + p
    return (a.push(m, g), a.push(x, y), 2)
  }
  function fi(r, e, t, i, n, s, o, a) {
    let u = t - r,
      l = i - e,
      c = Math.atan2(u, l),
      h = Math.atan2(n - r, s - e)
    a && c < h ? (c += Math.PI * 2) : !a && c > h && (h += Math.PI * 2)
    let f = c,
      p = h - c,
      m = Math.abs(p),
      g = Math.sqrt(u * u + l * l),
      x = (((15 * m * Math.sqrt(g)) / Math.PI) >> 0) + 1,
      y = p / x
    if (((f += y), a)) {
      ;(o.push(r, e), o.push(t, i))
      for (let v = 1, S = f; v < x; v++, S += y)
        (o.push(r, e), o.push(r + Math.sin(S) * g, e + Math.cos(S) * g))
      ;(o.push(r, e), o.push(n, s))
    } else {
      ;(o.push(t, i), o.push(r, e))
      for (let v = 1, S = f; v < x; v++, S += y)
        (o.push(r + Math.sin(S) * g, e + Math.cos(S) * g), o.push(r, e))
      ;(o.push(n, s), o.push(r, e))
    }
    return x * 2
  }
  function ay(r, e, t, i, n, s) {
    let o = 1e-4
    if (r.length === 0) return
    let a = e,
      u = a.alignment
    if (e.alignment !== 0.5) {
      let k = ny(r)
      ;(t && (k *= -1), (u = (u - 0.5) * k + 0.5))
    }
    let l = new re(r[0], r[1]),
      c = new re(r[r.length - 2], r[r.length - 1]),
      h = i,
      f = Math.abs(l.x - c.x) < o && Math.abs(l.y - c.y) < o
    if (h) {
      ;((r = r.slice()), f && (r.pop(), r.pop(), c.set(r[r.length - 2], r[r.length - 1])))
      let k = (l.x + c.x) * 0.5,
        X = (c.y + l.y) * 0.5
      ;(r.unshift(k, X), r.push(k, X))
    }
    let p = n,
      m = r.length / 2,
      g = r.length,
      x = p.length / 2,
      y = a.width / 2,
      v = y * y,
      S = a.miterLimit * a.miterLimit,
      b = r[0],
      M = r[1],
      C = r[2],
      w = r[3],
      B = 0,
      O = 0,
      G = -(M - w),
      A = b - C,
      W = 0,
      Y = 0,
      T = Math.sqrt(G * G + A * A)
    ;((G /= T), (A /= T), (G *= y), (A *= y))
    let N = u,
      E = (1 - N) * 2,
      P = N * 2
    ;(h ||
      (a.cap === "round"
        ? (g +=
            fi(
              b - G * (E - P) * 0.5,
              M - A * (E - P) * 0.5,
              b - G * E,
              M - A * E,
              b + G * P,
              M + A * P,
              p,
              !0,
            ) + 2)
        : a.cap === "square" && (g += oy(b, M, G, A, E, P, !0, p))),
      p.push(b - G * E, M - A * E),
      p.push(b + G * P, M + A * P))
    for (let k = 1; k < m - 1; ++k) {
      ;((b = r[(k - 1) * 2]),
        (M = r[(k - 1) * 2 + 1]),
        (C = r[k * 2]),
        (w = r[k * 2 + 1]),
        (B = r[(k + 1) * 2]),
        (O = r[(k + 1) * 2 + 1]),
        (G = -(M - w)),
        (A = b - C),
        (T = Math.sqrt(G * G + A * A)),
        (G /= T),
        (A /= T),
        (G *= y),
        (A *= y),
        (W = -(w - O)),
        (Y = C - B),
        (T = Math.sqrt(W * W + Y * Y)),
        (W /= T),
        (Y /= T),
        (W *= y),
        (Y *= y))
      let X = C - b,
        oe = M - w,
        he = C - B,
        Oe = O - w,
        we = X * he + oe * Oe,
        Le = oe * he - Oe * X,
        Ve = Le < 0
      if (Math.abs(Le) < 0.001 * Math.abs(we)) {
        ;(p.push(C - G * E, w - A * E),
          p.push(C + G * P, w + A * P),
          we >= 0 &&
            (a.join === "round"
              ? (g += fi(C, w, C - G * E, w - A * E, C - W * E, w - Y * E, p, !1) + 4)
              : (g += 2),
            p.push(C - W * P, w - Y * P),
            p.push(C + W * E, w + Y * E)))
        continue
      }
      let Ze = (-G + b) * (-A + w) - (-G + C) * (-A + M),
        ut = (-W + B) * (-Y + w) - (-W + C) * (-Y + O),
        U = (X * ut - he * Ze) / Le,
        J = (Oe * Ze - oe * ut) / Le,
        ne = (U - C) * (U - C) + (J - w) * (J - w),
        R = C + (U - C) * E,
        Me = w + (J - w) * E,
        ae = C - (U - C) * P,
        Re = w - (J - w) * P,
        tt = Math.min(X * X + oe * oe, he * he + Oe * Oe),
        Wt = Ve ? E : P,
        ma = tt + Wt * Wt * v
      ne <= ma
        ? a.join === "bevel" || ne / v > S
          ? (Ve
              ? (p.push(R, Me),
                p.push(C + G * P, w + A * P),
                p.push(R, Me),
                p.push(C + W * P, w + Y * P))
              : (p.push(C - G * E, w - A * E),
                p.push(ae, Re),
                p.push(C - W * E, w - Y * E),
                p.push(ae, Re)),
            (g += 2))
          : a.join === "round"
            ? Ve
              ? (p.push(R, Me),
                p.push(C + G * P, w + A * P),
                (g += fi(C, w, C + G * P, w + A * P, C + W * P, w + Y * P, p, !0) + 4),
                p.push(R, Me),
                p.push(C + W * P, w + Y * P))
              : (p.push(C - G * E, w - A * E),
                p.push(ae, Re),
                (g += fi(C, w, C - G * E, w - A * E, C - W * E, w - Y * E, p, !1) + 4),
                p.push(C - W * E, w - Y * E),
                p.push(ae, Re))
            : (p.push(R, Me), p.push(ae, Re))
        : (p.push(C - G * E, w - A * E),
          p.push(C + G * P, w + A * P),
          a.join === "round"
            ? Ve
              ? (g += fi(C, w, C + G * P, w + A * P, C + W * P, w + Y * P, p, !0) + 2)
              : (g += fi(C, w, C - G * E, w - A * E, C - W * E, w - Y * E, p, !1) + 2)
            : a.join === "miter" &&
              ne / v <= S &&
              (Ve ? (p.push(ae, Re), p.push(ae, Re)) : (p.push(R, Me), p.push(R, Me)), (g += 2)),
          p.push(C - W * E, w - Y * E),
          p.push(C + W * P, w + Y * P),
          (g += 2))
    }
    ;((b = r[(m - 2) * 2]),
      (M = r[(m - 2) * 2 + 1]),
      (C = r[(m - 1) * 2]),
      (w = r[(m - 1) * 2 + 1]),
      (G = -(M - w)),
      (A = b - C),
      (T = Math.sqrt(G * G + A * A)),
      (G /= T),
      (A /= T),
      (G *= y),
      (A *= y),
      p.push(C - G * E, w - A * E),
      p.push(C + G * P, w + A * P),
      h ||
        (a.cap === "round"
          ? (g +=
              fi(
                C - G * (E - P) * 0.5,
                w - A * (E - P) * 0.5,
                C - G * E,
                w - A * E,
                C + G * P,
                w + A * P,
                p,
                !1,
              ) + 2)
          : a.cap === "square" && (g += oy(C, w, G, A, E, P, !1, p))))
    let $ = 1e-4 * 1e-4
    for (let k = x; k < g + x - 2; ++k)
      ((b = p[k * 2]),
        (M = p[k * 2 + 1]),
        (C = p[(k + 1) * 2]),
        (w = p[(k + 1) * 2 + 1]),
        (B = p[(k + 2) * 2]),
        (O = p[(k + 2) * 2 + 1]),
        !(Math.abs(b * (w - O) + C * (O - M) + B * (M - w)) < $) && s.push(k, k + 1, k + 2))
  }
  var uy = d(() => {
    Et()
    sy()
  })
  function ly(r, e, t, i) {
    let n = 1e-4
    if (r.length === 0) return
    let s = r[0],
      o = r[1],
      a = r[r.length - 2],
      u = r[r.length - 1],
      l = e || (Math.abs(s - a) < n && Math.abs(o - u) < n),
      c = t,
      h = r.length / 2,
      f = c.length / 2
    for (let p = 0; p < h; p++) (c.push(r[p * 2]), c.push(r[p * 2 + 1]))
    for (let p = 0; p < h - 1; p++) i.push(f + p, f + p + 1)
    l && i.push(f + h - 1, f)
  }
  var cy = d(() => {})
  var qh = ga((dz, jh) => {
    "use strict"
    jh.exports = pu
    jh.exports.default = pu
    function pu(r, e, t) {
      t = t || 2
      var i = e && e.length,
        n = i ? e[0] * t : r.length,
        s = dy(r, 0, n, t, !0),
        o = []
      if (!s || s.next === s.prev) return o
      var a, u, l, c, h, f, p
      if ((i && (s = pP(r, e, s, t)), r.length > 80 * t)) {
        ;((a = l = r[0]), (u = c = r[1]))
        for (var m = t; m < n; m += t)
          ((h = r[m]),
            (f = r[m + 1]),
            h < a && (a = h),
            f < u && (u = f),
            h > l && (l = h),
            f > c && (c = f))
        ;((p = Math.max(l - a, c - u)), (p = p !== 0 ? 32767 / p : 0))
      }
      return (ys(s, o, t, a, u, p, 0), o)
    }
    function dy(r, e, t, i, n) {
      var s, o
      if (n === Kh(r, e, t, i) > 0) for (s = e; s < t; s += i) o = hy(s, r[s], r[s + 1], o)
      else for (s = t - i; s >= e; s -= i) o = hy(s, r[s], r[s + 1], o)
      return (o && mu(o, o.next) && (vs(o), (o = o.next)), o)
    }
    function pi(r, e) {
      if (!r) return r
      e || (e = r)
      var t = r,
        i
      do
        if (((i = !1), !t.steiner && (mu(t, t.next) || Ee(t.prev, t, t.next) === 0))) {
          if ((vs(t), (t = e = t.prev), t === t.next)) break
          i = !0
        } else t = t.next
      while (i || t !== e)
      return e
    }
    function ys(r, e, t, i, n, s, o) {
      if (r) {
        !o && s && yP(r, i, n, s)
        for (var a = r, u, l; r.prev !== r.next; ) {
          if (((u = r.prev), (l = r.next), s ? hP(r, i, n, s) : cP(r))) {
            ;(e.push((u.i / t) | 0),
              e.push((r.i / t) | 0),
              e.push((l.i / t) | 0),
              vs(r),
              (r = l.next),
              (a = l.next))
            continue
          }
          if (((r = l), r === a)) {
            o
              ? o === 1
                ? ((r = dP(pi(r), e, t)), ys(r, e, t, i, n, s, 2))
                : o === 2 && fP(r, e, t, i, n, s)
              : ys(pi(r), e, t, i, n, s, 1)
            break
          }
        }
      }
    }
    function cP(r) {
      var e = r.prev,
        t = r,
        i = r.next
      if (Ee(e, t, i) >= 0) return !1
      for (
        var n = e.x,
          s = t.x,
          o = i.x,
          a = e.y,
          u = t.y,
          l = i.y,
          c = n < s ? (n < o ? n : o) : s < o ? s : o,
          h = a < u ? (a < l ? a : l) : u < l ? u : l,
          f = n > s ? (n > o ? n : o) : s > o ? s : o,
          p = a > u ? (a > l ? a : l) : u > l ? u : l,
          m = i.next;
        m !== e;

      ) {
        if (
          m.x >= c &&
          m.x <= f &&
          m.y >= h &&
          m.y <= p &&
          en(n, a, s, u, o, l, m.x, m.y) &&
          Ee(m.prev, m, m.next) >= 0
        )
          return !1
        m = m.next
      }
      return !0
    }
    function hP(r, e, t, i) {
      var n = r.prev,
        s = r,
        o = r.next
      if (Ee(n, s, o) >= 0) return !1
      for (
        var a = n.x,
          u = s.x,
          l = o.x,
          c = n.y,
          h = s.y,
          f = o.y,
          p = a < u ? (a < l ? a : l) : u < l ? u : l,
          m = c < h ? (c < f ? c : f) : h < f ? h : f,
          g = a > u ? (a > l ? a : l) : u > l ? u : l,
          x = c > h ? (c > f ? c : f) : h > f ? h : f,
          y = Xh(p, m, e, t, i),
          v = Xh(g, x, e, t, i),
          S = r.prevZ,
          b = r.nextZ;
        S && S.z >= y && b && b.z <= v;

      ) {
        if (
          (S.x >= p &&
            S.x <= g &&
            S.y >= m &&
            S.y <= x &&
            S !== n &&
            S !== o &&
            en(a, c, u, h, l, f, S.x, S.y) &&
            Ee(S.prev, S, S.next) >= 0) ||
          ((S = S.prevZ),
          b.x >= p &&
            b.x <= g &&
            b.y >= m &&
            b.y <= x &&
            b !== n &&
            b !== o &&
            en(a, c, u, h, l, f, b.x, b.y) &&
            Ee(b.prev, b, b.next) >= 0)
        )
          return !1
        b = b.nextZ
      }
      for (; S && S.z >= y; ) {
        if (
          S.x >= p &&
          S.x <= g &&
          S.y >= m &&
          S.y <= x &&
          S !== n &&
          S !== o &&
          en(a, c, u, h, l, f, S.x, S.y) &&
          Ee(S.prev, S, S.next) >= 0
        )
          return !1
        S = S.prevZ
      }
      for (; b && b.z <= v; ) {
        if (
          b.x >= p &&
          b.x <= g &&
          b.y >= m &&
          b.y <= x &&
          b !== n &&
          b !== o &&
          en(a, c, u, h, l, f, b.x, b.y) &&
          Ee(b.prev, b, b.next) >= 0
        )
          return !1
        b = b.nextZ
      }
      return !0
    }
    function dP(r, e, t) {
      var i = r
      do {
        var n = i.prev,
          s = i.next.next
        ;(!mu(n, s) &&
          fy(n, i, i.next, s) &&
          bs(n, s) &&
          bs(s, n) &&
          (e.push((n.i / t) | 0),
          e.push((i.i / t) | 0),
          e.push((s.i / t) | 0),
          vs(i),
          vs(i.next),
          (i = r = s)),
          (i = i.next))
      } while (i !== r)
      return pi(i)
    }
    function fP(r, e, t, i, n, s) {
      var o = r
      do {
        for (var a = o.next.next; a !== o.prev; ) {
          if (o.i !== a.i && SP(o, a)) {
            var u = py(o, a)
            ;((o = pi(o, o.next)),
              (u = pi(u, u.next)),
              ys(o, e, t, i, n, s, 0),
              ys(u, e, t, i, n, s, 0))
            return
          }
          a = a.next
        }
        o = o.next
      } while (o !== r)
    }
    function pP(r, e, t, i) {
      var n = [],
        s,
        o,
        a,
        u,
        l
      for (s = 0, o = e.length; s < o; s++)
        ((a = e[s] * i),
          (u = s < o - 1 ? e[s + 1] * i : r.length),
          (l = dy(r, a, u, i, !1)),
          l === l.next && (l.steiner = !0),
          n.push(vP(l)))
      for (n.sort(mP), s = 0; s < n.length; s++) t = gP(n[s], t)
      return t
    }
    function mP(r, e) {
      return r.x - e.x
    }
    function gP(r, e) {
      var t = xP(r, e)
      if (!t) return e
      var i = py(t, r)
      return (pi(i, i.next), pi(t, t.next))
    }
    function xP(r, e) {
      var t = e,
        i = r.x,
        n = r.y,
        s = -1 / 0,
        o
      do {
        if (n <= t.y && n >= t.next.y && t.next.y !== t.y) {
          var a = t.x + ((n - t.y) * (t.next.x - t.x)) / (t.next.y - t.y)
          if (a <= i && a > s && ((s = a), (o = t.x < t.next.x ? t : t.next), a === i)) return o
        }
        t = t.next
      } while (t !== e)
      if (!o) return null
      var u = o,
        l = o.x,
        c = o.y,
        h = 1 / 0,
        f
      t = o
      do
        (i >= t.x &&
          t.x >= l &&
          i !== t.x &&
          en(n < c ? i : s, n, l, c, n < c ? s : i, n, t.x, t.y) &&
          ((f = Math.abs(n - t.y) / (i - t.x)),
          bs(t, r) &&
            (f < h || (f === h && (t.x > o.x || (t.x === o.x && _P(o, t))))) &&
            ((o = t), (h = f))),
          (t = t.next))
      while (t !== u)
      return o
    }
    function _P(r, e) {
      return Ee(r.prev, r, e.prev) < 0 && Ee(e.next, r, r.next) < 0
    }
    function yP(r, e, t, i) {
      var n = r
      do
        (n.z === 0 && (n.z = Xh(n.x, n.y, e, t, i)),
          (n.prevZ = n.prev),
          (n.nextZ = n.next),
          (n = n.next))
      while (n !== r)
      ;((n.prevZ.nextZ = null), (n.prevZ = null), bP(n))
    }
    function bP(r) {
      var e,
        t,
        i,
        n,
        s,
        o,
        a,
        u,
        l = 1
      do {
        for (t = r, r = null, s = null, o = 0; t; ) {
          for (o++, i = t, a = 0, e = 0; e < l && (a++, (i = i.nextZ), !!i); e++);
          for (u = l; a > 0 || (u > 0 && i); )
            (a !== 0 && (u === 0 || !i || t.z <= i.z)
              ? ((n = t), (t = t.nextZ), a--)
              : ((n = i), (i = i.nextZ), u--),
              s ? (s.nextZ = n) : (r = n),
              (n.prevZ = s),
              (s = n))
          t = i
        }
        ;((s.nextZ = null), (l *= 2))
      } while (o > 1)
      return r
    }
    function Xh(r, e, t, i, n) {
      return (
        (r = ((r - t) * n) | 0),
        (e = ((e - i) * n) | 0),
        (r = (r | (r << 8)) & 16711935),
        (r = (r | (r << 4)) & 252645135),
        (r = (r | (r << 2)) & 858993459),
        (r = (r | (r << 1)) & 1431655765),
        (e = (e | (e << 8)) & 16711935),
        (e = (e | (e << 4)) & 252645135),
        (e = (e | (e << 2)) & 858993459),
        (e = (e | (e << 1)) & 1431655765),
        r | (e << 1)
      )
    }
    function vP(r) {
      var e = r,
        t = r
      do ((e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next))
      while (e !== r)
      return t
    }
    function en(r, e, t, i, n, s, o, a) {
      return (
        (n - o) * (e - a) >= (r - o) * (s - a) &&
        (r - o) * (i - a) >= (t - o) * (e - a) &&
        (t - o) * (s - a) >= (n - o) * (i - a)
      )
    }
    function SP(r, e) {
      return (
        r.next.i !== e.i &&
        r.prev.i !== e.i &&
        !TP(r, e) &&
        ((bs(r, e) && bs(e, r) && CP(r, e) && (Ee(r.prev, r, e.prev) || Ee(r, e.prev, e))) ||
          (mu(r, e) && Ee(r.prev, r, r.next) > 0 && Ee(e.prev, e, e.next) > 0))
      )
    }
    function Ee(r, e, t) {
      return (e.y - r.y) * (t.x - e.x) - (e.x - r.x) * (t.y - e.y)
    }
    function mu(r, e) {
      return r.x === e.x && r.y === e.y
    }
    function fy(r, e, t, i) {
      var n = fu(Ee(r, e, t)),
        s = fu(Ee(r, e, i)),
        o = fu(Ee(t, i, r)),
        a = fu(Ee(t, i, e))
      return !!(
        (n !== s && o !== a) ||
        (n === 0 && du(r, t, e)) ||
        (s === 0 && du(r, i, e)) ||
        (o === 0 && du(t, r, i)) ||
        (a === 0 && du(t, e, i))
      )
    }
    function du(r, e, t) {
      return (
        e.x <= Math.max(r.x, t.x) &&
        e.x >= Math.min(r.x, t.x) &&
        e.y <= Math.max(r.y, t.y) &&
        e.y >= Math.min(r.y, t.y)
      )
    }
    function fu(r) {
      return r > 0 ? 1 : r < 0 ? -1 : 0
    }
    function TP(r, e) {
      var t = r
      do {
        if (
          t.i !== r.i &&
          t.next.i !== r.i &&
          t.i !== e.i &&
          t.next.i !== e.i &&
          fy(t, t.next, r, e)
        )
          return !0
        t = t.next
      } while (t !== r)
      return !1
    }
    function bs(r, e) {
      return Ee(r.prev, r, r.next) < 0
        ? Ee(r, e, r.next) >= 0 && Ee(r, r.prev, e) >= 0
        : Ee(r, e, r.prev) < 0 || Ee(r, r.next, e) < 0
    }
    function CP(r, e) {
      var t = r,
        i = !1,
        n = (r.x + e.x) / 2,
        s = (r.y + e.y) / 2
      do
        (t.y > s != t.next.y > s &&
          t.next.y !== t.y &&
          n < ((t.next.x - t.x) * (s - t.y)) / (t.next.y - t.y) + t.x &&
          (i = !i),
          (t = t.next))
      while (t !== r)
      return i
    }
    function py(r, e) {
      var t = new Yh(r.i, r.x, r.y),
        i = new Yh(e.i, e.x, e.y),
        n = r.next,
        s = e.prev
      return (
        (r.next = e),
        (e.prev = r),
        (t.next = n),
        (n.prev = t),
        (i.next = t),
        (t.prev = i),
        (s.next = i),
        (i.prev = s),
        i
      )
    }
    function hy(r, e, t, i) {
      var n = new Yh(r, e, t)
      return (
        i
          ? ((n.next = i.next), (n.prev = i), (i.next.prev = n), (i.next = n))
          : ((n.prev = n), (n.next = n)),
        n
      )
    }
    function vs(r) {
      ;((r.next.prev = r.prev),
        (r.prev.next = r.next),
        r.prevZ && (r.prevZ.nextZ = r.nextZ),
        r.nextZ && (r.nextZ.prevZ = r.prevZ))
    }
    function Yh(r, e, t) {
      ;((this.i = r),
        (this.x = e),
        (this.y = t),
        (this.prev = null),
        (this.next = null),
        (this.z = 0),
        (this.prevZ = null),
        (this.nextZ = null),
        (this.steiner = !1))
    }
    pu.deviation = function (r, e, t, i) {
      var n = e && e.length,
        s = n ? e[0] * t : r.length,
        o = Math.abs(Kh(r, 0, s, t))
      if (n)
        for (var a = 0, u = e.length; a < u; a++) {
          var l = e[a] * t,
            c = a < u - 1 ? e[a + 1] * t : r.length
          o -= Math.abs(Kh(r, l, c, t))
        }
      var h = 0
      for (a = 0; a < i.length; a += 3) {
        var f = i[a] * t,
          p = i[a + 1] * t,
          m = i[a + 2] * t
        h += Math.abs((r[f] - r[m]) * (r[p + 1] - r[f + 1]) - (r[f] - r[p]) * (r[m + 1] - r[f + 1]))
      }
      return o === 0 && h === 0 ? 0 : Math.abs((h - o) / o)
    }
    function Kh(r, e, t, i) {
      for (var n = 0, s = e, o = t - i; s < t; s += i)
        ((n += (r[o] - r[s]) * (r[s + 1] + r[o + 1])), (o = s))
      return n
    }
    pu.flatten = function (r) {
      for (
        var e = r[0][0].length, t = { vertices: [], holes: [], dimensions: e }, i = 0, n = 0;
        n < r.length;
        n++
      ) {
        for (var s = 0; s < r[n].length; s++)
          for (var o = 0; o < e; o++) t.vertices.push(r[n][s][o])
        n > 0 && ((i += r[n - 1].length), t.holes.push(i))
      }
      return t
    }
  })
  function gu(r, e, t, i, n, s, o) {
    let a = (0, my.default)(r, e, 2)
    if (!a) return
    for (let l = 0; l < a.length; l += 3)
      ((s[o++] = a[l] + n), (s[o++] = a[l + 1] + n), (s[o++] = a[l + 2] + n))
    let u = n * i
    for (let l = 0; l < r.length; l += 2) ((t[u] = r[l]), (t[u + 1] = r[l + 1]), (u += i))
  }
  var my,
    Zh = d(() => {
      my = Un(qh(), 1)
    })
  var EP,
    gy,
    xy = d(() => {
      D()
      Zh()
      ;((EP = []),
        (gy = {
          extension: { type: _.ShapeBuilder, name: "polygon" },
          build(r, e) {
            for (let t = 0; t < r.points.length; t++) e[t] = r.points[t]
            return e
          },
          triangulate(r, e, t, i, n, s) {
            gu(r, EP, e, t, i, n, s)
          },
        }))
    })
  var _y,
    yy = d(() => {
      D()
      _y = {
        extension: { type: _.ShapeBuilder, name: "rectangle" },
        build(r, e) {
          let t = r,
            i = t.x,
            n = t.y,
            s = t.width,
            o = t.height
          return (
            s >= 0 &&
              o >= 0 &&
              ((e[0] = i),
              (e[1] = n),
              (e[2] = i + s),
              (e[3] = n),
              (e[4] = i + s),
              (e[5] = n + o),
              (e[6] = i),
              (e[7] = n + o)),
            e
          )
        },
        triangulate(r, e, t, i, n, s) {
          let o = 0
          ;((i *= t),
            (e[i + o] = r[0]),
            (e[i + o + 1] = r[1]),
            (o += t),
            (e[i + o] = r[2]),
            (e[i + o + 1] = r[3]),
            (o += t),
            (e[i + o] = r[6]),
            (e[i + o + 1] = r[7]),
            (o += t),
            (e[i + o] = r[4]),
            (e[i + o + 1] = r[5]),
            (o += t))
          let a = i / t
          ;((n[s++] = a),
            (n[s++] = a + 1),
            (n[s++] = a + 2),
            (n[s++] = a + 1),
            (n[s++] = a + 3),
            (n[s++] = a + 2))
        },
      }
    })
  var by,
    vy = d(() => {
      D()
      by = {
        extension: { type: _.ShapeBuilder, name: "triangle" },
        build(r, e) {
          return (
            (e[0] = r.x),
            (e[1] = r.y),
            (e[2] = r.x2),
            (e[3] = r.y2),
            (e[4] = r.x3),
            (e[5] = r.y3),
            e
          )
        },
        triangulate(r, e, t, i, n, s) {
          let o = 0
          ;((i *= t),
            (e[i + o] = r[0]),
            (e[i + o + 1] = r[1]),
            (o += t),
            (e[i + o] = r[2]),
            (e[i + o + 1] = r[3]),
            (o += t),
            (e[i + o] = r[4]),
            (e[i + o + 1] = r[5]))
          let a = i / t
          ;((n[s++] = a), (n[s++] = a + 1), (n[s++] = a + 2))
        },
      }
    })
  function Ty(r, e) {
    for (let t = 0; t < e.length; t++) {
      let i = e[t]
      r.addColorStop(i.offset, i.color)
    }
  }
  function Cy(r, e) {
    let t = Z.get().createCanvas(r, e),
      i = t.getContext("2d")
    return { canvas: t, context: i }
  }
  function wP(r) {
    let e = r[0] ?? {}
    return (
      (typeof e == "number" || r[1]) &&
        (z("8.5.2", "use options object instead"),
        (e = {
          type: "linear",
          start: { x: r[0], y: r[1] },
          end: { x: r[2], y: r[3] },
          textureSpace: r[4],
          textureSize: r[5] ?? ft.defaultLinearOptions.textureSize,
        })),
      e
    )
  }
  var Sy,
    Jh,
    ft,
    tn = d(() => {
      $e()
      Ie()
      se()
      Ja()
      ge()
      Ye()
      Te()
      Hc()
      ;((Sy = [
        { offset: 0, color: "white" },
        { offset: 1, color: "black" },
      ]),
        (Jh = class Qh {
          constructor(...e) {
            ;((this.uid = te("fillGradient")), (this.type = "linear"), (this.colorStops = []))
            let t = wP(e)
            ;((t = {
              ...(t.type === "radial" ? Qh.defaultRadialOptions : Qh.defaultLinearOptions),
              ...Ua(t),
            }),
              (this._textureSize = t.textureSize),
              (this._wrapMode = t.wrapMode),
              t.type === "radial"
                ? ((this.center = t.center),
                  (this.outerCenter = t.outerCenter ?? this.center),
                  (this.innerRadius = t.innerRadius),
                  (this.outerRadius = t.outerRadius),
                  (this.scale = t.scale),
                  (this.rotation = t.rotation))
                : ((this.start = t.start), (this.end = t.end)),
              (this.textureSpace = t.textureSpace),
              (this.type = t.type),
              t.colorStops.forEach((n) => {
                this.addColorStop(n.offset, n.color)
              }))
          }
          addColorStop(e, t) {
            return (this.colorStops.push({ offset: e, color: q.shared.setValue(t).toHexa() }), this)
          }
          buildLinearGradient() {
            if (this.texture) return
            let { x: e, y: t } = this.start,
              { x: i, y: n } = this.end,
              s = i - e,
              o = n - t,
              a = s < 0 || o < 0
            if (this._wrapMode === "clamp-to-edge") {
              if (s < 0) {
                let x = e
                ;((e = i), (i = x), (s *= -1))
              }
              if (o < 0) {
                let x = t
                ;((t = n), (n = x), (o *= -1))
              }
            }
            let u = this.colorStops.length ? this.colorStops : Sy,
              l = this._textureSize,
              { canvas: c, context: h } = Cy(l, 1),
              f = a
                ? h.createLinearGradient(this._textureSize, 0, 0, 0)
                : h.createLinearGradient(0, 0, this._textureSize, 0)
            ;(Ty(f, u),
              (h.fillStyle = f),
              h.fillRect(0, 0, l, 1),
              (this.texture = new I({
                source: new Xt({ resource: c, addressMode: this._wrapMode }),
              })))
            let p = Math.sqrt(s * s + o * o),
              m = Math.atan2(o, s),
              g = new F()
            ;(g.scale(p / l, 1),
              g.rotate(m),
              g.translate(e, t),
              this.textureSpace === "local" && g.scale(l, l),
              (this.transform = g))
          }
          buildGradient() {
            this.type === "linear" ? this.buildLinearGradient() : this.buildRadialGradient()
          }
          buildRadialGradient() {
            if (this.texture) return
            let e = this.colorStops.length ? this.colorStops : Sy,
              t = this._textureSize,
              { canvas: i, context: n } = Cy(t, t),
              { x: s, y: o } = this.center,
              { x: a, y: u } = this.outerCenter,
              l = this.innerRadius,
              c = this.outerRadius,
              h = a - c,
              f = u - c,
              p = t / (c * 2),
              m = (s - h) * p,
              g = (o - f) * p,
              x = n.createRadialGradient(m, g, l * p, (a - h) * p, (u - f) * p, c * p)
            ;(Ty(x, e),
              (n.fillStyle = e[e.length - 1].color),
              n.fillRect(0, 0, t, t),
              (n.fillStyle = x),
              n.translate(m, g),
              n.rotate(this.rotation),
              n.scale(1, this.scale),
              n.translate(-m, -g),
              n.fillRect(0, 0, t, t),
              (this.texture = new I({
                source: new Xt({ resource: i, addressMode: this._wrapMode }),
              })))
            let y = new F()
            ;(y.scale(1 / p, 1 / p),
              y.translate(h, f),
              this.textureSpace === "local" && y.scale(t, t),
              (this.transform = y))
          }
          get styleKey() {
            return this.uid
          }
          destroy() {
            ;(this.texture?.destroy(!0), (this.texture = null))
          }
        }))
      Jh.defaultLinearOptions = {
        start: { x: 0, y: 0 },
        end: { x: 0, y: 1 },
        colorStops: [],
        textureSpace: "local",
        type: "linear",
        textureSize: 256,
        wrapMode: "clamp-to-edge",
      }
      Jh.defaultRadialOptions = {
        center: { x: 0.5, y: 0.5 },
        innerRadius: 0,
        outerRadius: 0.5,
        colorStops: [],
        scale: 1,
        textureSpace: "local",
        type: "radial",
        textureSize: 256,
        wrapMode: "clamp-to-edge",
      }
      ft = Jh
    })
  function Ey(r, e, t, i) {
    let n = e.matrix ? r.copyFrom(e.matrix).invert() : r.identity()
    if (e.textureSpace === "local") {
      let o = t.getBounds(AP)
      e.width && o.pad(e.width)
      let { x: a, y: u } = o,
        l = 1 / o.width,
        c = 1 / o.height,
        h = -a * l,
        f = -u * c,
        p = n.a,
        m = n.b,
        g = n.c,
        x = n.d
      ;((n.a *= l),
        (n.b *= l),
        (n.c *= c),
        (n.d *= c),
        (n.tx = h * p + f * g + n.tx),
        (n.ty = h * m + f * x + n.ty))
    } else
      (n.translate(e.texture.frame.x, e.texture.frame.y),
        n.scale(1 / e.texture.source.width, 1 / e.texture.source.height))
    let s = e.texture.source.style
    return (
      !(e.fill instanceof ft) &&
        s.addressMode === "clamp-to-edge" &&
        ((s.addressMode = "repeat"), s.update()),
      i && n.append(MP.copyFrom(i).invert()),
      n
    )
  }
  var MP,
    AP,
    wy = d(() => {
      se()
      Ke()
      tn()
      ;((MP = new F()), (AP = new ee()))
    })
  function Ay(r, e) {
    let { geometryData: t, batches: i } = e
    ;((i.length = 0), (t.indices.length = 0), (t.vertices.length = 0), (t.uvs.length = 0))
    for (let n = 0; n < r.instructions.length; n++) {
      let s = r.instructions[n]
      if (s.action === "texture") RP(s.data, i, t)
      else if (s.action === "fill" || s.action === "stroke") {
        let o = s.action === "stroke",
          a = s.data.path.shapePath,
          u = s.data.style,
          l = s.data.hole
        ;(o && l && My(l.shapePath, u, !0, i, t),
          l &&
            (a.shapePrimitives[a.shapePrimitives.length - 1].holes = l.shapePath.shapePrimitives),
          My(a, u, o, i, t))
      }
    }
  }
  function RP(r, e, t) {
    let { vertices: i, uvs: n, indices: s } = t,
      o = s.length,
      a = i.length / 2,
      u = [],
      l = xu.rectangle,
      c = DP,
      h = r.image
    ;((c.x = r.dx), (c.y = r.dy), (c.width = r.dw), (c.height = r.dh))
    let f = r.transform
    ;(l.build(c, u), f && Vh(u, f), l.triangulate(u, i, 2, a, s, o))
    let p = h.uvs
    n.push(p.x0, p.y0, p.x1, p.y1, p.x3, p.y3, p.x2, p.y2)
    let m = j.get(di)
    ;((m.indexOffset = o),
      (m.indexSize = s.length - o),
      (m.attributeOffset = a),
      (m.attributeSize = i.length / 2 - a),
      (m.baseColor = r.style),
      (m.alpha = r.alpha),
      (m.texture = h),
      (m.geometryData = t),
      e.push(m))
  }
  function My(r, e, t, i, n) {
    let { vertices: s, uvs: o, indices: a } = n
    r.shapePrimitives.forEach(({ shape: u, transform: l, holes: c }) => {
      let h = a.length,
        f = s.length / 2,
        p = [],
        m = xu[u.type],
        g = "triangle-list"
      if ((m.build(u, p), l && Vh(p, l), t)) {
        let S = u.closePath ?? !0,
          b = e
        b.pixelLine ? (ly(p, S, s, a), (g = "line-list")) : ay(p, b, !1, S, s, a)
      } else if (c) {
        let S = [],
          b = p.slice()
        ;(FP(c).forEach((C) => {
          ;(S.push(b.length / 2), b.push(...C))
        }),
          gu(b, S, s, 2, f, a, h))
      } else m.triangulate(p, s, 2, f, a, h)
      let x = o.length / 2,
        y = e.texture
      if (y !== I.WHITE) {
        let S = Ey(PP, e, u, l)
        Z_(s, 2, f, o, x, 2, s.length / 2 - f, S)
      } else Q_(o, x, 2, s.length / 2 - f)
      let v = j.get(di)
      ;((v.indexOffset = h),
        (v.indexSize = a.length - h),
        (v.attributeOffset = f),
        (v.attributeSize = s.length / 2 - f),
        (v.baseColor = e.color),
        (v.alpha = e.alpha),
        (v.texture = y),
        (v.geometryData = n),
        (v.topology = g),
        i.push(v))
    })
  }
  function FP(r) {
    let e = []
    for (let t = 0; t < r.length; t++) {
      let i = r[t].shape,
        n = []
      ;(xu[i.type].build(i, n), e.push(n))
    }
    return e
  }
  var xu,
    DP,
    PP,
    Dy = d(() => {
      D()
      se()
      Ke()
      J_()
      ey()
      ge()
      it()
      $h()
      iy()
      uy()
      cy()
      xy()
      yy()
      vy()
      wy()
      Zh()
      xu = {}
      L.handleByMap(_.ShapeBuilder, xu)
      L.add(_y, gy, by, Ji, ty, ry)
      ;((DP = new ee()), (PP = new F()))
    })
  var ed,
    td,
    id,
    rn,
    _u = d(() => {
      D()
      nu()
      Wh()
      Lc()
      Te()
      it()
      Dy()
      ;((ed = class {
        constructor() {
          ;((this.batches = []), (this.geometryData = { vertices: [], uvs: [], indices: [] }))
        }
      }),
        (td = class {
          constructor() {
            ;((this.batcher = new _s()), (this.instructions = new Ui()))
          }
          init() {
            this.instructions.reset()
          }
          get geometry() {
            return (
              z(
                Nm,
                "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.",
              ),
              this.batcher.geometry
            )
          }
        }),
        (id = class rd {
          constructor(e) {
            ;((this._gpuContextHash = {}),
              (this._graphicsDataContextHash = Object.create(null)),
              e.renderableGC.addManagedHash(this, "_gpuContextHash"),
              e.renderableGC.addManagedHash(this, "_graphicsDataContextHash"))
          }
          init(e) {
            rd.defaultOptions.bezierSmoothness =
              e?.bezierSmoothness ?? rd.defaultOptions.bezierSmoothness
          }
          getContextRenderData(e) {
            return this._graphicsDataContextHash[e.uid] || this._initContextRenderData(e)
          }
          updateGpuContext(e) {
            let t = this._gpuContextHash[e.uid] || this._initContext(e)
            if (e.dirty) {
              ;(t ? this._cleanGraphicsContextData(e) : (t = this._initContext(e)), Ay(e, t))
              let i = e.batchMode
              ;(e.customShader || i === "no-batch"
                ? (t.isBatchable = !1)
                : i === "auto" && (t.isBatchable = t.geometryData.vertices.length < 400),
                (e.dirty = !1))
            }
            return t
          }
          getGpuContext(e) {
            return this._gpuContextHash[e.uid] || this._initContext(e)
          }
          _initContextRenderData(e) {
            let t = j.get(td),
              { batches: i, geometryData: n } = this._gpuContextHash[e.uid],
              s = n.vertices.length,
              o = n.indices.length
            for (let c = 0; c < i.length; c++) i[c].applyTransform = !1
            let a = t.batcher
            ;(a.ensureAttributeBuffer(s), a.ensureIndexBuffer(o), a.begin())
            for (let c = 0; c < i.length; c++) {
              let h = i[c]
              a.add(h)
            }
            a.finish(t.instructions)
            let u = a.geometry
            ;(u.indexBuffer.setDataWithSize(a.indexBuffer, a.indexSize, !0),
              u.buffers[0].setDataWithSize(a.attributeBuffer.float32View, a.attributeSize, !0))
            let l = a.batches
            for (let c = 0; c < l.length; c++) {
              let h = l[c]
              h.bindGroup = Vi(h.textures.textures, h.textures.count)
            }
            return ((this._graphicsDataContextHash[e.uid] = t), t)
          }
          _initContext(e) {
            let t = new ed()
            return (
              (t.context = e),
              (this._gpuContextHash[e.uid] = t),
              e.on("destroy", this.onGraphicsContextDestroy, this),
              this._gpuContextHash[e.uid]
            )
          }
          onGraphicsContextDestroy(e) {
            ;(this._cleanGraphicsContextData(e),
              e.off("destroy", this.onGraphicsContextDestroy, this),
              (this._gpuContextHash[e.uid] = null))
          }
          _cleanGraphicsContextData(e) {
            let t = this._gpuContextHash[e.uid]
            ;(t.isBatchable ||
              (this._graphicsDataContextHash[e.uid] &&
                (j.return(this.getContextRenderData(e)),
                (this._graphicsDataContextHash[e.uid] = null))),
              t.batches &&
                t.batches.forEach((i) => {
                  j.return(i)
                }))
          }
          destroy() {
            for (let e in this._gpuContextHash)
              this._gpuContextHash[e] &&
                this.onGraphicsContextDestroy(this._gpuContextHash[e].context)
          }
        }))
      id.extension = {
        type: [_.WebGLSystem, _.WebGPUSystem, _.CanvasSystem],
        name: "graphicsContext",
      }
      id.defaultOptions = { bezierSmoothness: 0.5 }
      rn = id
    })
  var BP,
    nd,
    sd,
    od,
    ad,
    ud,
    ld,
    cd,
    Fe,
    Ot = d(() => {
      "use strict"
      ;((BP = {
        normal: 0,
        add: 1,
        multiply: 2,
        screen: 3,
        overlay: 4,
        erase: 5,
        "normal-npm": 6,
        "add-npm": 7,
        "screen-npm": 8,
        min: 9,
        max: 10,
      }),
        (nd = 0),
        (sd = 1),
        (od = 2),
        (ad = 3),
        (ud = 4),
        (ld = 5),
        (cd = class Py {
          constructor() {
            ;((this.data = 0),
              (this.blendMode = "normal"),
              (this.polygonOffset = 0),
              (this.blend = !0),
              (this.depthMask = !0))
          }
          get blend() {
            return !!(this.data & (1 << nd))
          }
          set blend(e) {
            !!(this.data & (1 << nd)) !== e && (this.data ^= 1 << nd)
          }
          get offsets() {
            return !!(this.data & (1 << sd))
          }
          set offsets(e) {
            !!(this.data & (1 << sd)) !== e && (this.data ^= 1 << sd)
          }
          set cullMode(e) {
            if (e === "none") {
              this.culling = !1
              return
            }
            ;((this.culling = !0), (this.clockwiseFrontFace = e === "front"))
          }
          get cullMode() {
            return this.culling ? (this.clockwiseFrontFace ? "front" : "back") : "none"
          }
          get culling() {
            return !!(this.data & (1 << od))
          }
          set culling(e) {
            !!(this.data & (1 << od)) !== e && (this.data ^= 1 << od)
          }
          get depthTest() {
            return !!(this.data & (1 << ad))
          }
          set depthTest(e) {
            !!(this.data & (1 << ad)) !== e && (this.data ^= 1 << ad)
          }
          get depthMask() {
            return !!(this.data & (1 << ld))
          }
          set depthMask(e) {
            !!(this.data & (1 << ld)) !== e && (this.data ^= 1 << ld)
          }
          get clockwiseFrontFace() {
            return !!(this.data & (1 << ud))
          }
          set clockwiseFrontFace(e) {
            !!(this.data & (1 << ud)) !== e && (this.data ^= 1 << ud)
          }
          get blendMode() {
            return this._blendMode
          }
          set blendMode(e) {
            ;((this.blend = e !== "none"), (this._blendMode = e), (this._blendModeId = BP[e] || 0))
          }
          get polygonOffset() {
            return this._polygonOffset
          }
          set polygonOffset(e) {
            ;((this.offsets = !!e), (this._polygonOffset = e))
          }
          toString() {
            return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`
          }
          static for2d() {
            let e = new Py()
            return ((e.depthTest = !1), (e.blend = !0), e)
          }
        }))
      cd.default2d = cd.for2d()
      Fe = cd
    })
  function Jt(r, e, t) {
    let i = ((r >> 24) & 255) / 255
    ;((e[t++] = ((r & 255) / 255) * i),
      (e[t++] = (((r >> 8) & 255) / 255) * i),
      (e[t++] = (((r >> 16) & 255) / 255) * i),
      (e[t++] = i))
  }
  var nn = d(() => {
    "use strict"
  })
  var Ss,
    Ry = d(() => {
      D()
      Ot()
      it()
      nn()
      $h()
      Ss = class {
        constructor(e, t) {
          ;((this.state = Fe.for2d()),
            (this._graphicsBatchesHash = Object.create(null)),
            (this._destroyRenderableBound = this.destroyRenderable.bind(this)),
            (this.renderer = e),
            (this._adaptor = t),
            this._adaptor.init(),
            this.renderer.renderableGC.addManagedHash(this, "_graphicsBatchesHash"))
        }
        validateRenderable(e) {
          let t = e.context,
            i = !!this._graphicsBatchesHash[e.uid],
            n = this.renderer.graphicsContext.updateGpuContext(t)
          return !!(n.isBatchable || i !== n.isBatchable)
        }
        addRenderable(e, t) {
          let i = this.renderer.graphicsContext.updateGpuContext(e.context)
          ;(e.didViewUpdate && this._rebuild(e),
            i.isBatchable
              ? this._addToBatcher(e, t)
              : (this.renderer.renderPipes.batch.break(t), t.add(e)))
        }
        updateRenderable(e) {
          let t = this._graphicsBatchesHash[e.uid]
          if (t)
            for (let i = 0; i < t.length; i++) {
              let n = t[i]
              n._batcher.updateElement(n)
            }
        }
        destroyRenderable(e) {
          ;(this._graphicsBatchesHash[e.uid] && this._removeBatchForRenderable(e.uid),
            e.off("destroyed", this._destroyRenderableBound))
        }
        execute(e) {
          if (!e.isRenderable) return
          let t = this.renderer,
            i = e.context
          if (!t.graphicsContext.getGpuContext(i).batches.length) return
          let s = i.customShader || this._adaptor.shader
          this.state.blendMode = e.groupBlendMode
          let o = s.resources.localUniforms.uniforms
          ;((o.uTransformMatrix = e.groupTransform),
            (o.uRound = t._roundPixels | e._roundPixels),
            Jt(e.groupColorAlpha, o.uColor, 0),
            this._adaptor.execute(this, e))
        }
        _rebuild(e) {
          let t = !!this._graphicsBatchesHash[e.uid],
            i = this.renderer.graphicsContext.updateGpuContext(e.context)
          ;(t && this._removeBatchForRenderable(e.uid),
            i.isBatchable && this._initBatchesForRenderable(e),
            (e.batched = i.isBatchable))
        }
        _addToBatcher(e, t) {
          let i = this.renderer.renderPipes.batch,
            n = this._getBatchesForRenderable(e)
          for (let s = 0; s < n.length; s++) {
            let o = n[s]
            i.addToBatch(o, t)
          }
        }
        _getBatchesForRenderable(e) {
          return this._graphicsBatchesHash[e.uid] || this._initBatchesForRenderable(e)
        }
        _initBatchesForRenderable(e) {
          let t = e.context,
            i = this.renderer.graphicsContext.getGpuContext(t),
            n = this.renderer._roundPixels | e._roundPixels,
            s = i.batches.map((o) => {
              let a = j.get(di)
              return (o.copyTo(a), (a.renderable = e), (a.roundPixels = n), a)
            })
          return (
            this._graphicsBatchesHash[e.uid] === void 0 &&
              e.on("destroyed", this._destroyRenderableBound),
            (this._graphicsBatchesHash[e.uid] = s),
            s
          )
        }
        _removeBatchForRenderable(e) {
          ;(this._graphicsBatchesHash[e].forEach((t) => {
            j.return(t)
          }),
            (this._graphicsBatchesHash[e] = null))
        }
        destroy() {
          ;((this.renderer = null),
            this._adaptor.destroy(),
            (this._adaptor = null),
            (this.state = null))
          for (let e in this._graphicsBatchesHash) this._removeBatchForRenderable(e)
          this._graphicsBatchesHash = null
        }
      }
      Ss.extension = { type: [_.WebGLPipes, _.WebGPUPipes, _.CanvasPipes], name: "graphics" }
    })
  var hd = d(() => {
    D()
    _u()
    Ry()
    L.add(Ss)
    L.add(rn)
  })
  var Br,
    yu = d(() => {
      "use strict"
      Br = class {
        constructor() {
          ;((this.batcherName = "default"),
            (this.packAsQuad = !1),
            (this.indexOffset = 0),
            (this.attributeOffset = 0),
            (this.roundPixels = 0),
            (this._batcher = null),
            (this._batch = null),
            (this._textureMatrixUpdateId = -1),
            (this._uvUpdateId = -1))
        }
        get blendMode() {
          return this.renderable.groupBlendMode
        }
        get topology() {
          return this._topology || this.geometry.topology
        }
        set topology(e) {
          this._topology = e
        }
        reset() {
          ;((this.renderable = null),
            (this.texture = null),
            (this._batcher = null),
            (this._batch = null),
            (this.geometry = null),
            (this._uvUpdateId = -1),
            (this._textureMatrixUpdateId = -1))
        }
        setTexture(e) {
          this.texture !== e && ((this.texture = e), (this._textureMatrixUpdateId = -1))
        }
        get uvs() {
          let t = this.geometry.getBuffer("aUV"),
            i = t.data,
            n = i,
            s = this.texture.textureMatrix
          return (
            s.isSimple ||
              ((n = this._transformedUvs),
              (this._textureMatrixUpdateId !== s._updateID || this._uvUpdateId !== t._updateID) &&
                ((!n || n.length < i.length) &&
                  (n = this._transformedUvs = new Float32Array(i.length)),
                (this._textureMatrixUpdateId = s._updateID),
                (this._uvUpdateId = t._updateID),
                s.multiplyUvs(i, n))),
            n
          )
        }
        get positions() {
          return this.geometry.positions
        }
        get indices() {
          return this.geometry.indices
        }
        get color() {
          return this.renderable.groupColorAlpha
        }
        get groupTransform() {
          return this.renderable.groupTransform
        }
        get attributeSize() {
          return this.geometry.positions.length / 2
        }
        get indexSize() {
          return this.geometry.indices.length
        }
      }
    })
  var Ts,
    Fy = d(() => {
      D()
      se()
      Ar()
      st()
      fs()
      it()
      nn()
      yu()
      Ts = class {
        constructor(e, t) {
          ;((this.localUniforms = new fe({
            uTransformMatrix: { value: new F(), type: "mat3x3<f32>" },
            uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
            uRound: { value: 0, type: "f32" },
          })),
            (this.localUniformsBindGroup = new He({ 0: this.localUniforms })),
            (this._meshDataHash = Object.create(null)),
            (this._gpuBatchableMeshHash = Object.create(null)),
            (this._destroyRenderableBound = this.destroyRenderable.bind(this)),
            (this.renderer = e),
            (this._adaptor = t),
            this._adaptor.init(),
            e.renderableGC.addManagedHash(this, "_gpuBatchableMeshHash"),
            e.renderableGC.addManagedHash(this, "_meshDataHash"))
        }
        validateRenderable(e) {
          let t = this._getMeshData(e),
            i = t.batched,
            n = e.batched
          if (((t.batched = n), i !== n)) return !0
          if (n) {
            let s = e._geometry
            if (s.indices.length !== t.indexSize || s.positions.length !== t.vertexSize)
              return ((t.indexSize = s.indices.length), (t.vertexSize = s.positions.length), !0)
            let o = this._getBatchableMesh(e)
            return (
              o.texture.uid !== e._texture.uid && (o._textureMatrixUpdateId = -1),
              !o._batcher.checkAndUpdateTexture(o, e._texture)
            )
          }
          return !1
        }
        addRenderable(e, t) {
          let i = this.renderer.renderPipes.batch,
            { batched: n } = this._getMeshData(e)
          if (n) {
            let s = this._getBatchableMesh(e)
            ;(s.setTexture(e._texture), (s.geometry = e._geometry), i.addToBatch(s, t))
          } else (i.break(t), t.add(e))
        }
        updateRenderable(e) {
          if (e.batched) {
            let t = this._gpuBatchableMeshHash[e.uid]
            ;(t.setTexture(e._texture), (t.geometry = e._geometry), t._batcher.updateElement(t))
          }
        }
        destroyRenderable(e) {
          this._meshDataHash[e.uid] = null
          let t = this._gpuBatchableMeshHash[e.uid]
          ;(t && (j.return(t), (this._gpuBatchableMeshHash[e.uid] = null)),
            e.off("destroyed", this._destroyRenderableBound))
        }
        execute(e) {
          if (!e.isRenderable) return
          e.state.blendMode = cr(e.groupBlendMode, e.texture._source)
          let t = this.localUniforms
          ;((t.uniforms.uTransformMatrix = e.groupTransform),
            (t.uniforms.uRound = this.renderer._roundPixels | e._roundPixels),
            t.update(),
            Jt(e.groupColorAlpha, t.uniforms.uColor, 0),
            this._adaptor.execute(this, e))
        }
        _getMeshData(e) {
          return this._meshDataHash[e.uid] || this._initMeshData(e)
        }
        _initMeshData(e) {
          return (
            (this._meshDataHash[e.uid] = {
              batched: e.batched,
              indexSize: e._geometry.indices?.length,
              vertexSize: e._geometry.positions?.length,
            }),
            e.on("destroyed", this._destroyRenderableBound),
            this._meshDataHash[e.uid]
          )
        }
        _getBatchableMesh(e) {
          return this._gpuBatchableMeshHash[e.uid] || this._initBatchableMesh(e)
        }
        _initBatchableMesh(e) {
          let t = j.get(Br)
          return (
            (t.renderable = e),
            t.setTexture(e._texture),
            (t.transform = e.groupTransform),
            (t.roundPixels = this.renderer._roundPixels | e._roundPixels),
            (this._gpuBatchableMeshHash[e.uid] = t),
            t
          )
        }
        destroy() {
          for (let e in this._gpuBatchableMeshHash)
            this._gpuBatchableMeshHash[e] && j.return(this._gpuBatchableMeshHash[e])
          ;((this._gpuBatchableMeshHash = null),
            (this._meshDataHash = null),
            (this.localUniforms = null),
            (this.localUniformsBindGroup = null),
            this._adaptor.destroy(),
            (this._adaptor = null),
            (this.renderer = null))
        }
      }
      Ts.extension = { type: [_.WebGLPipes, _.WebGPUPipes, _.CanvasPipes], name: "mesh" }
    })
  var dd = d(() => {
    D()
    Fy()
    L.add(Ts)
  })
  var bu,
    By = d(() => {
      "use strict"
      bu = class {
        execute(e, t) {
          let i = e.state,
            n = e.renderer,
            s = t.shader || e.defaultShader
          ;((s.resources.uTexture = t.texture._source), (s.resources.uniforms = e.localUniforms))
          let o = n.gl,
            a = e.getBuffers(t)
          ;(n.shader.bind(s), n.state.set(i), n.geometry.bind(a.geometry, s.glProgram))
          let l =
            a.geometry.indexBuffer.data.BYTES_PER_ELEMENT === 2 ? o.UNSIGNED_SHORT : o.UNSIGNED_INT
          o.drawElements(o.TRIANGLES, t.particleChildren.length * 6, l, 0)
        }
      }
    })
  function fd(r, e = null) {
    let t = r * 6
    if ((t > 65535 ? e || (e = new Uint32Array(t)) : e || (e = new Uint16Array(t)), e.length !== t))
      throw new Error(`Out buffer length is incorrect, got ${e.length} and expected ${t}`)
    for (let i = 0, n = 0; i < t; i += 6, n += 4)
      ((e[i + 0] = n + 0),
        (e[i + 1] = n + 1),
        (e[i + 2] = n + 2),
        (e[i + 3] = n + 0),
        (e[i + 4] = n + 2),
        (e[i + 5] = n + 3))
    return e
  }
  var Iy = d(() => {
    "use strict"
  })
  function ky(r) {
    return { dynamicUpdate: Gy(r, !0), staticUpdate: Gy(r, !1) }
  }
  function Gy(r, e) {
    let t = []
    t.push(`
      
        var index = 0;

        for (let i = 0; i < ps.length; ++i)
        {
            const p = ps[i];

            `)
    let i = 0
    for (let s in r) {
      let o = r[s]
      if (e !== o.dynamic) continue
      ;(t.push(`offset = index + ${i}`), t.push(o.code))
      let a = dt(o.format)
      i += a.stride / 4
    }
    ;(t.push(`
            index += stride * 4;
        }
    `),
      t.unshift(`
        var stride = ${i};
    `))
    let n = t.join(`
`)
    return new Function("ps", "f32v", "u32v", n)
  }
  var Uy = d(() => {
    hi()
  })
  function IP(r) {
    let e = []
    for (let t in r) {
      let i = r[t]
      e.push(t, i.code, i.dynamic ? "d" : "s")
    }
    return e.join("_")
  }
  var vu,
    Oy = d(() => {
      Dr()
      hr()
      $i()
      hi()
      Eh()
      Iy()
      Uy()
      vu = class {
        constructor(e) {
          ;((this._size = 0), (this._generateParticleUpdateCache = {}))
          let t = (this._size = e.size ?? 1e3),
            i = e.properties,
            n = 0,
            s = 0
          for (let c in i) {
            let h = i[c],
              f = dt(h.format)
            h.dynamic ? (s += f.stride) : (n += f.stride)
          }
          ;((this._dynamicStride = s / 4),
            (this._staticStride = n / 4),
            (this.staticAttributeBuffer = new Yt(t * 4 * n)),
            (this.dynamicAttributeBuffer = new Yt(t * 4 * s)),
            (this.indexBuffer = fd(t)))
          let o = new Mt(),
            a = 0,
            u = 0
          ;((this._staticBuffer = new Ae({
            data: new Float32Array(1),
            label: "static-particle-buffer",
            shrinkToFit: !1,
            usage: Q.VERTEX | Q.COPY_DST,
          })),
            (this._dynamicBuffer = new Ae({
              data: new Float32Array(1),
              label: "dynamic-particle-buffer",
              shrinkToFit: !1,
              usage: Q.VERTEX | Q.COPY_DST,
            })))
          for (let c in i) {
            let h = i[c],
              f = dt(h.format)
            h.dynamic
              ? (o.addAttribute(h.attributeName, {
                  buffer: this._dynamicBuffer,
                  stride: this._dynamicStride * 4,
                  offset: a * 4,
                  format: h.format,
                }),
                (a += f.size))
              : (o.addAttribute(h.attributeName, {
                  buffer: this._staticBuffer,
                  stride: this._staticStride * 4,
                  offset: u * 4,
                  format: h.format,
                }),
                (u += f.size))
          }
          o.addIndex(this.indexBuffer)
          let l = this.getParticleUpdate(i)
          ;((this._dynamicUpload = l.dynamicUpdate),
            (this._staticUpload = l.staticUpdate),
            (this.geometry = o))
        }
        getParticleUpdate(e) {
          let t = IP(e)
          return this._generateParticleUpdateCache[t]
            ? this._generateParticleUpdateCache[t]
            : ((this._generateParticleUpdateCache[t] = this.generateParticleUpdate(e)),
              this._generateParticleUpdateCache[t])
        }
        generateParticleUpdate(e) {
          return ky(e)
        }
        update(e, t) {
          e.length > this._size &&
            ((t = !0),
            (this._size = Math.max(e.length, (this._size * 1.5) | 0)),
            (this.staticAttributeBuffer = new Yt(this._size * this._staticStride * 4 * 4)),
            (this.dynamicAttributeBuffer = new Yt(this._size * this._dynamicStride * 4 * 4)),
            (this.indexBuffer = fd(this._size)),
            this.geometry.indexBuffer.setDataWithSize(
              this.indexBuffer,
              this.indexBuffer.byteLength,
              !0,
            ))
          let i = this.dynamicAttributeBuffer
          if (
            (this._dynamicUpload(e, i.float32View, i.uint32View),
            this._dynamicBuffer.setDataWithSize(
              this.dynamicAttributeBuffer.float32View,
              e.length * this._dynamicStride * 4,
              !0,
            ),
            t)
          ) {
            let n = this.staticAttributeBuffer
            ;(this._staticUpload(e, n.float32View, n.uint32View),
              this._staticBuffer.setDataWithSize(
                n.float32View,
                e.length * this._staticStride * 4,
                !0,
              ))
          }
        }
        destroy() {
          ;(this._staticBuffer.destroy(), this._dynamicBuffer.destroy(), this.geometry.destroy())
        }
      }
    })
  var Ly,
    Ny = d(() => {
      Ly = `varying vec2 vUV;
varying vec4 vColor;

uniform sampler2D uTexture;

void main(void){
    vec4 color = texture2D(uTexture, vUV) * vColor;
    gl_FragColor = color;
}`
    })
  var Hy,
    zy = d(() => {
      Hy = `attribute vec2 aVertex;
attribute vec2 aUV;
attribute vec4 aColor;

attribute vec2 aPosition;
attribute float aRotation;

uniform mat3 uTranslationMatrix;
uniform float uRound;
uniform vec2 uResolution;
uniform vec4 uColor;

varying vec2 vUV;
varying vec4 vColor;

vec2 roundPixels(vec2 position, vec2 targetSize)
{       
    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
}

void main(void){
    float cosRotation = cos(aRotation);
    float sinRotation = sin(aRotation);
    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;
    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;

    vec2 v = vec2(x, y);
    v = v + aPosition;

    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    if(uRound == 1.0)
    {
        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
    }

    vUV = aUV;
    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;
}
`
    })
  var pd,
    Wy = d(() => {
      pd = `
struct ParticleUniforms {
  uProjectionMatrix:mat3x3<f32>,
  uColor:vec4<f32>,
  uResolution:vec2<f32>,
  uRoundPixels:f32,
};

@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;

@group(1) @binding(0) var uTexture: texture_2d<f32>;
@group(1) @binding(1) var uSampler : sampler;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) color : vec4<f32>,
  };
@vertex
fn mainVertex(
  @location(0) aVertex: vec2<f32>,
  @location(1) aPosition: vec2<f32>,
  @location(2) aUV: vec2<f32>,
  @location(3) aColor: vec4<f32>,
  @location(4) aRotation: f32,
) -> VSOutput {
  
   let v = vec2(
       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),
       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)
   ) + aPosition;

   let position = vec4((uniforms.uProjectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;

  return VSOutput(
   position,
   aUV,
   vColor,
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) color: vec4<f32>,
  @builtin(position) position: vec4<f32>,
) -> @location(0) vec4<f32> {

    var sample = textureSample(uTexture, uSampler, uv) * color;
   
    return sample;
}`
    })
  var Su,
    Vy = d(() => {
      $e()
      se()
      ci()
      Yi()
      Ut()
      ge()
      zc()
      Ny()
      zy()
      Wy()
      Su = class extends De {
        constructor() {
          let e = At.from({ vertex: Hy, fragment: Ly }),
            t = Dt.from({
              fragment: { source: pd, entryPoint: "mainFragment" },
              vertex: { source: pd, entryPoint: "mainVertex" },
            })
          super({
            glProgram: e,
            gpuProgram: t,
            resources: {
              uTexture: I.WHITE.source,
              uSampler: new Oa({}),
              uniforms: {
                uTranslationMatrix: { value: new F(), type: "mat3x3<f32>" },
                uColor: { value: new q(16777215), type: "vec4<f32>" },
                uRound: { value: 1, type: "f32" },
                uResolution: { value: [0, 0], type: "vec2<f32>" },
              },
            },
          })
        }
      }
    })
  var sn,
    md = d(() => {
      se()
      st()
      fs()
      Ot()
      nn()
      Oy()
      Vy()
      sn = class {
        constructor(e, t) {
          ;((this.state = Fe.for2d()),
            (this._gpuBufferHash = Object.create(null)),
            (this._destroyRenderableBound = this.destroyRenderable.bind(this)),
            (this.localUniforms = new fe({
              uTranslationMatrix: { value: new F(), type: "mat3x3<f32>" },
              uColor: { value: new Float32Array(4), type: "vec4<f32>" },
              uRound: { value: 1, type: "f32" },
              uResolution: { value: [0, 0], type: "vec2<f32>" },
            })),
            (this.renderer = e),
            (this.adaptor = t),
            (this.defaultShader = new Su()),
            (this.state = Fe.for2d()))
        }
        validateRenderable(e) {
          return !1
        }
        addRenderable(e, t) {
          ;(this.renderer.renderPipes.batch.break(t), t.add(e))
        }
        getBuffers(e) {
          return this._gpuBufferHash[e.uid] || this._initBuffer(e)
        }
        _initBuffer(e) {
          return (
            (this._gpuBufferHash[e.uid] = new vu({
              size: e.particleChildren.length,
              properties: e._properties,
            })),
            e.on("destroyed", this._destroyRenderableBound),
            this._gpuBufferHash[e.uid]
          )
        }
        updateRenderable(e) {}
        destroyRenderable(e) {
          ;(this._gpuBufferHash[e.uid].destroy(),
            (this._gpuBufferHash[e.uid] = null),
            e.off("destroyed", this._destroyRenderableBound))
        }
        execute(e) {
          let t = e.particleChildren
          if (t.length === 0) return
          let i = this.renderer,
            n = this.getBuffers(e)
          e.texture || (e.texture = t[0].texture)
          let s = this.state
          ;(n.update(t, e._childrenDirty),
            (e._childrenDirty = !1),
            (s.blendMode = cr(e.blendMode, e.texture._source)))
          let o = this.localUniforms.uniforms,
            a = o.uTranslationMatrix
          ;(e.worldTransform.copyTo(a),
            a.prepend(i.globalUniforms.globalUniformData.projectionMatrix),
            (o.uResolution = i.globalUniforms.globalUniformData.resolution),
            (o.uRound = i._roundPixels | e._roundPixels),
            Jt(e.groupColorAlpha, o.uColor, 0),
            this.adaptor.execute(this, e))
        }
        destroy() {
          this.defaultShader && (this.defaultShader.destroy(), (this.defaultShader = null))
        }
      }
    })
  var Cs,
    $y = d(() => {
      D()
      By()
      md()
      Cs = class extends sn {
        constructor(e) {
          super(e, new bu())
        }
      }
      Cs.extension = { type: [_.WebGLPipes], name: "particle" }
    })
  var Tu,
    Xy = d(() => {
      "use strict"
      Tu = class {
        execute(e, t) {
          let i = e.renderer,
            n = t.shader || e.defaultShader
          ;((n.groups[0] = i.renderPipes.uniformBatch.getUniformBindGroup(e.localUniforms, !0)),
            (n.groups[1] = i.texture.getTextureBindGroup(t.texture)))
          let s = e.state,
            o = e.getBuffers(t)
          i.encoder.draw({
            geometry: o.geometry,
            shader: t.shader || e.defaultShader,
            state: s,
            size: t.particleChildren.length * 6,
          })
        }
      }
    })
  var Es,
    Yy = d(() => {
      D()
      Xy()
      md()
      Es = class extends sn {
        constructor(e) {
          super(e, new Tu())
        }
      }
      Es.extension = { type: [_.WebGPUPipes], name: "particle" }
    })
  var gd = d(() => {
    D()
    $y()
    Yy()
    L.add(Cs)
    L.add(Es)
  })
  var er,
    ws = d(() => {
      "use strict"
      er = class {
        constructor() {
          ;((this.batcherName = "default"),
            (this.topology = "triangle-list"),
            (this.attributeSize = 4),
            (this.indexSize = 6),
            (this.packAsQuad = !0),
            (this.roundPixels = 0),
            (this._attributeStart = 0),
            (this._batcher = null),
            (this._batch = null))
        }
        get blendMode() {
          return this.renderable.groupBlendMode
        }
        get color() {
          return this.renderable.groupColorAlpha
        }
        reset() {
          ;((this.renderable = null),
            (this.texture = null),
            (this._batcher = null),
            (this._batch = null),
            (this.bounds = null))
        }
      }
    })
  function Ms(r, e) {
    let { texture: t, bounds: i } = r
    qa(i, e._anchor, t)
    let n = e._style.padding
    ;((i.minX -= n), (i.minY -= n), (i.maxX -= n), (i.maxY -= n))
  }
  var xd = d(() => {
    mh()
  })
  var As,
    Ky = d(() => {
      D()
      it()
      ws()
      xd()
      As = class {
        constructor(e) {
          ;((this._gpuText = Object.create(null)),
            (this._destroyRenderableBound = this.destroyRenderable.bind(this)),
            (this._renderer = e),
            this._renderer.runners.resolutionChange.add(this),
            this._renderer.renderableGC.addManagedHash(this, "_gpuText"))
        }
        resolutionChange() {
          for (let e in this._gpuText) {
            let t = this._gpuText[e]
            if (!t) continue
            let i = t.batchableSprite.renderable
            i._autoResolution && ((i._resolution = this._renderer.resolution), i.onViewUpdate())
          }
        }
        validateRenderable(e) {
          let t = this._getGpuText(e),
            i = e._getKey()
          return t.currentKey !== i
        }
        addRenderable(e, t) {
          let n = this._getGpuText(e).batchableSprite
          ;(e._didTextUpdate && this._updateText(e),
            this._renderer.renderPipes.batch.addToBatch(n, t))
        }
        updateRenderable(e) {
          let i = this._getGpuText(e).batchableSprite
          ;(e._didTextUpdate && this._updateText(e), i._batcher.updateElement(i))
        }
        destroyRenderable(e) {
          ;(e.off("destroyed", this._destroyRenderableBound), this._destroyRenderableById(e.uid))
        }
        _destroyRenderableById(e) {
          let t = this._gpuText[e]
          ;(this._renderer.canvasText.decreaseReferenceCount(t.currentKey),
            j.return(t.batchableSprite),
            (this._gpuText[e] = null))
        }
        _updateText(e) {
          let t = e._getKey(),
            i = this._getGpuText(e),
            n = i.batchableSprite
          ;(i.currentKey !== t && this._updateGpuText(e), (e._didTextUpdate = !1), Ms(n, e))
        }
        _updateGpuText(e) {
          let t = this._getGpuText(e),
            i = t.batchableSprite
          ;(t.texture && this._renderer.canvasText.decreaseReferenceCount(t.currentKey),
            (t.texture = i.texture = this._renderer.canvasText.getManagedTexture(e)),
            (t.currentKey = e._getKey()),
            (i.texture = t.texture))
        }
        _getGpuText(e) {
          return this._gpuText[e.uid] || this.initGpuText(e)
        }
        initGpuText(e) {
          let t = { texture: null, currentKey: "--", batchableSprite: j.get(er) }
          return (
            (t.batchableSprite.renderable = e),
            (t.batchableSprite.transform = e.groupTransform),
            (t.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }),
            (t.batchableSprite.roundPixels = this._renderer._roundPixels | e._roundPixels),
            (this._gpuText[e.uid] = t),
            (e._resolution = e._autoResolution ? this._renderer.resolution : e.resolution),
            this._updateText(e),
            e.on("destroyed", this._destroyRenderableBound),
            t
          )
        }
        destroy() {
          for (let e in this._gpuText) this._destroyRenderableById(e)
          ;((this._gpuText = null), (this._renderer = null))
        }
      }
      As.extension = { type: [_.WebGLPipes, _.WebGPUPipes, _.CanvasPipes], name: "text" }
    })
  var _d,
    pt,
    on = d(() => {
      Ie()
      Zn()
      ;((_d = class {
        constructor(e) {
          ;((this._canvasPool = Object.create(null)),
            (this.canvasOptions = e || {}),
            (this.enableFullScreen = !1))
        }
        _createCanvasAndContext(e, t) {
          let i = Z.get().createCanvas()
          ;((i.width = e), (i.height = t))
          let n = i.getContext("2d")
          return { canvas: i, context: n }
        }
        getOptimalCanvasAndContext(e, t, i = 1) {
          ;((e = Math.ceil(e * i - 1e-6)), (t = Math.ceil(t * i - 1e-6)), (e = ar(e)), (t = ar(t)))
          let n = (e << 17) + (t << 1)
          this._canvasPool[n] || (this._canvasPool[n] = [])
          let s = this._canvasPool[n].pop()
          return (s || (s = this._createCanvasAndContext(e, t)), s)
        }
        returnCanvasAndContext(e) {
          let t = e.canvas,
            { width: i, height: n } = t,
            s = (i << 17) + (n << 1)
          ;(e.context.clearRect(0, 0, i, n), this._canvasPool[s].push(e))
        }
        clear() {
          this._canvasPool = {}
        }
      }),
        (pt = new _d()))
    })
  function jy(r, e, t) {
    for (let i = 0, n = 4 * t * e; i < e; ++i, n += 4) if (r[n + 3] !== 0) return !1
    return !0
  }
  function qy(r, e, t, i, n) {
    let s = 4 * e
    for (let o = i, a = i * s + 4 * t; o <= n; ++o, a += s) if (r[a + 3] !== 0) return !1
    return !0
  }
  function Zy(r, e = 1) {
    let { width: t, height: i } = r,
      n = r.getContext("2d", { willReadFrequently: !0 })
    if (n === null) throw new TypeError("Failed to get canvas 2D context")
    let o = n.getImageData(0, 0, t, i).data,
      a = 0,
      u = 0,
      l = t - 1,
      c = i - 1
    for (; u < i && jy(o, t, u); ) ++u
    if (u === i) return ee.EMPTY
    for (; jy(o, t, c); ) --c
    for (; qy(o, t, a, u, c); ) ++a
    for (; qy(o, t, l, u, c); ) --l
    return (++l, ++c, new ee(a / e, u / e, (l - a) / e, (c - u) / e))
  }
  var Qy = d(() => {
    Ke()
  })
  var Jy,
    fr,
    Cu = d(() => {
      se()
      Ye()
      ;((Jy = {
        repeat: { addressModeU: "repeat", addressModeV: "repeat" },
        "repeat-x": { addressModeU: "repeat", addressModeV: "clamp-to-edge" },
        "repeat-y": { addressModeU: "clamp-to-edge", addressModeV: "repeat" },
        "no-repeat": { addressModeU: "clamp-to-edge", addressModeV: "clamp-to-edge" },
      }),
        (fr = class {
          constructor(e, t) {
            ;((this.uid = te("fillPattern")),
              (this.transform = new F()),
              (this._styleKey = null),
              (this.texture = e),
              this.transform.scale(1 / e.frame.width, 1 / e.frame.height),
              t &&
                ((e.source.style.addressModeU = Jy[t].addressModeU),
                (e.source.style.addressModeV = Jy[t].addressModeV)))
          }
          setTransform(e) {
            let t = this.texture
            ;(this.transform.copyFrom(e),
              this.transform.invert(),
              this.transform.scale(1 / t.frame.width, 1 / t.frame.height),
              (this._styleKey = null))
          }
          get styleKey() {
            return this._styleKey
              ? this._styleKey
              : ((this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`),
                this._styleKey)
          }
        }))
    })
  var tb = ga((k8, eb) => {
    eb.exports = kP
    var yd = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 },
      GP = /([astvzqmhlc])([^astvzqmhlc]*)/gi
    function kP(r) {
      var e = []
      return (
        r.replace(GP, function (t, i, n) {
          var s = i.toLowerCase()
          for (
            n = OP(n),
              s == "m" &&
                n.length > 2 &&
                (e.push([i].concat(n.splice(0, 2))), (s = "l"), (i = i == "m" ? "l" : "L"));
            ;

          ) {
            if (n.length == yd[s]) return (n.unshift(i), e.push(n))
            if (n.length < yd[s]) throw new Error("malformed path data")
            e.push([i].concat(n.splice(0, yd[s])))
          }
        }),
        e
      )
    }
    var UP = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/gi
    function OP(r) {
      var e = r.match(UP)
      return e ? e.map(Number) : []
    }
  })
  function ib(r, e) {
    let t = (0, rb.default)(r),
      i = [],
      n = null,
      s = 0,
      o = 0
    for (let a = 0; a < t.length; a++) {
      let u = t[a],
        l = u[0],
        c = u
      switch (l) {
        case "M":
          ;((s = c[1]), (o = c[2]), e.moveTo(s, o))
          break
        case "m":
          ;((s += c[1]), (o += c[2]), e.moveTo(s, o))
          break
        case "H":
          ;((s = c[1]), e.lineTo(s, o))
          break
        case "h":
          ;((s += c[1]), e.lineTo(s, o))
          break
        case "V":
          ;((o = c[1]), e.lineTo(s, o))
          break
        case "v":
          ;((o += c[1]), e.lineTo(s, o))
          break
        case "L":
          ;((s = c[1]), (o = c[2]), e.lineTo(s, o))
          break
        case "l":
          ;((s += c[1]), (o += c[2]), e.lineTo(s, o))
          break
        case "C":
          ;((s = c[5]), (o = c[6]), e.bezierCurveTo(c[1], c[2], c[3], c[4], s, o))
          break
        case "c":
          ;(e.bezierCurveTo(s + c[1], o + c[2], s + c[3], o + c[4], s + c[5], o + c[6]),
            (s += c[5]),
            (o += c[6]))
          break
        case "S":
          ;((s = c[3]), (o = c[4]), e.bezierCurveToShort(c[1], c[2], s, o))
          break
        case "s":
          ;(e.bezierCurveToShort(s + c[1], o + c[2], s + c[3], o + c[4]), (s += c[3]), (o += c[4]))
          break
        case "Q":
          ;((s = c[3]), (o = c[4]), e.quadraticCurveTo(c[1], c[2], s, o))
          break
        case "q":
          ;(e.quadraticCurveTo(s + c[1], o + c[2], s + c[3], o + c[4]), (s += c[3]), (o += c[4]))
          break
        case "T":
          ;((s = c[1]), (o = c[2]), e.quadraticCurveToShort(s, o))
          break
        case "t":
          ;((s += c[1]), (o += c[2]), e.quadraticCurveToShort(s, o))
          break
        case "A":
          ;((s = c[6]), (o = c[7]), e.arcToSvg(c[1], c[2], c[3], c[4], c[5], s, o))
          break
        case "a":
          ;((s += c[6]), (o += c[7]), e.arcToSvg(c[1], c[2], c[3], c[4], c[5], s, o))
          break
        case "Z":
        case "z":
          ;(e.closePath(),
            i.length > 0 &&
              ((n = i.pop()), n ? ((s = n.startX), (o = n.startY)) : ((s = 0), (o = 0))),
            (n = null))
          break
        default:
          H(`Unknown SVG path command: ${l}`)
      }
      l !== "Z" && l !== "z" && n === null && ((n = { startX: s, startY: o }), i.push(n))
    }
    return e
  }
  var rb,
    nb = d(() => {
      rb = Un(tb(), 1)
      be()
    })
  var mi,
    bd = d(() => {
      Ke()
      mi = class r {
        constructor(e = 0, t = 0, i = 0) {
          ;((this.type = "circle"), (this.x = e), (this.y = t), (this.radius = i))
        }
        clone() {
          return new r(this.x, this.y, this.radius)
        }
        contains(e, t) {
          if (this.radius <= 0) return !1
          let i = this.radius * this.radius,
            n = this.x - e,
            s = this.y - t
          return ((n *= n), (s *= s), n + s <= i)
        }
        strokeContains(e, t, i, n = 0.5) {
          if (this.radius === 0) return !1
          let s = this.x - e,
            o = this.y - t,
            a = this.radius,
            u = (1 - n) * i,
            l = Math.sqrt(s * s + o * o)
          return l <= a + u && l > a - (i - u)
        }
        getBounds(e) {
          return (
            e || (e = new ee()),
            (e.x = this.x - this.radius),
            (e.y = this.y - this.radius),
            (e.width = this.radius * 2),
            (e.height = this.radius * 2),
            e
          )
        }
        copyFrom(e) {
          return ((this.x = e.x), (this.y = e.y), (this.radius = e.radius), this)
        }
        copyTo(e) {
          return (e.copyFrom(this), e)
        }
        toString() {
          return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`
        }
      }
    })
  var Eu,
    sb = d(() => {
      Ke()
      Eu = class r {
        constructor(e = 0, t = 0, i = 0, n = 0) {
          ;((this.type = "ellipse"),
            (this.x = e),
            (this.y = t),
            (this.halfWidth = i),
            (this.halfHeight = n))
        }
        clone() {
          return new r(this.x, this.y, this.halfWidth, this.halfHeight)
        }
        contains(e, t) {
          if (this.halfWidth <= 0 || this.halfHeight <= 0) return !1
          let i = (e - this.x) / this.halfWidth,
            n = (t - this.y) / this.halfHeight
          return ((i *= i), (n *= n), i + n <= 1)
        }
        strokeContains(e, t, i, n = 0.5) {
          let { halfWidth: s, halfHeight: o } = this
          if (s <= 0 || o <= 0) return !1
          let a = i * (1 - n),
            u = i - a,
            l = s - u,
            c = o - u,
            h = s + a,
            f = o + a,
            p = e - this.x,
            m = t - this.y,
            g = (p * p) / (l * l) + (m * m) / (c * c),
            x = (p * p) / (h * h) + (m * m) / (f * f)
          return g > 1 && x <= 1
        }
        getBounds(e) {
          return (
            e || (e = new ee()),
            (e.x = this.x - this.halfWidth),
            (e.y = this.y - this.halfHeight),
            (e.width = this.halfWidth * 2),
            (e.height = this.halfHeight * 2),
            e
          )
        }
        copyFrom(e) {
          return (
            (this.x = e.x),
            (this.y = e.y),
            (this.halfWidth = e.halfWidth),
            (this.halfHeight = e.halfHeight),
            this
          )
        }
        copyTo(e) {
          return (e.copyFrom(this), e)
        }
        toString() {
          return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`
        }
      }
    })
  function ob(r, e, t, i, n, s) {
    let o = r - t,
      a = e - i,
      u = n - t,
      l = s - i,
      c = o * u + a * l,
      h = u * u + l * l,
      f = -1
    h !== 0 && (f = c / h)
    let p, m
    f < 0 ? ((p = t), (m = i)) : f > 1 ? ((p = n), (m = s)) : ((p = t + f * u), (m = i + f * l))
    let g = r - p,
      x = e - m
    return g * g + x * x
  }
  var ab = d(() => {
    "use strict"
  })
  var LP,
    NP,
    an,
    ub = d(() => {
      ab()
      Ke()
      an = class r {
        constructor(...e) {
          this.type = "polygon"
          let t = Array.isArray(e[0]) ? e[0] : e
          if (typeof t[0] != "number") {
            let i = []
            for (let n = 0, s = t.length; n < s; n++) i.push(t[n].x, t[n].y)
            t = i
          }
          ;((this.points = t), (this.closePath = !0))
        }
        isClockwise() {
          let e = 0,
            t = this.points,
            i = t.length
          for (let n = 0; n < i; n += 2) {
            let s = t[n],
              o = t[n + 1],
              a = t[(n + 2) % i],
              u = t[(n + 3) % i]
            e += (a - s) * (u + o)
          }
          return e < 0
        }
        containsPolygon(e) {
          let t = this.getBounds(LP),
            i = e.getBounds(NP)
          if (!t.containsRect(i)) return !1
          let n = e.points
          for (let s = 0; s < n.length; s += 2) {
            let o = n[s],
              a = n[s + 1]
            if (!this.contains(o, a)) return !1
          }
          return !0
        }
        clone() {
          let e = this.points.slice(),
            t = new r(e)
          return ((t.closePath = this.closePath), t)
        }
        contains(e, t) {
          let i = !1,
            n = this.points.length / 2
          for (let s = 0, o = n - 1; s < n; o = s++) {
            let a = this.points[s * 2],
              u = this.points[s * 2 + 1],
              l = this.points[o * 2],
              c = this.points[o * 2 + 1]
            u > t != c > t && e < (l - a) * ((t - u) / (c - u)) + a && (i = !i)
          }
          return i
        }
        strokeContains(e, t, i, n = 0.5) {
          let s = i * i,
            o = s * (1 - n),
            a = s - o,
            { points: u } = this,
            l = u.length - (this.closePath ? 0 : 2)
          for (let c = 0; c < l; c += 2) {
            let h = u[c],
              f = u[c + 1],
              p = u[(c + 2) % u.length],
              m = u[(c + 3) % u.length],
              g = ob(e, t, h, f, p, m),
              x = Math.sign((p - h) * (t - f) - (m - f) * (e - h))
            if (g <= (x < 0 ? a : o)) return !0
          }
          return !1
        }
        getBounds(e) {
          e || (e = new ee())
          let t = this.points,
            i = 1 / 0,
            n = -1 / 0,
            s = 1 / 0,
            o = -1 / 0
          for (let a = 0, u = t.length; a < u; a += 2) {
            let l = t[a],
              c = t[a + 1]
            ;((i = l < i ? l : i), (n = l > n ? l : n), (s = c < s ? c : s), (o = c > o ? c : o))
          }
          return ((e.x = i), (e.width = n - i), (e.y = s), (e.height = o - s), e)
        }
        copyFrom(e) {
          return ((this.points = e.points.slice()), (this.closePath = e.closePath), this)
        }
        copyTo(e) {
          return (e.copyFrom(this), e)
        }
        toString() {
          return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((e, t) => `${e}, ${t}`, "")}]`
        }
        get lastX() {
          return this.points[this.points.length - 2]
        }
        get lastY() {
          return this.points[this.points.length - 1]
        }
        get x() {
          return this.points[this.points.length - 2]
        }
        get y() {
          return this.points[this.points.length - 1]
        }
      }
    })
  var wu,
    Mu,
    lb = d(() => {
      Ke()
      ;((wu = (r, e, t, i, n, s, o) => {
        let a = r - t,
          u = e - i,
          l = Math.sqrt(a * a + u * u)
        return l >= n - s && l <= n + o
      }),
        (Mu = class r {
          constructor(e = 0, t = 0, i = 0, n = 0, s = 20) {
            ;((this.type = "roundedRectangle"),
              (this.x = e),
              (this.y = t),
              (this.width = i),
              (this.height = n),
              (this.radius = s))
          }
          getBounds(e) {
            return (
              e || (e = new ee()),
              (e.x = this.x),
              (e.y = this.y),
              (e.width = this.width),
              (e.height = this.height),
              e
            )
          }
          clone() {
            return new r(this.x, this.y, this.width, this.height, this.radius)
          }
          copyFrom(e) {
            return (
              (this.x = e.x),
              (this.y = e.y),
              (this.width = e.width),
              (this.height = e.height),
              this
            )
          }
          copyTo(e) {
            return (e.copyFrom(this), e)
          }
          contains(e, t) {
            if (this.width <= 0 || this.height <= 0) return !1
            if (
              e >= this.x &&
              e <= this.x + this.width &&
              t >= this.y &&
              t <= this.y + this.height
            ) {
              let i = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2))
              if (
                (t >= this.y + i && t <= this.y + this.height - i) ||
                (e >= this.x + i && e <= this.x + this.width - i)
              )
                return !0
              let n = e - (this.x + i),
                s = t - (this.y + i),
                o = i * i
              if (
                n * n + s * s <= o ||
                ((n = e - (this.x + this.width - i)), n * n + s * s <= o) ||
                ((s = t - (this.y + this.height - i)), n * n + s * s <= o) ||
                ((n = e - (this.x + i)), n * n + s * s <= o)
              )
                return !0
            }
            return !1
          }
          strokeContains(e, t, i, n = 0.5) {
            let { x: s, y: o, width: a, height: u, radius: l } = this,
              c = i * (1 - n),
              h = i - c,
              f = s + l,
              p = o + l,
              m = a - l * 2,
              g = u - l * 2,
              x = s + a,
              y = o + u
            return (((e >= s - c && e <= s + h) || (e >= x - h && e <= x + c)) &&
              t >= p &&
              t <= p + g) ||
              (((t >= o - c && t <= o + h) || (t >= y - h && t <= y + c)) && e >= f && e <= f + m)
              ? !0
              : (e < f && t < p && wu(e, t, f, p, l, h, c)) ||
                  (e > x - l && t < p && wu(e, t, x - l, p, l, h, c)) ||
                  (e > x - l && t > y - l && wu(e, t, x - l, y - l, l, h, c)) ||
                  (e < f && t > y - l && wu(e, t, f, y - l, l, h, c))
          }
          toString() {
            return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`
          }
        }))
    })
  function Du(r, e, t, i, n, s, o, a, u, l) {
    let h = Math.min(0.99, Math.max(0, l ?? rn.defaultOptions.bezierSmoothness)),
      f = (zP - h) / 1
    return ((f *= f), WP(e, t, i, n, s, o, a, u, r, f), r)
  }
  function WP(r, e, t, i, n, s, o, a, u, l) {
    ;(Sd(r, e, t, i, n, s, o, a, u, l, 0), u.push(o, a))
  }
  function Sd(r, e, t, i, n, s, o, a, u, l, c) {
    if (c > HP) return
    let h = Math.PI,
      f = (r + t) / 2,
      p = (e + i) / 2,
      m = (t + n) / 2,
      g = (i + s) / 2,
      x = (n + o) / 2,
      y = (s + a) / 2,
      v = (f + m) / 2,
      S = (p + g) / 2,
      b = (m + x) / 2,
      M = (g + y) / 2,
      C = (v + b) / 2,
      w = (S + M) / 2
    if (c > 0) {
      let B = o - r,
        O = a - e,
        G = Math.abs((t - o) * O - (i - a) * B),
        A = Math.abs((n - o) * O - (s - a) * B),
        W,
        Y
      if (G > Au && A > Au) {
        if ((G + A) * (G + A) <= l * (B * B + O * O)) {
          if (un < vd) {
            u.push(C, w)
            return
          }
          let T = Math.atan2(s - i, n - t)
          if (
            ((W = Math.abs(T - Math.atan2(i - e, t - r))),
            (Y = Math.abs(Math.atan2(a - s, o - n) - T)),
            W >= h && (W = 2 * h - W),
            Y >= h && (Y = 2 * h - Y),
            W + Y < un)
          ) {
            u.push(C, w)
            return
          }
          if (gi !== 0) {
            if (W > gi) {
              u.push(t, i)
              return
            }
            if (Y > gi) {
              u.push(n, s)
              return
            }
          }
        }
      } else if (G > Au) {
        if (G * G <= l * (B * B + O * O)) {
          if (un < vd) {
            u.push(C, w)
            return
          }
          if (
            ((W = Math.abs(Math.atan2(s - i, n - t) - Math.atan2(i - e, t - r))),
            W >= h && (W = 2 * h - W),
            W < un)
          ) {
            ;(u.push(t, i), u.push(n, s))
            return
          }
          if (gi !== 0 && W > gi) {
            u.push(t, i)
            return
          }
        }
      } else if (A > Au) {
        if (A * A <= l * (B * B + O * O)) {
          if (un < vd) {
            u.push(C, w)
            return
          }
          if (
            ((W = Math.abs(Math.atan2(a - s, o - n) - Math.atan2(s - i, n - t))),
            W >= h && (W = 2 * h - W),
            W < un)
          ) {
            ;(u.push(t, i), u.push(n, s))
            return
          }
          if (gi !== 0 && W > gi) {
            u.push(n, s)
            return
          }
        }
      } else if (((B = C - (r + o) / 2), (O = w - (e + a) / 2), B * B + O * O <= l)) {
        u.push(C, w)
        return
      }
    }
    ;(Sd(r, e, f, p, v, S, C, w, u, l, c + 1), Sd(C, w, b, M, x, y, o, a, u, l, c + 1))
  }
  var HP,
    Au,
    zP,
    vd,
    un,
    gi,
    Td = d(() => {
      _u()
      ;((HP = 8), (Au = 11920929e-14), (zP = 1), (vd = 0.01), (un = 0), (gi = 0))
    })
  function hb(r, e, t, i, n, s, o, a) {
    let l = Math.min(0.99, Math.max(0, a ?? rn.defaultOptions.bezierSmoothness)),
      c = (XP - l) / 1
    return ((c *= c), KP(e, t, i, n, s, o, r, c), r)
  }
  function KP(r, e, t, i, n, s, o, a) {
    ;(Cd(o, r, e, t, i, n, s, a, 0), o.push(n, s))
  }
  function Cd(r, e, t, i, n, s, o, a, u) {
    if (u > VP) return
    let l = Math.PI,
      c = (e + i) / 2,
      h = (t + n) / 2,
      f = (i + s) / 2,
      p = (n + o) / 2,
      m = (c + f) / 2,
      g = (h + p) / 2,
      x = s - e,
      y = o - t,
      v = Math.abs((i - s) * y - (n - o) * x)
    if (v > $P) {
      if (v * v <= a * (x * x + y * y)) {
        if (cb < YP) {
          r.push(m, g)
          return
        }
        let S = Math.abs(Math.atan2(o - n, s - i) - Math.atan2(n - t, i - e))
        if ((S >= l && (S = 2 * l - S), S < cb)) {
          r.push(m, g)
          return
        }
      }
    } else if (((x = m - (e + s) / 2), (y = g - (t + o) / 2), x * x + y * y <= a)) {
      r.push(m, g)
      return
    }
    ;(Cd(r, e, t, c, h, m, g, a, u + 1), Cd(r, m, g, f, p, s, o, a, u + 1))
  }
  var VP,
    $P,
    XP,
    YP,
    cb,
    db = d(() => {
      _u()
      ;((VP = 8), ($P = 11920929e-14), (XP = 1), (YP = 0.01), (cb = 0))
    })
  function Pu(r, e, t, i, n, s, o, a) {
    let u = Math.abs(n - s)
    ;(((!o && n > s) || (o && s > n)) && (u = 2 * Math.PI - u),
      a || (a = Math.max(6, Math.floor(6 * Math.pow(i, 1 / 3) * (u / Math.PI)))),
      (a = Math.max(a, 3)))
    let l = u / a,
      c = n
    l *= o ? -1 : 1
    for (let h = 0; h < a + 1; h++) {
      let f = Math.cos(c),
        p = Math.sin(c),
        m = e + f * i,
        g = t + p * i
      ;(r.push(m, g), (c += l))
    }
  }
  var Ed = d(() => {
    "use strict"
  })
  function fb(r, e, t, i, n, s) {
    let o = r[r.length - 2],
      u = r[r.length - 1] - t,
      l = o - e,
      c = n - t,
      h = i - e,
      f = Math.abs(u * h - l * c)
    if (f < 1e-8 || s === 0) {
      ;(r[r.length - 2] !== e || r[r.length - 1] !== t) && r.push(e, t)
      return
    }
    let p = u * u + l * l,
      m = c * c + h * h,
      g = u * c + l * h,
      x = (s * Math.sqrt(p)) / f,
      y = (s * Math.sqrt(m)) / f,
      v = (x * g) / p,
      S = (y * g) / m,
      b = x * h + y * l,
      M = x * c + y * u,
      C = l * (y + v),
      w = u * (y + v),
      B = h * (x + S),
      O = c * (x + S),
      G = Math.atan2(w - M, C - b),
      A = Math.atan2(O - M, B - b)
    Pu(r, b + e, M + t, s, G, A, l * c > h * u)
  }
  var pb = d(() => {
    Ed()
  })
  function jP(r, e) {
    let t = e === -1.5707963267948966 ? -0.551915024494 : 1.3333333333333333 * Math.tan(e / 4),
      i = e === 1.5707963267948966 ? 0.551915024494 : t,
      n = Math.cos(r),
      s = Math.sin(r),
      o = Math.cos(r + e),
      a = Math.sin(r + e)
    return [
      { x: n - s * i, y: s + n * i },
      { x: o + a * i, y: a - o * i },
      { x: o, y: a },
    ]
  }
  function gb(r, e, t, i, n, s, o, a = 0, u = 0, l = 0) {
    if (s === 0 || o === 0) return
    let c = Math.sin((a * Ds) / 360),
      h = Math.cos((a * Ds) / 360),
      f = (h * (e - i)) / 2 + (c * (t - n)) / 2,
      p = (-c * (e - i)) / 2 + (h * (t - n)) / 2
    if (f === 0 && p === 0) return
    ;((s = Math.abs(s)), (o = Math.abs(o)))
    let m = Math.pow(f, 2) / Math.pow(s, 2) + Math.pow(p, 2) / Math.pow(o, 2)
    ;(m > 1 && ((s *= Math.sqrt(m)), (o *= Math.sqrt(m))),
      qP(e, t, i, n, s, o, u, l, c, h, f, p, wd))
    let { ang1: g, ang2: x } = wd,
      { centerX: y, centerY: v } = wd,
      S = Math.abs(x) / (Ds / 4)
    Math.abs(1 - S) < 1e-7 && (S = 1)
    let b = Math.max(Math.ceil(S), 1)
    x /= b
    let M = r[r.length - 2],
      C = r[r.length - 1],
      w = { x: 0, y: 0 }
    for (let B = 0; B < b; B++) {
      let O = jP(g, x),
        { x: G, y: A } = Md(O[0], s, o, h, c, y, v, w),
        { x: W, y: Y } = Md(O[1], s, o, h, c, y, v, w),
        { x: T, y: N } = Md(O[2], s, o, h, c, y, v, w)
      ;(Du(r, M, C, G, A, W, Y, T, N), (M = T), (C = N), (g += x))
    }
  }
  var Ds,
    wd,
    Md,
    mb,
    qP,
    xb = d(() => {
      Td()
      ;((Ds = Math.PI * 2),
        (wd = { centerX: 0, centerY: 0, ang1: 0, ang2: 0 }),
        (Md = ({ x: r, y: e }, t, i, n, s, o, a, u) => {
          ;((r *= t), (e *= i))
          let l = n * r - s * e,
            c = s * r + n * e
          return ((u.x = l + o), (u.y = c + a), u)
        }))
      ;((mb = (r, e, t, i) => {
        let n = r * i - e * t < 0 ? -1 : 1,
          s = r * t + e * i
        return (s > 1 && (s = 1), s < -1 && (s = -1), n * Math.acos(s))
      }),
        (qP = (r, e, t, i, n, s, o, a, u, l, c, h, f) => {
          let p = Math.pow(n, 2),
            m = Math.pow(s, 2),
            g = Math.pow(c, 2),
            x = Math.pow(h, 2),
            y = p * m - p * x - m * g
          ;(y < 0 && (y = 0), (y /= p * x + m * g), (y = Math.sqrt(y) * (o === a ? -1 : 1)))
          let v = ((y * n) / s) * h,
            S = ((y * -s) / n) * c,
            b = l * v - u * S + (r + t) / 2,
            M = u * v + l * S + (e + i) / 2,
            C = (c - v) / n,
            w = (h - S) / s,
            B = (-c - v) / n,
            O = (-h - S) / s,
            G = mb(1, 0, C, w),
            A = mb(C, w, B, O)
          ;(a === 0 && A > 0 && (A -= Ds),
            a === 1 && A < 0 && (A += Ds),
            (f.centerX = b),
            (f.centerY = M),
            (f.ang1 = G),
            (f.ang2 = A))
        }))
    })
  function _b(r, e, t) {
    let i = (o, a) => {
        let u = a.x - o.x,
          l = a.y - o.y,
          c = Math.sqrt(u * u + l * l),
          h = u / c,
          f = l / c
        return { len: c, nx: h, ny: f }
      },
      n = (o, a) => {
        o === 0 ? r.moveTo(a.x, a.y) : r.lineTo(a.x, a.y)
      },
      s = e[e.length - 1]
    for (let o = 0; o < e.length; o++) {
      let a = e[o % e.length],
        u = a.radius ?? t
      if (u <= 0) {
        ;(n(o, a), (s = a))
        continue
      }
      let l = e[(o + 1) % e.length],
        c = i(a, s),
        h = i(a, l)
      if (c.len < 1e-4 || h.len < 1e-4) {
        ;(n(o, a), (s = a))
        continue
      }
      let f = Math.asin(c.nx * h.ny - c.ny * h.nx),
        p = 1,
        m = !1
      c.nx * h.nx - c.ny * -h.ny < 0
        ? f < 0
          ? (f = Math.PI + f)
          : ((f = Math.PI - f), (p = -1), (m = !0))
        : f > 0 && ((p = -1), (m = !0))
      let g = f / 2,
        x,
        y = Math.abs((Math.cos(g) * u) / Math.sin(g))
      y > Math.min(c.len / 2, h.len / 2)
        ? ((y = Math.min(c.len / 2, h.len / 2)), (x = Math.abs((y * Math.sin(g)) / Math.cos(g))))
        : (x = u)
      let v = a.x + h.nx * y + -h.ny * x * p,
        S = a.y + h.ny * y + h.nx * x * p,
        b = Math.atan2(c.ny, c.nx) + (Math.PI / 2) * p,
        M = Math.atan2(h.ny, h.nx) - (Math.PI / 2) * p
      ;(o === 0 && r.moveTo(v + Math.cos(b) * x, S + Math.sin(b) * x),
        r.arc(v, S, x, b, M, m),
        (s = a))
    }
  }
  function yb(r, e, t, i) {
    let n = (a, u) => Math.sqrt((a.x - u.x) ** 2 + (a.y - u.y) ** 2),
      s = (a, u, l) => ({ x: a.x + (u.x - a.x) * l, y: a.y + (u.y - a.y) * l }),
      o = e.length
    for (let a = 0; a < o; a++) {
      let u = e[(a + 1) % o],
        l = u.radius ?? t
      if (l <= 0) {
        a === 0 ? r.moveTo(u.x, u.y) : r.lineTo(u.x, u.y)
        continue
      }
      let c = e[a],
        h = e[(a + 2) % o],
        f = n(c, u),
        p
      if (f < 1e-4) p = u
      else {
        let x = Math.min(f / 2, l)
        p = s(u, c, x / f)
      }
      let m = n(h, u),
        g
      if (m < 1e-4) g = u
      else {
        let x = Math.min(m / 2, l)
        g = s(u, h, x / m)
      }
      ;(a === 0 ? r.moveTo(p.x, p.y) : r.lineTo(p.x, p.y),
        r.quadraticCurveTo(u.x, u.y, g.x, g.y, i))
    }
  }
  var bb = d(() => {
    "use strict"
  })
  var ZP,
    Ru,
    vb = d(() => {
      bd()
      sb()
      ub()
      Ke()
      lb()
      lt()
      Td()
      db()
      Ed()
      pb()
      xb()
      bb()
      ;((ZP = new ee()),
        (Ru = class {
          constructor(e) {
            ;((this.shapePrimitives = []),
              (this._currentPoly = null),
              (this._bounds = new de()),
              (this._graphicsPath2D = e),
              (this.signed = e.checkForHoles))
          }
          moveTo(e, t) {
            return (this.startPoly(e, t), this)
          }
          lineTo(e, t) {
            this._ensurePoly()
            let i = this._currentPoly.points,
              n = i[i.length - 2],
              s = i[i.length - 1]
            return ((n !== e || s !== t) && i.push(e, t), this)
          }
          arc(e, t, i, n, s, o) {
            this._ensurePoly(!1)
            let a = this._currentPoly.points
            return (Pu(a, e, t, i, n, s, o), this)
          }
          arcTo(e, t, i, n, s) {
            this._ensurePoly()
            let o = this._currentPoly.points
            return (fb(o, e, t, i, n, s), this)
          }
          arcToSvg(e, t, i, n, s, o, a) {
            let u = this._currentPoly.points
            return (
              gb(u, this._currentPoly.lastX, this._currentPoly.lastY, o, a, e, t, i, n, s),
              this
            )
          }
          bezierCurveTo(e, t, i, n, s, o, a) {
            this._ensurePoly()
            let u = this._currentPoly
            return (Du(this._currentPoly.points, u.lastX, u.lastY, e, t, i, n, s, o, a), this)
          }
          quadraticCurveTo(e, t, i, n, s) {
            this._ensurePoly()
            let o = this._currentPoly
            return (hb(this._currentPoly.points, o.lastX, o.lastY, e, t, i, n, s), this)
          }
          closePath() {
            return (this.endPoly(!0), this)
          }
          addPath(e, t) {
            ;(this.endPoly(), t && !t.isIdentity() && ((e = e.clone(!0)), e.transform(t)))
            let i = this.shapePrimitives,
              n = i.length
            for (let s = 0; s < e.instructions.length; s++) {
              let o = e.instructions[s]
              this[o.action](...o.data)
            }
            if (e.checkForHoles && i.length - n > 1) {
              let s = null
              for (let o = n; o < i.length; o++) {
                let a = i[o]
                if (a.shape.type === "polygon") {
                  let u = a.shape,
                    l = s?.shape
                  l && l.containsPolygon(u)
                    ? (s.holes || (s.holes = []),
                      s.holes.push(a),
                      i.copyWithin(o, o + 1),
                      i.length--,
                      o--)
                    : (s = a)
                }
              }
            }
            return this
          }
          finish(e = !1) {
            this.endPoly(e)
          }
          rect(e, t, i, n, s) {
            return (this.drawShape(new ee(e, t, i, n), s), this)
          }
          circle(e, t, i, n) {
            return (this.drawShape(new mi(e, t, i), n), this)
          }
          poly(e, t, i) {
            let n = new an(e)
            return ((n.closePath = t), this.drawShape(n, i), this)
          }
          regularPoly(e, t, i, n, s = 0, o) {
            n = Math.max(n | 0, 3)
            let a = (-1 * Math.PI) / 2 + s,
              u = (Math.PI * 2) / n,
              l = []
            for (let c = 0; c < n; c++) {
              let h = a - c * u
              l.push(e + i * Math.cos(h), t + i * Math.sin(h))
            }
            return (this.poly(l, !0, o), this)
          }
          roundPoly(e, t, i, n, s, o = 0, a) {
            if (((n = Math.max(n | 0, 3)), s <= 0)) return this.regularPoly(e, t, i, n, o)
            let u = i * Math.sin(Math.PI / n) - 0.001
            s = Math.min(s, u)
            let l = (-1 * Math.PI) / 2 + o,
              c = (Math.PI * 2) / n,
              h = ((n - 2) * Math.PI) / n / 2
            for (let f = 0; f < n; f++) {
              let p = f * c + l,
                m = e + i * Math.cos(p),
                g = t + i * Math.sin(p),
                x = p + Math.PI + h,
                y = p - Math.PI - h,
                v = m + s * Math.cos(x),
                S = g + s * Math.sin(x),
                b = m + s * Math.cos(y),
                M = g + s * Math.sin(y)
              ;(f === 0 ? this.moveTo(v, S) : this.lineTo(v, S),
                this.quadraticCurveTo(m, g, b, M, a))
            }
            return this.closePath()
          }
          roundShape(e, t, i = !1, n) {
            return e.length < 3 ? this : (i ? yb(this, e, t, n) : _b(this, e, t), this.closePath())
          }
          filletRect(e, t, i, n, s) {
            if (s === 0) return this.rect(e, t, i, n)
            let o = Math.min(i, n) / 2,
              a = Math.min(o, Math.max(-o, s)),
              u = e + i,
              l = t + n,
              c = a < 0 ? -a : 0,
              h = Math.abs(a)
            return this.moveTo(e, t + h)
              .arcTo(e + c, t + c, e + h, t, h)
              .lineTo(u - h, t)
              .arcTo(u - c, t + c, u, t + h, h)
              .lineTo(u, l - h)
              .arcTo(u - c, l - c, e + i - h, l, h)
              .lineTo(e + h, l)
              .arcTo(e + c, l - c, e, l - h, h)
              .closePath()
          }
          chamferRect(e, t, i, n, s, o) {
            if (s <= 0) return this.rect(e, t, i, n)
            let a = Math.min(s, Math.min(i, n) / 2),
              u = e + i,
              l = t + n,
              c = [e + a, t, u - a, t, u, t + a, u, l - a, u - a, l, e + a, l, e, l - a, e, t + a]
            for (let h = c.length - 1; h >= 2; h -= 2)
              c[h] === c[h - 2] && c[h - 1] === c[h - 3] && c.splice(h - 1, 2)
            return this.poly(c, !0, o)
          }
          ellipse(e, t, i, n, s) {
            return (this.drawShape(new Eu(e, t, i, n), s), this)
          }
          roundRect(e, t, i, n, s, o) {
            return (this.drawShape(new Mu(e, t, i, n, s), o), this)
          }
          drawShape(e, t) {
            return (this.endPoly(), this.shapePrimitives.push({ shape: e, transform: t }), this)
          }
          startPoly(e, t) {
            let i = this._currentPoly
            return (
              i && this.endPoly(),
              (i = new an()),
              i.points.push(e, t),
              (this._currentPoly = i),
              this
            )
          }
          endPoly(e = !1) {
            let t = this._currentPoly
            return (
              t &&
                t.points.length > 2 &&
                ((t.closePath = e), this.shapePrimitives.push({ shape: t })),
              (this._currentPoly = null),
              this
            )
          }
          _ensurePoly(e = !0) {
            if (!this._currentPoly && ((this._currentPoly = new an()), e)) {
              let t = this.shapePrimitives[this.shapePrimitives.length - 1]
              if (t) {
                let i = t.shape.x,
                  n = t.shape.y
                if (t.transform && !t.transform.isIdentity()) {
                  let s = t.transform,
                    o = i
                  ;((i = s.a * i + s.c * n + s.tx), (n = s.b * o + s.d * n + s.ty))
                }
                this._currentPoly.points.push(i, n)
              } else this._currentPoly.points.push(0, 0)
            }
          }
          buildPath() {
            let e = this._graphicsPath2D
            ;((this.shapePrimitives.length = 0), (this._currentPoly = null))
            for (let t = 0; t < e.instructions.length; t++) {
              let i = e.instructions[t]
              this[i.action](...i.data)
            }
            this.finish()
          }
          get bounds() {
            let e = this._bounds
            e.clear()
            let t = this.shapePrimitives
            for (let i = 0; i < t.length; i++) {
              let n = t[i],
                s = n.shape.getBounds(ZP)
              n.transform ? e.addRect(s, n.transform) : e.addRect(s)
            }
            return e
          }
        }))
    })
  function Ps(r, e) {
    return r ? r.prepend(e) : e.clone()
  }
  var Ir,
    Ad = d(() => {
      Et()
      Ye()
      be()
      nb()
      vb()
      Ir = class r {
        constructor(e, t = !1) {
          ;((this.instructions = []),
            (this.uid = te("graphicsPath")),
            (this._dirty = !0),
            (this.checkForHoles = t),
            typeof e == "string" ? ib(e, this) : (this.instructions = e?.slice() ?? []))
        }
        get shapePath() {
          return (
            this._shapePath || (this._shapePath = new Ru(this)),
            this._dirty && ((this._dirty = !1), this._shapePath.buildPath()),
            this._shapePath
          )
        }
        addPath(e, t) {
          return (
            (e = e.clone()),
            this.instructions.push({ action: "addPath", data: [e, t] }),
            (this._dirty = !0),
            this
          )
        }
        arc(...e) {
          return (this.instructions.push({ action: "arc", data: e }), (this._dirty = !0), this)
        }
        arcTo(...e) {
          return (this.instructions.push({ action: "arcTo", data: e }), (this._dirty = !0), this)
        }
        arcToSvg(...e) {
          return (this.instructions.push({ action: "arcToSvg", data: e }), (this._dirty = !0), this)
        }
        bezierCurveTo(...e) {
          return (
            this.instructions.push({ action: "bezierCurveTo", data: e }),
            (this._dirty = !0),
            this
          )
        }
        bezierCurveToShort(e, t, i, n, s) {
          let o = this.instructions[this.instructions.length - 1],
            a = this.getLastPoint(re.shared),
            u = 0,
            l = 0
          if (!o || o.action !== "bezierCurveTo") ((u = a.x), (l = a.y))
          else {
            ;((u = o.data[2]), (l = o.data[3]))
            let c = a.x,
              h = a.y
            ;((u = c + (c - u)), (l = h + (h - l)))
          }
          return (
            this.instructions.push({ action: "bezierCurveTo", data: [u, l, e, t, i, n, s] }),
            (this._dirty = !0),
            this
          )
        }
        closePath() {
          return (
            this.instructions.push({ action: "closePath", data: [] }),
            (this._dirty = !0),
            this
          )
        }
        ellipse(...e) {
          return (this.instructions.push({ action: "ellipse", data: e }), (this._dirty = !0), this)
        }
        lineTo(...e) {
          return (this.instructions.push({ action: "lineTo", data: e }), (this._dirty = !0), this)
        }
        moveTo(...e) {
          return (this.instructions.push({ action: "moveTo", data: e }), this)
        }
        quadraticCurveTo(...e) {
          return (
            this.instructions.push({ action: "quadraticCurveTo", data: e }),
            (this._dirty = !0),
            this
          )
        }
        quadraticCurveToShort(e, t, i) {
          let n = this.instructions[this.instructions.length - 1],
            s = this.getLastPoint(re.shared),
            o = 0,
            a = 0
          if (!n || n.action !== "quadraticCurveTo") ((o = s.x), (a = s.y))
          else {
            ;((o = n.data[0]), (a = n.data[1]))
            let u = s.x,
              l = s.y
            ;((o = u + (u - o)), (a = l + (l - a)))
          }
          return (
            this.instructions.push({ action: "quadraticCurveTo", data: [o, a, e, t, i] }),
            (this._dirty = !0),
            this
          )
        }
        rect(e, t, i, n, s) {
          return (
            this.instructions.push({ action: "rect", data: [e, t, i, n, s] }),
            (this._dirty = !0),
            this
          )
        }
        circle(e, t, i, n) {
          return (
            this.instructions.push({ action: "circle", data: [e, t, i, n] }),
            (this._dirty = !0),
            this
          )
        }
        roundRect(...e) {
          return (
            this.instructions.push({ action: "roundRect", data: e }),
            (this._dirty = !0),
            this
          )
        }
        poly(...e) {
          return (this.instructions.push({ action: "poly", data: e }), (this._dirty = !0), this)
        }
        regularPoly(...e) {
          return (
            this.instructions.push({ action: "regularPoly", data: e }),
            (this._dirty = !0),
            this
          )
        }
        roundPoly(...e) {
          return (
            this.instructions.push({ action: "roundPoly", data: e }),
            (this._dirty = !0),
            this
          )
        }
        roundShape(...e) {
          return (
            this.instructions.push({ action: "roundShape", data: e }),
            (this._dirty = !0),
            this
          )
        }
        filletRect(...e) {
          return (
            this.instructions.push({ action: "filletRect", data: e }),
            (this._dirty = !0),
            this
          )
        }
        chamferRect(...e) {
          return (
            this.instructions.push({ action: "chamferRect", data: e }),
            (this._dirty = !0),
            this
          )
        }
        star(e, t, i, n, s, o, a) {
          s || (s = n / 2)
          let u = (-1 * Math.PI) / 2 + o,
            l = i * 2,
            c = (Math.PI * 2) / l,
            h = []
          for (let f = 0; f < l; f++) {
            let p = f % 2 ? s : n,
              m = f * c + u
            h.push(e + p * Math.cos(m), t + p * Math.sin(m))
          }
          return (this.poly(h, !0, a), this)
        }
        clone(e = !1) {
          let t = new r()
          if (((t.checkForHoles = this.checkForHoles), !e))
            t.instructions = this.instructions.slice()
          else
            for (let i = 0; i < this.instructions.length; i++) {
              let n = this.instructions[i]
              t.instructions.push({ action: n.action, data: n.data.slice() })
            }
          return t
        }
        clear() {
          return ((this.instructions.length = 0), (this._dirty = !0), this)
        }
        transform(e) {
          if (e.isIdentity()) return this
          let t = e.a,
            i = e.b,
            n = e.c,
            s = e.d,
            o = e.tx,
            a = e.ty,
            u = 0,
            l = 0,
            c = 0,
            h = 0,
            f = 0,
            p = 0,
            m = 0,
            g = 0
          for (let x = 0; x < this.instructions.length; x++) {
            let y = this.instructions[x],
              v = y.data
            switch (y.action) {
              case "moveTo":
              case "lineTo":
                ;((u = v[0]), (l = v[1]), (v[0] = t * u + n * l + o), (v[1] = i * u + s * l + a))
                break
              case "bezierCurveTo":
                ;((c = v[0]),
                  (h = v[1]),
                  (f = v[2]),
                  (p = v[3]),
                  (u = v[4]),
                  (l = v[5]),
                  (v[0] = t * c + n * h + o),
                  (v[1] = i * c + s * h + a),
                  (v[2] = t * f + n * p + o),
                  (v[3] = i * f + s * p + a),
                  (v[4] = t * u + n * l + o),
                  (v[5] = i * u + s * l + a))
                break
              case "quadraticCurveTo":
                ;((c = v[0]),
                  (h = v[1]),
                  (u = v[2]),
                  (l = v[3]),
                  (v[0] = t * c + n * h + o),
                  (v[1] = i * c + s * h + a),
                  (v[2] = t * u + n * l + o),
                  (v[3] = i * u + s * l + a))
                break
              case "arcToSvg":
                ;((u = v[5]),
                  (l = v[6]),
                  (m = v[0]),
                  (g = v[1]),
                  (v[0] = t * m + n * g),
                  (v[1] = i * m + s * g),
                  (v[5] = t * u + n * l + o),
                  (v[6] = i * u + s * l + a))
                break
              case "circle":
                v[4] = Ps(v[3], e)
                break
              case "rect":
                v[4] = Ps(v[4], e)
                break
              case "ellipse":
                v[8] = Ps(v[8], e)
                break
              case "roundRect":
                v[5] = Ps(v[5], e)
                break
              case "addPath":
                v[0].transform(e)
                break
              case "poly":
                v[2] = Ps(v[2], e)
                break
              default:
                H("unknown transform action", y.action)
                break
            }
          }
          return ((this._dirty = !0), this)
        }
        get bounds() {
          return this.shapePath.bounds
        }
        getLastPoint(e) {
          let t = this.instructions.length - 1,
            i = this.instructions[t]
          if (!i) return ((e.x = 0), (e.y = 0), e)
          for (; i.action === "closePath"; ) {
            if ((t--, t < 0)) return ((e.x = 0), (e.y = 0), e)
            i = this.instructions[t]
          }
          switch (i.action) {
            case "moveTo":
            case "lineTo":
              ;((e.x = i.data[0]), (e.y = i.data[1]))
              break
            case "quadraticCurveTo":
              ;((e.x = i.data[2]), (e.y = i.data[3]))
              break
            case "bezierCurveTo":
              ;((e.x = i.data[4]), (e.y = i.data[5]))
              break
            case "arc":
            case "arcToSvg":
              ;((e.x = i.data[5]), (e.y = i.data[6]))
              break
            case "addPath":
              i.data[0].getLastPoint(e)
              break
          }
          return e
        }
      }
    })
  function Se(r, e, t) {
    let i = r.getAttribute(e)
    return i ? Number(i) : t
  }
  var Dd = d(() => {
    "use strict"
  })
  function Sb(r, e) {
    let t = r.querySelectorAll("defs")
    for (let i = 0; i < t.length; i++) {
      let n = t[i]
      for (let s = 0; s < n.children.length; s++) {
        let o = n.children[s]
        switch (o.nodeName.toLowerCase()) {
          case "lineargradient":
            e.defs[o.id] = QP(o)
            break
          case "radialgradient":
            e.defs[o.id] = JP(o)
            break
          default:
            break
        }
      }
    }
  }
  function QP(r) {
    let e = Se(r, "x1", 0),
      t = Se(r, "y1", 0),
      i = Se(r, "x2", 1),
      n = Se(r, "y2", 0),
      s = r.getAttribute("gradientUnits") || "objectBoundingBox",
      o = new ft(e, t, i, n, s === "objectBoundingBox" ? "local" : "global")
    for (let a = 0; a < r.children.length; a++) {
      let u = r.children[a],
        l = Se(u, "offset", 0),
        c = q.shared.setValue(u.getAttribute("stop-color")).toNumber()
      o.addColorStop(l, c)
    }
    return o
  }
  function JP(r) {
    return (H("[SVG Parser] Radial gradients are not yet supported"), new ft(0, 0, 1, 0))
  }
  var Tb = d(() => {
    $e()
    be()
    tn()
    Dd()
  })
  function Pd(r) {
    let e = r.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i)
    return e ? e[1] : ""
  }
  var Cb = d(() => {
    "use strict"
  })
  function Rd(r, e) {
    let t = r.getAttribute("style"),
      i = {},
      n = {},
      s = { strokeStyle: i, fillStyle: n, useFill: !1, useStroke: !1 }
    for (let o in Eb) {
      let a = r.getAttribute(o)
      a && wb(e, s, o, a.trim())
    }
    if (t) {
      let o = t.split(";")
      for (let a = 0; a < o.length; a++) {
        let u = o[a].trim(),
          [l, c] = u.split(":")
        Eb[l] && wb(e, s, l, c.trim())
      }
    }
    return {
      strokeStyle: s.useStroke ? i : null,
      fillStyle: s.useFill ? n : null,
      useFill: s.useFill,
      useStroke: s.useStroke,
    }
  }
  function wb(r, e, t, i) {
    switch (t) {
      case "stroke":
        if (i !== "none") {
          if (i.startsWith("url(")) {
            let n = Pd(i)
            e.strokeStyle.fill = r.defs[n]
          } else e.strokeStyle.color = q.shared.setValue(i).toNumber()
          e.useStroke = !0
        }
        break
      case "stroke-width":
        e.strokeStyle.width = Number(i)
        break
      case "fill":
        if (i !== "none") {
          if (i.startsWith("url(")) {
            let n = Pd(i)
            e.fillStyle.fill = r.defs[n]
          } else e.fillStyle.color = q.shared.setValue(i).toNumber()
          e.useFill = !0
        }
        break
      case "fill-opacity":
        e.fillStyle.alpha = Number(i)
        break
      case "stroke-opacity":
        e.strokeStyle.alpha = Number(i)
        break
      case "opacity":
        ;((e.fillStyle.alpha = Number(i)), (e.strokeStyle.alpha = Number(i)))
        break
    }
  }
  var Eb,
    Mb = d(() => {
      $e()
      Cb()
      Eb = {
        fill: { type: "paint", default: 0 },
        "fill-opacity": { type: "number", default: 1 },
        stroke: { type: "paint", default: 0 },
        "stroke-width": { type: "number", default: 1 },
        "stroke-opacity": { type: "number", default: 1 },
        "stroke-linecap": { type: "string", default: "butt" },
        "stroke-linejoin": { type: "string", default: "miter" },
        "stroke-miterlimit": { type: "number", default: 10 },
        "stroke-dasharray": { type: "string", default: "none" },
        "stroke-dashoffset": { type: "number", default: 0 },
        opacity: { type: "number", default: 1 },
      }
    })
  function Ab(r, e) {
    if (typeof r == "string") {
      let o = document.createElement("div")
      ;((o.innerHTML = r.trim()), (r = o.querySelector("svg")))
    }
    let t = { context: e, defs: {}, path: new Ir() }
    Sb(r, t)
    let i = r.children,
      { fillStyle: n, strokeStyle: s } = Rd(r, t)
    for (let o = 0; o < i.length; o++) {
      let a = i[o]
      a.nodeName.toLowerCase() !== "defs" && Db(a, t, n, s)
    }
    return e
  }
  function Db(r, e, t, i) {
    let n = r.children,
      { fillStyle: s, strokeStyle: o } = Rd(r, e)
    ;(s && t ? (t = { ...t, ...s }) : s && (t = s), o && i ? (i = { ...i, ...o }) : o && (i = o))
    let a = !t && !i
    a && (t = { color: 0 })
    let u, l, c, h, f, p, m, g, x, y, v, S, b, M, C, w, B
    switch (r.nodeName.toLowerCase()) {
      case "path":
        ;((M = r.getAttribute("d")),
          r.getAttribute("fill-rule") === "evenodd" &&
            H("SVG Evenodd fill rule not supported, your svg may render incorrectly"),
          (C = new Ir(M, !0)),
          e.context.path(C),
          t && e.context.fill(t),
          i && e.context.stroke(i))
        break
      case "circle":
        ;((m = Se(r, "cx", 0)),
          (g = Se(r, "cy", 0)),
          (x = Se(r, "r", 0)),
          e.context.ellipse(m, g, x, x),
          t && e.context.fill(t),
          i && e.context.stroke(i))
        break
      case "rect":
        ;((u = Se(r, "x", 0)),
          (l = Se(r, "y", 0)),
          (w = Se(r, "width", 0)),
          (B = Se(r, "height", 0)),
          (y = Se(r, "rx", 0)),
          (v = Se(r, "ry", 0)),
          y || v ? e.context.roundRect(u, l, w, B, y || v) : e.context.rect(u, l, w, B),
          t && e.context.fill(t),
          i && e.context.stroke(i))
        break
      case "ellipse":
        ;((m = Se(r, "cx", 0)),
          (g = Se(r, "cy", 0)),
          (y = Se(r, "rx", 0)),
          (v = Se(r, "ry", 0)),
          e.context.beginPath(),
          e.context.ellipse(m, g, y, v),
          t && e.context.fill(t),
          i && e.context.stroke(i))
        break
      case "line":
        ;((c = Se(r, "x1", 0)),
          (h = Se(r, "y1", 0)),
          (f = Se(r, "x2", 0)),
          (p = Se(r, "y2", 0)),
          e.context.beginPath(),
          e.context.moveTo(c, h),
          e.context.lineTo(f, p),
          i && e.context.stroke(i))
        break
      case "polygon":
        ;((b = r.getAttribute("points")),
          (S = b.match(/\d+/g).map((O) => parseInt(O, 10))),
          e.context.poly(S, !0),
          t && e.context.fill(t),
          i && e.context.stroke(i))
        break
      case "polyline":
        ;((b = r.getAttribute("points")),
          (S = b.match(/\d+/g).map((O) => parseInt(O, 10))),
          e.context.poly(S, !1),
          i && e.context.stroke(i))
        break
      case "g":
      case "svg":
        break
      default: {
        H(`[SVG parser] <${r.nodeName}> elements unsupported`)
        break
      }
    }
    a && (t = null)
    for (let O = 0; O < n.length; O++) Db(n[O], e, t, i)
  }
  var Pb = d(() => {
    be()
    Ad()
    Tb()
    Dd()
    Mb()
  })
  function eR(r) {
    return q.isColorLike(r)
  }
  function Rb(r) {
    return r instanceof fr
  }
  function Fb(r) {
    return r instanceof ft
  }
  function tR(r) {
    return r instanceof I
  }
  function rR(r, e, t) {
    let i = q.shared.setValue(e ?? 0)
    return (
      (r.color = i.toNumber()),
      (r.alpha = i.alpha === 1 ? t.alpha : i.alpha),
      (r.texture = I.WHITE),
      { ...t, ...r }
    )
  }
  function iR(r, e, t) {
    return ((r.texture = e), { ...t, ...r })
  }
  function Bb(r, e, t) {
    return (
      (r.fill = e),
      (r.color = 16777215),
      (r.texture = e.texture),
      (r.matrix = e.transform),
      { ...t, ...r }
    )
  }
  function Ib(r, e, t) {
    return (
      e.buildGradient(),
      (r.fill = e),
      (r.color = 16777215),
      (r.texture = e.texture),
      (r.matrix = e.transform),
      (r.textureSpace = e.textureSpace),
      { ...t, ...r }
    )
  }
  function nR(r, e) {
    let t = { ...e, ...r },
      i = q.shared.setValue(t.color)
    return ((t.alpha *= i.alpha), (t.color = i.toNumber()), t)
  }
  function pr(r, e) {
    if (r == null) return null
    let t = {},
      i = r
    return eR(r)
      ? rR(t, r, e)
      : tR(r)
        ? iR(t, r, e)
        : Rb(r)
          ? Bb(t, r, e)
          : Fb(r)
            ? Ib(t, r, e)
            : i.fill && Rb(i.fill)
              ? Bb(i, i.fill, e)
              : i.fill && Fb(i.fill)
                ? Ib(i, i.fill, e)
                : nR(i, e)
  }
  function ln(r, e) {
    let { width: t, alignment: i, miterLimit: n, cap: s, join: o, pixelLine: a, ...u } = e,
      l = pr(r, u)
    return l ? { width: t, alignment: i, miterLimit: n, cap: s, join: o, pixelLine: a, ...l } : null
  }
  var Fd = d(() => {
    $e()
    ge()
    tn()
    Cu()
  })
  var sR,
    Gb,
    Bd,
    St,
    Id = d(() => {
      Je()
      $e()
      se()
      Et()
      ge()
      Ye()
      Te()
      lt()
      Ad()
      Pb()
      Fd()
      ;((sR = new re()),
        (Gb = new F()),
        (Bd = class tr extends pe {
          constructor() {
            ;(super(...arguments),
              (this.uid = te("graphicsContext")),
              (this.dirty = !0),
              (this.batchMode = "auto"),
              (this.instructions = []),
              (this._activePath = new Ir()),
              (this._transform = new F()),
              (this._fillStyle = { ...tr.defaultFillStyle }),
              (this._strokeStyle = { ...tr.defaultStrokeStyle }),
              (this._stateStack = []),
              (this._tick = 0),
              (this._bounds = new de()),
              (this._boundsDirty = !0))
          }
          clone() {
            let e = new tr()
            return (
              (e.batchMode = this.batchMode),
              (e.instructions = this.instructions.slice()),
              (e._activePath = this._activePath.clone()),
              (e._transform = this._transform.clone()),
              (e._fillStyle = { ...this._fillStyle }),
              (e._strokeStyle = { ...this._strokeStyle }),
              (e._stateStack = this._stateStack.slice()),
              (e._bounds = this._bounds.clone()),
              (e._boundsDirty = !0),
              e
            )
          }
          get fillStyle() {
            return this._fillStyle
          }
          set fillStyle(e) {
            this._fillStyle = pr(e, tr.defaultFillStyle)
          }
          get strokeStyle() {
            return this._strokeStyle
          }
          set strokeStyle(e) {
            this._strokeStyle = ln(e, tr.defaultStrokeStyle)
          }
          setFillStyle(e) {
            return ((this._fillStyle = pr(e, tr.defaultFillStyle)), this)
          }
          setStrokeStyle(e) {
            return ((this._strokeStyle = pr(e, tr.defaultStrokeStyle)), this)
          }
          texture(e, t, i, n, s, o) {
            return (
              this.instructions.push({
                action: "texture",
                data: {
                  image: e,
                  dx: i || 0,
                  dy: n || 0,
                  dw: s || e.frame.width,
                  dh: o || e.frame.height,
                  transform: this._transform.clone(),
                  alpha: this._fillStyle.alpha,
                  style: t ? q.shared.setValue(t).toNumber() : 16777215,
                },
              }),
              this.onUpdate(),
              this
            )
          }
          beginPath() {
            return ((this._activePath = new Ir()), this)
          }
          fill(e, t) {
            let i,
              n = this.instructions[this.instructions.length - 1]
            return (
              this._tick === 0 && n && n.action === "stroke"
                ? (i = n.data.path)
                : (i = this._activePath.clone()),
              i
                ? (e != null &&
                    (t !== void 0 &&
                      typeof e == "number" &&
                      (z(
                        K,
                        "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead",
                      ),
                      (e = { color: e, alpha: t })),
                    (this._fillStyle = pr(e, tr.defaultFillStyle))),
                  this.instructions.push({
                    action: "fill",
                    data: { style: this.fillStyle, path: i },
                  }),
                  this.onUpdate(),
                  this._initNextPathLocation(),
                  (this._tick = 0),
                  this)
                : this
            )
          }
          _initNextPathLocation() {
            let { x: e, y: t } = this._activePath.getLastPoint(re.shared)
            ;(this._activePath.clear(), this._activePath.moveTo(e, t))
          }
          stroke(e) {
            let t,
              i = this.instructions[this.instructions.length - 1]
            return (
              this._tick === 0 && i && i.action === "fill"
                ? (t = i.data.path)
                : (t = this._activePath.clone()),
              t
                ? (e != null && (this._strokeStyle = ln(e, tr.defaultStrokeStyle)),
                  this.instructions.push({
                    action: "stroke",
                    data: { style: this.strokeStyle, path: t },
                  }),
                  this.onUpdate(),
                  this._initNextPathLocation(),
                  (this._tick = 0),
                  this)
                : this
            )
          }
          cut() {
            for (let e = 0; e < 2; e++) {
              let t = this.instructions[this.instructions.length - 1 - e],
                i = this._activePath.clone()
              if (t && (t.action === "stroke" || t.action === "fill"))
                if (t.data.hole) t.data.hole.addPath(i)
                else {
                  t.data.hole = i
                  break
                }
            }
            return (this._initNextPathLocation(), this)
          }
          arc(e, t, i, n, s, o) {
            this._tick++
            let a = this._transform
            return (
              this._activePath.arc(a.a * e + a.c * t + a.tx, a.b * e + a.d * t + a.ty, i, n, s, o),
              this
            )
          }
          arcTo(e, t, i, n, s) {
            this._tick++
            let o = this._transform
            return (
              this._activePath.arcTo(
                o.a * e + o.c * t + o.tx,
                o.b * e + o.d * t + o.ty,
                o.a * i + o.c * n + o.tx,
                o.b * i + o.d * n + o.ty,
                s,
              ),
              this
            )
          }
          arcToSvg(e, t, i, n, s, o, a) {
            this._tick++
            let u = this._transform
            return (
              this._activePath.arcToSvg(
                e,
                t,
                i,
                n,
                s,
                u.a * o + u.c * a + u.tx,
                u.b * o + u.d * a + u.ty,
              ),
              this
            )
          }
          bezierCurveTo(e, t, i, n, s, o, a) {
            this._tick++
            let u = this._transform
            return (
              this._activePath.bezierCurveTo(
                u.a * e + u.c * t + u.tx,
                u.b * e + u.d * t + u.ty,
                u.a * i + u.c * n + u.tx,
                u.b * i + u.d * n + u.ty,
                u.a * s + u.c * o + u.tx,
                u.b * s + u.d * o + u.ty,
                a,
              ),
              this
            )
          }
          closePath() {
            return (this._tick++, this._activePath?.closePath(), this)
          }
          ellipse(e, t, i, n) {
            return (
              this._tick++,
              this._activePath.ellipse(e, t, i, n, this._transform.clone()),
              this
            )
          }
          circle(e, t, i) {
            return (this._tick++, this._activePath.circle(e, t, i, this._transform.clone()), this)
          }
          path(e) {
            return (this._tick++, this._activePath.addPath(e, this._transform.clone()), this)
          }
          lineTo(e, t) {
            this._tick++
            let i = this._transform
            return (
              this._activePath.lineTo(i.a * e + i.c * t + i.tx, i.b * e + i.d * t + i.ty),
              this
            )
          }
          moveTo(e, t) {
            this._tick++
            let i = this._transform,
              n = this._activePath.instructions,
              s = i.a * e + i.c * t + i.tx,
              o = i.b * e + i.d * t + i.ty
            return n.length === 1 && n[0].action === "moveTo"
              ? ((n[0].data[0] = s), (n[0].data[1] = o), this)
              : (this._activePath.moveTo(s, o), this)
          }
          quadraticCurveTo(e, t, i, n, s) {
            this._tick++
            let o = this._transform
            return (
              this._activePath.quadraticCurveTo(
                o.a * e + o.c * t + o.tx,
                o.b * e + o.d * t + o.ty,
                o.a * i + o.c * n + o.tx,
                o.b * i + o.d * n + o.ty,
                s,
              ),
              this
            )
          }
          rect(e, t, i, n) {
            return (this._tick++, this._activePath.rect(e, t, i, n, this._transform.clone()), this)
          }
          roundRect(e, t, i, n, s) {
            return (
              this._tick++,
              this._activePath.roundRect(e, t, i, n, s, this._transform.clone()),
              this
            )
          }
          poly(e, t) {
            return (this._tick++, this._activePath.poly(e, t, this._transform.clone()), this)
          }
          regularPoly(e, t, i, n, s = 0, o) {
            return (this._tick++, this._activePath.regularPoly(e, t, i, n, s, o), this)
          }
          roundPoly(e, t, i, n, s, o) {
            return (this._tick++, this._activePath.roundPoly(e, t, i, n, s, o), this)
          }
          roundShape(e, t, i, n) {
            return (this._tick++, this._activePath.roundShape(e, t, i, n), this)
          }
          filletRect(e, t, i, n, s) {
            return (this._tick++, this._activePath.filletRect(e, t, i, n, s), this)
          }
          chamferRect(e, t, i, n, s, o) {
            return (this._tick++, this._activePath.chamferRect(e, t, i, n, s, o), this)
          }
          star(e, t, i, n, s = 0, o = 0) {
            return (
              this._tick++,
              this._activePath.star(e, t, i, n, s, o, this._transform.clone()),
              this
            )
          }
          svg(e) {
            return (this._tick++, Ab(e, this), this)
          }
          restore() {
            let e = this._stateStack.pop()
            return (
              e &&
                ((this._transform = e.transform),
                (this._fillStyle = e.fillStyle),
                (this._strokeStyle = e.strokeStyle)),
              this
            )
          }
          save() {
            return (
              this._stateStack.push({
                transform: this._transform.clone(),
                fillStyle: { ...this._fillStyle },
                strokeStyle: { ...this._strokeStyle },
              }),
              this
            )
          }
          getTransform() {
            return this._transform
          }
          resetTransform() {
            return (this._transform.identity(), this)
          }
          rotate(e) {
            return (this._transform.rotate(e), this)
          }
          scale(e, t = e) {
            return (this._transform.scale(e, t), this)
          }
          setTransform(e, t, i, n, s, o) {
            return e instanceof F
              ? (this._transform.set(e.a, e.b, e.c, e.d, e.tx, e.ty), this)
              : (this._transform.set(e, t, i, n, s, o), this)
          }
          transform(e, t, i, n, s, o) {
            return e instanceof F
              ? (this._transform.append(e), this)
              : (Gb.set(e, t, i, n, s, o), this._transform.append(Gb), this)
          }
          translate(e, t = e) {
            return (this._transform.translate(e, t), this)
          }
          clear() {
            return (
              this._activePath.clear(),
              (this.instructions.length = 0),
              this.resetTransform(),
              this.onUpdate(),
              this
            )
          }
          onUpdate() {
            this.dirty ||
              (this.emit("update", this, 16), (this.dirty = !0), (this._boundsDirty = !0))
          }
          get bounds() {
            if (!this._boundsDirty) return this._bounds
            let e = this._bounds
            e.clear()
            for (let t = 0; t < this.instructions.length; t++) {
              let i = this.instructions[t],
                n = i.action
              if (n === "fill") {
                let s = i.data
                e.addBounds(s.path.bounds)
              } else if (n === "texture") {
                let s = i.data
                e.addFrame(s.dx, s.dy, s.dx + s.dw, s.dy + s.dh, s.transform)
              }
              if (n === "stroke") {
                let s = i.data,
                  o = s.style.alignment,
                  a = s.style.width * (1 - o),
                  u = s.path.bounds
                e.addFrame(u.minX - a, u.minY - a, u.maxX + a, u.maxY + a)
              }
            }
            return e
          }
          containsPoint(e) {
            if (!this.bounds.containsPoint(e.x, e.y)) return !1
            let t = this.instructions,
              i = !1
            for (let n = 0; n < t.length; n++) {
              let s = t[n],
                o = s.data,
                a = o.path
              if (!s.action || !a) continue
              let u = o.style,
                l = a.shapePath.shapePrimitives
              for (let c = 0; c < l.length; c++) {
                let h = l[c].shape
                if (!u || !h) continue
                let f = l[c].transform,
                  p = f ? f.applyInverse(e, sR) : e
                if (s.action === "fill") i = h.contains(p.x, p.y)
                else {
                  let g = u
                  i = h.strokeContains(p.x, p.y, g.width, g.alignment)
                }
                let m = o.hole
                if (m) {
                  let g = m.shapePath?.shapePrimitives
                  if (g)
                    for (let x = 0; x < g.length; x++) g[x].shape.contains(p.x, p.y) && (i = !1)
                }
                if (i) return !0
              }
            }
            return i
          }
          destroy(e = !1) {
            if (
              ((this._stateStack.length = 0),
              (this._transform = null),
              this.emit("destroy", this),
              this.removeAllListeners(),
              typeof e == "boolean" ? e : e?.texture)
            ) {
              let i = typeof e == "boolean" ? e : e?.textureSource
              ;(this._fillStyle.texture && this._fillStyle.texture.destroy(i),
                this._strokeStyle.texture && this._strokeStyle.texture.destroy(i))
            }
            ;((this._fillStyle = null),
              (this._strokeStyle = null),
              (this.instructions = null),
              (this._activePath = null),
              (this._bounds = null),
              (this._stateStack = null),
              (this.customShader = null),
              (this._transform = null))
          }
        }))
      Bd.defaultFillStyle = {
        color: 16777215,
        alpha: 1,
        texture: I.WHITE,
        matrix: null,
        fill: null,
        textureSpace: "local",
      }
      Bd.defaultStrokeStyle = {
        width: 1,
        color: 16777215,
        alpha: 1,
        alignment: 0.5,
        miterLimit: 10,
        cap: "butt",
        join: "miter",
        texture: I.WHITE,
        matrix: null,
        fill: null,
        textureSpace: "local",
        pixelLine: !1,
      }
      St = Bd
    })
  function Fu(r) {
    let e = [],
      t = 0
    for (let i = 0; i < kb.length; i++) {
      let n = `_${kb[i]}`
      e[t++] = r[n]
    }
    return (
      (t = Ub(r._fill, e, t)),
      (t = oR(r._stroke, e, t)),
      (t = aR(r.dropShadow, e, t)),
      e.join("-")
    )
  }
  function Ub(r, e, t) {
    return (r && ((e[t++] = r.color), (e[t++] = r.alpha), (e[t++] = r.fill?.styleKey)), t)
  }
  function oR(r, e, t) {
    return (
      r &&
        ((t = Ub(r, e, t)),
        (e[t++] = r.width),
        (e[t++] = r.alignment),
        (e[t++] = r.cap),
        (e[t++] = r.join),
        (e[t++] = r.miterLimit)),
      t
    )
  }
  function aR(r, e, t) {
    return (
      r &&
        ((e[t++] = r.alpha),
        (e[t++] = r.angle),
        (e[t++] = r.blur),
        (e[t++] = r.distance),
        (e[t++] = q.shared.setValue(r.color).toNumber())),
      t
    )
  }
  var kb,
    Gd = d(() => {
      $e()
      kb = [
        "align",
        "breakWords",
        "cssOverrides",
        "fontVariant",
        "fontWeight",
        "leading",
        "letterSpacing",
        "lineHeight",
        "padding",
        "textBaseline",
        "trim",
        "whiteSpace",
        "wordWrap",
        "wordWrapWidth",
        "fontFamily",
        "fontStyle",
        "fontSize",
      ]
    })
  function uR(r) {
    let e = r
    if (typeof e.dropShadow == "boolean" && e.dropShadow) {
      let t = mt.defaultDropShadow
      r.dropShadow = {
        alpha: e.dropShadowAlpha ?? t.alpha,
        angle: e.dropShadowAngle ?? t.angle,
        blur: e.dropShadowBlur ?? t.blur,
        color: e.dropShadowColor ?? t.color,
        distance: e.dropShadowDistance ?? t.distance,
      }
    }
    if (e.strokeThickness !== void 0) {
      z(K, "strokeThickness is now a part of stroke")
      let t = e.stroke,
        i = {}
      if (q.isColorLike(t)) i.color = t
      else if (t instanceof ft || t instanceof fr) i.fill = t
      else if (Object.hasOwnProperty.call(t, "color") || Object.hasOwnProperty.call(t, "fill"))
        i = t
      else throw new Error("Invalid stroke value.")
      r.stroke = { ...i, width: e.strokeThickness }
    }
    if (Array.isArray(e.fillGradientStops)) {
      z(K, "gradient fill is now a fill pattern: `new FillGradient(...)`")
      let t
      r.fontSize == null
        ? (r.fontSize = mt.defaultTextStyle.fontSize)
        : typeof r.fontSize == "string"
          ? (t = parseInt(r.fontSize, 10))
          : (t = r.fontSize)
      let i = new ft({ start: { x: 0, y: 0 }, end: { x: 0, y: (t || 0) * 1.7 } }),
        n = e.fillGradientStops.map((s) => q.shared.setValue(s).toNumber())
      ;(n.forEach((s, o) => {
        let a = o / (n.length - 1)
        i.addColorStop(a, s)
      }),
        (r.fill = { fill: i }))
    }
  }
  var kd,
    mt,
    hn = d(() => {
      Je()
      $e()
      Te()
      tn()
      Cu()
      Id()
      Fd()
      Gd()
      kd = class cn extends pe {
        constructor(e = {}) {
          ;(super(), uR(e))
          let t = { ...cn.defaultTextStyle, ...e }
          for (let i in t) {
            let n = i
            this[n] = t[i]
          }
          this.update()
        }
        get align() {
          return this._align
        }
        set align(e) {
          ;((this._align = e), this.update())
        }
        get breakWords() {
          return this._breakWords
        }
        set breakWords(e) {
          ;((this._breakWords = e), this.update())
        }
        get dropShadow() {
          return this._dropShadow
        }
        set dropShadow(e) {
          ;(e !== null && typeof e == "object"
            ? (this._dropShadow = this._createProxy({ ...cn.defaultDropShadow, ...e }))
            : (this._dropShadow = e ? this._createProxy({ ...cn.defaultDropShadow }) : null),
            this.update())
        }
        get fontFamily() {
          return this._fontFamily
        }
        set fontFamily(e) {
          ;((this._fontFamily = e), this.update())
        }
        get fontSize() {
          return this._fontSize
        }
        set fontSize(e) {
          ;(typeof e == "string" ? (this._fontSize = parseInt(e, 10)) : (this._fontSize = e),
            this.update())
        }
        get fontStyle() {
          return this._fontStyle
        }
        set fontStyle(e) {
          ;((this._fontStyle = e.toLowerCase()), this.update())
        }
        get fontVariant() {
          return this._fontVariant
        }
        set fontVariant(e) {
          ;((this._fontVariant = e), this.update())
        }
        get fontWeight() {
          return this._fontWeight
        }
        set fontWeight(e) {
          ;((this._fontWeight = e), this.update())
        }
        get leading() {
          return this._leading
        }
        set leading(e) {
          ;((this._leading = e), this.update())
        }
        get letterSpacing() {
          return this._letterSpacing
        }
        set letterSpacing(e) {
          ;((this._letterSpacing = e), this.update())
        }
        get lineHeight() {
          return this._lineHeight
        }
        set lineHeight(e) {
          ;((this._lineHeight = e), this.update())
        }
        get padding() {
          return this._padding
        }
        set padding(e) {
          ;((this._padding = e), this.update())
        }
        get trim() {
          return this._trim
        }
        set trim(e) {
          ;((this._trim = e), this.update())
        }
        get textBaseline() {
          return this._textBaseline
        }
        set textBaseline(e) {
          ;((this._textBaseline = e), this.update())
        }
        get whiteSpace() {
          return this._whiteSpace
        }
        set whiteSpace(e) {
          ;((this._whiteSpace = e), this.update())
        }
        get wordWrap() {
          return this._wordWrap
        }
        set wordWrap(e) {
          ;((this._wordWrap = e), this.update())
        }
        get wordWrapWidth() {
          return this._wordWrapWidth
        }
        set wordWrapWidth(e) {
          ;((this._wordWrapWidth = e), this.update())
        }
        get fill() {
          return this._originalFill
        }
        set fill(e) {
          e !== this._originalFill &&
            ((this._originalFill = e),
            this._isFillStyle(e) &&
              (this._originalFill = this._createProxy({ ...St.defaultFillStyle, ...e }, () => {
                this._fill = pr({ ...this._originalFill }, St.defaultFillStyle)
              })),
            (this._fill = pr(e === 0 ? "black" : e, St.defaultFillStyle)),
            this.update())
        }
        get stroke() {
          return this._originalStroke
        }
        set stroke(e) {
          e !== this._originalStroke &&
            ((this._originalStroke = e),
            this._isFillStyle(e) &&
              (this._originalStroke = this._createProxy({ ...St.defaultStrokeStyle, ...e }, () => {
                this._stroke = ln({ ...this._originalStroke }, St.defaultStrokeStyle)
              })),
            (this._stroke = ln(e, St.defaultStrokeStyle)),
            this.update())
        }
        _generateKey() {
          return ((this._styleKey = Fu(this)), this._styleKey)
        }
        update() {
          ;((this._styleKey = null), this.emit("update", this))
        }
        reset() {
          let e = cn.defaultTextStyle
          for (let t in e) this[t] = e[t]
        }
        get styleKey() {
          return this._styleKey || this._generateKey()
        }
        clone() {
          return new cn({
            align: this.align,
            breakWords: this.breakWords,
            dropShadow: this._dropShadow ? { ...this._dropShadow } : null,
            fill: this._fill,
            fontFamily: this.fontFamily,
            fontSize: this.fontSize,
            fontStyle: this.fontStyle,
            fontVariant: this.fontVariant,
            fontWeight: this.fontWeight,
            leading: this.leading,
            letterSpacing: this.letterSpacing,
            lineHeight: this.lineHeight,
            padding: this.padding,
            stroke: this._stroke,
            textBaseline: this.textBaseline,
            whiteSpace: this.whiteSpace,
            wordWrap: this.wordWrap,
            wordWrapWidth: this.wordWrapWidth,
          })
        }
        destroy(e = !1) {
          if ((this.removeAllListeners(), typeof e == "boolean" ? e : e?.texture)) {
            let i = typeof e == "boolean" ? e : e?.textureSource
            ;(this._fill?.texture && this._fill.texture.destroy(i),
              this._originalFill?.texture && this._originalFill.texture.destroy(i),
              this._stroke?.texture && this._stroke.texture.destroy(i),
              this._originalStroke?.texture && this._originalStroke.texture.destroy(i))
          }
          ;((this._fill = null),
            (this._stroke = null),
            (this.dropShadow = null),
            (this._originalStroke = null),
            (this._originalFill = null))
        }
        _createProxy(e, t) {
          return new Proxy(e, { set: (i, n, s) => ((i[n] = s), t?.(n, s), this.update(), !0) })
        }
        _isFillStyle(e) {
          return (e ?? null) !== null && !(q.isColorLike(e) || e instanceof ft || e instanceof fr)
        }
      }
      kd.defaultDropShadow = { alpha: 1, angle: Math.PI / 6, blur: 0, color: "black", distance: 5 }
      kd.defaultTextStyle = {
        align: "left",
        breakWords: !1,
        dropShadow: null,
        fill: "black",
        fontFamily: "Arial",
        fontSize: 26,
        fontStyle: "normal",
        fontVariant: "normal",
        fontWeight: "normal",
        leading: 0,
        letterSpacing: 0,
        lineHeight: 0,
        padding: 0,
        stroke: null,
        textBaseline: "alphabetic",
        trim: !1,
        whiteSpace: "pre",
        wordWrap: !1,
        wordWrapWidth: 100,
      }
      mt = kd
    })
  function Bu(r, e, t, i) {
    let n = lR
    ;((n.minX = 0), (n.minY = 0), (n.maxX = (r.width / i) | 0), (n.maxY = (r.height / i) | 0))
    let s = Ce.getOptimalTexture(n.width, n.height, i, !1)
    return (
      (s.source.uploadMethodId = "image"),
      (s.source.resource = r),
      (s.source.alphaMode = "premultiply-alpha-on-upload"),
      (s.frame.width = e / i),
      (s.frame.height = t / i),
      s.source.emit("update", s.source),
      s.updateUvs(),
      s
    )
  }
  var lR,
    Ud = d(() => {
      Tr()
      lt()
      lR = new de()
    })
  function xi(r) {
    let e = typeof r.fontSize == "number" ? `${r.fontSize}px` : r.fontSize,
      t = r.fontFamily
    Array.isArray(r.fontFamily) || (t = r.fontFamily.split(","))
    for (let i = t.length - 1; i >= 0; i--) {
      let n = t[i].trim()
      ;(!/([\"\'])[^\'\"]+\1/.test(n) && !cR.includes(n) && (n = `"${n}"`), (t[i] = n))
    }
    return `${r.fontStyle} ${r.fontVariant} ${r.fontWeight} ${e} ${t.join(",")}`
  }
  var cR,
    Iu = d(() => {
      "use strict"
      cR = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"]
    })
  var Od,
    Lt,
    Pt,
    Gu = d(() => {
      Ie()
      Iu()
      ;((Od = { willReadFrequently: !0 }),
        (Lt = class V {
          static get experimentalLetterSpacingSupported() {
            let e = V._experimentalLetterSpacingSupported
            if (e !== void 0) {
              let t = Z.get().getCanvasRenderingContext2D().prototype
              e = V._experimentalLetterSpacingSupported =
                "letterSpacing" in t || "textLetterSpacing" in t
            }
            return e
          }
          constructor(e, t, i, n, s, o, a, u, l) {
            ;((this.text = e),
              (this.style = t),
              (this.width = i),
              (this.height = n),
              (this.lines = s),
              (this.lineWidths = o),
              (this.lineHeight = a),
              (this.maxLineWidth = u),
              (this.fontProperties = l))
          }
          static measureText(e = " ", t, i = V._canvas, n = t.wordWrap) {
            let s = `${e}:${t.styleKey}`
            if (V._measurementCache[s]) return V._measurementCache[s]
            let o = xi(t),
              a = V.measureFont(o)
            a.fontSize === 0 && ((a.fontSize = t.fontSize), (a.ascent = t.fontSize))
            let u = V.__context
            u.font = o
            let c = (n ? V._wordWrap(e, t, i) : e).split(/(?:\r\n|\r|\n)/),
              h = new Array(c.length),
              f = 0
            for (let v = 0; v < c.length; v++) {
              let S = V._measureText(c[v], t.letterSpacing, u)
              ;((h[v] = S), (f = Math.max(f, S)))
            }
            let p = t._stroke?.width || 0,
              m = f + p
            t.dropShadow && (m += t.dropShadow.distance)
            let g = t.lineHeight || a.fontSize,
              x = Math.max(g, a.fontSize + p) + (c.length - 1) * (g + t.leading)
            return (
              t.dropShadow && (x += t.dropShadow.distance),
              new V(e, t, m, x, c, h, g + t.leading, f, a)
            )
          }
          static _measureText(e, t, i) {
            let n = !1
            V.experimentalLetterSpacingSupported &&
              (V.experimentalLetterSpacing
                ? ((i.letterSpacing = `${t}px`), (i.textLetterSpacing = `${t}px`), (n = !0))
                : ((i.letterSpacing = "0px"), (i.textLetterSpacing = "0px")))
            let s = i.measureText(e),
              o = s.width,
              a = -s.actualBoundingBoxLeft,
              l = s.actualBoundingBoxRight - a
            if (o > 0)
              if (n) ((o -= t), (l -= t))
              else {
                let c = (V.graphemeSegmenter(e).length - 1) * t
                ;((o += c), (l += c))
              }
            return Math.max(o, l)
          }
          static _wordWrap(e, t, i = V._canvas) {
            let n = i.getContext("2d", Od),
              s = 0,
              o = "",
              a = "",
              u = Object.create(null),
              { letterSpacing: l, whiteSpace: c } = t,
              h = V._collapseSpaces(c),
              f = V._collapseNewlines(c),
              p = !h,
              m = t.wordWrapWidth + l,
              g = V._tokenize(e)
            for (let x = 0; x < g.length; x++) {
              let y = g[x]
              if (V._isNewline(y)) {
                if (!f) {
                  ;((a += V._addLine(o)), (p = !h), (o = ""), (s = 0))
                  continue
                }
                y = " "
              }
              if (h) {
                let S = V.isBreakingSpace(y),
                  b = V.isBreakingSpace(o[o.length - 1])
                if (S && b) continue
              }
              let v = V._getFromCache(y, l, u, n)
              if (v > m)
                if (
                  (o !== "" && ((a += V._addLine(o)), (o = ""), (s = 0)),
                  V.canBreakWords(y, t.breakWords))
                ) {
                  let S = V.wordWrapSplit(y)
                  for (let b = 0; b < S.length; b++) {
                    let M = S[b],
                      C = M,
                      w = 1
                    for (; S[b + w]; ) {
                      let O = S[b + w]
                      if (!V.canBreakChars(C, O, y, b, t.breakWords)) M += O
                      else break
                      ;((C = O), w++)
                    }
                    b += w - 1
                    let B = V._getFromCache(M, l, u, n)
                    ;(B + s > m && ((a += V._addLine(o)), (p = !1), (o = ""), (s = 0)),
                      (o += M),
                      (s += B))
                  }
                } else {
                  o.length > 0 && ((a += V._addLine(o)), (o = ""), (s = 0))
                  let S = x === g.length - 1
                  ;((a += V._addLine(y, !S)), (p = !1), (o = ""), (s = 0))
                }
              else
                (v + s > m && ((p = !1), (a += V._addLine(o)), (o = ""), (s = 0)),
                  (o.length > 0 || !V.isBreakingSpace(y) || p) && ((o += y), (s += v)))
            }
            return ((a += V._addLine(o, !1)), a)
          }
          static _addLine(e, t = !0) {
            return (
              (e = V._trimRight(e)),
              (e = t
                ? `${e}
`
                : e),
              e
            )
          }
          static _getFromCache(e, t, i, n) {
            let s = i[e]
            return (typeof s != "number" && ((s = V._measureText(e, t, n) + t), (i[e] = s)), s)
          }
          static _collapseSpaces(e) {
            return e === "normal" || e === "pre-line"
          }
          static _collapseNewlines(e) {
            return e === "normal"
          }
          static _trimRight(e) {
            if (typeof e != "string") return ""
            for (let t = e.length - 1; t >= 0; t--) {
              let i = e[t]
              if (!V.isBreakingSpace(i)) break
              e = e.slice(0, -1)
            }
            return e
          }
          static _isNewline(e) {
            return typeof e != "string" ? !1 : V._newlines.includes(e.charCodeAt(0))
          }
          static isBreakingSpace(e, t) {
            return typeof e != "string" ? !1 : V._breakingSpaces.includes(e.charCodeAt(0))
          }
          static _tokenize(e) {
            let t = [],
              i = ""
            if (typeof e != "string") return t
            for (let n = 0; n < e.length; n++) {
              let s = e[n],
                o = e[n + 1]
              if (V.isBreakingSpace(s, o) || V._isNewline(s)) {
                ;(i !== "" && (t.push(i), (i = "")), t.push(s))
                continue
              }
              i += s
            }
            return (i !== "" && t.push(i), t)
          }
          static canBreakWords(e, t) {
            return t
          }
          static canBreakChars(e, t, i, n, s) {
            return !0
          }
          static wordWrapSplit(e) {
            return V.graphemeSegmenter(e)
          }
          static measureFont(e) {
            if (V._fonts[e]) return V._fonts[e]
            let t = V._context
            t.font = e
            let i = t.measureText(V.METRICS_STRING + V.BASELINE_SYMBOL),
              n = {
                ascent: i.actualBoundingBoxAscent,
                descent: i.actualBoundingBoxDescent,
                fontSize: i.actualBoundingBoxAscent + i.actualBoundingBoxDescent,
              }
            return ((V._fonts[e] = n), n)
          }
          static clearMetrics(e = "") {
            e ? delete V._fonts[e] : (V._fonts = {})
          }
          static get _canvas() {
            if (!V.__canvas) {
              let e
              try {
                let t = new OffscreenCanvas(0, 0)
                if (t.getContext("2d", Od)?.measureText) return ((V.__canvas = t), t)
                e = Z.get().createCanvas()
              } catch {
                e = Z.get().createCanvas()
              }
              ;((e.width = e.height = 10), (V.__canvas = e))
            }
            return V.__canvas
          }
          static get _context() {
            return (V.__context || (V.__context = V._canvas.getContext("2d", Od)), V.__context)
          }
        }))
      Lt.METRICS_STRING = "|\xC9q\xC5"
      Lt.BASELINE_SYMBOL = "M"
      Lt.BASELINE_MULTIPLIER = 1.4
      Lt.HEIGHT_MULTIPLIER = 2
      Lt.graphemeSegmenter = (() => {
        if (typeof Intl?.Segmenter == "function") {
          let r = new Intl.Segmenter()
          return (e) => [...r.segment(e)].map((t) => t.segment)
        }
        return (r) => [...r]
      })()
      Lt.experimentalLetterSpacing = !1
      Lt._fonts = {}
      Lt._newlines = [10, 13]
      Lt._breakingSpaces = [
        9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288,
      ]
      Lt._measurementCache = {}
      Pt = Lt
    })
  function dn(r, e, t, i = 0) {
    if (r.texture === I.WHITE && !r.fill)
      return q.shared
        .setValue(r.color)
        .setAlpha(r.alpha ?? 1)
        .toHexa()
    if (r.fill) {
      if (r.fill instanceof fr) {
        let n = r.fill,
          s = e.createPattern(n.texture.source.resource, "repeat"),
          o = n.transform.copyTo(F.shared)
        return (o.scale(n.texture.frame.width, n.texture.frame.height), s.setTransform(o), s)
      } else if (r.fill instanceof ft) {
        let n = r.fill,
          s = n.type === "linear",
          o = n.textureSpace === "local",
          a = 1,
          u = 1
        o && t && ((a = t.width + i), (u = t.height + i))
        let l,
          c = !1
        if (s) {
          let { start: h, end: f } = n
          ;((l = e.createLinearGradient(h.x * a, h.y * u, f.x * a, f.y * u)),
            (c = Math.abs(f.x - h.x) < Math.abs((f.y - h.y) * 0.1)))
        } else {
          let { center: h, innerRadius: f, outerCenter: p, outerRadius: m } = n
          l = e.createRadialGradient(h.x * a, h.y * u, f * a, p.x * a, p.y * u, m * a)
        }
        if (c && o && t) {
          let h = t.lineHeight / u
          for (let f = 0; f < t.lines.length; f++) {
            let p = (f * t.lineHeight + i / 2) / u
            n.colorStops.forEach((m) => {
              let g = p + m.offset * h
              l.addColorStop(Math.floor(g * Ob) / Ob, q.shared.setValue(m.color).toHex())
            })
          }
        } else
          n.colorStops.forEach((h) => {
            l.addColorStop(h.offset, q.shared.setValue(h.color).toHex())
          })
        return l
      }
    } else {
      let n = e.createPattern(r.texture.source.resource, "repeat"),
        s = r.matrix.copyTo(F.shared)
      return (s.scale(r.texture.frame.width, r.texture.frame.height), n.setTransform(s), n)
    }
    return (H("FillStyle not recognised", r), "red")
  }
  var Ob,
    Ld = d(() => {
      $e()
      se()
      ge()
      be()
      tn()
      Cu()
      Ob = 1e5
    })
  var Rs,
    Lb = d(() => {
      $e()
      D()
      Zn()
      on()
      Tr()
      Qy()
      Te()
      hn()
      Ud()
      Gu()
      Iu()
      Ld()
      Rs = class {
        constructor(e) {
          ;((this._activeTextures = {}), (this._renderer = e))
        }
        getTextureSize(e, t, i) {
          let n = Pt.measureText(e || " ", i),
            s = Math.ceil(Math.ceil(Math.max(1, n.width) + i.padding * 2) * t),
            o = Math.ceil(Math.ceil(Math.max(1, n.height) + i.padding * 2) * t)
          return (
            (s = Math.ceil(s - 1e-6)),
            (o = Math.ceil(o - 1e-6)),
            (s = ar(s)),
            (o = ar(o)),
            { width: s, height: o }
          )
        }
        getTexture(e, t, i, n) {
          ;(typeof e == "string" &&
            (z(
              "8.0.0",
              "CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments",
            ),
            (e = { text: e, style: i, resolution: t })),
            e.style instanceof mt || (e.style = new mt(e.style)))
          let { texture: s, canvasAndContext: o } = this.createTextureAndCanvas(e)
          return (this._renderer.texture.initSource(s._source), pt.returnCanvasAndContext(o), s)
        }
        createTextureAndCanvas(e) {
          let { text: t, style: i } = e,
            n = e.resolution ?? this._renderer.resolution,
            s = Pt.measureText(t || " ", i),
            o = Math.ceil(Math.ceil(Math.max(1, s.width) + i.padding * 2) * n),
            a = Math.ceil(Math.ceil(Math.max(1, s.height) + i.padding * 2) * n),
            u = pt.getOptimalCanvasAndContext(o, a),
            { canvas: l } = u
          this.renderTextToCanvas(t, i, n, u)
          let c = Bu(l, o, a, n)
          if (i.trim) {
            let h = Zy(l, n)
            ;(c.frame.copyFrom(h), c.updateUvs())
          }
          return { texture: c, canvasAndContext: u }
        }
        getManagedTexture(e) {
          e._resolution = e._autoResolution ? this._renderer.resolution : e.resolution
          let t = e._getKey()
          if (this._activeTextures[t])
            return (this._increaseReferenceCount(t), this._activeTextures[t].texture)
          let { texture: i, canvasAndContext: n } = this.createTextureAndCanvas(e)
          return ((this._activeTextures[t] = { canvasAndContext: n, texture: i, usageCount: 1 }), i)
        }
        _increaseReferenceCount(e) {
          this._activeTextures[e].usageCount++
        }
        returnTexture(e) {
          let t = e.source
          ;((t.resource = null),
            (t.uploadMethodId = "unknown"),
            (t.alphaMode = "no-premultiply-alpha"),
            Ce.returnTexture(e))
        }
        decreaseReferenceCount(e) {
          let t = this._activeTextures[e]
          ;(t.usageCount--,
            t.usageCount === 0 &&
              (pt.returnCanvasAndContext(t.canvasAndContext),
              this.returnTexture(t.texture),
              (this._activeTextures[e] = null)))
        }
        getReferenceCount(e) {
          return this._activeTextures[e].usageCount
        }
        renderTextToCanvas(e, t, i, n) {
          let { canvas: s, context: o } = n,
            a = xi(t),
            u = Pt.measureText(e || " ", t),
            l = u.lines,
            c = u.lineHeight,
            h = u.lineWidths,
            f = u.maxLineWidth,
            p = u.fontProperties,
            m = s.height
          if (
            (o.resetTransform(), o.scale(i, i), (o.textBaseline = t.textBaseline), t._stroke?.width)
          ) {
            let v = t._stroke
            ;((o.lineWidth = v.width),
              (o.miterLimit = v.miterLimit),
              (o.lineJoin = v.join),
              (o.lineCap = v.cap))
          }
          o.font = a
          let g,
            x,
            y = t.dropShadow ? 2 : 1
          for (let v = 0; v < y; ++v) {
            let S = t.dropShadow && v === 0,
              b = S ? Math.ceil(Math.max(1, m) + t.padding * 2) : 0,
              M = b * i
            if (S) {
              ;((o.fillStyle = "black"), (o.strokeStyle = "black"))
              let B = t.dropShadow,
                O = B.color,
                G = B.alpha
              o.shadowColor = q.shared.setValue(O).setAlpha(G).toRgbaString()
              let A = B.blur * i,
                W = B.distance * i
              ;((o.shadowBlur = A),
                (o.shadowOffsetX = Math.cos(B.angle) * W),
                (o.shadowOffsetY = Math.sin(B.angle) * W + M))
            } else {
              if (((o.fillStyle = t._fill ? dn(t._fill, o, u) : null), t._stroke?.width)) {
                let B = t._stroke.width * t._stroke.alignment
                o.strokeStyle = dn(t._stroke, o, u, B)
              }
              o.shadowColor = "black"
            }
            let C = (c - p.fontSize) / 2
            c - p.fontSize < 0 && (C = 0)
            let w = t._stroke?.width ?? 0
            for (let B = 0; B < l.length; B++)
              ((g = w / 2),
                (x = w / 2 + B * c + p.ascent + C),
                t.align === "right"
                  ? (g += f - h[B])
                  : t.align === "center" && (g += (f - h[B]) / 2),
                t._stroke?.width &&
                  this._drawLetterSpacing(l[B], t, n, g + t.padding, x + t.padding - b, !0),
                t._fill !== void 0 &&
                  this._drawLetterSpacing(l[B], t, n, g + t.padding, x + t.padding - b))
          }
        }
        _drawLetterSpacing(e, t, i, n, s, o = !1) {
          let { context: a } = i,
            u = t.letterSpacing,
            l = !1
          if (
            (Pt.experimentalLetterSpacingSupported &&
              (Pt.experimentalLetterSpacing
                ? ((a.letterSpacing = `${u}px`), (a.textLetterSpacing = `${u}px`), (l = !0))
                : ((a.letterSpacing = "0px"), (a.textLetterSpacing = "0px"))),
            u === 0 || l)
          ) {
            o ? a.strokeText(e, n, s) : a.fillText(e, n, s)
            return
          }
          let c = n,
            h = Pt.graphemeSegmenter(e),
            f = a.measureText(e).width,
            p = 0
          for (let m = 0; m < h.length; ++m) {
            let g = h[m]
            o ? a.strokeText(g, c, s) : a.fillText(g, c, s)
            let x = ""
            for (let y = m + 1; y < h.length; ++y) x += h[y]
            ;((p = a.measureText(x).width), (c += f - p + u), (f = p))
          }
        }
        destroy() {
          this._activeTextures = null
        }
      }
      Rs.extension = { type: [_.WebGLSystem, _.WebGPUSystem, _.CanvasSystem], name: "canvasText" }
    })
  var Nd = d(() => {
    D()
    Ky()
    Lb()
    L.add(Rs)
    L.add(As)
  })
  var Gr,
    Hd = d(() => {
      Te()
      Ka()
      Id()
      Gr = class r extends wr {
        constructor(e) {
          e instanceof St && (e = { context: e })
          let { context: t, roundPixels: i, ...n } = e || {}
          ;(super({ label: "Graphics", ...n }),
            (this.renderPipeId = "graphics"),
            t ? (this._context = t) : (this._context = this._ownedContext = new St()),
            this._context.on("update", this.onViewUpdate, this),
            (this.allowChildren = !1),
            (this.roundPixels = i ?? !1))
        }
        set context(e) {
          e !== this._context &&
            (this._context.off("update", this.onViewUpdate, this),
            (this._context = e),
            this._context.on("update", this.onViewUpdate, this),
            this.onViewUpdate())
        }
        get context() {
          return this._context
        }
        get bounds() {
          return this._context.bounds
        }
        updateBounds() {}
        containsPoint(e) {
          return this._context.containsPoint(e)
        }
        destroy(e) {
          ;(this._ownedContext && !e
            ? this._ownedContext.destroy(e)
            : (e === !0 || e?.context === !0) && this._context.destroy(e),
            (this._ownedContext = null),
            (this._context = null),
            super.destroy(e))
        }
        _callContextMethod(e, t) {
          return (this.context[e](...t), this)
        }
        setFillStyle(...e) {
          return this._callContextMethod("setFillStyle", e)
        }
        setStrokeStyle(...e) {
          return this._callContextMethod("setStrokeStyle", e)
        }
        fill(...e) {
          return this._callContextMethod("fill", e)
        }
        stroke(...e) {
          return this._callContextMethod("stroke", e)
        }
        texture(...e) {
          return this._callContextMethod("texture", e)
        }
        beginPath() {
          return this._callContextMethod("beginPath", [])
        }
        cut() {
          return this._callContextMethod("cut", [])
        }
        arc(...e) {
          return this._callContextMethod("arc", e)
        }
        arcTo(...e) {
          return this._callContextMethod("arcTo", e)
        }
        arcToSvg(...e) {
          return this._callContextMethod("arcToSvg", e)
        }
        bezierCurveTo(...e) {
          return this._callContextMethod("bezierCurveTo", e)
        }
        closePath() {
          return this._callContextMethod("closePath", [])
        }
        ellipse(...e) {
          return this._callContextMethod("ellipse", e)
        }
        circle(...e) {
          return this._callContextMethod("circle", e)
        }
        path(...e) {
          return this._callContextMethod("path", e)
        }
        lineTo(...e) {
          return this._callContextMethod("lineTo", e)
        }
        moveTo(...e) {
          return this._callContextMethod("moveTo", e)
        }
        quadraticCurveTo(...e) {
          return this._callContextMethod("quadraticCurveTo", e)
        }
        rect(...e) {
          return this._callContextMethod("rect", e)
        }
        roundRect(...e) {
          return this._callContextMethod("roundRect", e)
        }
        poly(...e) {
          return this._callContextMethod("poly", e)
        }
        regularPoly(...e) {
          return this._callContextMethod("regularPoly", e)
        }
        roundPoly(...e) {
          return this._callContextMethod("roundPoly", e)
        }
        roundShape(...e) {
          return this._callContextMethod("roundShape", e)
        }
        filletRect(...e) {
          return this._callContextMethod("filletRect", e)
        }
        chamferRect(...e) {
          return this._callContextMethod("chamferRect", e)
        }
        star(...e) {
          return this._callContextMethod("star", e)
        }
        svg(...e) {
          return this._callContextMethod("svg", e)
        }
        restore(...e) {
          return this._callContextMethod("restore", e)
        }
        save() {
          return this._callContextMethod("save", [])
        }
        getTransform() {
          return this.context.getTransform()
        }
        resetTransform() {
          return this._callContextMethod("resetTransform", [])
        }
        rotateTransform(...e) {
          return this._callContextMethod("rotate", e)
        }
        scaleTransform(...e) {
          return this._callContextMethod("scale", e)
        }
        setTransform(...e) {
          return this._callContextMethod("setTransform", e)
        }
        transform(...e) {
          return this._callContextMethod("transform", e)
        }
        translateTransform(...e) {
          return this._callContextMethod("translate", e)
        }
        clear() {
          return this._callContextMethod("clear", [])
        }
        get fillStyle() {
          return this._context.fillStyle
        }
        set fillStyle(e) {
          this._context.fillStyle = e
        }
        get strokeStyle() {
          return this._context.strokeStyle
        }
        set strokeStyle(e) {
          this._context.strokeStyle = e
        }
        clone(e = !1) {
          return e
            ? new r(this._context.clone())
            : ((this._ownedContext = null), new r(this._context))
        }
        lineStyle(e, t, i) {
          z(
            K,
            "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.",
          )
          let n = {}
          return (
            e && (n.width = e),
            t && (n.color = t),
            i && (n.alpha = i),
            (this.context.strokeStyle = n),
            this
          )
        }
        beginFill(e, t) {
          z(
            K,
            "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.",
          )
          let i = {}
          return (
            e !== void 0 && (i.color = e),
            t !== void 0 && (i.alpha = t),
            (this.context.fillStyle = i),
            this
          )
        }
        endFill() {
          ;(z(
            K,
            "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.",
          ),
            this.context.fill())
          let e = this.context.strokeStyle
          return (
            (e.width !== St.defaultStrokeStyle.width ||
              e.color !== St.defaultStrokeStyle.color ||
              e.alpha !== St.defaultStrokeStyle.alpha) &&
              this.context.stroke(),
            this
          )
        }
        drawCircle(...e) {
          return (
            z(K, "Graphics#drawCircle has been renamed to Graphics#circle"),
            this._callContextMethod("circle", e)
          )
        }
        drawEllipse(...e) {
          return (
            z(K, "Graphics#drawEllipse has been renamed to Graphics#ellipse"),
            this._callContextMethod("ellipse", e)
          )
        }
        drawPolygon(...e) {
          return (
            z(K, "Graphics#drawPolygon has been renamed to Graphics#poly"),
            this._callContextMethod("poly", e)
          )
        }
        drawRect(...e) {
          return (
            z(K, "Graphics#drawRect has been renamed to Graphics#rect"),
            this._callContextMethod("rect", e)
          )
        }
        drawRoundedRect(...e) {
          return (
            z(K, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect"),
            this._callContextMethod("roundRect", e)
          )
        }
        drawStar(...e) {
          return (
            z(K, "Graphics#drawStar has been renamed to Graphics#star"),
            this._callContextMethod("star", e)
          )
        }
      }
    })
  var Nb,
    Hb,
    zb = d(() => {
      "use strict"
      ;((Nb = {
        name: "local-uniform-msdf-bit",
        vertex: {
          header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
          main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
          end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `,
        },
        fragment: {
          header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `,
          main: ` 
            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));
        `,
        },
      }),
        (Hb = {
          name: "local-uniform-msdf-bit",
          vertex: {
            header: `
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
            main: `
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `,
            end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `,
          },
          fragment: {
            header: `
            uniform float uDistance;
         `,
            main: ` 
            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));
        `,
          },
        }))
    })
  var Wb,
    Vb,
    $b = d(() => {
      "use strict"
      ;((Wb = {
        name: "msdf-bit",
        fragment: {
          header: `
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {
                
                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));
            
                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));
                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);
                var coverage: f32 = pow(shapeColor.a * alpha, gamma);

                return coverage;
             
            }
        `,
        },
      }),
        (Vb = {
          name: "msdf-bit",
          fragment: {
            header: `
            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {
                
                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));
               
                // SDF
                median = min(median, msdfColor.a);
            
                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
           
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));
                float gamma = mix(1.0, 1.0 / 2.2, luma);
                float coverage = pow(shapeColor.a * alpha, gamma);  
              
                return coverage;
            }
        `,
          },
        }))
    })
  var zd,
    Wd,
    ku,
    Xb = d(() => {
      se()
      ui()
      Rr()
      gs()
      xs()
      Fr()
      cu()
      Ut()
      st()
      zb()
      $b()
      ku = class extends De {
        constructor() {
          let e = new fe({
              uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
              uTransformMatrix: { value: new F(), type: "mat3x3<f32>" },
              uDistance: { value: 4, type: "f32" },
              uRound: { value: 0, type: "f32" },
            }),
            t = wt()
          ;(zd ?? (zd = Kt({ name: "sdf-shader", bits: [Ki, qi(t), Nb, Wb, qt] })),
            Wd ?? (Wd = jt({ name: "sdf-shader", bits: [ji, Zi(t), Hb, Vb, Zt] })),
            super({
              glProgram: Wd,
              gpuProgram: zd,
              resources: { localUniforms: e, batchSamplers: Qi(t) },
            }))
        }
      }
    })
  var Uu,
    Yb = d(() => {
      Je()
      Te()
      Uu = class extends pe {
        constructor() {
          ;(super(...arguments),
            (this.chars = Object.create(null)),
            (this.lineHeight = 0),
            (this.fontFamily = ""),
            (this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 }),
            (this.baseLineOffset = 0),
            (this.distanceField = { type: "none", range: 0 }),
            (this.pages = []),
            (this.applyFillAsTint = !0),
            (this.baseMeasurementFontSize = 100),
            (this.baseRenderedFontSize = 100))
        }
        get font() {
          return (
            z(K, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."),
            this.fontFamily
          )
        }
        get pageTextures() {
          return (
            z(K, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),
            this.pages
          )
        }
        get size() {
          return (
            z(
              K,
              "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.",
            ),
            this.fontMetrics.fontSize
          )
        }
        get distanceFieldRange() {
          return (
            z(
              K,
              "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.",
            ),
            this.distanceField.range
          )
        }
        get distanceFieldType() {
          return (
            z(
              K,
              "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.",
            ),
            this.distanceField.type
          )
        }
        destroy(e = !1) {
          ;(this.emit("destroy", this), this.removeAllListeners())
          for (let t in this.chars) this.chars[t].texture?.destroy()
          ;((this.chars = null),
            e && (this.pages.forEach((t) => t.texture.destroy(!0)), (this.pages = null)))
        }
      }
    })
  function Ou(r) {
    if (r === "") return []
    typeof r == "string" && (r = [r])
    let e = []
    for (let t = 0, i = r.length; t < i; t++) {
      let n = r[t]
      if (Array.isArray(n)) {
        if (n.length !== 2)
          throw new Error(
            `[BitmapFont]: Invalid character range length, expecting 2 got ${n.length}.`,
          )
        if (n[0].length === 0 || n[1].length === 0)
          throw new Error("[BitmapFont]: Invalid character delimiter.")
        let s = n[0].charCodeAt(0),
          o = n[1].charCodeAt(0)
        if (o < s) throw new Error("[BitmapFont]: Invalid character range.")
        for (let a = s, u = o; a <= u; a++) e.push(String.fromCharCode(a))
      } else e.push(...Array.from(n))
    }
    if (e.length === 0) throw new Error("[BitmapFont]: Empty set when resolving characters.")
    return e
  }
  var Vd = d(() => {
    "use strict"
  })
  var Kb,
    $d,
    qb = d(() => {
      $e()
      Ke()
      on()
      Ja()
      ge()
      Te()
      Gu()
      Iu()
      Ld()
      hn()
      Yb()
      Vd()
      Kb = class jb extends Uu {
        constructor(e) {
          ;(super(),
            (this.resolution = 1),
            (this.pages = []),
            (this._padding = 0),
            (this._measureCache = Object.create(null)),
            (this._currentChars = []),
            (this._currentX = 0),
            (this._currentY = 0),
            (this._currentPageIndex = -1),
            (this._skipKerning = !1))
          let t = { ...jb.defaultOptions, ...e }
          ;((this._textureSize = t.textureSize), (this._mipmap = t.mipmap))
          let i = t.style.clone()
          ;(t.overrideFill &&
            ((i._fill.color = 16777215),
            (i._fill.alpha = 1),
            (i._fill.texture = I.WHITE),
            (i._fill.fill = null)),
            (this.applyFillAsTint = t.overrideFill))
          let n = i.fontSize
          i.fontSize = this.baseMeasurementFontSize
          let s = xi(i)
          ;(t.overrideSize
            ? i._stroke && (i._stroke.width *= this.baseRenderedFontSize / n)
            : (i.fontSize = this.baseRenderedFontSize = n),
            (this._style = i),
            (this._skipKerning = t.skipKerning ?? !1),
            (this.resolution = t.resolution ?? 1),
            (this._padding = t.padding ?? 4),
            (this.fontMetrics = Pt.measureFont(s)),
            (this.lineHeight = i.lineHeight || this.fontMetrics.fontSize || i.fontSize))
        }
        ensureCharacters(e) {
          let t = Ou(e)
            .filter((x) => !this._currentChars.includes(x))
            .filter((x, y, v) => v.indexOf(x) === y)
          if (!t.length) return
          this._currentChars = [...this._currentChars, ...t]
          let i
          this._currentPageIndex === -1
            ? (i = this._nextPage())
            : (i = this.pages[this._currentPageIndex])
          let { canvas: n, context: s } = i.canvasAndContext,
            o = i.texture.source,
            a = this._style,
            u = this._currentX,
            l = this._currentY,
            c = this.baseRenderedFontSize / this.baseMeasurementFontSize,
            h = this._padding * c,
            f = 0,
            p = !1,
            m = n.width / this.resolution,
            g = n.height / this.resolution
          for (let x = 0; x < t.length; x++) {
            let y = t[x],
              v = Pt.measureText(y, a, n, !1)
            v.lineHeight = v.height
            let S = v.width * c,
              b = Math.ceil((a.fontStyle === "italic" ? 2 : 1) * S),
              M = v.height * c,
              C = b + h * 2,
              w = M + h * 2
            if (
              ((p = !1),
              y !==
                `
` &&
                y !== "\r" &&
                y !== "	" &&
                y !== " " &&
                ((p = !0), (f = Math.ceil(Math.max(w, f)))),
              u + C > m && ((l += f), (f = w), (u = 0), l + f > g))
            ) {
              o.update()
              let O = this._nextPage()
              ;((n = O.canvasAndContext.canvas),
                (s = O.canvasAndContext.context),
                (o = O.texture.source),
                (l = 0))
            }
            let B = S / c - (a.dropShadow?.distance ?? 0) - (a._stroke?.width ?? 0)
            if (
              ((this.chars[y] = {
                id: y.codePointAt(0),
                xOffset: -this._padding,
                yOffset: -this._padding,
                xAdvance: B,
                kerning: {},
              }),
              p)
            ) {
              this._drawGlyph(s, v, u + h, l + h, c, a)
              let O = o.width * c,
                G = o.height * c,
                A = new ee(
                  (u / O) * o.width,
                  (l / G) * o.height,
                  (C / O) * o.width,
                  (w / G) * o.height,
                )
              ;((this.chars[y].texture = new I({ source: o, frame: A })), (u += Math.ceil(C)))
            }
          }
          ;(o.update(),
            (this._currentX = u),
            (this._currentY = l),
            this._skipKerning && this._applyKerning(t, s))
        }
        get pageTextures() {
          return (
            z(K, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),
            this.pages
          )
        }
        _applyKerning(e, t) {
          let i = this._measureCache
          for (let n = 0; n < e.length; n++) {
            let s = e[n]
            for (let o = 0; o < this._currentChars.length; o++) {
              let a = this._currentChars[o],
                u = i[s]
              u || (u = i[s] = t.measureText(s).width)
              let l = i[a]
              l || (l = i[a] = t.measureText(a).width)
              let c = t.measureText(s + a).width,
                h = c - (u + l)
              ;(h && (this.chars[s].kerning[a] = h),
                (c = t.measureText(s + a).width),
                (h = c - (u + l)),
                h && (this.chars[a].kerning[s] = h))
            }
          }
        }
        _nextPage() {
          this._currentPageIndex++
          let e = this.resolution,
            t = pt.getOptimalCanvasAndContext(this._textureSize, this._textureSize, e)
          this._setupContext(t.context, this._style, e)
          let i = e * (this.baseRenderedFontSize / this.baseMeasurementFontSize),
            n = new I({
              source: new Xt({
                resource: t.canvas,
                resolution: i,
                alphaMode: "premultiply-alpha-on-upload",
                autoGenerateMipmaps: this._mipmap,
              }),
            }),
            s = { canvasAndContext: t, texture: n }
          return ((this.pages[this._currentPageIndex] = s), s)
        }
        _setupContext(e, t, i) {
          ;((t.fontSize = this.baseRenderedFontSize),
            e.scale(i, i),
            (e.font = xi(t)),
            (t.fontSize = this.baseMeasurementFontSize),
            (e.textBaseline = t.textBaseline))
          let n = t._stroke,
            s = n?.width ?? 0
          if (
            (n &&
              ((e.lineWidth = s),
              (e.lineJoin = n.join),
              (e.miterLimit = n.miterLimit),
              (e.strokeStyle = dn(n, e))),
            t._fill && (e.fillStyle = dn(t._fill, e)),
            t.dropShadow)
          ) {
            let o = t.dropShadow,
              a = q.shared.setValue(o.color).toArray(),
              u = o.blur * i,
              l = o.distance * i
            ;((e.shadowColor = `rgba(${a[0] * 255},${a[1] * 255},${a[2] * 255},${o.alpha})`),
              (e.shadowBlur = u),
              (e.shadowOffsetX = Math.cos(o.angle) * l),
              (e.shadowOffsetY = Math.sin(o.angle) * l))
          } else
            ((e.shadowColor = "black"),
              (e.shadowBlur = 0),
              (e.shadowOffsetX = 0),
              (e.shadowOffsetY = 0))
        }
        _drawGlyph(e, t, i, n, s, o) {
          let a = t.text,
            u = t.fontProperties,
            c = (o._stroke?.width ?? 0) * s,
            h = i + c / 2,
            f = n - c / 2,
            p = u.descent * s,
            m = t.lineHeight * s
          ;(o.stroke && c && e.strokeText(a, h, f + m - p), o._fill && e.fillText(a, h, f + m - p))
        }
        destroy() {
          super.destroy()
          for (let e = 0; e < this.pages.length; e++) {
            let { canvasAndContext: t, texture: i } = this.pages[e]
            ;(pt.returnCanvasAndContext(t), i.destroy(!0))
          }
          this.pages = null
        }
      }
      Kb.defaultOptions = { textureSize: 512, style: new mt(), mipmap: !0 }
      $d = Kb
    })
  function Lu(r, e, t, i) {
    let n = {
      width: 0,
      height: 0,
      offsetY: 0,
      scale: e.fontSize / t.baseMeasurementFontSize,
      lines: [{ width: 0, charPositions: [], spaceWidth: 0, spacesIndex: [], chars: [] }],
    }
    n.offsetY = t.baseLineOffset
    let s = n.lines[0],
      o = null,
      a = !0,
      u = { spaceWord: !1, width: 0, start: 0, index: 0, positions: [], chars: [] },
      l = (m) => {
        let g = s.width
        for (let x = 0; x < u.index; x++) {
          let y = m.positions[x]
          ;(s.chars.push(m.chars[x]), s.charPositions.push(y + g))
        }
        ;((s.width += m.width), (a = !1), (u.width = 0), (u.index = 0), (u.chars.length = 0))
      },
      c = () => {
        let m = s.chars.length - 1
        if (i) {
          let g = s.chars[m]
          for (; g === " "; ) ((s.width -= t.chars[g].xAdvance), (g = s.chars[--m]))
        }
        ;((n.width = Math.max(n.width, s.width)),
          (s = { width: 0, charPositions: [], chars: [], spaceWidth: 0, spacesIndex: [] }),
          (a = !0),
          n.lines.push(s),
          (n.height += t.lineHeight))
      },
      h = t.baseMeasurementFontSize / e.fontSize,
      f = e.letterSpacing * h,
      p = e.wordWrapWidth * h
    for (let m = 0; m < r.length + 1; m++) {
      let g,
        x = m === r.length
      x || (g = r[m])
      let y = t.chars[g] || t.chars[" "]
      if (
        /(?:\s)/.test(g) ||
        g === "\r" ||
        g ===
          `
` ||
        x
      ) {
        if (
          (!a && e.wordWrap && s.width + u.width - f > p
            ? (c(), l(u), x || s.charPositions.push(0))
            : ((u.start = s.width), l(u), x || s.charPositions.push(0)),
          g === "\r" ||
            g ===
              `
`)
        )
          s.width !== 0 && c()
        else if (!x) {
          let M = y.xAdvance + (y.kerning[o] || 0) + f
          ;((s.width += M),
            (s.spaceWidth = M),
            s.spacesIndex.push(s.charPositions.length),
            s.chars.push(g))
        }
      } else {
        let b = y.kerning[o] || 0,
          M = y.xAdvance + b + f
        ;((u.positions[u.index++] = u.width + b), u.chars.push(g), (u.width += M))
      }
      o = g
    }
    return (
      c(),
      e.align === "center" ? hR(n) : e.align === "right" ? dR(n) : e.align === "justify" && fR(n),
      n
    )
  }
  function hR(r) {
    for (let e = 0; e < r.lines.length; e++) {
      let t = r.lines[e],
        i = r.width / 2 - t.width / 2
      for (let n = 0; n < t.charPositions.length; n++) t.charPositions[n] += i
    }
  }
  function dR(r) {
    for (let e = 0; e < r.lines.length; e++) {
      let t = r.lines[e],
        i = r.width - t.width
      for (let n = 0; n < t.charPositions.length; n++) t.charPositions[n] += i
    }
  }
  function fR(r) {
    let e = r.width
    for (let t = 0; t < r.lines.length; t++) {
      let i = r.lines[t],
        n = 0,
        s = i.spacesIndex[n++],
        o = 0,
        a = i.spacesIndex.length,
        l = (e - i.width) / a
      for (let c = 0; c < i.charPositions.length; c++)
        (c === s && ((s = i.spacesIndex[n++]), (o += l)), (i.charPositions[c] += o))
    }
  }
  var Xd = d(() => {
    "use strict"
  })
  var Nu,
    Yd,
    Zb,
    Qb = d(() => {
      hs()
      Te()
      be()
      hn()
      qb()
      Xd()
      Vd()
      ;((Nu = 0),
        (Yd = class {
          constructor() {
            ;((this.ALPHA = [["a", "z"], ["A", "Z"], " "]),
              (this.NUMERIC = [["0", "9"]]),
              (this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "]),
              (this.ASCII = [[" ", "~"]]),
              (this.defaultOptions = {
                chars: this.ALPHANUMERIC,
                resolution: 1,
                padding: 4,
                skipKerning: !1,
              }))
          }
          getFont(e, t) {
            let i = `${t.fontFamily}-bitmap`,
              n = !0
            if (t._fill.fill && !t._stroke) ((i += t._fill.fill.styleKey), (n = !1))
            else if (t._stroke || t.dropShadow) {
              let o = t.styleKey
              ;((o = o.substring(0, o.lastIndexOf("-"))), (i = `${o}-bitmap`), (n = !1))
            }
            if (!Ge.has(i)) {
              let o = new $d({
                style: t,
                overrideFill: n,
                overrideSize: !0,
                ...this.defaultOptions,
              })
              ;(Nu++,
                Nu > 50 &&
                  H(
                    "BitmapText",
                    `You have dynamically created ${Nu} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``,
                  ),
                o.once("destroy", () => {
                  ;(Nu--, Ge.remove(i))
                }),
                Ge.set(i, o))
            }
            let s = Ge.get(i)
            return (s.ensureCharacters?.(e), s)
          }
          getLayout(e, t, i = !0) {
            let n = this.getFont(e, t)
            return Lu([...e], t, n, i)
          }
          measureText(e, t, i = !0) {
            return this.getLayout(e, t, i)
          }
          install(...e) {
            let t = e[0]
            typeof t == "string" &&
              ((t = {
                name: t,
                style: e[1],
                chars: e[2]?.chars,
                resolution: e[2]?.resolution,
                padding: e[2]?.padding,
                skipKerning: e[2]?.skipKerning,
              }),
              z(
                K,
                "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})",
              ))
            let i = t?.name
            if (!i) throw new Error("[BitmapFontManager] Property `name` is required.")
            t = { ...this.defaultOptions, ...t }
            let n = t.style,
              s = n instanceof mt ? n : new mt(n),
              o = s._fill.fill !== null && s._fill.fill !== void 0,
              a = new $d({
                style: s,
                overrideFill: o,
                skipKerning: t.skipKerning,
                padding: t.padding,
                resolution: t.resolution,
                overrideSize: !1,
              }),
              u = Ou(t.chars)
            return (
              a.ensureCharacters(u.join("")),
              Ge.set(`${i}-bitmap`, a),
              a.once("destroy", () => Ge.remove(`${i}-bitmap`)),
              a
            )
          }
          uninstall(e) {
            let t = `${e}-bitmap`,
              i = Ge.get(t)
            i && i.destroy()
          }
        }),
        (Zb = new Yd()))
    })
  function Jb(r, e) {
    ;((e.groupTransform = r.groupTransform),
      (e.groupColorAlpha = r.groupColorAlpha),
      (e.groupColor = r.groupColor),
      (e.groupBlendMode = r.groupBlendMode),
      (e.globalDisplayStatus = r.globalDisplayStatus),
      (e.groupTransform = r.groupTransform),
      (e.localDisplayStatus = r.localDisplayStatus),
      (e.groupAlpha = r.groupAlpha),
      (e._roundPixels = r._roundPixels))
  }
  var Fs,
    e0 = d(() => {
      hs()
      D()
      it()
      Hd()
      Xb()
      Qb()
      Xd()
      Fs = class {
        constructor(e) {
          ;((this._gpuBitmapText = {}),
            (this._destroyRenderableBound = this.destroyRenderable.bind(this)),
            (this._renderer = e),
            this._renderer.renderableGC.addManagedHash(this, "_gpuBitmapText"))
        }
        validateRenderable(e) {
          let t = this._getGpuBitmapText(e)
          return (
            e._didTextUpdate && ((e._didTextUpdate = !1), this._updateContext(e, t)),
            this._renderer.renderPipes.graphics.validateRenderable(t)
          )
        }
        addRenderable(e, t) {
          let i = this._getGpuBitmapText(e)
          ;(Jb(e, i),
            e._didTextUpdate && ((e._didTextUpdate = !1), this._updateContext(e, i)),
            this._renderer.renderPipes.graphics.addRenderable(i, t),
            i.context.customShader && this._updateDistanceField(e))
        }
        destroyRenderable(e) {
          ;(e.off("destroyed", this._destroyRenderableBound), this._destroyRenderableByUid(e.uid))
        }
        _destroyRenderableByUid(e) {
          let t = this._gpuBitmapText[e].context
          ;(t.customShader && (j.return(t.customShader), (t.customShader = null)),
            j.return(this._gpuBitmapText[e]),
            (this._gpuBitmapText[e] = null))
        }
        updateRenderable(e) {
          let t = this._getGpuBitmapText(e)
          ;(Jb(e, t),
            this._renderer.renderPipes.graphics.updateRenderable(t),
            t.context.customShader && this._updateDistanceField(e))
        }
        _updateContext(e, t) {
          let { context: i } = t,
            n = Zb.getFont(e.text, e._style)
          ;(i.clear(),
            n.distanceField.type !== "none" && (i.customShader || (i.customShader = j.get(ku))))
          let s = Array.from(e.text),
            o = e._style,
            a = n.baseLineOffset,
            u = Lu(s, o, n, !0),
            l = 0,
            c = o.padding,
            h = u.scale,
            f = u.width,
            p = u.height + u.offsetY
          ;(o._stroke && ((f += o._stroke.width / h), (p += o._stroke.width / h)),
            i.translate(-e._anchor._x * f - c, -e._anchor._y * p - c).scale(h, h))
          let m = n.applyFillAsTint ? o._fill.color : 16777215
          for (let g = 0; g < u.lines.length; g++) {
            let x = u.lines[g]
            for (let y = 0; y < x.charPositions.length; y++) {
              let v = s[l++],
                S = n.chars[v]
              S?.texture &&
                i.texture(
                  S.texture,
                  m || "black",
                  Math.round(x.charPositions[y] + S.xOffset),
                  Math.round(a + S.yOffset),
                )
            }
            a += n.lineHeight
          }
        }
        _getGpuBitmapText(e) {
          return this._gpuBitmapText[e.uid] || this.initGpuText(e)
        }
        initGpuText(e) {
          let t = j.get(Gr)
          return (
            (this._gpuBitmapText[e.uid] = t),
            this._updateContext(e, t),
            e.on("destroyed", this._destroyRenderableBound),
            this._gpuBitmapText[e.uid]
          )
        }
        _updateDistanceField(e) {
          let t = this._getGpuBitmapText(e).context,
            i = e._style.fontFamily,
            n = Ge.get(`${i}-bitmap`),
            { a: s, b: o, c: a, d: u } = e.groupTransform,
            l = Math.sqrt(s * s + o * o),
            c = Math.sqrt(a * a + u * u),
            h = (Math.abs(l) + Math.abs(c)) / 2,
            f = n.baseRenderedFontSize / e._style.fontSize,
            p = h * n.distanceField.range * (1 / f)
          t.customShader.resources.localUniforms.uniforms.uDistance = p
        }
        destroy() {
          for (let e in this._gpuBitmapText) this._destroyRenderableByUid(e)
          ;((this._gpuBitmapText = null), (this._renderer = null))
        }
      }
      Fs.extension = { type: [_.WebGLPipes, _.WebGPUPipes, _.CanvasPipes], name: "bitmapText" }
    })
  var Kd = d(() => {
    D()
    e0()
    L.add(Fs)
  })
  var Bs,
    t0 = d(() => {
      D()
      ge()
      it()
      ws()
      xd()
      Bs = class {
        constructor(e) {
          ;((this._gpuText = Object.create(null)),
            (this._destroyRenderableBound = this.destroyRenderable.bind(this)),
            (this._renderer = e),
            this._renderer.runners.resolutionChange.add(this),
            this._renderer.renderableGC.addManagedHash(this, "_gpuText"))
        }
        resolutionChange() {
          for (let e in this._gpuText) {
            let t = this._gpuText[e]
            if (!t) continue
            let i = t.batchableSprite.renderable
            i._autoResolution && ((i._resolution = this._renderer.resolution), i.onViewUpdate())
          }
        }
        validateRenderable(e) {
          let t = this._getGpuText(e),
            i = e._getKey()
          return t.textureNeedsUploading ? ((t.textureNeedsUploading = !1), !0) : t.currentKey !== i
        }
        addRenderable(e, t) {
          let n = this._getGpuText(e).batchableSprite
          ;(e._didTextUpdate && this._updateText(e),
            this._renderer.renderPipes.batch.addToBatch(n, t))
        }
        updateRenderable(e) {
          let i = this._getGpuText(e).batchableSprite
          ;(e._didTextUpdate && this._updateText(e), i._batcher.updateElement(i))
        }
        destroyRenderable(e) {
          ;(e.off("destroyed", this._destroyRenderableBound), this._destroyRenderableById(e.uid))
        }
        _destroyRenderableById(e) {
          let t = this._gpuText[e]
          ;(this._renderer.htmlText.decreaseReferenceCount(t.currentKey),
            j.return(t.batchableSprite),
            (this._gpuText[e] = null))
        }
        _updateText(e) {
          let t = e._getKey(),
            i = this._getGpuText(e),
            n = i.batchableSprite
          ;(i.currentKey !== t &&
            this._updateGpuText(e).catch((s) => {
              console.error(s)
            }),
            (e._didTextUpdate = !1),
            Ms(n, e))
        }
        async _updateGpuText(e) {
          e._didTextUpdate = !1
          let t = this._getGpuText(e)
          if (t.generatingTexture) return
          let i = e._getKey()
          ;(this._renderer.htmlText.decreaseReferenceCount(t.currentKey),
            (t.generatingTexture = !0),
            (t.currentKey = i))
          let n = e.resolution ?? this._renderer.resolution,
            s = await this._renderer.htmlText.getManagedTexture(e.text, n, e._style, e._getKey()),
            o = t.batchableSprite
          ;((o.texture = t.texture = s),
            (t.generatingTexture = !1),
            (t.textureNeedsUploading = !0),
            e.onViewUpdate(),
            Ms(o, e))
        }
        _getGpuText(e) {
          return this._gpuText[e.uid] || this.initGpuText(e)
        }
        initGpuText(e) {
          let t = {
              texture: I.EMPTY,
              currentKey: "--",
              batchableSprite: j.get(er),
              textureNeedsUploading: !1,
              generatingTexture: !1,
            },
            i = t.batchableSprite
          return (
            (i.renderable = e),
            (i.transform = e.groupTransform),
            (i.texture = I.EMPTY),
            (i.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }),
            (i.roundPixels = this._renderer._roundPixels | e._roundPixels),
            (e._resolution = e._autoResolution ? this._renderer.resolution : e.resolution),
            (this._gpuText[e.uid] = t),
            e.on("destroyed", this._destroyRenderableBound),
            t
          )
        }
        destroy() {
          for (let e in this._gpuText) this._destroyRenderableById(e)
          ;((this._gpuText = null), (this._renderer = null))
        }
      }
      Bs.extension = { type: [_.WebGLPipes, _.WebGPUPipes, _.CanvasPipes], name: "htmlText" }
    })
  function r0() {
    let { userAgent: r } = Z.get().getNavigator()
    return /^((?!chrome|android).)*safari/i.test(r)
  }
  var i0 = d(() => {
    Ie()
  })
  var n0,
    s0,
    fn,
    jd = d(() => {
      "use strict"
      ;((n0 = "http://www.w3.org/2000/svg"),
        (s0 = "http://www.w3.org/1999/xhtml"),
        (fn = class {
          constructor() {
            ;((this.svgRoot = document.createElementNS(n0, "svg")),
              (this.foreignObject = document.createElementNS(n0, "foreignObject")),
              (this.domElement = document.createElementNS(s0, "div")),
              (this.styleElement = document.createElementNS(s0, "style")),
              (this.image = new Image()))
            let { foreignObject: e, svgRoot: t, styleElement: i, domElement: n } = this
            ;(e.setAttribute("width", "10000"),
              e.setAttribute("height", "10000"),
              (e.style.overflow = "hidden"),
              t.appendChild(e),
              e.appendChild(i),
              e.appendChild(n))
          }
        }))
    })
  function u0(r) {
    let e = r._stroke,
      t = r._fill,
      n = [
        `div { ${[`color: ${q.shared.setValue(t.color).toHex()}`, `font-size: ${r.fontSize}px`, `font-family: ${r.fontFamily}`, `font-weight: ${r.fontWeight}`, `font-style: ${r.fontStyle}`, `font-variant: ${r.fontVariant}`, `letter-spacing: ${r.letterSpacing}px`, `text-align: ${r.align}`, `padding: ${r.padding}px`, `white-space: ${r.whiteSpace === "pre" && r.wordWrap ? "pre-wrap" : r.whiteSpace}`, ...(r.lineHeight ? [`line-height: ${r.lineHeight}px`] : []), ...(r.wordWrap ? [`word-wrap: ${r.breakWords ? "break-all" : "break-word"}`, `max-width: ${r.wordWrapWidth}px`] : []), ...(e ? [c0(e)] : []), ...(r.dropShadow ? [l0(r.dropShadow)] : []), ...r.cssOverrides].join(";")} }`,
      ]
    return (pR(r.tagStyles, n), n.join(" "))
  }
  function l0(r) {
    let e = q.shared.setValue(r.color).setAlpha(r.alpha).toHexa(),
      t = Math.round(Math.cos(r.angle) * r.distance),
      i = Math.round(Math.sin(r.angle) * r.distance),
      n = `${t}px ${i}px`
    return r.blur > 0 ? `text-shadow: ${n} ${r.blur}px ${e}` : `text-shadow: ${n} ${e}`
  }
  function c0(r) {
    return [
      `-webkit-text-stroke-width: ${r.width}px`,
      `-webkit-text-stroke-color: ${q.shared.setValue(r.color).toHex()}`,
      `text-stroke-width: ${r.width}px`,
      `text-stroke-color: ${q.shared.setValue(r.color).toHex()}`,
      "paint-order: stroke",
    ].join(";")
  }
  function pR(r, e) {
    for (let t in r) {
      let i = r[t],
        n = []
      for (let s in i)
        a0[s] ? n.push(a0[s](i[s])) : o0[s] && n.push(o0[s].replace("{{VALUE}}", i[s]))
      e.push(`${t} { ${n.join(";")} }`)
    }
  }
  var o0,
    a0,
    h0 = d(() => {
      $e()
      ;((o0 = {
        fontSize: "font-size: {{VALUE}}px",
        fontFamily: "font-family: {{VALUE}}",
        fontWeight: "font-weight: {{VALUE}}",
        fontStyle: "font-style: {{VALUE}}",
        fontVariant: "font-variant: {{VALUE}}",
        letterSpacing: "letter-spacing: {{VALUE}}px",
        align: "text-align: {{VALUE}}",
        padding: "padding: {{VALUE}}px",
        whiteSpace: "white-space: {{VALUE}}",
        lineHeight: "line-height: {{VALUE}}px",
        wordWrapWidth: "max-width: {{VALUE}}px",
      }),
        (a0 = {
          fill: (r) => `color: ${q.shared.setValue(r).toHex()}`,
          breakWords: (r) => `word-wrap: ${r ? "break-all" : "break-word"}`,
          stroke: c0,
          dropShadow: l0,
        }))
    })
  var Hu,
    d0 = d(() => {
      be()
      hn()
      Gd()
      h0()
      Hu = class r extends mt {
        constructor(e = {}) {
          ;(super(e),
            (this._cssOverrides = []),
            this.cssOverrides ?? (this.cssOverrides = e.cssOverrides),
            (this.tagStyles = e.tagStyles ?? {}))
        }
        set cssOverrides(e) {
          ;((this._cssOverrides = e instanceof Array ? e : [e]), this.update())
        }
        get cssOverrides() {
          return this._cssOverrides
        }
        _generateKey() {
          return ((this._styleKey = Fu(this) + this._cssOverrides.join("-")), this._styleKey)
        }
        update() {
          ;((this._cssStyle = null), super.update())
        }
        clone() {
          return new r({
            align: this.align,
            breakWords: this.breakWords,
            dropShadow: this.dropShadow ? { ...this.dropShadow } : null,
            fill: this._fill,
            fontFamily: this.fontFamily,
            fontSize: this.fontSize,
            fontStyle: this.fontStyle,
            fontVariant: this.fontVariant,
            fontWeight: this.fontWeight,
            letterSpacing: this.letterSpacing,
            lineHeight: this.lineHeight,
            padding: this.padding,
            stroke: this._stroke,
            whiteSpace: this.whiteSpace,
            wordWrap: this.wordWrap,
            wordWrapWidth: this.wordWrapWidth,
            cssOverrides: this.cssOverrides,
          })
        }
        get cssStyle() {
          return (this._cssStyle || (this._cssStyle = u0(this)), this._cssStyle)
        }
        addOverride(...e) {
          let t = e.filter((i) => !this.cssOverrides.includes(i))
          t.length > 0 && (this.cssOverrides.push(...t), this.update())
        }
        removeOverride(...e) {
          let t = e.filter((i) => this.cssOverrides.includes(i))
          t.length > 0 &&
            ((this.cssOverrides = this.cssOverrides.filter((i) => !t.includes(i))), this.update())
        }
        set fill(e) {
          ;(typeof e != "string" &&
            typeof e != "number" &&
            H("[HTMLTextStyle] only color fill is not supported by HTMLText"),
            (super.fill = e))
        }
        set stroke(e) {
          ;(e &&
            typeof e != "string" &&
            typeof e != "number" &&
            H("[HTMLTextStyle] only color stroke is not supported by HTMLText"),
            (super.stroke = e))
        }
      }
    })
  function f0(r, e) {
    let t = e.fontFamily,
      i = [],
      n = {},
      s = /font-family:([^;"\s]+)/g,
      o = r.match(s)
    function a(u) {
      n[u] || (i.push(u), (n[u] = !0))
    }
    if (Array.isArray(t)) for (let u = 0; u < t.length; u++) a(t[u])
    else a(t)
    o &&
      o.forEach((u) => {
        let l = u.split(":")[1].trim()
        a(l)
      })
    for (let u in e.tagStyles) {
      let l = e.tagStyles[u].fontFamily
      a(l)
    }
    return i
  }
  var p0 = d(() => {
    "use strict"
  })
  async function m0(r) {
    let t = await (await Z.get().fetch(r)).blob(),
      i = new FileReader()
    return await new Promise((s, o) => {
      ;((i.onloadend = () => s(i.result)), (i.onerror = o), i.readAsDataURL(t))
    })
  }
  var g0 = d(() => {
    Ie()
  })
  async function qd(r, e) {
    let t = await m0(e)
    return `@font-face {
        font-family: "${r.fontFamily}";
        src: url('${t}');
        font-weight: ${r.fontWeight};
        font-style: ${r.fontStyle};
    }`
  }
  var x0 = d(() => {
    g0()
  })
  async function _0(r, e, t) {
    let i = r
      .filter((n) => Ge.has(`${n}-and-url`))
      .map((n, s) => {
        if (!zu.has(n)) {
          let { url: o } = Ge.get(`${n}-and-url`)
          s === 0
            ? zu.set(n, qd({ fontWeight: e.fontWeight, fontStyle: e.fontStyle, fontFamily: n }, o))
            : zu.set(n, qd({ fontWeight: t.fontWeight, fontStyle: t.fontStyle, fontFamily: n }, o))
        }
        return zu.get(n)
      })
    return (await Promise.all(i)).join(`
`)
  }
  var zu,
    y0 = d(() => {
      hs()
      x0()
      zu = new Map()
    })
  function b0(r, e, t, i, n) {
    let { domElement: s, styleElement: o, svgRoot: a } = n
    ;((s.innerHTML = `<style>${e.cssStyle}</style><div style='padding:0;'>${r}</div>`),
      s.setAttribute(
        "style",
        `transform: scale(${t});transform-origin: top left; display: inline-block`,
      ),
      (o.textContent = i))
    let { width: u, height: l } = n.image
    return (
      a.setAttribute("width", u.toString()),
      a.setAttribute("height", l.toString()),
      new XMLSerializer().serializeToString(a)
    )
  }
  var v0 = d(() => {
    "use strict"
  })
  function S0(r, e) {
    let t = pt.getOptimalCanvasAndContext(r.width, r.height, e),
      { context: i } = t
    return (i.clearRect(0, 0, r.width, r.height), i.drawImage(r, 0, 0), t)
  }
  var T0 = d(() => {
    on()
  })
  function C0(r, e, t) {
    return new Promise(async (i) => {
      ;(t && (await new Promise((n) => setTimeout(n, 100))),
        (r.onload = () => {
          i()
        }),
        (r.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(e)}`),
        (r.crossOrigin = "anonymous"))
    })
  }
  var E0 = d(() => {
    "use strict"
  })
  function M0(r, e, t, i) {
    i || (i = w0 || (w0 = new fn()))
    let { domElement: n, styleElement: s, svgRoot: o } = i
    ;((n.innerHTML = `<style>${e.cssStyle};</style><div style='padding:0'>${r}</div>`),
      n.setAttribute("style", "transform-origin: top left; display: inline-block"),
      t && (s.textContent = t),
      document.body.appendChild(o))
    let a = n.getBoundingClientRect()
    o.remove()
    let u = e.padding * 2
    return { width: a.width - u, height: a.height - u }
  }
  var w0,
    A0 = d(() => {
      jd()
    })
  var pn,
    D0 = d(() => {
      D()
      on()
      Tr()
      Qt()
      i0()
      be()
      it()
      Ud()
      jd()
      d0()
      p0()
      y0()
      v0()
      T0()
      E0()
      A0()
      pn = class {
        constructor(e) {
          ;((this._activeTextures = {}),
            (this._renderer = e),
            (this._createCanvas = e.type === ke.WEBGPU))
        }
        getTexture(e) {
          return this._buildTexturePromise(e.text, e.resolution, e.style)
        }
        getManagedTexture(e, t, i, n) {
          if (this._activeTextures[n])
            return (this._increaseReferenceCount(n), this._activeTextures[n].promise)
          let s = this._buildTexturePromise(e, t, i).then(
            (o) => ((this._activeTextures[n].texture = o), o),
          )
          return ((this._activeTextures[n] = { texture: null, promise: s, usageCount: 1 }), s)
        }
        async _buildTexturePromise(e, t, i) {
          let n = j.get(fn),
            s = f0(e, i),
            o = await _0(s, i, Hu.defaultTextStyle),
            a = M0(e, i, o, n),
            u = Math.ceil(Math.ceil(Math.max(1, a.width) + i.padding * 2) * t),
            l = Math.ceil(Math.ceil(Math.max(1, a.height) + i.padding * 2) * t),
            c = n.image,
            h = 2
          ;((c.width = (u | 0) + h), (c.height = (l | 0) + h))
          let f = b0(e, i, t, o, n)
          await C0(c, f, r0() && s.length > 0)
          let p = c,
            m
          this._createCanvas && (m = S0(c, t))
          let g = Bu(m ? m.canvas : p, c.width - h, c.height - h, t)
          return (
            this._createCanvas &&
              (this._renderer.texture.initSource(g.source), pt.returnCanvasAndContext(m)),
            j.return(n),
            g
          )
        }
        _increaseReferenceCount(e) {
          this._activeTextures[e].usageCount++
        }
        decreaseReferenceCount(e) {
          let t = this._activeTextures[e]
          t &&
            (t.usageCount--,
            t.usageCount === 0 &&
              (t.texture
                ? this._cleanUp(t)
                : t.promise
                    .then((i) => {
                      ;((t.texture = i), this._cleanUp(t))
                    })
                    .catch(() => {
                      H("HTMLTextSystem: Failed to clean texture")
                    }),
              (this._activeTextures[e] = null)))
        }
        _cleanUp(e) {
          ;(Ce.returnTexture(e.texture),
            (e.texture.source.resource = null),
            (e.texture.source.uploadMethodId = "unknown"))
        }
        getReferenceCount(e) {
          return this._activeTextures[e].usageCount
        }
        destroy() {
          this._activeTextures = null
        }
      }
      pn.extension = { type: [_.WebGLSystem, _.WebGPUSystem, _.CanvasSystem], name: "htmlText" }
      pn.defaultFontOptions = { fontFamily: "Arial", fontStyle: "normal", fontWeight: "normal" }
    })
  var Zd = d(() => {
    D()
    t0()
    D0()
    L.add(pn)
    L.add(Bs)
  })
  var P0,
    mn,
    Wu = d(() => {
      Dr()
      hr()
      $i()
      Te()
      P0 = class R0 extends Mt {
        constructor(...e) {
          let t = e[0] ?? {}
          ;(t instanceof Float32Array &&
            (z(K, "use new MeshGeometry({ positions, uvs, indices }) instead"),
            (t = { positions: t, uvs: e[1], indices: e[2] })),
            (t = { ...R0.defaultOptions, ...t }))
          let i = t.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            n = t.uvs
          n ||
            (t.positions
              ? (n = new Float32Array(i.length))
              : (n = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])))
          let s = t.indices || new Uint32Array([0, 1, 2, 0, 2, 3]),
            o = t.shrinkBuffersToFit,
            a = new Ae({
              data: i,
              label: "attribute-mesh-positions",
              shrinkToFit: o,
              usage: Q.VERTEX | Q.COPY_DST,
            }),
            u = new Ae({
              data: n,
              label: "attribute-mesh-uvs",
              shrinkToFit: o,
              usage: Q.VERTEX | Q.COPY_DST,
            }),
            l = new Ae({
              data: s,
              label: "index-mesh-buffer",
              shrinkToFit: o,
              usage: Q.INDEX | Q.COPY_DST,
            })
          ;(super({
            attributes: {
              aPosition: { buffer: a, format: "float32x2", stride: 2 * 4, offset: 0 },
              aUV: { buffer: u, format: "float32x2", stride: 2 * 4, offset: 0 },
            },
            indexBuffer: l,
            topology: t.topology,
          }),
            (this.batchMode = "auto"))
        }
        get positions() {
          return this.attributes.aPosition.buffer.data
        }
        set positions(e) {
          this.attributes.aPosition.buffer.data = e
        }
        get uvs() {
          return this.attributes.aUV.buffer.data
        }
        set uvs(e) {
          this.attributes.aUV.buffer.data = e
        }
        get indices() {
          return this.indexBuffer.data
        }
        set indices(e) {
          this.indexBuffer.data = e
        }
      }
      P0.defaultOptions = { topology: "triangle-list", shrinkBuffersToFit: !1 }
      mn = P0
    })
  var _i,
    F0,
    gn,
    xn = d(() => {
      "use strict"
      ;((_i = {
        name: "local-uniform-bit",
        vertex: {
          header: `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
          main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
          end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `,
        },
      }),
        (F0 = {
          ..._i,
          vertex: { ..._i.vertex, header: _i.vertex.header.replace("group(1)", "group(2)") },
        }),
        (gn = {
          name: "local-uniform-bit",
          vertex: {
            header: `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
            main: `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `,
            end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `,
          },
        }))
    })
  var B0,
    I0,
    G0 = d(() => {
      "use strict"
      ;((B0 = {
        name: "tiling-bit",
        vertex: {
          header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,
          main: `
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `,
        },
        fragment: {
          header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,
          main: `

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            } 

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `,
        },
      }),
        (I0 = {
          name: "tiling-bit",
          vertex: {
            header: `
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;
        
        `,
            main: `
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `,
          },
          fragment: {
            header: `
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `,
            main: `

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);
        
        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0
    
        `,
          },
        }))
    })
  var Qd,
    Jd,
    Vu,
    k0 = d(() => {
      se()
      Rr()
      xn()
      Fr()
      Ut()
      st()
      ge()
      G0()
      Vu = class extends De {
        constructor() {
          ;(Qd ?? (Qd = Kt({ name: "tiling-sprite-shader", bits: [_i, B0, qt] })),
            Jd ?? (Jd = jt({ name: "tiling-sprite-shader", bits: [gn, I0, Zt] })))
          let e = new fe({
            uMapCoord: { value: new F(), type: "mat3x3<f32>" },
            uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: "vec4<f32>" },
            uClampOffset: { value: new Float32Array([0, 0]), type: "vec2<f32>" },
            uTextureTransform: { value: new F(), type: "mat3x3<f32>" },
            uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: "vec4<f32>" },
          })
          super({
            glProgram: Jd,
            gpuProgram: Qd,
            resources: {
              localUniforms: new fe({
                uTransformMatrix: { value: new F(), type: "mat3x3<f32>" },
                uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
                uRound: { value: 0, type: "f32" },
              }),
              tilingUniforms: e,
              uTexture: I.EMPTY.source,
              uSampler: I.EMPTY.source.style,
            },
          })
        }
        updateUniforms(e, t, i, n, s, o) {
          let a = this.resources.tilingUniforms,
            u = o.width,
            l = o.height,
            c = o.textureMatrix,
            h = a.uniforms.uTextureTransform
          ;(h.set((i.a * u) / e, (i.b * u) / t, (i.c * l) / e, (i.d * l) / t, i.tx / e, i.ty / t),
            h.invert(),
            (a.uniforms.uMapCoord = c.mapCoord),
            (a.uniforms.uClampFrame = c.uClampFrame),
            (a.uniforms.uClampOffset = c.uClampOffset),
            (a.uniforms.uTextureTransform = h),
            (a.uniforms.uSizeAnchor[0] = e),
            (a.uniforms.uSizeAnchor[1] = t),
            (a.uniforms.uSizeAnchor[2] = n),
            (a.uniforms.uSizeAnchor[3] = s),
            o && ((this.resources.uTexture = o.source), (this.resources.uSampler = o.source.style)))
        }
      }
    })
  var $u,
    U0 = d(() => {
      Wu()
      $u = class extends mn {
        constructor() {
          super({
            positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            indices: new Uint32Array([0, 1, 2, 0, 2, 3]),
          })
        }
      }
    })
  function O0(r, e) {
    let t = r.anchor.x,
      i = r.anchor.y
    ;((e[0] = -t * r.width),
      (e[1] = -i * r.height),
      (e[2] = (1 - t) * r.width),
      (e[3] = -i * r.height),
      (e[4] = (1 - t) * r.width),
      (e[5] = (1 - i) * r.height),
      (e[6] = -t * r.width),
      (e[7] = (1 - i) * r.height))
  }
  var L0 = d(() => {
    "use strict"
  })
  function N0(r, e, t, i) {
    let n = 0,
      s = r.length / (e || 2),
      o = i.a,
      a = i.b,
      u = i.c,
      l = i.d,
      c = i.tx,
      h = i.ty
    for (t *= e; n < s; ) {
      let f = r[t],
        p = r[t + 1]
      ;((r[t] = o * f + u * p + c), (r[t + 1] = a * f + l * p + h), (t += e), n++)
    }
  }
  var H0 = d(() => {
    "use strict"
  })
  function z0(r, e) {
    let t = r.texture,
      i = t.frame.width,
      n = t.frame.height,
      s = 0,
      o = 0
    ;(r.applyAnchorToTexture && ((s = r.anchor.x), (o = r.anchor.y)),
      (e[0] = e[6] = -s),
      (e[2] = e[4] = 1 - s),
      (e[1] = e[3] = -o),
      (e[5] = e[7] = 1 - o))
    let a = F.shared
    ;(a.copyFrom(r._tileTransform.matrix),
      (a.tx /= r.width),
      (a.ty /= r.height),
      a.invert(),
      a.scale(r.width / i, r.height / n),
      N0(e, 2, 0, a))
  }
  var W0 = d(() => {
    se()
    H0()
  })
  var Xu,
    Is,
    V0 = d(() => {
      D()
      fs()
      Ot()
      Qt()
      nn()
      yu()
      Wu()
      k0()
      U0()
      L0()
      W0()
      ;((Xu = new $u()),
        (Is = class {
          constructor(e) {
            ;((this._state = Fe.default2d),
              (this._tilingSpriteDataHash = Object.create(null)),
              (this._destroyRenderableBound = this.destroyRenderable.bind(this)),
              (this._renderer = e),
              this._renderer.renderableGC.addManagedHash(this, "_tilingSpriteDataHash"))
          }
          validateRenderable(e) {
            let t = this._getTilingSpriteData(e),
              i = t.canBatch
            this._updateCanBatch(e)
            let n = t.canBatch
            if (n && n === i) {
              let { batchableMesh: s } = t
              return !s._batcher.checkAndUpdateTexture(s, e.texture)
            }
            return i !== n
          }
          addRenderable(e, t) {
            let i = this._renderer.renderPipes.batch
            this._updateCanBatch(e)
            let n = this._getTilingSpriteData(e),
              { geometry: s, canBatch: o } = n
            if (o) {
              n.batchableMesh || (n.batchableMesh = new Br())
              let a = n.batchableMesh
              ;(e.didViewUpdate &&
                (this._updateBatchableMesh(e),
                (a.geometry = s),
                (a.renderable = e),
                (a.transform = e.groupTransform),
                a.setTexture(e._texture)),
                (a.roundPixels = this._renderer._roundPixels | e._roundPixels),
                i.addToBatch(a, t))
            } else
              (i.break(t), n.shader || (n.shader = new Vu()), this.updateRenderable(e), t.add(e))
          }
          execute(e) {
            let { shader: t } = this._tilingSpriteDataHash[e.uid]
            t.groups[0] = this._renderer.globalUniforms.bindGroup
            let i = t.resources.localUniforms.uniforms
            ;((i.uTransformMatrix = e.groupTransform),
              (i.uRound = this._renderer._roundPixels | e._roundPixels),
              Jt(e.groupColorAlpha, i.uColor, 0),
              (this._state.blendMode = cr(e.groupBlendMode, e.texture._source)),
              this._renderer.encoder.draw({ geometry: Xu, shader: t, state: this._state }))
          }
          updateRenderable(e) {
            let t = this._getTilingSpriteData(e),
              { canBatch: i } = t
            if (i) {
              let { batchableMesh: n } = t
              ;(e.didViewUpdate && this._updateBatchableMesh(e), n._batcher.updateElement(n))
            } else if (e.didViewUpdate) {
              let { shader: n } = t
              n.updateUniforms(
                e.width,
                e.height,
                e._tileTransform.matrix,
                e.anchor.x,
                e.anchor.y,
                e.texture,
              )
            }
          }
          destroyRenderable(e) {
            let t = this._getTilingSpriteData(e)
            ;((t.batchableMesh = null),
              t.shader?.destroy(),
              (this._tilingSpriteDataHash[e.uid] = null),
              e.off("destroyed", this._destroyRenderableBound))
          }
          _getTilingSpriteData(e) {
            return this._tilingSpriteDataHash[e.uid] || this._initTilingSpriteData(e)
          }
          _initTilingSpriteData(e) {
            let t = new mn({
              indices: Xu.indices,
              positions: Xu.positions.slice(),
              uvs: Xu.uvs.slice(),
            })
            return (
              (this._tilingSpriteDataHash[e.uid] = { canBatch: !0, renderable: e, geometry: t }),
              e.on("destroyed", this._destroyRenderableBound),
              this._tilingSpriteDataHash[e.uid]
            )
          }
          _updateBatchableMesh(e) {
            let t = this._getTilingSpriteData(e),
              { geometry: i } = t,
              n = e.texture.source.style
            ;(n.addressMode !== "repeat" && ((n.addressMode = "repeat"), n.update()),
              z0(e, i.uvs),
              O0(e, i.positions))
          }
          destroy() {
            for (let e in this._tilingSpriteDataHash)
              this.destroyRenderable(this._tilingSpriteDataHash[e].renderable)
            ;((this._tilingSpriteDataHash = null), (this._renderer = null))
          }
          _updateCanBatch(e) {
            let t = this._getTilingSpriteData(e),
              i = e.texture,
              n = !0
            return (
              this._renderer.type === ke.WEBGL &&
                (n = this._renderer.context.supports.nonPowOf2wrapping),
              (t.canBatch = i.textureMatrix.isSimple && (n || i.source.isPowerOfTwo)),
              t.canBatch
            )
          }
        }))
      Is.extension = { type: [_.WebGLPipes, _.WebGPUPipes, _.CanvasPipes], name: "tilingSprite" }
    })
  var ef = d(() => {
    D()
    V0()
    L.add(Is)
  })
  var $0,
    Y0,
    K0 = d(() => {
      Te()
      Wu()
      $0 = class X0 extends mn {
        constructor(...e) {
          super({})
          let t = e[0] ?? {}
          ;(typeof t == "number" &&
            (z(
              K,
              "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead",
            ),
            (t = { width: t, height: e[1], verticesX: e[2], verticesY: e[3] })),
            this.build(t))
        }
        build(e) {
          ;((e = { ...X0.defaultOptions, ...e }),
            (this.verticesX = this.verticesX ?? e.verticesX),
            (this.verticesY = this.verticesY ?? e.verticesY),
            (this.width = this.width ?? e.width),
            (this.height = this.height ?? e.height))
          let t = this.verticesX * this.verticesY,
            i = [],
            n = [],
            s = [],
            o = this.verticesX - 1,
            a = this.verticesY - 1,
            u = this.width / o,
            l = this.height / a
          for (let h = 0; h < t; h++) {
            let f = h % this.verticesX,
              p = (h / this.verticesX) | 0
            ;(i.push(f * u, p * l), n.push(f / o, p / a))
          }
          let c = o * a
          for (let h = 0; h < c; h++) {
            let f = h % o,
              p = (h / o) | 0,
              m = p * this.verticesX + f,
              g = p * this.verticesX + f + 1,
              x = (p + 1) * this.verticesX + f,
              y = (p + 1) * this.verticesX + f + 1
            s.push(m, g, x, g, y, x)
          }
          ;((this.buffers[0].data = new Float32Array(i)),
            (this.buffers[1].data = new Float32Array(n)),
            (this.indexBuffer.data = new Uint32Array(s)),
            this.buffers[0].update(),
            this.buffers[1].update(),
            this.indexBuffer.update())
        }
      }
      $0.defaultOptions = { width: 100, height: 100, verticesX: 10, verticesY: 10 }
      Y0 = $0
    })
  var j0,
    Z0,
    Q0 = d(() => {
      K0()
      j0 = class q0 extends Y0 {
        constructor(e = {}) {
          ;((e = { ...q0.defaultOptions, ...e }),
            super({ width: e.width, height: e.height, verticesX: 4, verticesY: 4 }),
            this.update(e))
        }
        update(e) {
          ;((this.width = e.width ?? this.width),
            (this.height = e.height ?? this.height),
            (this._originalWidth = e.originalWidth ?? this._originalWidth),
            (this._originalHeight = e.originalHeight ?? this._originalHeight),
            (this._leftWidth = e.leftWidth ?? this._leftWidth),
            (this._rightWidth = e.rightWidth ?? this._rightWidth),
            (this._topHeight = e.topHeight ?? this._topHeight),
            (this._bottomHeight = e.bottomHeight ?? this._bottomHeight),
            (this._anchorX = e.anchor?.x),
            (this._anchorY = e.anchor?.y),
            this.updateUvs(),
            this.updatePositions())
        }
        updatePositions() {
          let e = this.positions,
            {
              width: t,
              height: i,
              _leftWidth: n,
              _rightWidth: s,
              _topHeight: o,
              _bottomHeight: a,
              _anchorX: u,
              _anchorY: l,
            } = this,
            c = n + s,
            h = t > c ? 1 : t / c,
            f = o + a,
            p = i > f ? 1 : i / f,
            m = Math.min(h, p),
            g = u * t,
            x = l * i
          ;((e[0] = e[8] = e[16] = e[24] = -g),
            (e[2] = e[10] = e[18] = e[26] = n * m - g),
            (e[4] = e[12] = e[20] = e[28] = t - s * m - g),
            (e[6] = e[14] = e[22] = e[30] = t - g),
            (e[1] = e[3] = e[5] = e[7] = -x),
            (e[9] = e[11] = e[13] = e[15] = o * m - x),
            (e[17] = e[19] = e[21] = e[23] = i - a * m - x),
            (e[25] = e[27] = e[29] = e[31] = i - x),
            this.getBuffer("aPosition").update())
        }
        updateUvs() {
          let e = this.uvs
          ;((e[0] = e[8] = e[16] = e[24] = 0),
            (e[1] = e[3] = e[5] = e[7] = 0),
            (e[6] = e[14] = e[22] = e[30] = 1),
            (e[25] = e[27] = e[29] = e[31] = 1))
          let t = 1 / this._originalWidth,
            i = 1 / this._originalHeight
          ;((e[2] = e[10] = e[18] = e[26] = t * this._leftWidth),
            (e[9] = e[11] = e[13] = e[15] = i * this._topHeight),
            (e[4] = e[12] = e[20] = e[28] = 1 - t * this._rightWidth),
            (e[17] = e[19] = e[21] = e[23] = 1 - i * this._bottomHeight),
            this.getBuffer("aUV").update())
        }
      }
      j0.defaultOptions = {
        width: 100,
        height: 100,
        leftWidth: 10,
        topHeight: 10,
        rightWidth: 10,
        bottomHeight: 10,
        originalWidth: 100,
        originalHeight: 100,
      }
      Z0 = j0
    })
  var Gs,
    J0 = d(() => {
      D()
      it()
      yu()
      Q0()
      Gs = class {
        constructor(e) {
          ;((this._gpuSpriteHash = Object.create(null)),
            (this._destroyRenderableBound = this.destroyRenderable.bind(this)),
            (this._renderer = e),
            this._renderer.renderableGC.addManagedHash(this, "_gpuSpriteHash"))
        }
        addRenderable(e, t) {
          let i = this._getGpuSprite(e)
          ;(e.didViewUpdate && this._updateBatchableSprite(e, i),
            this._renderer.renderPipes.batch.addToBatch(i, t))
        }
        updateRenderable(e) {
          let t = this._gpuSpriteHash[e.uid]
          ;(e.didViewUpdate && this._updateBatchableSprite(e, t), t._batcher.updateElement(t))
        }
        validateRenderable(e) {
          let t = this._getGpuSprite(e)
          return !t._batcher.checkAndUpdateTexture(t, e._texture)
        }
        destroyRenderable(e) {
          let t = this._gpuSpriteHash[e.uid]
          ;(j.return(t.geometry),
            j.return(t),
            (this._gpuSpriteHash[e.uid] = null),
            e.off("destroyed", this._destroyRenderableBound))
        }
        _updateBatchableSprite(e, t) {
          ;(t.geometry.update(e), t.setTexture(e._texture))
        }
        _getGpuSprite(e) {
          return this._gpuSpriteHash[e.uid] || this._initGPUSprite(e)
        }
        _initGPUSprite(e) {
          let t = j.get(Br)
          return (
            (t.geometry = j.get(Z0)),
            (t.renderable = e),
            (t.transform = e.groupTransform),
            (t.texture = e._texture),
            (t.roundPixels = this._renderer._roundPixels | e._roundPixels),
            (this._gpuSpriteHash[e.uid] = t),
            e.didViewUpdate || this._updateBatchableSprite(e, t),
            e.on("destroyed", this._destroyRenderableBound),
            t
          )
        }
        destroy() {
          for (let e in this._gpuSpriteHash) this._gpuSpriteHash[e].geometry.destroy()
          ;((this._gpuSpriteHash = null), (this._renderer = null))
        }
      }
      Gs.extension = { type: [_.WebGLPipes, _.WebGPUPipes, _.CanvasPipes], name: "nineSliceSprite" }
    })
  var tf = d(() => {
    D()
    J0()
    L.add(Gs)
  })
  var ks,
    ev = d(() => {
      D()
      ks = class {
        constructor(e) {
          this._renderer = e
        }
        push(e, t, i) {
          ;(this._renderer.renderPipes.batch.break(i),
            i.add({
              renderPipeId: "filter",
              canBundle: !1,
              action: "pushFilter",
              container: t,
              filterEffect: e,
            }))
        }
        pop(e, t, i) {
          ;(this._renderer.renderPipes.batch.break(i),
            i.add({ renderPipeId: "filter", action: "popFilter", canBundle: !1 }))
        }
        execute(e) {
          e.action === "pushFilter"
            ? this._renderer.filter.push(e)
            : e.action === "popFilter" && this._renderer.filter.pop()
        }
        destroy() {
          this._renderer = null
        }
      }
      ks.extension = { type: [_.WebGLPipes, _.WebGPUPipes, _.CanvasPipes], name: "filter" }
    })
  function tv(r, e) {
    e.clear()
    let t = e.matrix
    for (let i = 0; i < r.length; i++) {
      let n = r[i]
      n.globalDisplayStatus < 7 || ((e.matrix = n.worldTransform), e.addBounds(n.bounds))
    }
    return ((e.matrix = t), e)
  }
  var rv = d(() => {
    "use strict"
  })
  var mR,
    Us,
    iv = d(() => {
      D()
      se()
      Et()
      Ar()
      $i()
      st()
      ge()
      Tr()
      Qt()
      lt()
      rv()
      be()
      ;((mR = new Mt({
        attributes: {
          aPosition: {
            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            format: "float32x2",
            stride: 2 * 4,
            offset: 0,
          },
        },
        indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]),
      })),
        (Us = class {
          constructor(e) {
            ;((this._filterStackIndex = 0),
              (this._filterStack = []),
              (this._filterGlobalUniforms = new fe({
                uInputSize: { value: new Float32Array(4), type: "vec4<f32>" },
                uInputPixel: { value: new Float32Array(4), type: "vec4<f32>" },
                uInputClamp: { value: new Float32Array(4), type: "vec4<f32>" },
                uOutputFrame: { value: new Float32Array(4), type: "vec4<f32>" },
                uGlobalFrame: { value: new Float32Array(4), type: "vec4<f32>" },
                uOutputTexture: { value: new Float32Array(4), type: "vec4<f32>" },
              })),
              (this._globalFilterBindGroup = new He({})),
              (this.renderer = e))
          }
          get activeBackTexture() {
            return this._activeFilterData?.backTexture
          }
          push(e) {
            let t = this.renderer,
              i = e.filterEffect.filters
            this._filterStack[this._filterStackIndex] ||
              (this._filterStack[this._filterStackIndex] = this._getFilterData())
            let n = this._filterStack[this._filterStackIndex]
            if ((this._filterStackIndex++, i.length === 0)) {
              n.skip = !0
              return
            }
            let s = n.bounds
            if (
              (e.renderables
                ? tv(e.renderables, s)
                : e.filterEffect.filterArea
                  ? (s.clear(),
                    s.addRect(e.filterEffect.filterArea),
                    s.applyMatrix(e.container.worldTransform))
                  : e.container.getFastGlobalBounds(!0, s),
              e.container)
            ) {
              let m = (e.container.renderGroup || e.container.parentRenderGroup)
                .cacheToLocalTransform
              m && s.applyMatrix(m)
            }
            let o = t.renderTarget.renderTarget.colorTexture.source,
              a = 1 / 0,
              u = 0,
              l = !0,
              c = !1,
              h = !1,
              f = !0
            for (let p = 0; p < i.length; p++) {
              let m = i[p]
              if (
                ((a = Math.min(a, m.resolution === "inherit" ? o._resolution : m.resolution)),
                (u += m.padding),
                m.antialias === "off"
                  ? (l = !1)
                  : m.antialias === "inherit" && l && (l = o.antialias),
                m.clipToViewport || (f = !1),
                !!!(m.compatibleRenderers & t.type))
              ) {
                h = !1
                break
              }
              if (m.blendRequired && !(t.backBuffer?.useBackBuffer ?? !0)) {
                ;(H(
                  "Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.",
                ),
                  (h = !1))
                break
              }
              ;((h = m.enabled || h), c || (c = m.blendRequired))
            }
            if (!h) {
              n.skip = !0
              return
            }
            if (f) {
              let p = t.renderTarget.rootViewPort,
                m = t.renderTarget.renderTarget.resolution
              s.fitBounds(0, p.width / m, 0, p.height / m)
            }
            if (
              (s
                .scale(a)
                .ceil()
                .scale(1 / a)
                .pad(u | 0),
              !s.isPositive)
            ) {
              n.skip = !0
              return
            }
            ;((n.skip = !1),
              (n.bounds = s),
              (n.blendRequired = c),
              (n.container = e.container),
              (n.filterEffect = e.filterEffect),
              (n.previousRenderSurface = t.renderTarget.renderSurface),
              (n.inputTexture = Ce.getOptimalTexture(s.width, s.height, a, l)),
              t.renderTarget.bind(n.inputTexture, !0),
              t.globalUniforms.push({ offset: s }))
          }
          pop() {
            let e = this.renderer
            this._filterStackIndex--
            let t = this._filterStack[this._filterStackIndex]
            if (t.skip) return
            this._activeFilterData = t
            let i = t.inputTexture,
              n = t.bounds,
              s = I.EMPTY
            if ((e.renderTarget.finishRenderPass(), t.blendRequired)) {
              let a =
                  this._filterStackIndex > 0
                    ? this._filterStack[this._filterStackIndex - 1].bounds
                    : null,
                u = e.renderTarget.getRenderTarget(t.previousRenderSurface)
              s = this.getBackTexture(u, n, a)
            }
            t.backTexture = s
            let o = t.filterEffect.filters
            if (
              (this._globalFilterBindGroup.setResource(i.source.style, 2),
              this._globalFilterBindGroup.setResource(s.source, 3),
              e.globalUniforms.pop(),
              o.length === 1)
            )
              (o[0].apply(this, i, t.previousRenderSurface, !1), Ce.returnTexture(i))
            else {
              let a = t.inputTexture,
                u = Ce.getOptimalTexture(n.width, n.height, a.source._resolution, !1),
                l = 0
              for (l = 0; l < o.length - 1; ++l) {
                o[l].apply(this, a, u, !0)
                let h = a
                ;((a = u), (u = h))
              }
              ;(o[l].apply(this, a, t.previousRenderSurface, !1),
                Ce.returnTexture(a),
                Ce.returnTexture(u))
            }
            t.blendRequired && Ce.returnTexture(s)
          }
          getBackTexture(e, t, i) {
            let n = e.colorTexture.source._resolution,
              s = Ce.getOptimalTexture(t.width, t.height, n, !1),
              o = t.minX,
              a = t.minY
            ;(i && ((o -= i.minX), (a -= i.minY)), (o = Math.floor(o * n)), (a = Math.floor(a * n)))
            let u = Math.ceil(t.width * n),
              l = Math.ceil(t.height * n)
            return (
              this.renderer.renderTarget.copyToTexture(
                e,
                s,
                { x: o, y: a },
                { width: u, height: l },
                { x: 0, y: 0 },
              ),
              s
            )
          }
          applyFilter(e, t, i, n) {
            let s = this.renderer,
              o = this._filterStack[this._filterStackIndex],
              a = o.bounds,
              u = re.shared,
              c = o.previousRenderSurface === i,
              h = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution,
              f = this._filterStackIndex - 1
            for (; f > 0 && this._filterStack[f].skip; ) --f
            f > 0 && (h = this._filterStack[f].inputTexture.source._resolution)
            let p = this._filterGlobalUniforms,
              m = p.uniforms,
              g = m.uOutputFrame,
              x = m.uInputSize,
              y = m.uInputPixel,
              v = m.uInputClamp,
              S = m.uGlobalFrame,
              b = m.uOutputTexture
            if (c) {
              let w = this._filterStackIndex
              for (; w > 0; ) {
                w--
                let B = this._filterStack[this._filterStackIndex - 1]
                if (!B.skip) {
                  ;((u.x = B.bounds.minX), (u.y = B.bounds.minY))
                  break
                }
              }
              ;((g[0] = a.minX - u.x), (g[1] = a.minY - u.y))
            } else ((g[0] = 0), (g[1] = 0))
            ;((g[2] = t.frame.width),
              (g[3] = t.frame.height),
              (x[0] = t.source.width),
              (x[1] = t.source.height),
              (x[2] = 1 / x[0]),
              (x[3] = 1 / x[1]),
              (y[0] = t.source.pixelWidth),
              (y[1] = t.source.pixelHeight),
              (y[2] = 1 / y[0]),
              (y[3] = 1 / y[1]),
              (v[0] = 0.5 * y[2]),
              (v[1] = 0.5 * y[3]),
              (v[2] = t.frame.width * x[2] - 0.5 * y[2]),
              (v[3] = t.frame.height * x[3] - 0.5 * y[3]))
            let M = this.renderer.renderTarget.rootRenderTarget.colorTexture
            ;((S[0] = u.x * h),
              (S[1] = u.y * h),
              (S[2] = M.source.width * h),
              (S[3] = M.source.height * h))
            let C = this.renderer.renderTarget.getRenderTarget(i)
            if (
              (s.renderTarget.bind(i, !!n),
              i instanceof I
                ? ((b[0] = i.frame.width), (b[1] = i.frame.height))
                : ((b[0] = C.width), (b[1] = C.height)),
              (b[2] = C.isRoot ? -1 : 1),
              p.update(),
              s.renderPipes.uniformBatch)
            ) {
              let w = s.renderPipes.uniformBatch.getUboResource(p)
              this._globalFilterBindGroup.setResource(w, 0)
            } else this._globalFilterBindGroup.setResource(p, 0)
            ;(this._globalFilterBindGroup.setResource(t.source, 1),
              this._globalFilterBindGroup.setResource(t.source.style, 2),
              (e.groups[0] = this._globalFilterBindGroup),
              s.encoder.draw({
                geometry: mR,
                shader: e,
                state: e._state,
                topology: "triangle-list",
              }),
              s.type === ke.WEBGL && s.renderTarget.finishRenderPass())
          }
          _getFilterData() {
            return {
              skip: !1,
              inputTexture: null,
              bounds: new de(),
              container: null,
              filterEffect: null,
              blendRequired: !1,
              previousRenderSurface: null,
            }
          }
          calculateSpriteMatrix(e, t) {
            let i = this._activeFilterData,
              n = e.set(
                i.inputTexture._source.width,
                0,
                0,
                i.inputTexture._source.height,
                i.bounds.minX,
                i.bounds.minY,
              ),
              s = t.worldTransform.copyTo(F.shared),
              o = t.renderGroup || t.parentRenderGroup
            return (
              o && o.cacheToLocalTransform && s.prepend(o.cacheToLocalTransform),
              s.invert(),
              n.prepend(s),
              n.scale(1 / t.texture.frame.width, 1 / t.texture.frame.height),
              n.translate(t.anchor.x, t.anchor.y),
              n
            )
          }
        }))
      Us.extension = { type: [_.WebGLSystem, _.WebGPUSystem], name: "filter" }
    })
  var rf = d(() => {
    D()
    ev()
    iv()
    L.add(Us)
    L.add(ks)
  })
  var gR = {}
  var nv = d(() => {
    jg()
    th()
    ix()
    sx()
    ja()
    tu()
    hd()
    dd()
    gd()
    Nd()
    Kd()
    Zd()
    ef()
    tf()
    rf()
  })
  var sv,
    ov = d(() => {
      D()
      sv = {
        extension: { type: _.Environment, name: "browser", priority: -1 },
        test: () => !0,
        load: async () => {
          await Promise.resolve().then(() => (nv(), gR))
        },
      }
    })
  var xR = {}
  var av = d(() => {
    th()
    ja()
    tu()
    hd()
    dd()
    gd()
    Nd()
    Kd()
    Zd()
    ef()
    tf()
    rf()
  })
  var uv,
    lv = d(() => {
      D()
      uv = {
        extension: { type: _.Environment, name: "webworker", priority: 0 },
        test: () => typeof self < "u" && self.WorkerGlobalScope !== void 0,
        load: async () => {
          await Promise.resolve().then(() => (av(), xR))
        },
      }
    })
  var cv,
    hv,
    dv = d(() => {
      ci()
      Yi()
      Ut()
      Ot()
      cv = class nf extends De {
        constructor(e) {
          ;((e = { ...nf.defaultOptions, ...e }),
            super(e),
            (this.enabled = !0),
            (this._state = Fe.for2d()),
            (this.blendMode = e.blendMode),
            (this.padding = e.padding),
            typeof e.antialias == "boolean"
              ? (this.antialias = e.antialias ? "on" : "off")
              : (this.antialias = e.antialias),
            (this.resolution = e.resolution),
            (this.blendRequired = e.blendRequired),
            (this.clipToViewport = e.clipToViewport),
            this.addResource("uTexture", 0, 1))
        }
        apply(e, t, i, n) {
          e.applyFilter(this, t, i, n)
        }
        get blendMode() {
          return this._state.blendMode
        }
        set blendMode(e) {
          this._state.blendMode = e
        }
        static from(e) {
          let { gpu: t, gl: i, ...n } = e,
            s,
            o
          return (
            t && (s = Dt.from(t)),
            i && (o = At.from(i)),
            new nf({ gpuProgram: s, glProgram: o, ...n })
          )
        }
      }
      cv.defaultOptions = {
        blendMode: "normal",
        resolution: 1,
        padding: 0,
        antialias: "off",
        blendRequired: !1,
        clipToViewport: !0,
      }
      hv = cv
    })
  async function fv(r) {
    if (!r)
      for (let e = 0; e < sf.length; e++) {
        let t = sf[e]
        if (t.value.test()) {
          await t.value.load()
          return
        }
      }
  }
  var sf,
    pv = d(() => {
      D()
      sf = []
      L.handleByNamedList(_.Environment, sf)
    })
  function Yu() {
    if (typeof Os == "boolean") return Os
    try {
      Os =
        new Function("param1", "param2", "param3", "return param1[param2] === param3;")(
          { a: "b" },
          "a",
          "b",
        ) === !0
    } catch {
      Os = !1
    }
    return Os
  }
  var Os,
    of = d(() => {
      "use strict"
    })
  var ze,
    _n = d(() => {
      "use strict"
      ze = ((r) => (
        (r[(r.NONE = 0)] = "NONE"),
        (r[(r.COLOR = 16384)] = "COLOR"),
        (r[(r.STENCIL = 1024)] = "STENCIL"),
        (r[(r.DEPTH = 256)] = "DEPTH"),
        (r[(r.COLOR_DEPTH = 16640)] = "COLOR_DEPTH"),
        (r[(r.COLOR_STENCIL = 17408)] = "COLOR_STENCIL"),
        (r[(r.DEPTH_STENCIL = 1280)] = "DEPTH_STENCIL"),
        (r[(r.ALL = 17664)] = "ALL"),
        r
      ))(ze || {})
    })
  var yn,
    af = d(() => {
      "use strict"
      yn = class {
        constructor(e) {
          ;((this.items = []), (this._name = e))
        }
        emit(e, t, i, n, s, o, a, u) {
          let { name: l, items: c } = this
          for (let h = 0, f = c.length; h < f; h++) c[h][l](e, t, i, n, s, o, a, u)
          return this
        }
        add(e) {
          return (e[this._name] && (this.remove(e), this.items.push(e)), this)
        }
        remove(e) {
          let t = this.items.indexOf(e)
          return (t !== -1 && this.items.splice(t, 1), this)
        }
        contains(e) {
          return this.items.indexOf(e) !== -1
        }
        removeAll() {
          return ((this.items.length = 0), this)
        }
        destroy() {
          ;(this.removeAll(), (this.items = null), (this._name = null))
        }
        get empty() {
          return this.items.length === 0
        }
        get name() {
          return this._name
        }
      }
    })
  var _R,
    mv,
    kr,
    Ls = d(() => {
      $e()
      pv()
      Gt()
      of()
      Te()
      _n()
      af()
      Je()
      ;((_R = [
        "init",
        "destroy",
        "contextChange",
        "resolutionChange",
        "resetState",
        "renderEnd",
        "renderStart",
        "render",
        "update",
        "postrender",
        "prerender",
      ]),
        (mv = class gv extends pe {
          constructor(e) {
            ;(super(),
              (this.runners = Object.create(null)),
              (this.renderPipes = Object.create(null)),
              (this._initOptions = {}),
              (this._systemsHash = Object.create(null)),
              (this.type = e.type),
              (this.name = e.name),
              (this.config = e))
            let t = [..._R, ...(this.config.runners ?? [])]
            ;(this._addRunners(...t), this._unsafeEvalCheck())
          }
          async init(e = {}) {
            let t = e.skipExtensionImports === !0 ? !0 : e.manageImports === !1
            ;(await fv(t),
              this._addSystems(this.config.systems),
              this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors))
            for (let i in this._systemsHash)
              e = { ...this._systemsHash[i].constructor.defaultOptions, ...e }
            ;((e = { ...gv.defaultOptions, ...e }), (this._roundPixels = e.roundPixels ? 1 : 0))
            for (let i = 0; i < this.runners.init.items.length; i++)
              await this.runners.init.items[i].init(e)
            this._initOptions = e
          }
          render(e, t) {
            let i = e
            if (
              (i instanceof xe &&
                ((i = { container: i }),
                t &&
                  (z(
                    K,
                    "passing a second argument is deprecated, please use render options instead",
                  ),
                  (i.target = t.renderTexture))),
              i.target || (i.target = this.view.renderTarget),
              i.target === this.view.renderTarget &&
                ((this._lastObjectRendered = i.container),
                i.clearColor ?? (i.clearColor = this.background.colorRgba),
                i.clear ?? (i.clear = this.background.clearBeforeRender)),
              i.clearColor)
            ) {
              let n = Array.isArray(i.clearColor) && i.clearColor.length === 4
              i.clearColor = n ? i.clearColor : q.shared.setValue(i.clearColor).toArray()
            }
            ;(i.transform ||
              (i.container.updateLocalTransform(), (i.transform = i.container.localTransform)),
              i.container.enableRenderGroup(),
              this.runners.prerender.emit(i),
              this.runners.renderStart.emit(i),
              this.runners.render.emit(i),
              this.runners.renderEnd.emit(i),
              this.runners.postrender.emit(i))
          }
          resize(e, t, i) {
            let n = this.view.resolution
            ;(this.view.resize(e, t, i),
              this.emit(
                "resize",
                this.view.screen.width,
                this.view.screen.height,
                this.view.resolution,
              ),
              i !== void 0 && i !== n && this.runners.resolutionChange.emit(i))
          }
          clear(e = {}) {
            let t = this
            ;(e.target || (e.target = t.renderTarget.renderTarget),
              e.clearColor || (e.clearColor = this.background.colorRgba),
              e.clear ?? (e.clear = ze.ALL))
            let { clear: i, clearColor: n, target: s } = e
            ;(q.shared.setValue(n ?? this.background.colorRgba),
              t.renderTarget.clear(s, i, q.shared.toArray()))
          }
          get resolution() {
            return this.view.resolution
          }
          set resolution(e) {
            ;((this.view.resolution = e), this.runners.resolutionChange.emit(e))
          }
          get width() {
            return this.view.texture.frame.width
          }
          get height() {
            return this.view.texture.frame.height
          }
          get canvas() {
            return this.view.canvas
          }
          get lastObjectRendered() {
            return this._lastObjectRendered
          }
          get renderingToScreen() {
            return this.renderTarget.renderingToScreen
          }
          get screen() {
            return this.view.screen
          }
          _addRunners(...e) {
            e.forEach((t) => {
              this.runners[t] = new yn(t)
            })
          }
          _addSystems(e) {
            let t
            for (t in e) {
              let i = e[t]
              this._addSystem(i.value, i.name)
            }
          }
          _addSystem(e, t) {
            let i = new e(this)
            if (this[t]) throw new Error(`Whoops! The name "${t}" is already in use`)
            ;((this[t] = i), (this._systemsHash[t] = i))
            for (let n in this.runners) this.runners[n].add(i)
            return this
          }
          _addPipes(e, t) {
            let i = t.reduce((n, s) => ((n[s.name] = s.value), n), {})
            e.forEach((n) => {
              let s = n.value,
                o = n.name,
                a = i[o]
              this.renderPipes[o] = new s(this, a ? new a() : null)
            })
          }
          destroy(e = !1) {
            ;(this.runners.destroy.items.reverse(),
              this.runners.destroy.emit(e),
              Object.values(this.runners).forEach((t) => {
                t.destroy()
              }),
              (this._systemsHash = null),
              (this.renderPipes = null))
          }
          generateTexture(e) {
            return this.textureGenerator.generateTexture(e)
          }
          get roundPixels() {
            return !!this._roundPixels
          }
          _unsafeEvalCheck() {
            if (!Yu())
              throw new Error(
                "Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.",
              )
          }
          resetState() {
            this.runners.resetState.emit()
          }
        }))
      mv.defaultOptions = { resolution: 1, failIfMajorPerformanceCaveat: !1, roundPixels: !1 }
      kr = mv
    })
  function xv(r) {
    return (
      Ku !== void 0 ||
        (Ku = (() => {
          let e = {
            stencil: !0,
            failIfMajorPerformanceCaveat: r ?? kr.defaultOptions.failIfMajorPerformanceCaveat,
          }
          try {
            if (!Z.get().getWebGLRenderingContext()) return !1
            let i = Z.get().createCanvas().getContext("webgl", e),
              n = !!i?.getContextAttributes()?.stencil
            if (i) {
              let s = i.getExtension("WEBGL_lose_context")
              s && s.loseContext()
            }
            return ((i = null), n)
          } catch {
            return !1
          }
        })()),
      Ku
    )
  }
  var Ku,
    _v = d(() => {
      Ie()
      Ls()
    })
  async function yv(r = {}) {
    return (
      ju !== void 0 ||
        (ju = await (async () => {
          let e = Z.get().getNavigator().gpu
          if (!e) return !1
          try {
            return (await (await e.requestAdapter(r)).requestDevice(), !0)
          } catch {
            return !1
          }
        })()),
      ju
    )
  }
  var ju,
    bv = d(() => {
      Ie()
    })
  var Ns,
    vv = d(() => {
      D()
      se()
      ui()
      nu()
      Rr()
      gs()
      xs()
      xn()
      Fr()
      Ut()
      st()
      Ns = class {
        init() {
          let e = new fe({
              uTransformMatrix: { value: new F(), type: "mat3x3<f32>" },
              uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
              uRound: { value: 0, type: "f32" },
            }),
            t = Kt({ name: "graphics", bits: [Ki, qi(wt()), F0, qt] })
          this.shader = new De({ gpuProgram: t, resources: { localUniforms: e } })
        }
        execute(e, t) {
          let i = t.context,
            n = i.customShader || this.shader,
            s = e.renderer,
            o = s.graphicsContext,
            { batcher: a, instructions: u } = o.getContextRenderData(i),
            l = s.encoder
          l.setGeometry(a.geometry, n.gpuProgram)
          let c = s.globalUniforms.bindGroup
          l.setBindGroup(0, c, n.gpuProgram)
          let h = s.renderPipes.uniformBatch.getUniformBindGroup(n.resources.localUniforms, !0)
          l.setBindGroup(2, h, n.gpuProgram)
          let f = u.instructions,
            p = null
          for (let m = 0; m < u.instructionSize; m++) {
            let g = f[m]
            if (
              (g.topology !== p &&
                ((p = g.topology),
                l.setPipelineFromGeometryProgramAndState(
                  a.geometry,
                  n.gpuProgram,
                  e.state,
                  g.topology,
                )),
              (n.groups[1] = g.bindGroup),
              !g.gpuBindGroup)
            ) {
              let x = g.textures
              ;((g.bindGroup = Vi(x.textures, x.count)),
                (g.gpuBindGroup = s.bindGroup.getBindGroup(g.bindGroup, n.gpuProgram, 1)))
            }
            ;(l.setBindGroup(1, g.bindGroup, n.gpuProgram),
              l.renderPassEncoder.drawIndexed(g.size, 1, g.start))
          }
        }
        destroy() {
          ;(this.shader.destroy(!0), (this.shader = null))
        }
      }
      Ns.extension = { type: [_.WebGPUPipesAdaptor], name: "graphics" }
    })
  var Sv,
    Tv,
    uf = d(() => {
      "use strict"
      ;((Sv = {
        name: "texture-bit",
        vertex: {
          header: `

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `,
          main: `
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `,
        },
        fragment: {
          header: `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;

         
        `,
          main: `
            outColor = textureSample(uTexture, uSampler, vUV);
        `,
        },
      }),
        (Tv = {
          name: "texture-bit",
          vertex: {
            header: `
            uniform mat3 uTextureMatrix;
        `,
            main: `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `,
          },
          fragment: {
            header: `
        uniform sampler2D uTexture;

         
        `,
            main: `
            outColor = texture(uTexture, vUV);
        `,
          },
        }))
    })
  var Hs,
    Cv = d(() => {
      D()
      se()
      Rr()
      xn()
      Fr()
      uf()
      Ut()
      ge()
      be()
      Hs = class {
        init() {
          let e = Kt({ name: "mesh", bits: [_i, Sv, qt] })
          this._shader = new De({
            gpuProgram: e,
            resources: {
              uTexture: I.EMPTY._source,
              uSampler: I.EMPTY._source.style,
              textureUniforms: { uTextureMatrix: { type: "mat3x3<f32>", value: new F() } },
            },
          })
        }
        execute(e, t) {
          let i = e.renderer,
            n = t._shader
          if (!n) ((n = this._shader), (n.groups[2] = i.texture.getTextureBindGroup(t.texture)))
          else if (!n.gpuProgram) {
            H("Mesh shader has no gpuProgram", t.shader)
            return
          }
          let s = n.gpuProgram
          if (
            (s.autoAssignGlobalUniforms && (n.groups[0] = i.globalUniforms.bindGroup),
            s.autoAssignLocalUniforms)
          ) {
            let o = e.localUniforms
            n.groups[1] = i.renderPipes.uniformBatch.getUniformBindGroup(o, !0)
          }
          i.encoder.draw({ geometry: t._geometry, shader: n, state: t.state })
        }
        destroy() {
          ;(this._shader.destroy(!0), (this._shader = null))
        }
      }
      Hs.extension = { type: [_.WebGPUPipesAdaptor], name: "mesh" }
    })
  var qu,
    zs,
    Ev = d(() => {
      D()
      Ot()
      nu()
      ;((qu = Fe.for2d()),
        (zs = class {
          start(e, t, i) {
            let n = e.renderer,
              s = n.encoder,
              o = i.gpuProgram
            ;((this._shader = i),
              (this._geometry = t),
              s.setGeometry(t, o),
              (qu.blendMode = "normal"),
              n.pipeline.getPipeline(t, o, qu))
            let a = n.globalUniforms.bindGroup
            ;(s.resetBindGroup(1), s.setBindGroup(0, a, o))
          }
          execute(e, t) {
            let i = this._shader.gpuProgram,
              n = e.renderer,
              s = n.encoder
            if (!t.bindGroup) {
              let u = t.textures
              t.bindGroup = Vi(u.textures, u.count)
            }
            qu.blendMode = t.blendMode
            let o = n.bindGroup.getBindGroup(t.bindGroup, i, 1),
              a = n.pipeline.getPipeline(this._geometry, i, qu, t.topology)
            ;(t.bindGroup._touch(n.textureGC.count),
              s.setPipeline(a),
              s.renderPassEncoder.setBindGroup(1, o),
              s.renderPassEncoder.drawIndexed(t.size, 1, t.start))
          }
        }))
      zs.extension = { type: [_.WebGPUPipesAdaptor], name: "batch" }
    })
  var Ws,
    wv = d(() => {
      D()
      Ws = class {
        constructor(e) {
          this._renderer = e
        }
        updateRenderable() {}
        destroyRenderable() {}
        validateRenderable() {
          return !1
        }
        addRenderable(e, t) {
          ;(this._renderer.renderPipes.batch.break(t), t.add(e))
        }
        execute(e) {
          e.isRenderable && e.render(this._renderer)
        }
        destroy() {
          this._renderer = null
        }
      }
      Ws.extension = { type: [_.WebGLPipes, _.WebGPUPipes, _.CanvasPipes], name: "customRender" }
    })
  function Vs(r, e) {
    let t = r.instructionSet,
      i = t.instructions
    for (let n = 0; n < t.instructionSize; n++) {
      let s = i[n]
      e[s.renderPipeId].execute(s)
    }
  }
  var lf = d(() => {
    "use strict"
  })
  var yR,
    $s,
    Mv = d(() => {
      D()
      se()
      it()
      ws()
      lf()
      ;((yR = new F()),
        ($s = class {
          constructor(e) {
            this._renderer = e
          }
          addRenderGroup(e, t) {
            e.isCachedAsTexture
              ? this._addRenderableCacheAsTexture(e, t)
              : this._addRenderableDirect(e, t)
          }
          execute(e) {
            e.isRenderable &&
              (e.isCachedAsTexture ? this._executeCacheAsTexture(e) : this._executeDirect(e))
          }
          destroy() {
            this._renderer = null
          }
          _addRenderableDirect(e, t) {
            ;(this._renderer.renderPipes.batch.break(t),
              e._batchableRenderGroup &&
                (j.return(e._batchableRenderGroup), (e._batchableRenderGroup = null)),
              t.add(e))
          }
          _addRenderableCacheAsTexture(e, t) {
            let i = e._batchableRenderGroup ?? (e._batchableRenderGroup = j.get(er))
            ;((i.renderable = e.root),
              (i.transform = e.root.relativeGroupTransform),
              (i.texture = e.texture),
              (i.bounds = e._textureBounds),
              t.add(e),
              this._renderer.renderPipes.batch.addToBatch(i, t))
          }
          _executeCacheAsTexture(e) {
            if (e.textureNeedsUpdate) {
              e.textureNeedsUpdate = !1
              let t = yR.identity().translate(-e._textureBounds.x, -e._textureBounds.y)
              ;(this._renderer.renderTarget.push(e.texture, !0, null, e.texture.frame),
                this._renderer.globalUniforms.push({
                  worldTransformMatrix: t,
                  worldColor: 4294967295,
                }),
                Vs(e, this._renderer.renderPipes),
                this._renderer.renderTarget.finishRenderPass(),
                this._renderer.renderTarget.pop(),
                this._renderer.globalUniforms.pop())
            }
            ;(e._batchableRenderGroup._batcher.updateElement(e._batchableRenderGroup),
              e._batchableRenderGroup._batcher.geometry.buffers[0].update())
          }
          _executeDirect(e) {
            ;(this._renderer.globalUniforms.push({
              worldTransformMatrix: e.inverseParentTextureTransform,
              worldColor: e.worldColorAlpha,
            }),
              Vs(e, this._renderer.renderPipes),
              this._renderer.globalUniforms.pop())
          }
        }))
      $s.extension = { type: [_.WebGLPipes, _.WebGPUPipes, _.CanvasPipes], name: "renderGroup" }
    })
  function Xs(r, e) {
    e || (e = 0)
    for (let t = e; t < r.length && r[t]; t++) r[t] = null
  }
  var cf = d(() => {
    "use strict"
  })
  function hf(r, e = !1) {
    vR(r)
    let t = r.childrenToUpdate,
      i = r.updateTick++
    for (let n in t) {
      let s = Number(n),
        o = t[n],
        a = o.list,
        u = o.index
      for (let l = 0; l < u; l++) {
        let c = a[l]
        c.parentRenderGroup === r && c.relativeRenderGroupDepth === s && Pv(c, i, 0)
      }
      ;(Xs(a, u), (o.index = 0))
    }
    if (e) for (let n = 0; n < r.renderGroupChildren.length; n++) hf(r.renderGroupChildren[n], e)
  }
  function vR(r) {
    let e = r.root,
      t
    if (r.renderGroupParent) {
      let i = r.renderGroupParent
      ;(r.worldTransform.appendFrom(e.relativeGroupTransform, i.worldTransform),
        (r.worldColor = Gi(e.groupColor, i.worldColor)),
        (t = e.groupAlpha * i.worldAlpha))
    } else
      (r.worldTransform.copyFrom(e.localTransform),
        (r.worldColor = e.localColor),
        (t = e.localAlpha))
    ;((t = t < 0 ? 0 : t > 1 ? 1 : t),
      (r.worldAlpha = t),
      (r.worldColorAlpha = r.worldColor + (((t * 255) | 0) << 24)))
  }
  function Pv(r, e, t) {
    if (e === r.updateTick) return
    ;((r.updateTick = e), (r.didChange = !1))
    let i = r.localTransform
    r.updateLocalTransform()
    let n = r.parent
    if (
      (n && !n.renderGroup
        ? ((t |= r._updateFlags),
          r.relativeGroupTransform.appendFrom(i, n.relativeGroupTransform),
          t & Av && Dv(r, n, t))
        : ((t = r._updateFlags), r.relativeGroupTransform.copyFrom(i), t & Av && Dv(r, bR, t)),
      !r.renderGroup)
    ) {
      let s = r.children,
        o = s.length
      for (let l = 0; l < o; l++) Pv(s[l], e, t)
      let a = r.parentRenderGroup,
        u = r
      u.renderPipeId && !a.structureDidChange && a.updateRenderable(u)
    }
  }
  function Dv(r, e, t) {
    if (t & Li) {
      r.groupColor = Gi(r.localColor, e.groupColor)
      let i = r.localAlpha * e.groupAlpha
      ;((i = i < 0 ? 0 : i > 1 ? 1 : i),
        (r.groupAlpha = i),
        (r.groupColorAlpha = r.groupColor + (((i * 255) | 0) << 24)))
    }
    ;(t & Qn &&
      (r.groupBlendMode = r.localBlendMode === "inherit" ? e.groupBlendMode : r.localBlendMode),
      t & si && (r.globalDisplayStatus = r.localDisplayStatus & e.globalDisplayStatus),
      (r._updateFlags = 0))
  }
  var bR,
    Av,
    Rv = d(() => {
      Gt()
      cf()
      kc()
      ;((bR = new xe()), (Av = si | Li | Qn))
    })
  function Fv(r, e) {
    let { list: t, index: i } = r.childrenRenderablesToUpdate,
      n = !1
    for (let s = 0; s < i; s++) {
      let o = t[s]
      if (((n = e[o.renderPipeId].validateRenderable(o)), n)) break
    }
    return ((r.structureDidChange = n), n)
  }
  var Bv = d(() => {
    "use strict"
  })
  var SR,
    Ys,
    Iv = d(() => {
      D()
      se()
      Tr()
      lt()
      cf()
      lf()
      Rv()
      Bv()
      ;((SR = new F()),
        (Ys = class {
          constructor(e) {
            this._renderer = e
          }
          render({ container: e, transform: t }) {
            let i = e.parent,
              n = e.renderGroup.renderGroupParent
            ;((e.parent = null), (e.renderGroup.renderGroupParent = null))
            let s = this._renderer,
              o = SR
            t &&
              ((o = o.copyFrom(e.renderGroup.localTransform)),
              e.renderGroup.localTransform.copyFrom(t))
            let a = s.renderPipes
            ;(this._updateCachedRenderGroups(e.renderGroup, null),
              this._updateRenderGroups(e.renderGroup),
              s.globalUniforms.start({
                worldTransformMatrix: t
                  ? e.renderGroup.localTransform
                  : e.renderGroup.worldTransform,
                worldColor: e.renderGroup.worldColorAlpha,
              }),
              Vs(e.renderGroup, a),
              a.uniformBatch && a.uniformBatch.renderEnd(),
              t && e.renderGroup.localTransform.copyFrom(o),
              (e.parent = i),
              (e.renderGroup.renderGroupParent = n))
          }
          destroy() {
            this._renderer = null
          }
          _updateCachedRenderGroups(e, t) {
            if (e.isCachedAsTexture) {
              if (!e.updateCacheTexture) return
              t = e
            }
            e._parentCacheAsTextureRenderGroup = t
            for (let i = e.renderGroupChildren.length - 1; i >= 0; i--)
              this._updateCachedRenderGroups(e.renderGroupChildren[i], t)
            if ((e.invalidateMatrices(), e.isCachedAsTexture)) {
              if (e.textureNeedsUpdate) {
                let i = e.root.getLocalBounds()
                i.ceil()
                let n = e.texture
                e.texture && Ce.returnTexture(e.texture)
                let s = this._renderer,
                  o = e.textureOptions.resolution || s.view.resolution,
                  a = e.textureOptions.antialias ?? s.view.antialias
                ;((e.texture = Ce.getOptimalTexture(i.width, i.height, o, a)),
                  e._textureBounds || (e._textureBounds = new de()),
                  e._textureBounds.copyFrom(i),
                  n !== e.texture &&
                    e.renderGroupParent &&
                    (e.renderGroupParent.structureDidChange = !0))
              }
            } else e.texture && (Ce.returnTexture(e.texture), (e.texture = null))
          }
          _updateRenderGroups(e) {
            let t = this._renderer,
              i = t.renderPipes
            if (
              (e.runOnRender(t),
              (e.instructionSet.renderPipes = i),
              e.structureDidChange ? Xs(e.childrenRenderablesToUpdate.list, 0) : Fv(e, i),
              hf(e),
              e.structureDidChange
                ? ((e.structureDidChange = !1), this._buildInstructions(e, t))
                : this._updateRenderables(e),
              (e.childrenRenderablesToUpdate.index = 0),
              t.renderPipes.batch.upload(e.instructionSet),
              !(e.isCachedAsTexture && !e.textureNeedsUpdate))
            )
              for (let n = 0; n < e.renderGroupChildren.length; n++)
                this._updateRenderGroups(e.renderGroupChildren[n])
          }
          _updateRenderables(e) {
            let { list: t, index: i } = e.childrenRenderablesToUpdate
            for (let n = 0; n < i; n++) {
              let s = t[n]
              s.didViewUpdate && e.updateRenderable(s)
            }
            Xs(t, i)
          }
          _buildInstructions(e, t) {
            let i = e.root,
              n = e.instructionSet
            n.reset()
            let s = t.renderPipes ? t : t.batch.renderer,
              o = s.renderPipes
            ;(o.batch.buildStart(n),
              o.blendMode.buildStart(),
              o.colorMask.buildStart(),
              i.sortableChildren && i.sortChildren(),
              i.collectRenderablesWithEffects(n, s, null),
              o.batch.buildEnd(n),
              o.blendMode.buildEnd(n))
          }
        }))
      Ys.extension = { type: [_.WebGLSystem, _.WebGPUSystem, _.CanvasSystem], name: "renderGroup" }
    })
  var Ks,
    Gv = d(() => {
      D()
      it()
      ws()
      Ks = class {
        constructor(e) {
          ;((this._gpuSpriteHash = Object.create(null)),
            (this._destroyRenderableBound = this.destroyRenderable.bind(this)),
            (this._renderer = e),
            this._renderer.renderableGC.addManagedHash(this, "_gpuSpriteHash"))
        }
        addRenderable(e, t) {
          let i = this._getGpuSprite(e)
          ;(e.didViewUpdate && this._updateBatchableSprite(e, i),
            this._renderer.renderPipes.batch.addToBatch(i, t))
        }
        updateRenderable(e) {
          let t = this._gpuSpriteHash[e.uid]
          ;(e.didViewUpdate && this._updateBatchableSprite(e, t), t._batcher.updateElement(t))
        }
        validateRenderable(e) {
          let t = this._getGpuSprite(e)
          return !t._batcher.checkAndUpdateTexture(t, e._texture)
        }
        destroyRenderable(e) {
          let t = this._gpuSpriteHash[e.uid]
          ;(j.return(t),
            (this._gpuSpriteHash[e.uid] = null),
            e.off("destroyed", this._destroyRenderableBound))
        }
        _updateBatchableSprite(e, t) {
          ;((t.bounds = e.visualBounds), (t.texture = e._texture))
        }
        _getGpuSprite(e) {
          return this._gpuSpriteHash[e.uid] || this._initGPUSprite(e)
        }
        _initGPUSprite(e) {
          let t = j.get(er)
          return (
            (t.renderable = e),
            (t.transform = e.groupTransform),
            (t.texture = e._texture),
            (t.bounds = e.visualBounds),
            (t.roundPixels = this._renderer._roundPixels | e._roundPixels),
            (this._gpuSpriteHash[e.uid] = t),
            e.on("destroyed", this._destroyRenderableBound),
            t
          )
        }
        destroy() {
          for (let e in this._gpuSpriteHash) j.return(this._gpuSpriteHash[e])
          ;((this._gpuSpriteHash = null), (this._renderer = null))
        }
      }
      Ks.extension = { type: [_.WebGLPipes, _.WebGPUPipes, _.CanvasPipes], name: "sprite" }
    })
  var bn,
    df = d(() => {
      Je()
      bn = "8.9.2"
    })
  var js,
    qs,
    ff = d(() => {
      D()
      df()
      js = class {
        static init() {
          globalThis.__PIXI_APP_INIT__?.(this, bn)
        }
        static destroy() {}
      }
      js.extension = _.Application
      qs = class {
        constructor(e) {
          this._renderer = e
        }
        init() {
          globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, bn)
        }
        destroy() {
          this._renderer = null
        }
      }
      qs.extension = { type: [_.WebGLSystem, _.WebGPUSystem], name: "initHook", priority: -10 }
    })
  var pf,
    mf,
    Uv = d(() => {
      D()
      Ot()
      Wh()
      pf = class kv {
        constructor(e, t) {
          ;((this.state = Fe.for2d()),
            (this._batchersByInstructionSet = Object.create(null)),
            (this._activeBatches = Object.create(null)),
            (this.renderer = e),
            (this._adaptor = t),
            this._adaptor.init?.(this))
        }
        static getBatcher(e) {
          return new this._availableBatchers[e]()
        }
        buildStart(e) {
          let t = this._batchersByInstructionSet[e.uid]
          ;(t ||
            ((t = this._batchersByInstructionSet[e.uid] = Object.create(null)),
            t.default || (t.default = new _s())),
            (this._activeBatches = t),
            (this._activeBatch = this._activeBatches.default))
          for (let i in this._activeBatches) this._activeBatches[i].begin()
        }
        addToBatch(e, t) {
          if (this._activeBatch.name !== e.batcherName) {
            this._activeBatch.break(t)
            let i = this._activeBatches[e.batcherName]
            ;(i ||
              ((i = this._activeBatches[e.batcherName] = kv.getBatcher(e.batcherName)), i.begin()),
              (this._activeBatch = i))
          }
          this._activeBatch.add(e)
        }
        break(e) {
          this._activeBatch.break(e)
        }
        buildEnd(e) {
          this._activeBatch.break(e)
          let t = this._activeBatches
          for (let i in t) {
            let n = t[i],
              s = n.geometry
            ;(s.indexBuffer.setDataWithSize(n.indexBuffer, n.indexSize, !0),
              s.buffers[0].setDataWithSize(n.attributeBuffer.float32View, n.attributeSize, !1))
          }
        }
        upload(e) {
          let t = this._batchersByInstructionSet[e.uid]
          for (let i in t) {
            let n = t[i],
              s = n.geometry
            n.dirty && ((n.dirty = !1), s.buffers[0].update(n.attributeSize * 4))
          }
        }
        execute(e) {
          if (e.action === "startBatch") {
            let t = e.batcher,
              i = t.geometry,
              n = t.shader
            this._adaptor.start(this, i, n)
          }
          this._adaptor.execute(this, e)
        }
        destroy() {
          ;((this.state = null), (this.renderer = null), (this._adaptor = null))
          for (let e in this._activeBatches) this._activeBatches[e].destroy()
          this._activeBatches = null
        }
      }
      pf.extension = { type: [_.WebGLPipes, _.WebGPUPipes, _.CanvasPipes], name: "batch" }
      pf._availableBatchers = Object.create(null)
      mf = pf
      L.handleByMap(_.Batcher, mf._availableBatchers)
      L.add(_s)
    })
  var Ov,
    Lv = d(() => {
      Ov = `in vec2 vMaskCoord;
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform sampler2D uMaskTexture;

uniform float uAlpha;
uniform vec4 uMaskClamp;
uniform float uInverse;

out vec4 finalColor;

void main(void)
{
    float clip = step(3.5,
        step(uMaskClamp.x, vMaskCoord.x) +
        step(uMaskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, uMaskClamp.z) +
        step(vMaskCoord.y, uMaskClamp.w));

    // TODO look into why this is needed
    float npmAlpha = uAlpha;
    vec4 original = texture(uTexture, vTextureCoord);
    vec4 masky = texture(uMaskTexture, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    float a = alphaMul * masky.r * npmAlpha * clip;

    if (uInverse == 1.0) {
        a = 1.0 - a;
    }

    finalColor = original * a;
}
`
    })
  var Nv,
    Hv = d(() => {
      Nv = `in vec2 aPosition;

out vec2 vTextureCoord;
out vec2 vMaskCoord;


uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;
uniform mat3 uFilterMatrix;

vec4 filterVertexPosition(  vec2 aPosition )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
       
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord(  vec2 aPosition )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

vec2 getFilterCoord( vec2 aPosition )
{
    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}   

void main(void)
{
    gl_Position = filterVertexPosition(aPosition);
    vTextureCoord = filterTextureCoord(aPosition);
    vMaskCoord = getFilterCoord(aPosition);
}
`
    })
  var gf,
    zv = d(() => {
      gf = `struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct MaskUniforms {
  uFilterMatrix:mat3x3<f32>,
  uMaskClamp:vec4<f32>,
  uAlpha:f32,
  uInverse:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;
@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) filterUv : vec2<f32>,
};

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);
}

fn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>
{
  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}

@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>,
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
   getFilterCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) filterUv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var maskClamp = filterUniforms.uMaskClamp;
    var uAlpha = filterUniforms.uAlpha;

    var clip = step(3.5,
      step(maskClamp.x, filterUv.x) +
      step(maskClamp.y, filterUv.y) +
      step(filterUv.x, maskClamp.z) +
      step(filterUv.y, maskClamp.w));

    var mask = textureSample(uMaskTexture, uSampler, filterUv);
    var source = textureSample(uTexture, uSampler, uv);
    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);

    var a: f32 = alphaMul * mask.r * uAlpha * clip;

    if (filterUniforms.uInverse == 1.0) {
        a = 1.0 - a;
    }

    return source * a;
}
`
    })
  var Zu,
    Wv = d(() => {
      se()
      ci()
      Yi()
      st()
      Xc()
      dv()
      Lv()
      Hv()
      zv()
      Zu = class extends hv {
        constructor(e) {
          let { sprite: t, ...i } = e,
            n = new Oi(t.texture),
            s = new fe({
              uFilterMatrix: { value: new F(), type: "mat3x3<f32>" },
              uMaskClamp: { value: n.uClampFrame, type: "vec4<f32>" },
              uAlpha: { value: 1, type: "f32" },
              uInverse: { value: e.inverse ? 1 : 0, type: "f32" },
            }),
            o = Dt.from({
              vertex: { source: gf, entryPoint: "mainVertex" },
              fragment: { source: gf, entryPoint: "mainFragment" },
            }),
            a = At.from({ vertex: Nv, fragment: Ov, name: "mask-filter" })
          ;(super({
            ...i,
            gpuProgram: o,
            glProgram: a,
            resources: { filterUniforms: s, uMaskTexture: t.texture.source },
          }),
            (this.sprite = t),
            (this._textureMatrix = n))
        }
        set inverse(e) {
          this.resources.filterUniforms.uniforms.uInverse = e ? 1 : 0
        }
        get inverse() {
          return this.resources.filterUniforms.uniforms.uInverse === 1
        }
        apply(e, t, i, n) {
          ;((this._textureMatrix.texture = this.sprite.texture),
            e
              .calculateSpriteMatrix(
                this.resources.filterUniforms.uniforms.uFilterMatrix,
                this.sprite,
              )
              .prepend(this._textureMatrix.mapCoord),
            (this.resources.uMaskTexture = this.sprite.texture.source),
            e.applyFilter(this, t, i, n))
        }
      }
    })
  var TR,
    xf,
    Zs,
    Vv = d(() => {
      D()
      Ra()
      Wv()
      lt()
      jn()
      gh()
      it()
      ge()
      Tr()
      Qt()
      ;((TR = new de()),
        (xf = class extends or {
          constructor() {
            ;(super(),
              (this.filters = [
                new Zu({
                  sprite: new ai(I.EMPTY),
                  inverse: !1,
                  resolution: "inherit",
                  antialias: "inherit",
                }),
              ]))
          }
          get sprite() {
            return this.filters[0].sprite
          }
          set sprite(e) {
            this.filters[0].sprite = e
          }
          get inverse() {
            return this.filters[0].inverse
          }
          set inverse(e) {
            this.filters[0].inverse = e
          }
        }),
        (Zs = class {
          constructor(e) {
            ;((this._activeMaskStage = []), (this._renderer = e))
          }
          push(e, t, i) {
            let n = this._renderer
            if (
              (n.renderPipes.batch.break(i),
              i.add({
                renderPipeId: "alphaMask",
                action: "pushMaskBegin",
                mask: e,
                inverse: t._maskOptions.inverse,
                canBundle: !1,
                maskedContainer: t,
              }),
              (e.inverse = t._maskOptions.inverse),
              e.renderMaskToTexture)
            ) {
              let s = e.mask
              ;((s.includeInBuild = !0), s.collectRenderables(i, n, null), (s.includeInBuild = !1))
            }
            ;(n.renderPipes.batch.break(i),
              i.add({
                renderPipeId: "alphaMask",
                action: "pushMaskEnd",
                mask: e,
                maskedContainer: t,
                inverse: t._maskOptions.inverse,
                canBundle: !1,
              }))
          }
          pop(e, t, i) {
            ;(this._renderer.renderPipes.batch.break(i),
              i.add({
                renderPipeId: "alphaMask",
                action: "popMaskEnd",
                mask: e,
                inverse: t._maskOptions.inverse,
                canBundle: !1,
              }))
          }
          execute(e) {
            let t = this._renderer,
              i = e.mask.renderMaskToTexture
            if (e.action === "pushMaskBegin") {
              let n = j.get(xf)
              if (((n.inverse = e.inverse), i)) {
                e.mask.mask.measurable = !0
                let s = Ii(e.mask.mask, !0, TR)
                ;((e.mask.mask.measurable = !1), s.ceil())
                let o = t.renderTarget.renderTarget.colorTexture.source,
                  a = Ce.getOptimalTexture(s.width, s.height, o._resolution, o.antialias)
                ;(t.renderTarget.push(a, !0),
                  t.globalUniforms.push({ offset: s, worldColor: 4294967295 }))
                let u = n.sprite
                ;((u.texture = a),
                  (u.worldTransform.tx = s.minX),
                  (u.worldTransform.ty = s.minY),
                  this._activeMaskStage.push({
                    filterEffect: n,
                    maskedContainer: e.maskedContainer,
                    filterTexture: a,
                  }))
              } else
                ((n.sprite = e.mask.mask),
                  this._activeMaskStage.push({
                    filterEffect: n,
                    maskedContainer: e.maskedContainer,
                  }))
            } else if (e.action === "pushMaskEnd") {
              let n = this._activeMaskStage[this._activeMaskStage.length - 1]
              ;(i &&
                (t.type === ke.WEBGL && t.renderTarget.finishRenderPass(),
                t.renderTarget.pop(),
                t.globalUniforms.pop()),
                t.filter.push({
                  renderPipeId: "filter",
                  action: "pushFilter",
                  container: n.maskedContainer,
                  filterEffect: n.filterEffect,
                  canBundle: !1,
                }))
            } else if (e.action === "popMaskEnd") {
              t.filter.pop()
              let n = this._activeMaskStage.pop()
              ;(i && Ce.returnTexture(n.filterTexture), j.return(n.filterEffect))
            }
          }
          destroy() {
            ;((this._renderer = null), (this._activeMaskStage = null))
          }
        }))
      Zs.extension = { type: [_.WebGLPipes, _.WebGPUPipes, _.CanvasPipes], name: "alphaMask" }
    })
  var Qs,
    $v = d(() => {
      D()
      Qs = class {
        constructor(e) {
          ;((this._colorStack = []),
            (this._colorStackIndex = 0),
            (this._currentColor = 0),
            (this._renderer = e))
        }
        buildStart() {
          ;((this._colorStack[0] = 15), (this._colorStackIndex = 1), (this._currentColor = 15))
        }
        push(e, t, i) {
          this._renderer.renderPipes.batch.break(i)
          let s = this._colorStack
          s[this._colorStackIndex] = s[this._colorStackIndex - 1] & e.mask
          let o = this._colorStack[this._colorStackIndex]
          ;(o !== this._currentColor &&
            ((this._currentColor = o),
            i.add({ renderPipeId: "colorMask", colorMask: o, canBundle: !1 })),
            this._colorStackIndex++)
        }
        pop(e, t, i) {
          this._renderer.renderPipes.batch.break(i)
          let s = this._colorStack
          this._colorStackIndex--
          let o = s[this._colorStackIndex - 1]
          o !== this._currentColor &&
            ((this._currentColor = o),
            i.add({ renderPipeId: "colorMask", colorMask: o, canBundle: !1 }))
        }
        execute(e) {
          this._renderer.colorMask.setMask(e.colorMask)
        }
        destroy() {
          this._colorStack = null
        }
      }
      Qs.extension = { type: [_.WebGLPipes, _.WebGPUPipes, _.CanvasPipes], name: "colorMask" }
    })
  var Js,
    Xv = d(() => {
      D()
      _n()
      li()
      Js = class {
        constructor(e) {
          ;((this._maskStackHash = {}), (this._maskHash = new WeakMap()), (this._renderer = e))
        }
        push(e, t, i) {
          var n
          let s = e,
            o = this._renderer
          ;(o.renderPipes.batch.break(i),
            o.renderPipes.blendMode.setBlendMode(s.mask, "none", i),
            i.add({
              renderPipeId: "stencilMask",
              action: "pushMaskBegin",
              mask: e,
              inverse: t._maskOptions.inverse,
              canBundle: !1,
            }))
          let a = s.mask
          ;((a.includeInBuild = !0),
            this._maskHash.has(s) ||
              this._maskHash.set(s, { instructionsStart: 0, instructionsLength: 0 }))
          let u = this._maskHash.get(s)
          ;((u.instructionsStart = i.instructionSize),
            a.collectRenderables(i, o, null),
            (a.includeInBuild = !1),
            o.renderPipes.batch.break(i),
            i.add({
              renderPipeId: "stencilMask",
              action: "pushMaskEnd",
              mask: e,
              inverse: t._maskOptions.inverse,
              canBundle: !1,
            }))
          let l = i.instructionSize - u.instructionsStart - 1
          u.instructionsLength = l
          let c = o.renderTarget.renderTarget.uid
          ;(n = this._maskStackHash)[c] ?? (n[c] = 0)
        }
        pop(e, t, i) {
          let n = e,
            s = this._renderer
          ;(s.renderPipes.batch.break(i),
            s.renderPipes.blendMode.setBlendMode(n.mask, "none", i),
            i.add({
              renderPipeId: "stencilMask",
              action: "popMaskBegin",
              inverse: t._maskOptions.inverse,
              canBundle: !1,
            }))
          let o = this._maskHash.get(e)
          for (let a = 0; a < o.instructionsLength; a++)
            i.instructions[i.instructionSize++] = i.instructions[o.instructionsStart++]
          i.add({ renderPipeId: "stencilMask", action: "popMaskEnd", canBundle: !1 })
        }
        execute(e) {
          var t
          let i = this._renderer,
            n = i.renderTarget.renderTarget.uid,
            s = (t = this._maskStackHash)[n] ?? (t[n] = 0)
          ;(e.action === "pushMaskBegin"
            ? (i.renderTarget.ensureDepthStencil(),
              i.stencil.setStencilMode(ye.RENDERING_MASK_ADD, s),
              s++,
              i.colorMask.setMask(0))
            : e.action === "pushMaskEnd"
              ? (e.inverse
                  ? i.stencil.setStencilMode(ye.INVERSE_MASK_ACTIVE, s)
                  : i.stencil.setStencilMode(ye.MASK_ACTIVE, s),
                i.colorMask.setMask(15))
              : e.action === "popMaskBegin"
                ? (i.colorMask.setMask(0),
                  s !== 0
                    ? i.stencil.setStencilMode(ye.RENDERING_MASK_REMOVE, s)
                    : (i.renderTarget.clear(null, ze.STENCIL),
                      i.stencil.setStencilMode(ye.DISABLED, s)),
                  s--)
                : e.action === "popMaskEnd" &&
                  (e.inverse
                    ? i.stencil.setStencilMode(ye.INVERSE_MASK_ACTIVE, s)
                    : i.stencil.setStencilMode(ye.MASK_ACTIVE, s),
                  i.colorMask.setMask(15)),
            (this._maskStackHash[n] = s))
        }
        destroy() {
          ;((this._renderer = null), (this._maskStackHash = null), (this._maskHash = null))
        }
      }
      Js.extension = { type: [_.WebGLPipes, _.WebGPUPipes, _.CanvasPipes], name: "stencilMask" }
    })
  var _f,
    Kv,
    jv = d(() => {
      $e()
      D()
      _f = class Yv {
        constructor() {
          ;((this.clearBeforeRender = !0),
            (this._backgroundColor = new q(0)),
            (this.color = this._backgroundColor),
            (this.alpha = 1))
        }
        init(e) {
          ;((e = { ...Yv.defaultOptions, ...e }),
            (this.clearBeforeRender = e.clearBeforeRender),
            (this.color = e.background || e.backgroundColor || this._backgroundColor),
            (this.alpha = e.backgroundAlpha),
            this._backgroundColor.setAlpha(e.backgroundAlpha))
        }
        get color() {
          return this._backgroundColor
        }
        set color(e) {
          this._backgroundColor.setValue(e)
        }
        get alpha() {
          return this._backgroundColor.alpha
        }
        set alpha(e) {
          this._backgroundColor.setAlpha(e)
        }
        get colorRgba() {
          return this._backgroundColor.toArray()
        }
        destroy() {}
      }
      _f.extension = {
        type: [_.WebGLSystem, _.WebGPUSystem, _.CanvasSystem],
        name: "background",
        priority: 0,
      }
      _f.defaultOptions = { backgroundAlpha: 1, backgroundColor: 0, clearBeforeRender: !0 }
      Kv = _f
    })
  var eo,
    to,
    qv = d(() => {
      D()
      Ra()
      be()
      eo = {}
      L.handle(
        _.BlendMode,
        (r) => {
          if (!r.name) throw new Error("BlendMode extension must have a name property")
          eo[r.name] = r.ref
        },
        (r) => {
          delete eo[r.name]
        },
      )
      to = class {
        constructor(e) {
          ;((this._isAdvanced = !1),
            (this._filterHash = Object.create(null)),
            (this._renderer = e),
            this._renderer.runners.prerender.add(this))
        }
        prerender() {
          ;((this._activeBlendMode = "normal"), (this._isAdvanced = !1))
        }
        setBlendMode(e, t, i) {
          if (this._activeBlendMode === t) {
            this._isAdvanced && this._renderableList.push(e)
            return
          }
          ;((this._activeBlendMode = t),
            this._isAdvanced && this._endAdvancedBlendMode(i),
            (this._isAdvanced = !!eo[t]),
            this._isAdvanced && (this._beginAdvancedBlendMode(i), this._renderableList.push(e)))
        }
        _beginAdvancedBlendMode(e) {
          this._renderer.renderPipes.batch.break(e)
          let t = this._activeBlendMode
          if (!eo[t]) {
            H(
              `Unable to assign BlendMode: '${t}'. You may want to include: import 'pixi.js/advanced-blend-modes'`,
            )
            return
          }
          let i = this._filterHash[t]
          i || ((i = this._filterHash[t] = new or()), (i.filters = [new eo[t]()]))
          let n = {
            renderPipeId: "filter",
            action: "pushFilter",
            renderables: [],
            filterEffect: i,
            canBundle: !1,
          }
          ;((this._renderableList = n.renderables), e.add(n))
        }
        _endAdvancedBlendMode(e) {
          ;((this._renderableList = null),
            this._renderer.renderPipes.batch.break(e),
            e.add({ renderPipeId: "filter", action: "popFilter", canBundle: !1 }))
        }
        buildStart() {
          this._isAdvanced = !1
        }
        buildEnd(e) {
          this._isAdvanced && this._endAdvancedBlendMode(e)
        }
        destroy() {
          ;((this._renderer = null), (this._renderableList = null))
          for (let e in this._filterHash) this._filterHash[e].destroy()
          this._filterHash = null
        }
      }
      to.extension = { type: [_.WebGLPipes, _.WebGPUPipes, _.CanvasPipes], name: "blendMode" }
    })
  var yf,
    bf,
    Qv,
    Jv = d(() => {
      D()
      Gt()
      ge()
      ;((yf = { png: "image/png", jpg: "image/jpeg", webp: "image/webp" }),
        (bf = class Zv {
          constructor(e) {
            this._renderer = e
          }
          _normalizeOptions(e, t = {}) {
            return e instanceof xe || e instanceof I ? { target: e, ...t } : { ...t, ...e }
          }
          async image(e) {
            let t = new Image()
            return ((t.src = await this.base64(e)), t)
          }
          async base64(e) {
            e = this._normalizeOptions(e, Zv.defaultImageOptions)
            let { format: t, quality: i } = e,
              n = this.canvas(e)
            if (n.toBlob !== void 0)
              return new Promise((s, o) => {
                n.toBlob(
                  (a) => {
                    if (!a) {
                      o(new Error("ICanvas.toBlob failed!"))
                      return
                    }
                    let u = new FileReader()
                    ;((u.onload = () => s(u.result)), (u.onerror = o), u.readAsDataURL(a))
                  },
                  yf[t],
                  i,
                )
              })
            if (n.toDataURL !== void 0) return n.toDataURL(yf[t], i)
            if (n.convertToBlob !== void 0) {
              let s = await n.convertToBlob({ type: yf[t], quality: i })
              return new Promise((o, a) => {
                let u = new FileReader()
                ;((u.onload = () => o(u.result)), (u.onerror = a), u.readAsDataURL(s))
              })
            }
            throw new Error(
              "Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented",
            )
          }
          canvas(e) {
            e = this._normalizeOptions(e)
            let t = e.target,
              i = this._renderer
            if (t instanceof I) return i.texture.generateCanvas(t)
            let n = i.textureGenerator.generateTexture(e),
              s = i.texture.generateCanvas(n)
            return (n.destroy(!0), s)
          }
          pixels(e) {
            e = this._normalizeOptions(e)
            let t = e.target,
              i = this._renderer,
              n = t instanceof I ? t : i.textureGenerator.generateTexture(e),
              s = i.texture.getPixels(n)
            return (t instanceof xe && n.destroy(!0), s)
          }
          texture(e) {
            return (
              (e = this._normalizeOptions(e)),
              e.target instanceof I ? e.target : this._renderer.textureGenerator.generateTexture(e)
            )
          }
          download(e) {
            e = this._normalizeOptions(e)
            let t = this.canvas(e),
              i = document.createElement("a")
            ;((i.download = e.filename ?? "image.png"),
              (i.href = t.toDataURL("image/png")),
              document.body.appendChild(i),
              i.click(),
              document.body.removeChild(i))
          }
          log(e) {
            let t = e.width ?? 200
            e = this._normalizeOptions(e)
            let i = this.canvas(e),
              n = i.toDataURL()
            console.log(`[Pixi Texture] ${i.width}px ${i.height}px`)
            let s = [
              "font-size: 1px;",
              `padding: ${t}px 300px;`,
              `background: url(${n}) no-repeat;`,
              "background-size: contain;",
            ].join(" ")
            console.log("%c ", s)
          }
          destroy() {
            this._renderer = null
          }
        }))
      bf.extension = { type: [_.WebGLSystem, _.WebGPUSystem], name: "extract" }
      bf.defaultImageOptions = { format: "png", quality: 1 }
      Qv = bf
    })
  var Qu,
    eS = d(() => {
      ct()
      ge()
      Qu = class r extends I {
        static create(e) {
          return new r({ source: new ce(e) })
        }
        resize(e, t, i) {
          return (this.source.resize(e, t, i), this)
        }
      }
    })
  var CR,
    ER,
    wR,
    ro,
    tS = d(() => {
      $e()
      D()
      se()
      Ke()
      lt()
      ka()
      Gt()
      eS()
      ;((CR = new ee()),
        (ER = new de()),
        (wR = [0, 0, 0, 0]),
        (ro = class {
          constructor(e) {
            this._renderer = e
          }
          generateTexture(e) {
            e instanceof xe &&
              (e = { target: e, frame: void 0, textureSourceOptions: {}, resolution: void 0 })
            let t = e.resolution || this._renderer.resolution,
              i = e.antialias || this._renderer.view.antialias,
              n = e.target,
              s = e.clearColor
            s
              ? (s = Array.isArray(s) && s.length === 4 ? s : q.shared.setValue(s).toArray())
              : (s = wR)
            let o = e.frame?.copyTo(CR) || ki(n, ER).rectangle
            ;((o.width = Math.max(o.width, 1 / t) | 0), (o.height = Math.max(o.height, 1 / t) | 0))
            let a = Qu.create({
                ...e.textureSourceOptions,
                width: o.width,
                height: o.height,
                resolution: t,
                antialias: i,
              }),
              u = F.shared.translate(-o.x, -o.y)
            return (
              this._renderer.render({ container: n, transform: u, target: a, clearColor: s }),
              a.source.updateMipmaps(),
              a
            )
          }
          destroy() {
            this._renderer = null
          }
        }))
      ro.extension = { type: [_.WebGLSystem, _.WebGPUSystem], name: "textureGenerator" }
    })
  var io,
    rS = d(() => {
      D()
      se()
      Et()
      nn()
      Ar()
      Qt()
      st()
      io = class {
        constructor(e) {
          ;((this._stackIndex = 0),
            (this._globalUniformDataStack = []),
            (this._uniformsPool = []),
            (this._activeUniforms = []),
            (this._bindGroupPool = []),
            (this._activeBindGroups = []),
            (this._renderer = e))
        }
        reset() {
          this._stackIndex = 0
          for (let e = 0; e < this._activeUniforms.length; e++)
            this._uniformsPool.push(this._activeUniforms[e])
          for (let e = 0; e < this._activeBindGroups.length; e++)
            this._bindGroupPool.push(this._activeBindGroups[e])
          ;((this._activeUniforms.length = 0), (this._activeBindGroups.length = 0))
        }
        start(e) {
          ;(this.reset(), this.push(e))
        }
        bind({ size: e, projectionMatrix: t, worldTransformMatrix: i, worldColor: n, offset: s }) {
          let o = this._renderer.renderTarget.renderTarget,
            a = this._stackIndex
              ? this._globalUniformDataStack[this._stackIndex - 1]
              : {
                  projectionData: o,
                  worldTransformMatrix: new F(),
                  worldColor: 4294967295,
                  offset: new re(),
                },
            u = {
              projectionMatrix: t || this._renderer.renderTarget.projectionMatrix,
              resolution: e || o.size,
              worldTransformMatrix: i || a.worldTransformMatrix,
              worldColor: n || a.worldColor,
              offset: s || a.offset,
              bindGroup: null,
            },
            l = this._uniformsPool.pop() || this._createUniforms()
          this._activeUniforms.push(l)
          let c = l.uniforms
          ;((c.uProjectionMatrix = u.projectionMatrix),
            (c.uResolution = u.resolution),
            c.uWorldTransformMatrix.copyFrom(u.worldTransformMatrix),
            (c.uWorldTransformMatrix.tx -= u.offset.x),
            (c.uWorldTransformMatrix.ty -= u.offset.y),
            Jt(u.worldColor, c.uWorldColorAlpha, 0),
            l.update())
          let h
          ;(this._renderer.renderPipes.uniformBatch
            ? (h = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(l, !1))
            : ((h = this._bindGroupPool.pop() || new He()),
              this._activeBindGroups.push(h),
              h.setResource(l, 0)),
            (u.bindGroup = h),
            (this._currentGlobalUniformData = u))
        }
        push(e) {
          ;(this.bind(e),
            (this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData))
        }
        pop() {
          ;((this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1]),
            this._renderer.type === ke.WEBGL &&
              this._currentGlobalUniformData.bindGroup.resources[0].update())
        }
        get bindGroup() {
          return this._currentGlobalUniformData.bindGroup
        }
        get globalUniformData() {
          return this._currentGlobalUniformData
        }
        get uniformGroup() {
          return this._currentGlobalUniformData.bindGroup.resources[0]
        }
        _createUniforms() {
          return new fe(
            {
              uProjectionMatrix: { value: new F(), type: "mat3x3<f32>" },
              uWorldTransformMatrix: { value: new F(), type: "mat3x3<f32>" },
              uWorldColorAlpha: { value: new Float32Array(4), type: "vec4<f32>" },
              uResolution: { value: [0, 0], type: "vec2<f32>" },
            },
            { isStatic: !0 },
          )
        }
        destroy() {
          this._renderer = null
        }
      }
      io.extension = {
        type: [_.WebGLSystem, _.WebGPUSystem, _.CanvasSystem],
        name: "globalUniforms",
      }
    })
  var MR,
    no,
    iS = d(() => {
      D()
      ts()
      ;((MR = 1),
        (no = class {
          constructor() {
            ;((this._tasks = []), (this._offset = 0))
          }
          init() {
            ht.system.add(this._update, this)
          }
          repeat(e, t, i = !0) {
            let n = MR++,
              s = 0
            return (
              i && ((this._offset += 1e3), (s = this._offset)),
              this._tasks.push({
                func: e,
                duration: t,
                start: performance.now(),
                offset: s,
                last: performance.now(),
                repeat: !0,
                id: n,
              }),
              n
            )
          }
          cancel(e) {
            for (let t = 0; t < this._tasks.length; t++)
              if (this._tasks[t].id === e) {
                this._tasks.splice(t, 1)
                return
              }
          }
          _update() {
            let e = performance.now()
            for (let t = 0; t < this._tasks.length; t++) {
              let i = this._tasks[t]
              if (e - i.offset - i.last >= i.duration) {
                let n = e - i.start
                ;(i.func(n), (i.last = e))
              }
            }
          }
          destroy() {
            ;(ht.system.remove(this._update, this), (this._tasks.length = 0))
          }
        }))
      no.extension = {
        type: [_.WebGLSystem, _.WebGPUSystem, _.CanvasSystem],
        name: "scheduler",
        priority: 0,
      }
    })
  function sS(r) {
    if (!nS) {
      if (Z.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
        let e = [
          `%c  %c  %c  %c  %c PixiJS %c v${bn} (${r}) http://www.pixijs.com/

`,
          "background: #E72264; padding:5px 0;",
          "background: #6CA2EA; padding:5px 0;",
          "background: #B5D33D; padding:5px 0;",
          "background: #FED23F; padding:5px 0;",
          "color: #FFFFFF; background: #E72264; padding:5px 0;",
          "color: #E72264; background: #FFFFFF; padding:5px 0;",
        ]
        globalThis.console.log(...e)
      } else
        globalThis.console && globalThis.console.log(`PixiJS ${bn} - ${r} - http://www.pixijs.com/`)
      nS = !0
    }
  }
  var nS,
    oS = d(() => {
      Ie()
      df()
      nS = !1
    })
  var vn,
    aS = d(() => {
      D()
      oS()
      Qt()
      vn = class {
        constructor(e) {
          this._renderer = e
        }
        init(e) {
          if (e.hello) {
            let t = this._renderer.name
            ;(this._renderer.type === ke.WEBGL && (t += ` ${this._renderer.context.webGLVersion}`),
              sS(t))
          }
        }
      }
      vn.extension = {
        type: [_.WebGLSystem, _.WebGPUSystem, _.CanvasSystem],
        name: "hello",
        priority: -2,
      }
      vn.defaultOptions = { hello: !1 }
    })
  function uS(r) {
    let e = !1
    for (let i in r)
      if (r[i] == null) {
        e = !0
        break
      }
    if (!e) return r
    let t = Object.create(null)
    for (let i in r) {
      let n = r[i]
      n && (t[i] = n)
    }
    return t
  }
  function lS(r) {
    let e = 0
    for (let t = 0; t < r.length; t++) r[t] == null ? e++ : (r[t - e] = r[t])
    return ((r.length -= e), r)
  }
  var cS = d(() => {
    "use strict"
  })
  var AR,
    vf,
    dS,
    fS = d(() => {
      D()
      cS()
      ;((AR = 0),
        (vf = class hS {
          constructor(e) {
            ;((this._managedRenderables = []),
              (this._managedHashes = []),
              (this._managedArrays = []),
              (this._renderer = e))
          }
          init(e) {
            ;((e = { ...hS.defaultOptions, ...e }),
              (this.maxUnusedTime = e.renderableGCMaxUnusedTime),
              (this._frequency = e.renderableGCFrequency),
              (this.enabled = e.renderableGCActive))
          }
          get enabled() {
            return !!this._handler
          }
          set enabled(e) {
            this.enabled !== e &&
              (e
                ? ((this._handler = this._renderer.scheduler.repeat(
                    () => this.run(),
                    this._frequency,
                    !1,
                  )),
                  (this._hashHandler = this._renderer.scheduler.repeat(() => {
                    for (let t of this._managedHashes) t.context[t.hash] = uS(t.context[t.hash])
                  }, this._frequency)),
                  (this._arrayHandler = this._renderer.scheduler.repeat(() => {
                    for (let t of this._managedArrays) lS(t.context[t.hash])
                  }, this._frequency)))
                : (this._renderer.scheduler.cancel(this._handler),
                  this._renderer.scheduler.cancel(this._hashHandler),
                  this._renderer.scheduler.cancel(this._arrayHandler)))
          }
          addManagedHash(e, t) {
            this._managedHashes.push({ context: e, hash: t })
          }
          addManagedArray(e, t) {
            this._managedArrays.push({ context: e, hash: t })
          }
          prerender({ container: e }) {
            ;((this._now = performance.now()),
              (e.renderGroup.gcTick = AR++),
              this._updateInstructionGCTick(e.renderGroup, e.renderGroup.gcTick))
          }
          addRenderable(e) {
            this.enabled &&
              (e._lastUsed === -1 &&
                (this._managedRenderables.push(e),
                e.once("destroyed", this._removeRenderable, this)),
              (e._lastUsed = this._now))
          }
          run() {
            let e = this._now,
              t = this._managedRenderables,
              i = this._renderer.renderPipes,
              n = 0
            for (let s = 0; s < t.length; s++) {
              let o = t[s]
              if (o === null) {
                n++
                continue
              }
              let a = o.renderGroup ?? o.parentRenderGroup,
                u = a?.instructionSet?.gcTick ?? -1
              if (
                ((a?.gcTick ?? 0) === u && (o._lastUsed = e), e - o._lastUsed > this.maxUnusedTime)
              ) {
                if (!o.destroyed) {
                  let l = i
                  ;(a && (a.structureDidChange = !0), l[o.renderPipeId].destroyRenderable(o))
                }
                ;((o._lastUsed = -1), n++, o.off("destroyed", this._removeRenderable, this))
              } else t[s - n] = o
            }
            t.length -= n
          }
          destroy() {
            ;((this.enabled = !1),
              (this._renderer = null),
              (this._managedRenderables.length = 0),
              (this._managedHashes.length = 0),
              (this._managedArrays.length = 0))
          }
          _removeRenderable(e) {
            let t = this._managedRenderables.indexOf(e)
            t >= 0 &&
              (e.off("destroyed", this._removeRenderable, this),
              (this._managedRenderables[t] = null))
          }
          _updateInstructionGCTick(e, t) {
            e.instructionSet.gcTick = t
            for (let i of e.renderGroupChildren) this._updateInstructionGCTick(i, t)
          }
        }))
      vf.extension = { type: [_.WebGLSystem, _.WebGPUSystem], name: "renderableGC", priority: 0 }
      vf.defaultOptions = {
        renderableGCActive: !0,
        renderableGCMaxUnusedTime: 6e4,
        renderableGCFrequency: 3e4,
      }
      dS = vf
    })
  var Sf,
    mS,
    gS = d(() => {
      D()
      Sf = class pS {
        constructor(e) {
          ;((this._renderer = e), (this.count = 0), (this.checkCount = 0))
        }
        init(e) {
          ;((e = { ...pS.defaultOptions, ...e }),
            (this.checkCountMax = e.textureGCCheckCountMax),
            (this.maxIdle = e.textureGCAMaxIdle ?? e.textureGCMaxIdle),
            (this.active = e.textureGCActive))
        }
        postrender() {
          this._renderer.renderingToScreen &&
            (this.count++,
            this.active &&
              (this.checkCount++,
              this.checkCount > this.checkCountMax && ((this.checkCount = 0), this.run())))
        }
        run() {
          let e = this._renderer.texture.managedTextures
          for (let t = 0; t < e.length; t++) {
            let i = e[t]
            i.autoGarbageCollect &&
              i.resource &&
              i._touched > -1 &&
              this.count - i._touched > this.maxIdle &&
              ((i._touched = -1), i.unload())
          }
        }
        destroy() {
          this._renderer = null
        }
      }
      Sf.extension = { type: [_.WebGLSystem, _.WebGPUSystem], name: "textureGC" }
      Sf.defaultOptions = {
        textureGCActive: !0,
        textureGCAMaxIdle: null,
        textureGCMaxIdle: 60 * 60,
        textureGCCheckCountMax: 600,
      }
      mS = Sf
    })
  var xS,
    so,
    Tf = d(() => {
      Ye()
      ct()
      ge()
      xS = class _S {
        constructor(e = {}) {
          if (
            ((this.uid = te("renderTarget")),
            (this.colorTextures = []),
            (this.dirtyId = 0),
            (this.isRoot = !1),
            (this._size = new Float32Array(2)),
            (this._managedColorTextures = !1),
            (e = { ..._S.defaultOptions, ...e }),
            (this.stencil = e.stencil),
            (this.depth = e.depth),
            (this.isRoot = e.isRoot),
            typeof e.colorTextures == "number")
          ) {
            this._managedColorTextures = !0
            for (let t = 0; t < e.colorTextures; t++)
              this.colorTextures.push(
                new ce({
                  width: e.width,
                  height: e.height,
                  resolution: e.resolution,
                  antialias: e.antialias,
                }),
              )
          } else {
            this.colorTextures = [...e.colorTextures.map((i) => i.source)]
            let t = this.colorTexture.source
            this.resize(t.width, t.height, t._resolution)
          }
          ;(this.colorTexture.source.on("resize", this.onSourceResize, this),
            (e.depthStencilTexture || this.stencil) &&
              (e.depthStencilTexture instanceof I || e.depthStencilTexture instanceof ce
                ? (this.depthStencilTexture = e.depthStencilTexture.source)
                : this.ensureDepthStencilTexture()))
        }
        get size() {
          let e = this._size
          return ((e[0] = this.pixelWidth), (e[1] = this.pixelHeight), e)
        }
        get width() {
          return this.colorTexture.source.width
        }
        get height() {
          return this.colorTexture.source.height
        }
        get pixelWidth() {
          return this.colorTexture.source.pixelWidth
        }
        get pixelHeight() {
          return this.colorTexture.source.pixelHeight
        }
        get resolution() {
          return this.colorTexture.source._resolution
        }
        get colorTexture() {
          return this.colorTextures[0]
        }
        onSourceResize(e) {
          this.resize(e.width, e.height, e._resolution, !0)
        }
        ensureDepthStencilTexture() {
          this.depthStencilTexture ||
            (this.depthStencilTexture = new ce({
              width: this.width,
              height: this.height,
              resolution: this.resolution,
              format: "depth24plus-stencil8",
              autoGenerateMipmaps: !1,
              antialias: !1,
              mipLevelCount: 1,
            }))
        }
        resize(e, t, i = this.resolution, n = !1) {
          ;(this.dirtyId++,
            this.colorTextures.forEach((s, o) => {
              ;(n && o === 0) || s.source.resize(e, t, i)
            }),
            this.depthStencilTexture && this.depthStencilTexture.source.resize(e, t, i))
        }
        destroy() {
          ;(this.colorTexture.source.off("resize", this.onSourceResize, this),
            this._managedColorTextures &&
              this.colorTextures.forEach((e) => {
                e.destroy()
              }),
            this.depthStencilTexture &&
              (this.depthStencilTexture.destroy(), delete this.depthStencilTexture))
        }
      }
      xS.defaultOptions = {
        width: 0,
        height: 0,
        resolution: 1,
        colorTextures: 1,
        stencil: !1,
        depth: !1,
        antialias: !1,
        isRoot: !1,
      }
      so = xS
    })
  function Ju(r, e) {
    if (!oo.has(r)) {
      let t = new I({ source: new et({ resource: r, ...e }) }),
        i = () => {
          oo.get(r) === t && oo.delete(r)
        }
      ;(t.once("destroy", i), t.source.once("destroy", i), oo.set(r, t))
    }
    return oo.get(r)
  }
  var oo,
    Cf = d(() => {
      zi()
      ge()
      oo = new Map()
    })
  var Ef,
    bS,
    vS = d(() => {
      Ie()
      D()
      Ke()
      Te()
      Tf()
      Cf()
      Ef = class yS {
        get autoDensity() {
          return this.texture.source.autoDensity
        }
        set autoDensity(e) {
          this.texture.source.autoDensity = e
        }
        get resolution() {
          return this.texture.source._resolution
        }
        set resolution(e) {
          this.texture.source.resize(this.texture.source.width, this.texture.source.height, e)
        }
        init(e) {
          ;((e = { ...yS.defaultOptions, ...e }),
            e.view &&
              (z(K, "ViewSystem.view has been renamed to ViewSystem.canvas"), (e.canvas = e.view)),
            (this.screen = new ee(0, 0, e.width, e.height)),
            (this.canvas = e.canvas || Z.get().createCanvas()),
            (this.antialias = !!e.antialias),
            (this.texture = Ju(this.canvas, e)),
            (this.renderTarget = new so({
              colorTextures: [this.texture],
              depth: !!e.depth,
              isRoot: !0,
            })),
            (this.texture.source.transparent = e.backgroundAlpha < 1),
            (this.resolution = e.resolution))
        }
        resize(e, t, i) {
          ;(this.texture.source.resize(e, t, i),
            (this.screen.width = this.texture.frame.width),
            (this.screen.height = this.texture.frame.height))
        }
        destroy(e = !1) {
          ;(typeof e == "boolean" ? e : !!e?.removeView) &&
            this.canvas.parentNode &&
            this.canvas.parentNode.removeChild(this.canvas)
        }
      }
      Ef.extension = {
        type: [_.WebGLSystem, _.WebGPUSystem, _.CanvasSystem],
        name: "view",
        priority: 0,
      }
      Ef.defaultOptions = { width: 800, height: 600, autoDensity: !1, antialias: !1 }
      bS = Ef
    })
  var el,
    tl,
    wf = d(() => {
      wv()
      Mv()
      Iv()
      Gv()
      ff()
      Uv()
      Vv()
      $v()
      Xv()
      jv()
      qv()
      Jv()
      tS()
      rS()
      iS()
      aS()
      fS()
      gS()
      vS()
      ;((el = [Kv, io, vn, bS, Ys, mS, ro, Qv, qs, dS, no]),
        (tl = [to, mf, Ks, $s, Zs, Js, Qs, Ws]))
    })
  var ao,
    SS = d(() => {
      D()
      ao = class {
        constructor(e) {
          ;((this._hash = Object.create(null)),
            (this._renderer = e),
            this._renderer.renderableGC.addManagedHash(this, "_hash"))
        }
        contextChange(e) {
          this._gpu = e
        }
        getBindGroup(e, t, i) {
          return (e._updateKey(), this._hash[e._key] || this._createBindGroup(e, t, i))
        }
        _createBindGroup(e, t, i) {
          let n = this._gpu.device,
            s = t.layout[i],
            o = [],
            a = this._renderer
          for (let c in s) {
            let h = e.resources[c] ?? e.resources[s[c]],
              f
            if (h._resourceType === "uniformGroup") {
              let p = h
              a.ubo.updateUniformGroup(p)
              let m = p.buffer
              f = { buffer: a.buffer.getGPUBuffer(m), offset: 0, size: m.descriptor.size }
            } else if (h._resourceType === "buffer") {
              let p = h
              f = { buffer: a.buffer.getGPUBuffer(p), offset: 0, size: p.descriptor.size }
            } else if (h._resourceType === "bufferResource") {
              let p = h
              f = { buffer: a.buffer.getGPUBuffer(p.buffer), offset: p.offset, size: p.size }
            } else if (h._resourceType === "textureSampler") {
              let p = h
              f = a.texture.getGpuSampler(p)
            } else if (h._resourceType === "textureSource") {
              let p = h
              f = a.texture.getGpuSource(p).createView({})
            }
            o.push({ binding: s[c], resource: f })
          }
          let u = a.shader.getProgramData(t).bindGroups[i],
            l = n.createBindGroup({ layout: u, entries: o })
          return ((this._hash[e._key] = l), l)
        }
        destroy() {
          for (let e of Object.keys(this._hash)) this._hash[e] = null
          ;((this._hash = null), (this._renderer = null))
        }
      }
      ao.extension = { type: [_.WebGPUSystem], name: "bindGroup" }
    })
  var uo,
    TS = d(() => {
      D()
      wh()
      uo = class {
        constructor(e) {
          ;((this._gpuBuffers = Object.create(null)),
            (this._managedBuffers = []),
            e.renderableGC.addManagedHash(this, "_gpuBuffers"))
        }
        contextChange(e) {
          this._gpu = e
        }
        getGPUBuffer(e) {
          return this._gpuBuffers[e.uid] || this.createGPUBuffer(e)
        }
        updateBuffer(e) {
          let t = this._gpuBuffers[e.uid] || this.createGPUBuffer(e),
            i = e.data
          return (
            e._updateID &&
              i &&
              ((e._updateID = 0),
              this._gpu.device.queue.writeBuffer(
                t,
                0,
                i.buffer,
                0,
                ((e._updateSize || i.byteLength) + 3) & -4,
              )),
            t
          )
        }
        destroyAll() {
          for (let e in this._gpuBuffers) this._gpuBuffers[e].destroy()
          this._gpuBuffers = {}
        }
        createGPUBuffer(e) {
          this._gpuBuffers[e.uid] ||
            (e.on("update", this.updateBuffer, this),
            e.on("change", this.onBufferChange, this),
            e.on("destroy", this.onBufferDestroy, this),
            this._managedBuffers.push(e))
          let t = this._gpu.device.createBuffer(e.descriptor)
          return (
            (e._updateID = 0),
            e.data && (ds(e.data.buffer, t.getMappedRange()), t.unmap()),
            (this._gpuBuffers[e.uid] = t),
            t
          )
        }
        onBufferChange(e) {
          ;(this._gpuBuffers[e.uid].destroy(),
            (e._updateID = 0),
            (this._gpuBuffers[e.uid] = this.createGPUBuffer(e)))
        }
        onBufferDestroy(e) {
          ;(this._managedBuffers.splice(this._managedBuffers.indexOf(e), 1), this._destroyBuffer(e))
        }
        destroy() {
          ;(this._managedBuffers.forEach((e) => this._destroyBuffer(e)),
            (this._managedBuffers = null),
            (this._gpuBuffers = null))
        }
        _destroyBuffer(e) {
          ;(this._gpuBuffers[e.uid].destroy(),
            e.off("update", this.updateBuffer, this),
            e.off("change", this.onBufferChange, this),
            e.off("destroy", this.onBufferDestroy, this),
            (this._gpuBuffers[e.uid] = null))
        }
      }
      uo.extension = { type: [_.WebGPUSystem], name: "buffer" }
    })
  var lo,
    CS = d(() => {
      D()
      lo = class {
        constructor(e) {
          ;((this._colorMaskCache = 15), (this._renderer = e))
        }
        setMask(e) {
          this._colorMaskCache !== e &&
            ((this._colorMaskCache = e), this._renderer.pipeline.setColorMask(e))
        }
        destroy() {
          ;((this._renderer = null), (this._colorMaskCache = null))
        }
      }
      lo.extension = { type: [_.WebGPUSystem], name: "colorMask" }
    })
  var Sn,
    ES = d(() => {
      Ie()
      D()
      Sn = class {
        constructor(e) {
          this._renderer = e
        }
        async init(e) {
          return this._initPromise
            ? this._initPromise
            : ((this._initPromise = this._createDeviceAndAdaptor(e).then((t) => {
                ;((this.gpu = t), this._renderer.runners.contextChange.emit(this.gpu))
              })),
              this._initPromise)
        }
        contextChange(e) {
          this._renderer.gpu = e
        }
        async _createDeviceAndAdaptor(e) {
          let t = await Z.get()
              .getNavigator()
              .gpu.requestAdapter({
                powerPreference: e.powerPreference,
                forceFallbackAdapter: e.forceFallbackAdapter,
              }),
            i = [
              "texture-compression-bc",
              "texture-compression-astc",
              "texture-compression-etc2",
            ].filter((s) => t.features.has(s)),
            n = await t.requestDevice({ requiredFeatures: i })
          return { adapter: t, device: n }
        }
        destroy() {
          ;((this.gpu = null), (this._renderer = null))
        }
      }
      Sn.extension = { type: [_.WebGPUSystem], name: "device" }
      Sn.defaultOptions = { powerPreference: void 0, forceFallbackAdapter: !1 }
    })
  var co,
    wS = d(() => {
      D()
      co = class {
        constructor(e) {
          ;((this._boundBindGroup = Object.create(null)),
            (this._boundVertexBuffer = Object.create(null)),
            (this._renderer = e))
        }
        renderStart() {
          ;((this.commandFinished = new Promise((e) => {
            this._resolveCommandFinished = e
          })),
            (this.commandEncoder = this._renderer.gpu.device.createCommandEncoder()))
        }
        beginRenderPass(e) {
          ;(this.endRenderPass(),
            this._clearCache(),
            (this.renderPassEncoder = this.commandEncoder.beginRenderPass(e.descriptor)))
        }
        endRenderPass() {
          ;(this.renderPassEncoder && this.renderPassEncoder.end(), (this.renderPassEncoder = null))
        }
        setViewport(e) {
          this.renderPassEncoder.setViewport(e.x, e.y, e.width, e.height, 0, 1)
        }
        setPipelineFromGeometryProgramAndState(e, t, i, n) {
          let s = this._renderer.pipeline.getPipeline(e, t, i, n)
          this.setPipeline(s)
        }
        setPipeline(e) {
          this._boundPipeline !== e &&
            ((this._boundPipeline = e), this.renderPassEncoder.setPipeline(e))
        }
        _setVertexBuffer(e, t) {
          this._boundVertexBuffer[e] !== t &&
            ((this._boundVertexBuffer[e] = t),
            this.renderPassEncoder.setVertexBuffer(e, this._renderer.buffer.updateBuffer(t)))
        }
        _setIndexBuffer(e) {
          if (this._boundIndexBuffer === e) return
          this._boundIndexBuffer = e
          let t = e.data.BYTES_PER_ELEMENT === 2 ? "uint16" : "uint32"
          this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(e), t)
        }
        resetBindGroup(e) {
          this._boundBindGroup[e] = null
        }
        setBindGroup(e, t, i) {
          if (this._boundBindGroup[e] === t) return
          ;((this._boundBindGroup[e] = t), t._touch(this._renderer.textureGC.count))
          let n = this._renderer.bindGroup.getBindGroup(t, i, e)
          this.renderPassEncoder.setBindGroup(e, n)
        }
        setGeometry(e, t) {
          let i = this._renderer.pipeline.getBufferNamesToBind(e, t)
          for (let n in i) this._setVertexBuffer(n, e.attributes[i[n]].buffer)
          e.indexBuffer && this._setIndexBuffer(e.indexBuffer)
        }
        _setShaderBindGroups(e, t) {
          for (let i in e.groups) {
            let n = e.groups[i]
            ;(t || this._syncBindGroup(n), this.setBindGroup(i, n, e.gpuProgram))
          }
        }
        _syncBindGroup(e) {
          for (let t in e.resources) {
            let i = e.resources[t]
            i.isUniformGroup && this._renderer.ubo.updateUniformGroup(i)
          }
        }
        draw(e) {
          let {
            geometry: t,
            shader: i,
            state: n,
            topology: s,
            size: o,
            start: a,
            instanceCount: u,
            skipSync: l,
          } = e
          ;(this.setPipelineFromGeometryProgramAndState(t, i.gpuProgram, n, s),
            this.setGeometry(t, i.gpuProgram),
            this._setShaderBindGroups(i, l),
            t.indexBuffer
              ? this.renderPassEncoder.drawIndexed(
                  o || t.indexBuffer.data.length,
                  u ?? t.instanceCount,
                  a || 0,
                )
              : this.renderPassEncoder.draw(o || t.getSize(), u ?? t.instanceCount, a || 0))
        }
        finishRenderPass() {
          this.renderPassEncoder && (this.renderPassEncoder.end(), (this.renderPassEncoder = null))
        }
        postrender() {
          ;(this.finishRenderPass(),
            this._gpu.device.queue.submit([this.commandEncoder.finish()]),
            this._resolveCommandFinished(),
            (this.commandEncoder = null))
        }
        restoreRenderPass() {
          let e = this._renderer.renderTarget.adaptor.getDescriptor(
            this._renderer.renderTarget.renderTarget,
            !1,
            [0, 0, 0, 1],
          )
          this.renderPassEncoder = this.commandEncoder.beginRenderPass(e)
          let t = this._boundPipeline,
            i = { ...this._boundVertexBuffer },
            n = this._boundIndexBuffer,
            s = { ...this._boundBindGroup }
          this._clearCache()
          let o = this._renderer.renderTarget.viewport
          ;(this.renderPassEncoder.setViewport(o.x, o.y, o.width, o.height, 0, 1),
            this.setPipeline(t))
          for (let a in i) this._setVertexBuffer(a, i[a])
          for (let a in s) this.setBindGroup(a, s[a], null)
          this._setIndexBuffer(n)
        }
        _clearCache() {
          for (let e = 0; e < 16; e++)
            ((this._boundBindGroup[e] = null), (this._boundVertexBuffer[e] = null))
          ;((this._boundIndexBuffer = null), (this._boundPipeline = null))
        }
        destroy() {
          ;((this._renderer = null),
            (this._gpu = null),
            (this._boundBindGroup = null),
            (this._boundVertexBuffer = null),
            (this._boundIndexBuffer = null),
            (this._boundPipeline = null))
        }
        contextChange(e) {
          this._gpu = e
        }
      }
      co.extension = { type: [_.WebGPUSystem], name: "encoder", priority: 1 }
    })
  var ho,
    MS = d(() => {
      D()
      li()
      ho = class {
        constructor(e) {
          ;((this._renderTargetStencilState = Object.create(null)),
            (this._renderer = e),
            e.renderTarget.onRenderTargetChange.add(this))
        }
        onRenderTargetChange(e) {
          let t = this._renderTargetStencilState[e.uid]
          ;(t ||
            (t = this._renderTargetStencilState[e.uid] =
              { stencilMode: ye.DISABLED, stencilReference: 0 }),
            (this._activeRenderTarget = e),
            this.setStencilMode(t.stencilMode, t.stencilReference))
        }
        setStencilMode(e, t) {
          let i = this._renderTargetStencilState[this._activeRenderTarget.uid]
          ;((i.stencilMode = e), (i.stencilReference = t))
          let n = this._renderer
          ;(n.pipeline.setStencilMode(e), n.encoder.renderPassEncoder.setStencilReference(t))
        }
        destroy() {
          ;(this._renderer.renderTarget.onRenderTargetChange.remove(this),
            (this._renderer = null),
            (this._activeRenderTarget = null),
            (this._renderTargetStencilState = null))
        }
      }
      ho.extension = { type: [_.WebGPUSystem], name: "stencil" }
    })
  var Tn,
    Mf = d(() => {
      of()
      Dr()
      hr()
      Tn = class {
        constructor(e) {
          ;((this._syncFunctionHash = Object.create(null)),
            (this._adaptor = e),
            this._systemCheck())
        }
        _systemCheck() {
          if (!Yu())
            throw new Error(
              "Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.",
            )
        }
        ensureUniformGroup(e) {
          let t = this.getUniformGroupData(e)
          e.buffer ||
            (e.buffer = new Ae({
              data: new Float32Array(t.layout.size / 4),
              usage: Q.UNIFORM | Q.COPY_DST,
            }))
        }
        getUniformGroupData(e) {
          return this._syncFunctionHash[e._signature] || this._initUniformGroup(e)
        }
        _initUniformGroup(e) {
          let t = e._signature,
            i = this._syncFunctionHash[t]
          if (!i) {
            let n = Object.keys(e.uniformStructures).map((a) => e.uniformStructures[a]),
              s = this._adaptor.createUboElements(n),
              o = this._generateUboSync(s.uboElements)
            i = this._syncFunctionHash[t] = { layout: s, syncFunction: o }
          }
          return this._syncFunctionHash[t]
        }
        _generateUboSync(e) {
          return this._adaptor.generateUboSync(e)
        }
        syncUniformGroup(e, t, i) {
          let n = this.getUniformGroupData(e)
          e.buffer ||
            (e.buffer = new Ae({
              data: new Float32Array(n.layout.size / 4),
              usage: Q.UNIFORM | Q.COPY_DST,
            }))
          let s = null
          return (
            t || ((t = e.buffer.data), (s = e.buffer.dataInt32)),
            i || (i = 0),
            n.syncFunction(e.uniforms, t, s, i),
            !0
          )
        }
        updateUniformGroup(e) {
          if (e.isStatic && !e._dirtyId) return !1
          e._dirtyId = 0
          let t = this.syncUniformGroup(e)
          return (e.buffer.update(), t)
        }
        destroy() {
          this._syncFunctionHash = null
        }
      }
    })
  function AS(r) {
    let e = r.map((i) => ({ data: i, offset: 0, size: 0 })),
      t = 0
    for (let i = 0; i < e.length; i++) {
      let n = e[i],
        s = fo[n.data.type].size,
        o = fo[n.data.type].align
      if (!fo[n.data.type])
        throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${n.data.type}`)
      ;(n.data.size > 1 && (s = Math.max(s, o) * n.data.size),
        (t = Math.ceil(t / o) * o),
        (n.size = s),
        (n.offset = t),
        (t += s))
    }
    return ((t = Math.ceil(t / 16) * 16), { uboElements: e, size: t })
  }
  var fo,
    Af = d(() => {
      "use strict"
      fo = {
        i32: { align: 4, size: 4 },
        u32: { align: 4, size: 4 },
        f32: { align: 4, size: 4 },
        f16: { align: 2, size: 2 },
        "vec2<i32>": { align: 8, size: 8 },
        "vec2<u32>": { align: 8, size: 8 },
        "vec2<f32>": { align: 8, size: 8 },
        "vec2<f16>": { align: 4, size: 4 },
        "vec3<i32>": { align: 16, size: 12 },
        "vec3<u32>": { align: 16, size: 12 },
        "vec3<f32>": { align: 16, size: 12 },
        "vec3<f16>": { align: 8, size: 6 },
        "vec4<i32>": { align: 16, size: 16 },
        "vec4<u32>": { align: 16, size: 16 },
        "vec4<f32>": { align: 16, size: 16 },
        "vec4<f16>": { align: 8, size: 8 },
        "mat2x2<f32>": { align: 8, size: 16 },
        "mat2x2<f16>": { align: 4, size: 8 },
        "mat3x2<f32>": { align: 8, size: 24 },
        "mat3x2<f16>": { align: 4, size: 12 },
        "mat4x2<f32>": { align: 8, size: 32 },
        "mat4x2<f16>": { align: 4, size: 16 },
        "mat2x3<f32>": { align: 16, size: 32 },
        "mat2x3<f16>": { align: 8, size: 16 },
        "mat3x3<f32>": { align: 16, size: 48 },
        "mat3x3<f16>": { align: 8, size: 24 },
        "mat4x3<f32>": { align: 16, size: 64 },
        "mat4x3<f16>": { align: 8, size: 32 },
        "mat2x4<f32>": { align: 16, size: 32 },
        "mat2x4<f16>": { align: 8, size: 16 },
        "mat3x4<f32>": { align: 16, size: 48 },
        "mat3x4<f16>": { align: 8, size: 24 },
        "mat4x4<f32>": { align: 16, size: 64 },
        "mat4x4<f16>": { align: 8, size: 32 },
      }
    })
  var mr,
    Df = d(() => {
      "use strict"
      mr = [
        {
          type: "mat3x3<f32>",
          test: (r) => r.value.a !== void 0,
          ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,
          uniform: `
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `,
        },
        {
          type: "vec4<f32>",
          test: (r) => r.type === "vec4<f32>" && r.size === 1 && r.value.width !== void 0,
          ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,
          uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `,
        },
        {
          type: "vec2<f32>",
          test: (r) => r.type === "vec2<f32>" && r.size === 1 && r.value.x !== void 0,
          ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,
          uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `,
        },
        {
          type: "vec4<f32>",
          test: (r) => r.type === "vec4<f32>" && r.size === 1 && r.value.red !== void 0,
          ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,
          uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `,
        },
        {
          type: "vec3<f32>",
          test: (r) => r.type === "vec3<f32>" && r.size === 1 && r.value.red !== void 0,
          ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,
          uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `,
        },
      ]
    })
  function rl(r, e, t, i) {
    let n = [
        `
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `,
      ],
      s = 0
    for (let a = 0; a < r.length; a++) {
      let u = r[a],
        l = u.data.name,
        c = !1,
        h = 0
      for (let f = 0; f < mr.length; f++)
        if (mr[f].test(u.data)) {
          ;((h = u.offset / 4),
            n.push(`name = "${l}";`, `offset += ${h - s};`, mr[f][e] || mr[f].ubo),
            (c = !0))
          break
        }
      if (!c)
        if (u.data.size > 1) ((h = u.offset / 4), n.push(t(u, h - s)))
        else {
          let f = i[u.data.type]
          ;((h = u.offset / 4),
            n.push(`
                    v = uv.${l};
                    offset += ${h - s};
                    ${f};
                `))
        }
      s = h
    }
    let o = n.join(`
`)
    return new Function("uv", "data", "dataInt32", "offset", o)
  }
  var Pf = d(() => {
    Df()
  })
  function Cn(r, e) {
    return `
        for (let i = 0; i < ${r * e}; i++) {
            data[offset + (((i / ${r})|0) * 4) + (i % ${r})] = v[i];
        }
    `
  }
  var Rf,
    DS,
    Ff = d(() => {
      "use strict"
      ;((Rf = {
        f32: `
        data[offset] = v;`,
        i32: `
        dataInt32[offset] = v;`,
        "vec2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];`,
        "vec3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,
        "vec4<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,
        "vec2<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];`,
        "vec3<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];`,
        "vec4<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];
        dataInt32[offset + 3] = v[3];`,
        "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,
        "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,
        "mat4x4<f32>": `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,
        "mat3x2<f32>": Cn(3, 2),
        "mat4x2<f32>": Cn(4, 2),
        "mat2x3<f32>": Cn(2, 3),
        "mat4x3<f32>": Cn(4, 3),
        "mat2x4<f32>": Cn(2, 4),
        "mat3x4<f32>": Cn(3, 4),
      }),
        (DS = {
          ...Rf,
          "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `,
        }))
    })
  function PS(r, e) {
    let { size: t, align: i } = fo[r.data.type],
      n = (i - t) / 4,
      s = r.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data"
    return `
         v = uv.${r.data.name};
         ${e !== 0 ? `offset += ${e};` : ""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${r.data.size * (t / 4)}; i++)
         {
             for(var j = 0; j < ${t / 4}; j++)
             {
                 ${s}[arrayOffset++] = v[t++];
             }
             ${n !== 0 ? `arrayOffset += ${n};` : ""}
         }
     `
  }
  var RS = d(() => {
    Af()
  })
  function FS(r) {
    return rl(r, "uboWgsl", PS, DS)
  }
  var BS = d(() => {
    Pf()
    Ff()
    RS()
  })
  var po,
    IS = d(() => {
      D()
      Mf()
      Af()
      BS()
      po = class extends Tn {
        constructor() {
          super({ createUboElements: AS, generateUboSync: FS })
        }
      }
      po.extension = { type: [_.WebGPUSystem], name: "ubo" }
    })
  var Ur,
    il = d(() => {
      Je()
      Ye()
      Ur = class extends pe {
        constructor({ buffer: e, offset: t, size: i }) {
          ;(super(),
            (this.uid = te("buffer")),
            (this._resourceType = "bufferResource"),
            (this._touched = 0),
            (this._resourceId = te("resource")),
            (this._bufferResource = !0),
            (this.destroyed = !1),
            (this.buffer = e),
            (this.offset = t | 0),
            (this.size = i),
            this.buffer.on("change", this.onBufferChange, this))
        }
        onBufferChange() {
          ;((this._resourceId = te("resource")), this.emit("change", this))
        }
        destroy(e = !1) {
          ;((this.destroyed = !0),
            e && this.buffer.destroy(),
            this.emit("change", this),
            (this.buffer = null))
        }
      }
    })
  var nl,
    GS = d(() => {
      "use strict"
      nl = class {
        constructor({ minUniformOffsetAlignment: e }) {
          ;((this._minUniformOffsetAlignment = 256),
            (this.byteIndex = 0),
            (this._minUniformOffsetAlignment = e),
            (this.data = new Float32Array(65535)))
        }
        clear() {
          this.byteIndex = 0
        }
        addEmptyGroup(e) {
          if (e > this._minUniformOffsetAlignment / 4)
            throw new Error(`UniformBufferBatch: array is too large: ${e * 4}`)
          let t = this.byteIndex,
            i = t + e * 4
          if (
            ((i = Math.ceil(i / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment),
            i > this.data.length * 4)
          )
            throw new Error("UniformBufferBatch: ubo batch got too big")
          return ((this.byteIndex = i), t)
        }
        addGroup(e) {
          let t = this.addEmptyGroup(e.length)
          for (let i = 0; i < e.length; i++) this.data[t / 4 + i] = e[i]
          return t
        }
        destroy() {
          this.data = null
        }
      }
    })
  var Or,
    mo,
    kS = d(() => {
      D()
      Dr()
      il()
      hr()
      GS()
      Ar()
      ;((Or = 128),
        (mo = class {
          constructor(e) {
            ;((this._bindGroupHash = Object.create(null)),
              (this._buffers = []),
              (this._bindGroups = []),
              (this._bufferResources = []),
              (this._renderer = e),
              this._renderer.renderableGC.addManagedHash(this, "_bindGroupHash"),
              (this._batchBuffer = new nl({ minUniformOffsetAlignment: Or })))
            let t = 256 / Or
            for (let i = 0; i < t; i++) {
              let n = Q.UNIFORM | Q.COPY_DST
              ;(i === 0 && (n |= Q.COPY_SRC),
                this._buffers.push(new Ae({ data: this._batchBuffer.data, usage: n })))
            }
          }
          renderEnd() {
            ;(this._uploadBindGroups(), this._resetBindGroups())
          }
          _resetBindGroups() {
            for (let e in this._bindGroupHash) this._bindGroupHash[e] = null
            this._batchBuffer.clear()
          }
          getUniformBindGroup(e, t) {
            if (!t && this._bindGroupHash[e.uid]) return this._bindGroupHash[e.uid]
            this._renderer.ubo.ensureUniformGroup(e)
            let i = e.buffer.data,
              n = this._batchBuffer.addEmptyGroup(i.length)
            return (
              this._renderer.ubo.syncUniformGroup(e, this._batchBuffer.data, n / 4),
              (this._bindGroupHash[e.uid] = this._getBindGroup(n / Or)),
              this._bindGroupHash[e.uid]
            )
          }
          getUboResource(e) {
            this._renderer.ubo.updateUniformGroup(e)
            let t = e.buffer.data,
              i = this._batchBuffer.addGroup(t)
            return this._getBufferResource(i / Or)
          }
          getArrayBindGroup(e) {
            let t = this._batchBuffer.addGroup(e)
            return this._getBindGroup(t / Or)
          }
          getArrayBufferResource(e) {
            let i = this._batchBuffer.addGroup(e) / Or
            return this._getBufferResource(i)
          }
          _getBufferResource(e) {
            if (!this._bufferResources[e]) {
              let t = this._buffers[e % 2]
              this._bufferResources[e] = new Ur({
                buffer: t,
                offset: ((e / 2) | 0) * 256,
                size: Or,
              })
            }
            return this._bufferResources[e]
          }
          _getBindGroup(e) {
            if (!this._bindGroups[e]) {
              let t = new He({ 0: this._getBufferResource(e) })
              this._bindGroups[e] = t
            }
            return this._bindGroups[e]
          }
          _uploadBindGroups() {
            let e = this._renderer.buffer,
              t = this._buffers[0]
            ;(t.update(this._batchBuffer.byteIndex), e.updateBuffer(t))
            let i = this._renderer.gpu.device.createCommandEncoder()
            for (let n = 1; n < this._buffers.length; n++) {
              let s = this._buffers[n]
              i.copyBufferToBuffer(
                e.getGPUBuffer(t),
                Or,
                e.getGPUBuffer(s),
                0,
                this._batchBuffer.byteIndex,
              )
            }
            this._renderer.gpu.device.queue.submit([i.finish()])
          }
          destroy() {
            for (let e = 0; e < this._bindGroups.length; e++) this._bindGroups[e].destroy()
            ;((this._bindGroups = null), (this._bindGroupHash = null))
            for (let e = 0; e < this._buffers.length; e++) this._buffers[e].destroy()
            this._buffers = null
            for (let e = 0; e < this._bufferResources.length; e++)
              this._bufferResources[e].destroy()
            ;((this._bufferResources = null),
              this._batchBuffer.destroy(),
              (this._bindGroupHash = null),
              (this._renderer = null))
          }
        }))
      mo.extension = { type: [_.WebGPUPipes], name: "uniformBatch" }
    })
  function sl(r, e) {
    for (let t in r.attributes) {
      let i = r.attributes[t],
        n = e[t]
      n
        ? (i.format ?? (i.format = n.format),
          i.offset ?? (i.offset = n.offset),
          i.instance ?? (i.instance = n.instance))
        : H(
            `Attribute ${t} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`,
          )
    }
    DR(r)
  }
  function DR(r) {
    let { buffers: e, attributes: t } = r,
      i = {},
      n = {}
    for (let s in e) {
      let o = e[s]
      ;((i[o.uid] = 0), (n[o.uid] = 0))
    }
    for (let s in t) {
      let o = t[s]
      i[o.buffer.uid] += dt(o.format).stride
    }
    for (let s in t) {
      let o = t[s]
      ;(o.stride ?? (o.stride = i[o.buffer.uid]),
        o.start ?? (o.start = n[o.buffer.uid]),
        (n[o.buffer.uid] += dt(o.format).stride))
    }
  }
  var Bf = d(() => {
    be()
    hi()
  })
  var rr,
    If = d(() => {
      li()
      rr = []
      rr[ye.NONE] = void 0
      rr[ye.DISABLED] = { stencilWriteMask: 0, stencilReadMask: 0 }
      rr[ye.RENDERING_MASK_ADD] = {
        stencilFront: { compare: "equal", passOp: "increment-clamp" },
        stencilBack: { compare: "equal", passOp: "increment-clamp" },
      }
      rr[ye.RENDERING_MASK_REMOVE] = {
        stencilFront: { compare: "equal", passOp: "decrement-clamp" },
        stencilBack: { compare: "equal", passOp: "decrement-clamp" },
      }
      rr[ye.MASK_ACTIVE] = {
        stencilWriteMask: 0,
        stencilFront: { compare: "equal", passOp: "keep" },
        stencilBack: { compare: "equal", passOp: "keep" },
      }
      rr[ye.INVERSE_MASK_ACTIVE] = {
        stencilWriteMask: 0,
        stencilFront: { compare: "not-equal", passOp: "replace" },
        stencilBack: { compare: "not-equal", passOp: "replace" },
      }
    })
  function RR(r, e, t, i, n) {
    return (r << 24) | (e << 16) | (t << 10) | (i << 5) | n
  }
  function FR(r, e, t, i) {
    return (t << 6) | (r << 3) | (i << 1) | e
  }
  var PR,
    go,
    US = d(() => {
      D()
      be()
      Bf()
      li()
      ms()
      If()
      PR = {
        "point-list": 0,
        "line-list": 1,
        "line-strip": 2,
        "triangle-list": 3,
        "triangle-strip": 4,
      }
      go = class {
        constructor(e) {
          ;((this._moduleCache = Object.create(null)),
            (this._bufferLayoutsCache = Object.create(null)),
            (this._bindingNamesCache = Object.create(null)),
            (this._pipeCache = Object.create(null)),
            (this._pipeStateCaches = Object.create(null)),
            (this._colorMask = 15),
            (this._multisampleCount = 1),
            (this._renderer = e))
        }
        contextChange(e) {
          ;((this._gpu = e), this.setStencilMode(ye.DISABLED), this._updatePipeHash())
        }
        setMultisampleCount(e) {
          this._multisampleCount !== e && ((this._multisampleCount = e), this._updatePipeHash())
        }
        setRenderTarget(e) {
          ;((this._multisampleCount = e.msaaSamples),
            (this._depthStencilAttachment = e.descriptor.depthStencilAttachment ? 1 : 0),
            this._updatePipeHash())
        }
        setColorMask(e) {
          this._colorMask !== e && ((this._colorMask = e), this._updatePipeHash())
        }
        setStencilMode(e) {
          this._stencilMode !== e &&
            ((this._stencilMode = e), (this._stencilState = rr[e]), this._updatePipeHash())
        }
        setPipeline(e, t, i, n) {
          let s = this.getPipeline(e, t, i)
          n.setPipeline(s)
        }
        getPipeline(e, t, i, n) {
          ;(e._layoutKey || (sl(e, t.attributeData), this._generateBufferKey(e)),
            n || (n = e.topology))
          let s = RR(e._layoutKey, t._layoutKey, i.data, i._blendModeId, PR[n])
          return this._pipeCache[s]
            ? this._pipeCache[s]
            : ((this._pipeCache[s] = this._createPipeline(e, t, i, n)), this._pipeCache[s])
        }
        _createPipeline(e, t, i, n) {
          let s = this._gpu.device,
            o = this._createVertexBufferLayouts(e, t),
            a = this._renderer.state.getColorTargets(i)
          a[0].writeMask = this._stencilMode === ye.RENDERING_MASK_ADD ? 0 : this._colorMask
          let u = this._renderer.shader.getProgramData(t).pipeline,
            l = {
              vertex: {
                module: this._getModule(t.vertex.source),
                entryPoint: t.vertex.entryPoint,
                buffers: o,
              },
              fragment: {
                module: this._getModule(t.fragment.source),
                entryPoint: t.fragment.entryPoint,
                targets: a,
              },
              primitive: { topology: n, cullMode: i.cullMode },
              layout: u,
              multisample: { count: this._multisampleCount },
              label: "PIXI Pipeline",
            }
          return (
            this._depthStencilAttachment &&
              (l.depthStencil = {
                ...this._stencilState,
                format: "depth24plus-stencil8",
                depthWriteEnabled: i.depthTest,
                depthCompare: i.depthTest ? "less" : "always",
              }),
            s.createRenderPipeline(l)
          )
        }
        _getModule(e) {
          return this._moduleCache[e] || this._createModule(e)
        }
        _createModule(e) {
          let t = this._gpu.device
          return ((this._moduleCache[e] = t.createShaderModule({ code: e })), this._moduleCache[e])
        }
        _generateBufferKey(e) {
          let t = [],
            i = 0,
            n = Object.keys(e.attributes).sort()
          for (let o = 0; o < n.length; o++) {
            let a = e.attributes[n[o]]
            ;((t[i++] = a.offset), (t[i++] = a.format), (t[i++] = a.stride), (t[i++] = a.instance))
          }
          let s = t.join("|")
          return ((e._layoutKey = dr(s, "geometry")), e._layoutKey)
        }
        _generateAttributeLocationsKey(e) {
          let t = [],
            i = 0,
            n = Object.keys(e.attributeData).sort()
          for (let o = 0; o < n.length; o++) {
            let a = e.attributeData[n[o]]
            t[i++] = a.location
          }
          let s = t.join("|")
          return ((e._attributeLocationsKey = dr(s, "programAttributes")), e._attributeLocationsKey)
        }
        getBufferNamesToBind(e, t) {
          let i = (e._layoutKey << 16) | t._attributeLocationsKey
          if (this._bindingNamesCache[i]) return this._bindingNamesCache[i]
          let n = this._createVertexBufferLayouts(e, t),
            s = Object.create(null),
            o = t.attributeData
          for (let a = 0; a < n.length; a++) {
            let l = Object.values(n[a].attributes)[0].shaderLocation
            for (let c in o)
              if (o[c].location === l) {
                s[a] = c
                break
              }
          }
          return ((this._bindingNamesCache[i] = s), s)
        }
        _createVertexBufferLayouts(e, t) {
          t._attributeLocationsKey || this._generateAttributeLocationsKey(t)
          let i = (e._layoutKey << 16) | t._attributeLocationsKey
          if (this._bufferLayoutsCache[i]) return this._bufferLayoutsCache[i]
          let n = []
          return (
            e.buffers.forEach((s) => {
              let o = { arrayStride: 0, stepMode: "vertex", attributes: [] },
                a = o.attributes
              for (let u in t.attributeData) {
                let l = e.attributes[u]
                ;((l.divisor ?? 1) !== 1 &&
                  H(
                    `Attribute ${u} has an invalid divisor value of '${l.divisor}'. WebGPU only supports a divisor value of 1`,
                  ),
                  l.buffer === s &&
                    ((o.arrayStride = l.stride),
                    (o.stepMode = l.instance ? "instance" : "vertex"),
                    a.push({
                      shaderLocation: t.attributeData[u].location,
                      offset: l.offset,
                      format: l.format,
                    })))
              }
              a.length && n.push(o)
            }),
            (this._bufferLayoutsCache[i] = n),
            n
          )
        }
        _updatePipeHash() {
          let e = FR(
            this._stencilMode,
            this._multisampleCount,
            this._colorMask,
            this._depthStencilAttachment,
          )
          ;(this._pipeStateCaches[e] || (this._pipeStateCaches[e] = Object.create(null)),
            (this._pipeCache = this._pipeStateCaches[e]))
        }
        destroy() {
          ;((this._renderer = null), (this._bufferLayoutsCache = null))
        }
      }
      go.extension = { type: [_.WebGPUSystem], name: "pipeline" }
    })
  function OS(r, e, t, i, n, s) {
    let o = s ? 1 : -1
    return (
      r.identity(),
      (r.a = (1 / i) * 2),
      (r.d = o * ((1 / n) * 2)),
      (r.tx = -1 - e * r.a),
      (r.ty = -o - t * r.d),
      r
    )
  }
  var LS = d(() => {
    "use strict"
  })
  function NS(r) {
    let e = r.colorTexture.source.resource
    return (
      globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement && document.body.contains(e)
    )
  }
  var HS = d(() => {
    "use strict"
  })
  var En,
    Gf = d(() => {
      se()
      Ke()
      _n()
      LS()
      af()
      zi()
      ct()
      ge()
      Cf()
      HS()
      Tf()
      En = class {
        constructor(e) {
          ;((this.rootViewPort = new ee()),
            (this.viewport = new ee()),
            (this.onRenderTargetChange = new yn("onRenderTargetChange")),
            (this.projectionMatrix = new F()),
            (this.defaultClearColor = [0, 0, 0, 0]),
            (this._renderSurfaceToRenderTargetHash = new Map()),
            (this._gpuRenderTargetHash = Object.create(null)),
            (this._renderTargetStack = []),
            (this._renderer = e),
            e.renderableGC.addManagedHash(this, "_gpuRenderTargetHash"))
        }
        finishRenderPass() {
          this.adaptor.finishRenderPass(this.renderTarget)
        }
        renderStart({ target: e, clear: t, clearColor: i, frame: n }) {
          ;((this._renderTargetStack.length = 0),
            this.push(e, t, i, n),
            this.rootViewPort.copyFrom(this.viewport),
            (this.rootRenderTarget = this.renderTarget),
            (this.renderingToScreen = NS(this.rootRenderTarget)),
            this.adaptor.prerender?.(this.rootRenderTarget))
        }
        postrender() {
          this.adaptor.postrender?.(this.rootRenderTarget)
        }
        bind(e, t = !0, i, n) {
          let s = this.getRenderTarget(e),
            o = this.renderTarget !== s
          ;((this.renderTarget = s), (this.renderSurface = e))
          let a = this.getGpuRenderTarget(s)
          ;(s.pixelWidth !== a.width || s.pixelHeight !== a.height) &&
            (this.adaptor.resizeGpuRenderTarget(s),
            (a.width = s.pixelWidth),
            (a.height = s.pixelHeight))
          let u = s.colorTexture,
            l = this.viewport,
            c = u.pixelWidth,
            h = u.pixelHeight
          if ((!n && e instanceof I && (n = e.frame), n)) {
            let f = u._resolution
            ;((l.x = (n.x * f + 0.5) | 0),
              (l.y = (n.y * f + 0.5) | 0),
              (l.width = (n.width * f + 0.5) | 0),
              (l.height = (n.height * f + 0.5) | 0))
          } else ((l.x = 0), (l.y = 0), (l.width = c), (l.height = h))
          return (
            OS(
              this.projectionMatrix,
              0,
              0,
              l.width / u.resolution,
              l.height / u.resolution,
              !s.isRoot,
            ),
            this.adaptor.startRenderPass(s, t, i, l),
            o && this.onRenderTargetChange.emit(s),
            s
          )
        }
        clear(e, t = ze.ALL, i) {
          t &&
            (e && (e = this.getRenderTarget(e)),
            this.adaptor.clear(e || this.renderTarget, t, i, this.viewport))
        }
        contextChange() {
          this._gpuRenderTargetHash = Object.create(null)
        }
        push(e, t = ze.ALL, i, n) {
          let s = this.bind(e, t, i, n)
          return (this._renderTargetStack.push({ renderTarget: s, frame: n }), s)
        }
        pop() {
          this._renderTargetStack.pop()
          let e = this._renderTargetStack[this._renderTargetStack.length - 1]
          this.bind(e.renderTarget, !1, null, e.frame)
        }
        getRenderTarget(e) {
          return (
            e.isTexture && (e = e.source),
            this._renderSurfaceToRenderTargetHash.get(e) ?? this._initRenderTarget(e)
          )
        }
        copyToTexture(e, t, i, n, s) {
          ;(i.x < 0 && ((n.width += i.x), (s.x -= i.x), (i.x = 0)),
            i.y < 0 && ((n.height += i.y), (s.y -= i.y), (i.y = 0)))
          let { pixelWidth: o, pixelHeight: a } = e
          return (
            (n.width = Math.min(n.width, o - i.x)),
            (n.height = Math.min(n.height, a - i.y)),
            this.adaptor.copyToTexture(e, t, i, n, s)
          )
        }
        ensureDepthStencil() {
          this.renderTarget.stencil ||
            ((this.renderTarget.stencil = !0),
            this.adaptor.startRenderPass(this.renderTarget, !1, null, this.viewport))
        }
        destroy() {
          ;((this._renderer = null),
            this._renderSurfaceToRenderTargetHash.forEach((e, t) => {
              e !== t && e.destroy()
            }),
            this._renderSurfaceToRenderTargetHash.clear(),
            (this._gpuRenderTargetHash = Object.create(null)))
        }
        _initRenderTarget(e) {
          let t = null
          return (
            et.test(e) && (e = Ju(e).source),
            e instanceof so
              ? (t = e)
              : e instanceof ce &&
                ((t = new so({ colorTextures: [e] })),
                et.test(e.source.resource) && (t.isRoot = !0),
                e.once("destroy", () => {
                  ;(t.destroy(), this._renderSurfaceToRenderTargetHash.delete(e))
                  let i = this._gpuRenderTargetHash[t.uid]
                  i &&
                    ((this._gpuRenderTargetHash[t.uid] = null),
                    this.adaptor.destroyGpuRenderTarget(i))
                })),
            this._renderSurfaceToRenderTargetHash.set(e, t),
            t
          )
        }
        getGpuRenderTarget(e) {
          return (
            this._gpuRenderTargetHash[e.uid] ||
            (this._gpuRenderTargetHash[e.uid] = this.adaptor.initGpuRenderTarget(e))
          )
        }
        resetState() {
          ;((this.renderTarget = null), (this.renderSurface = null))
        }
      }
    })
  var ol,
    zS = d(() => {
      "use strict"
      ol = class {
        constructor() {
          ;((this.contexts = []), (this.msaaTextures = []), (this.msaaSamples = 1))
        }
      }
    })
  var al,
    WS = d(() => {
      _n()
      zi()
      ct()
      zS()
      al = class {
        init(e, t) {
          ;((this._renderer = e), (this._renderTargetSystem = t))
        }
        copyToTexture(e, t, i, n, s) {
          let o = this._renderer,
            a = this._getGpuColorTexture(e),
            u = o.texture.getGpuSource(t.source)
          return (
            o.encoder.commandEncoder.copyTextureToTexture(
              { texture: a, origin: i },
              { texture: u, origin: s },
              n,
            ),
            t
          )
        }
        startRenderPass(e, t = !0, i, n) {
          let o = this._renderTargetSystem.getGpuRenderTarget(e),
            a = this.getDescriptor(e, t, i)
          ;((o.descriptor = a),
            this._renderer.pipeline.setRenderTarget(o),
            this._renderer.encoder.beginRenderPass(o),
            this._renderer.encoder.setViewport(n))
        }
        finishRenderPass() {
          this._renderer.encoder.endRenderPass()
        }
        _getGpuColorTexture(e) {
          let t = this._renderTargetSystem.getGpuRenderTarget(e)
          return t.contexts[0]
            ? t.contexts[0].getCurrentTexture()
            : this._renderer.texture.getGpuSource(e.colorTextures[0].source)
        }
        getDescriptor(e, t, i) {
          typeof t == "boolean" && (t = t ? ze.ALL : ze.NONE)
          let n = this._renderTargetSystem,
            s = n.getGpuRenderTarget(e),
            o = e.colorTextures.map((l, c) => {
              let h = s.contexts[c],
                f,
                p
              ;(h
                ? (f = h.getCurrentTexture().createView())
                : (f = this._renderer.texture.getGpuSource(l).createView({ mipLevelCount: 1 })),
                s.msaaTextures[c] &&
                  ((p = f), (f = this._renderer.texture.getTextureView(s.msaaTextures[c]))))
              let m = t & ze.COLOR ? "clear" : "load"
              return (
                i ?? (i = n.defaultClearColor),
                { view: f, resolveTarget: p, clearValue: i, storeOp: "store", loadOp: m }
              )
            }),
            a
          if (
            ((e.stencil || e.depth) &&
              !e.depthStencilTexture &&
              (e.ensureDepthStencilTexture(),
              (e.depthStencilTexture.source.sampleCount = s.msaa ? 4 : 1)),
            e.depthStencilTexture)
          ) {
            let l = t & ze.STENCIL ? "clear" : "load",
              c = t & ze.DEPTH ? "clear" : "load"
            a = {
              view: this._renderer.texture.getGpuSource(e.depthStencilTexture.source).createView(),
              stencilStoreOp: "store",
              stencilLoadOp: l,
              depthClearValue: 1,
              depthLoadOp: c,
              depthStoreOp: "store",
            }
          }
          return { colorAttachments: o, depthStencilAttachment: a }
        }
        clear(e, t = !0, i, n) {
          if (!t) return
          let { gpu: s, encoder: o } = this._renderer,
            a = s.device
          if (o.commandEncoder === null) {
            let l = a.createCommandEncoder(),
              c = this.getDescriptor(e, t, i),
              h = l.beginRenderPass(c)
            ;(h.setViewport(n.x, n.y, n.width, n.height, 0, 1), h.end())
            let f = l.finish()
            a.queue.submit([f])
          } else this.startRenderPass(e, t, i, n)
        }
        initGpuRenderTarget(e) {
          e.isRoot = !0
          let t = new ol()
          return (
            e.colorTextures.forEach((i, n) => {
              if (et.test(i.resource)) {
                let s = i.resource.getContext("webgpu"),
                  o = i.transparent ? "premultiplied" : "opaque"
                try {
                  s.configure({
                    device: this._renderer.gpu.device,
                    usage:
                      GPUTextureUsage.TEXTURE_BINDING |
                      GPUTextureUsage.COPY_DST |
                      GPUTextureUsage.RENDER_ATTACHMENT |
                      GPUTextureUsage.COPY_SRC,
                    format: "bgra8unorm",
                    alphaMode: o,
                  })
                } catch (a) {
                  console.error(a)
                }
                t.contexts[n] = s
              }
              if (((t.msaa = i.source.antialias), i.source.antialias)) {
                let s = new ce({ width: 0, height: 0, sampleCount: 4 })
                t.msaaTextures[n] = s
              }
            }),
            t.msaa &&
              ((t.msaaSamples = 4),
              e.depthStencilTexture && (e.depthStencilTexture.source.sampleCount = 4)),
            t
          )
        }
        destroyGpuRenderTarget(e) {
          ;(e.contexts.forEach((t) => {
            t.unconfigure()
          }),
            e.msaaTextures.forEach((t) => {
              t.destroy()
            }),
            (e.msaaTextures.length = 0),
            (e.contexts.length = 0))
        }
        ensureDepthStencilTexture(e) {
          let t = this._renderTargetSystem.getGpuRenderTarget(e)
          e.depthStencilTexture && t.msaa && (e.depthStencilTexture.source.sampleCount = 4)
        }
        resizeGpuRenderTarget(e) {
          let t = this._renderTargetSystem.getGpuRenderTarget(e)
          ;((t.width = e.width),
            (t.height = e.height),
            t.msaa &&
              e.colorTextures.forEach((i, n) => {
                t.msaaTextures[n]?.resize(i.source.width, i.source.height, i.source._resolution)
              }))
        }
      }
    })
  var xo,
    VS = d(() => {
      D()
      Gf()
      WS()
      xo = class extends En {
        constructor(e) {
          ;(super(e), (this.adaptor = new al()), this.adaptor.init(e, this))
        }
      }
      xo.extension = { type: [_.WebGPUSystem], name: "renderTarget" }
    })
  var _o,
    $S = d(() => {
      D()
      _o = class {
        constructor() {
          this._gpuProgramData = Object.create(null)
        }
        contextChange(e) {
          ;((this._gpu = e), (this.maxTextures = e.device.limits.maxSampledTexturesPerShaderStage))
        }
        getProgramData(e) {
          return this._gpuProgramData[e._layoutKey] || this._createGPUProgramData(e)
        }
        _createGPUProgramData(e) {
          let t = this._gpu.device,
            i = e.gpuLayout.map((s) => t.createBindGroupLayout({ entries: s })),
            n = { bindGroupLayouts: i }
          return (
            (this._gpuProgramData[e._layoutKey] = {
              bindGroups: i,
              pipeline: t.createPipelineLayout(n),
            }),
            this._gpuProgramData[e._layoutKey]
          )
        }
        destroy() {
          ;((this._gpu = null), (this._gpuProgramData = null))
        }
      }
      _o.extension = { type: [_.WebGPUSystem], name: "shader" }
    })
  var ot,
    XS = d(() => {
      "use strict"
      ot = {}
      ot.normal = {
        alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" },
        color: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" },
      }
      ot.add = {
        alpha: { srcFactor: "src-alpha", dstFactor: "one-minus-src-alpha", operation: "add" },
        color: { srcFactor: "one", dstFactor: "one", operation: "add" },
      }
      ot.multiply = {
        alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" },
        color: { srcFactor: "dst", dstFactor: "one-minus-src-alpha", operation: "add" },
      }
      ot.screen = {
        alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" },
        color: { srcFactor: "one", dstFactor: "one-minus-src", operation: "add" },
      }
      ot.overlay = {
        alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" },
        color: { srcFactor: "one", dstFactor: "one-minus-src", operation: "add" },
      }
      ot.none = {
        alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" },
        color: { srcFactor: "zero", dstFactor: "zero", operation: "add" },
      }
      ot["normal-npm"] = {
        alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" },
        color: { srcFactor: "src-alpha", dstFactor: "one-minus-src-alpha", operation: "add" },
      }
      ot["add-npm"] = {
        alpha: { srcFactor: "one", dstFactor: "one", operation: "add" },
        color: { srcFactor: "src-alpha", dstFactor: "one", operation: "add" },
      }
      ot["screen-npm"] = {
        alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" },
        color: { srcFactor: "src-alpha", dstFactor: "one-minus-src", operation: "add" },
      }
      ot.erase = {
        alpha: { srcFactor: "zero", dstFactor: "one-minus-src-alpha", operation: "add" },
        color: { srcFactor: "zero", dstFactor: "one-minus-src", operation: "add" },
      }
      ot.min = {
        alpha: { srcFactor: "one", dstFactor: "one", operation: "min" },
        color: { srcFactor: "one", dstFactor: "one", operation: "min" },
      }
      ot.max = {
        alpha: { srcFactor: "one", dstFactor: "one", operation: "max" },
        color: { srcFactor: "one", dstFactor: "one", operation: "max" },
      }
    })
  var yo,
    YS = d(() => {
      D()
      Ot()
      XS()
      yo = class {
        constructor() {
          ;((this.defaultState = new Fe()), (this.defaultState.blend = !0))
        }
        contextChange(e) {
          this.gpu = e
        }
        getColorTargets(e) {
          return [{ format: "bgra8unorm", writeMask: 0, blend: ot[e.blendMode] || ot.normal }]
        }
        destroy() {
          this.gpu = null
        }
      }
      yo.extension = { type: [_.WebGPUSystem], name: "state" }
    })
  var KS,
    jS = d(() => {
      "use strict"
      KS = {
        type: "image",
        upload(r, e, t) {
          let i = r.resource,
            n = (r.pixelWidth | 0) * (r.pixelHeight | 0),
            s = i.byteLength / n
          t.device.queue.writeTexture(
            { texture: e },
            i,
            { offset: 0, rowsPerImage: r.pixelHeight, bytesPerRow: r.pixelHeight * s },
            { width: r.pixelWidth, height: r.pixelHeight, depthOrArrayLayers: 1 },
          )
        },
      }
    })
  var kf,
    BR,
    qS,
    ZS = d(() => {
      "use strict"
      ;((kf = {
        "bc1-rgba-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
        "bc2-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        "bc3-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        "bc7-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        "etc1-rgb-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
        "etc2-rgba8unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        "astc-4x4-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
      }),
        (BR = { blockBytes: 4, blockWidth: 1, blockHeight: 1 }),
        (qS = {
          type: "compressed",
          upload(r, e, t) {
            let i = r.pixelWidth,
              n = r.pixelHeight,
              s = kf[r.format] || BR
            for (let o = 0; o < r.resource.length; o++) {
              let a = r.resource[o],
                u = Math.ceil(i / s.blockWidth) * s.blockBytes
              ;(t.device.queue.writeTexture(
                { texture: e, mipLevel: o },
                a,
                { offset: 0, bytesPerRow: u },
                {
                  width: Math.ceil(i / s.blockWidth) * s.blockWidth,
                  height: Math.ceil(n / s.blockHeight) * s.blockHeight,
                  depthOrArrayLayers: 1,
                },
              ),
                (i = Math.max(i >> 1, 1)),
                (n = Math.max(n >> 1, 1)))
            }
          },
        }))
    })
  var ul,
    Uf = d(() => {
      "use strict"
      ul = {
        type: "image",
        upload(r, e, t) {
          let i = r.resource
          if (!i) return
          let n = Math.min(e.width, r.resourceWidth || r.pixelWidth),
            s = Math.min(e.height, r.resourceHeight || r.pixelHeight),
            o = r.alphaMode === "premultiply-alpha-on-upload"
          t.device.queue.copyExternalImageToTexture(
            { source: i },
            { texture: e, premultipliedAlpha: o },
            { width: n, height: s },
          )
        },
      }
    })
  var QS,
    JS = d(() => {
      Uf()
      QS = {
        type: "video",
        upload(r, e, t) {
          ul.upload(r, e, t)
        },
      }
    })
  var ll,
    eT = d(() => {
      "use strict"
      ll = class {
        constructor(e) {
          ;((this.device = e),
            (this.sampler = e.createSampler({ minFilter: "linear" })),
            (this.pipelines = {}))
        }
        _getMipmapPipeline(e) {
          let t = this.pipelines[e]
          return (
            t ||
              (this.mipmapShaderModule ||
                (this.mipmapShaderModule = this.device.createShaderModule({
                  code: `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `,
                })),
              (t = this.device.createRenderPipeline({
                layout: "auto",
                vertex: { module: this.mipmapShaderModule, entryPoint: "vertexMain" },
                fragment: {
                  module: this.mipmapShaderModule,
                  entryPoint: "fragmentMain",
                  targets: [{ format: e }],
                },
              })),
              (this.pipelines[e] = t)),
            t
          )
        }
        generateMipmap(e) {
          let t = this._getMipmapPipeline(e.format)
          if (e.dimension === "3d" || e.dimension === "1d")
            throw new Error("Generating mipmaps for non-2d textures is currently unsupported!")
          let i = e,
            n = e.depthOrArrayLayers || 1,
            s = e.usage & GPUTextureUsage.RENDER_ATTACHMENT
          if (!s) {
            let u = {
              size: {
                width: Math.ceil(e.width / 2),
                height: Math.ceil(e.height / 2),
                depthOrArrayLayers: n,
              },
              format: e.format,
              usage:
                GPUTextureUsage.TEXTURE_BINDING |
                GPUTextureUsage.COPY_SRC |
                GPUTextureUsage.RENDER_ATTACHMENT,
              mipLevelCount: e.mipLevelCount - 1,
            }
            i = this.device.createTexture(u)
          }
          let o = this.device.createCommandEncoder({}),
            a = t.getBindGroupLayout(0)
          for (let u = 0; u < n; ++u) {
            let l = e.createView({
                baseMipLevel: 0,
                mipLevelCount: 1,
                dimension: "2d",
                baseArrayLayer: u,
                arrayLayerCount: 1,
              }),
              c = s ? 1 : 0
            for (let h = 1; h < e.mipLevelCount; ++h) {
              let f = i.createView({
                  baseMipLevel: c++,
                  mipLevelCount: 1,
                  dimension: "2d",
                  baseArrayLayer: u,
                  arrayLayerCount: 1,
                }),
                p = o.beginRenderPass({
                  colorAttachments: [
                    {
                      view: f,
                      storeOp: "store",
                      loadOp: "clear",
                      clearValue: { r: 0, g: 0, b: 0, a: 0 },
                    },
                  ],
                }),
                m = this.device.createBindGroup({
                  layout: a,
                  entries: [
                    { binding: 0, resource: this.sampler },
                    { binding: 1, resource: l },
                  ],
                })
              ;(p.setPipeline(t), p.setBindGroup(0, m), p.draw(3, 1, 0, 0), p.end(), (l = f))
            }
          }
          if (!s) {
            let u = {
              width: Math.ceil(e.width / 2),
              height: Math.ceil(e.height / 2),
              depthOrArrayLayers: n,
            }
            for (let l = 1; l < e.mipLevelCount; ++l)
              (o.copyTextureToTexture(
                { texture: i, mipLevel: l - 1 },
                { texture: e, mipLevel: l },
                u,
              ),
                (u.width = Math.ceil(u.width / 2)),
                (u.height = Math.ceil(u.height / 2)))
          }
          return (this.device.queue.submit([o.finish()]), s || i.destroy(), e)
        }
      }
    })
  var bo,
    tT = d(() => {
      Ie()
      D()
      st()
      on()
      Ar()
      jS()
      ZS()
      Uf()
      JS()
      eT()
      bo = class {
        constructor(e) {
          ;((this.managedTextures = []),
            (this._gpuSources = Object.create(null)),
            (this._gpuSamplers = Object.create(null)),
            (this._bindGroupHash = Object.create(null)),
            (this._textureViewHash = Object.create(null)),
            (this._uploads = { image: ul, buffer: KS, video: QS, compressed: qS }),
            (this._renderer = e),
            e.renderableGC.addManagedHash(this, "_gpuSources"),
            e.renderableGC.addManagedHash(this, "_gpuSamplers"),
            e.renderableGC.addManagedHash(this, "_bindGroupHash"),
            e.renderableGC.addManagedHash(this, "_textureViewHash"))
        }
        contextChange(e) {
          this._gpu = e
        }
        initSource(e) {
          if (e.autoGenerateMipmaps) {
            let u = Math.max(e.pixelWidth, e.pixelHeight)
            e.mipLevelCount = Math.floor(Math.log2(u)) + 1
          }
          let t = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
          e.uploadMethodId !== "compressed" &&
            ((t |= GPUTextureUsage.RENDER_ATTACHMENT), (t |= GPUTextureUsage.COPY_SRC))
          let i = kf[e.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 },
            n = Math.ceil(e.pixelWidth / i.blockWidth) * i.blockWidth,
            s = Math.ceil(e.pixelHeight / i.blockHeight) * i.blockHeight,
            o = {
              label: e.label,
              size: { width: n, height: s },
              format: e.format,
              sampleCount: e.sampleCount,
              mipLevelCount: e.mipLevelCount,
              dimension: e.dimension,
              usage: t,
            },
            a = this._gpu.device.createTexture(o)
          return (
            (this._gpuSources[e.uid] = a),
            this.managedTextures.includes(e) ||
              (e.on("update", this.onSourceUpdate, this),
              e.on("resize", this.onSourceResize, this),
              e.on("destroy", this.onSourceDestroy, this),
              e.on("unload", this.onSourceUnload, this),
              e.on("updateMipmaps", this.onUpdateMipmaps, this),
              this.managedTextures.push(e)),
            this.onSourceUpdate(e),
            a
          )
        }
        onSourceUpdate(e) {
          let t = this.getGpuSource(e)
          t &&
            (this._uploads[e.uploadMethodId] &&
              this._uploads[e.uploadMethodId].upload(e, t, this._gpu),
            e.autoGenerateMipmaps && e.mipLevelCount > 1 && this.onUpdateMipmaps(e))
        }
        onSourceUnload(e) {
          let t = this._gpuSources[e.uid]
          t && ((this._gpuSources[e.uid] = null), t.destroy())
        }
        onUpdateMipmaps(e) {
          this._mipmapGenerator || (this._mipmapGenerator = new ll(this._gpu.device))
          let t = this.getGpuSource(e)
          this._mipmapGenerator.generateMipmap(t)
        }
        onSourceDestroy(e) {
          ;(e.off("update", this.onSourceUpdate, this),
            e.off("unload", this.onSourceUnload, this),
            e.off("destroy", this.onSourceDestroy, this),
            e.off("resize", this.onSourceResize, this),
            e.off("updateMipmaps", this.onUpdateMipmaps, this),
            this.managedTextures.splice(this.managedTextures.indexOf(e), 1),
            this.onSourceUnload(e))
        }
        onSourceResize(e) {
          let t = this._gpuSources[e.uid]
          t
            ? (t.width !== e.pixelWidth || t.height !== e.pixelHeight) &&
              ((this._textureViewHash[e.uid] = null),
              (this._bindGroupHash[e.uid] = null),
              this.onSourceUnload(e),
              this.initSource(e))
            : this.initSource(e)
        }
        _initSampler(e) {
          return (
            (this._gpuSamplers[e._resourceId] = this._gpu.device.createSampler(e)),
            this._gpuSamplers[e._resourceId]
          )
        }
        getGpuSampler(e) {
          return this._gpuSamplers[e._resourceId] || this._initSampler(e)
        }
        getGpuSource(e) {
          return this._gpuSources[e.uid] || this.initSource(e)
        }
        getTextureBindGroup(e) {
          return this._bindGroupHash[e.uid] ?? this._createTextureBindGroup(e)
        }
        _createTextureBindGroup(e) {
          let t = e.source
          return (
            (this._bindGroupHash[e.uid] = new He({
              0: t,
              1: t.style,
              2: new fe({
                uTextureMatrix: { type: "mat3x3<f32>", value: e.textureMatrix.mapCoord },
              }),
            })),
            this._bindGroupHash[e.uid]
          )
        }
        getTextureView(e) {
          let t = e.source
          return this._textureViewHash[t.uid] ?? this._createTextureView(t)
        }
        _createTextureView(e) {
          return (
            (this._textureViewHash[e.uid] = this.getGpuSource(e).createView()),
            this._textureViewHash[e.uid]
          )
        }
        generateCanvas(e) {
          let t = this._renderer,
            i = t.gpu.device.createCommandEncoder(),
            n = Z.get().createCanvas()
          ;((n.width = e.source.pixelWidth), (n.height = e.source.pixelHeight))
          let s = n.getContext("webgpu")
          return (
            s.configure({
              device: t.gpu.device,
              usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,
              format: Z.get().getNavigator().gpu.getPreferredCanvasFormat(),
              alphaMode: "premultiplied",
            }),
            i.copyTextureToTexture(
              { texture: t.texture.getGpuSource(e.source), origin: { x: 0, y: 0 } },
              { texture: s.getCurrentTexture() },
              { width: n.width, height: n.height },
            ),
            t.gpu.device.queue.submit([i.finish()]),
            n
          )
        }
        getPixels(e) {
          let t = this.generateCanvas(e),
            i = pt.getOptimalCanvasAndContext(t.width, t.height),
            n = i.context
          n.drawImage(t, 0, 0)
          let { width: s, height: o } = t,
            a = n.getImageData(0, 0, s, o),
            u = new Uint8ClampedArray(a.data.buffer)
          return (pt.returnCanvasAndContext(i), { pixels: u, width: s, height: o })
        }
        destroy() {
          ;(this.managedTextures.slice().forEach((e) => this.onSourceDestroy(e)),
            (this.managedTextures = null))
          for (let e of Object.keys(this._bindGroupHash)) {
            let t = Number(e)
            ;(this._bindGroupHash[t]?.destroy(), (this._bindGroupHash[t] = null))
          }
          ;((this._gpu = null),
            (this._mipmapGenerator = null),
            (this._gpuSources = null),
            (this._bindGroupHash = null),
            (this._textureViewHash = null),
            (this._gpuSamplers = null))
        }
      }
      bo.extension = { type: [_.WebGPUSystem], name: "texture" }
    })
  var sT = {}
  uc(sT, { WebGPURenderer: () => Of })
  var IR,
    GR,
    kR,
    rT,
    iT,
    nT,
    Of,
    oT = d(() => {
      D()
      vv()
      Cv()
      Ev()
      Ls()
      wf()
      Qt()
      SS()
      TS()
      CS()
      ES()
      wS()
      MS()
      IS()
      kS()
      US()
      VS()
      $S()
      YS()
      tT()
      ;((IR = [...el, po, co, Sn, uo, bo, xo, _o, yo, go, lo, ho, ao]),
        (GR = [...tl, mo]),
        (kR = [zs, Hs, Ns]),
        (rT = []),
        (iT = []),
        (nT = []))
      L.handleByNamedList(_.WebGPUSystem, rT)
      L.handleByNamedList(_.WebGPUPipes, iT)
      L.handleByNamedList(_.WebGPUPipesAdaptor, nT)
      L.add(...IR, ...GR, ...kR)
      Of = class extends kr {
        constructor() {
          let e = {
            name: "webgpu",
            type: ke.WEBGPU,
            systems: rT,
            renderPipes: iT,
            renderPipeAdaptors: nT,
          }
          super(e)
        }
      }
    })
  var vo,
    aT = d(() => {
      D()
      se()
      ui()
      Rr()
      gs()
      xs()
      xn()
      Fr()
      cu()
      Ut()
      st()
      vo = class {
        init() {
          let e = new fe({
              uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
              uTransformMatrix: { value: new F(), type: "mat3x3<f32>" },
              uRound: { value: 0, type: "f32" },
            }),
            t = wt(),
            i = jt({ name: "graphics", bits: [ji, Zi(t), gn, Zt] })
          this.shader = new De({
            glProgram: i,
            resources: { localUniforms: e, batchSamplers: Qi(t) },
          })
        }
        execute(e, t) {
          let i = t.context,
            n = i.customShader || this.shader,
            s = e.renderer,
            o = s.graphicsContext,
            { batcher: a, instructions: u } = o.getContextRenderData(i)
          ;((n.groups[0] = s.globalUniforms.bindGroup),
            s.state.set(e.state),
            s.shader.bind(n),
            s.geometry.bind(a.geometry, n.glProgram))
          let l = u.instructions
          for (let c = 0; c < u.instructionSize; c++) {
            let h = l[c]
            if (h.size) {
              for (let f = 0; f < h.textures.count; f++) s.texture.bind(h.textures.textures[f], f)
              s.geometry.draw(h.topology, h.size, h.start)
            }
          }
        }
        destroy() {
          ;(this.shader.destroy(!0), (this.shader = null))
        }
      }
      vo.extension = { type: [_.WebGLPipesAdaptor], name: "graphics" }
    })
  var So,
    uT = d(() => {
      D()
      se()
      Rr()
      xn()
      Fr()
      uf()
      Ut()
      ge()
      be()
      So = class {
        init() {
          let e = jt({ name: "mesh", bits: [gn, Tv, Zt] })
          this._shader = new De({
            glProgram: e,
            resources: {
              uTexture: I.EMPTY.source,
              textureUniforms: { uTextureMatrix: { type: "mat3x3<f32>", value: new F() } },
            },
          })
        }
        execute(e, t) {
          let i = e.renderer,
            n = t._shader
          if (n) {
            if (!n.glProgram) {
              H("Mesh shader has no glProgram", t.shader)
              return
            }
          } else {
            n = this._shader
            let s = t.texture,
              o = s.source
            ;((n.resources.uTexture = o),
              (n.resources.uSampler = o.style),
              (n.resources.textureUniforms.uniforms.uTextureMatrix = s.textureMatrix.mapCoord))
          }
          ;((n.groups[100] = i.globalUniforms.bindGroup),
            (n.groups[101] = e.localUniformsBindGroup),
            i.encoder.draw({ geometry: t._geometry, shader: n, state: t.state }))
        }
        destroy() {
          ;(this._shader.destroy(!0), (this._shader = null))
        }
      }
      So.extension = { type: [_.WebGLPipesAdaptor], name: "mesh" }
    })
  var To,
    lT = d(() => {
      D()
      Ot()
      To = class {
        constructor() {
          ;((this._tempState = Fe.for2d()), (this._didUploadHash = {}))
        }
        init(e) {
          e.renderer.runners.contextChange.add(this)
        }
        contextChange() {
          this._didUploadHash = {}
        }
        start(e, t, i) {
          let n = e.renderer,
            s = this._didUploadHash[i.uid]
          ;(n.shader.bind(i, s),
            s || (this._didUploadHash[i.uid] = !0),
            n.shader.updateUniformGroup(n.globalUniforms.uniformGroup),
            n.geometry.bind(t, i.glProgram))
        }
        execute(e, t) {
          let i = e.renderer
          ;((this._tempState.blendMode = t.blendMode), i.state.set(this._tempState))
          let n = t.textures.textures
          for (let s = 0; s < t.textures.count; s++) i.texture.bind(n[s], s)
          i.geometry.draw(t.topology, t.size, t.start)
        }
      }
      To.extension = { type: [_.WebGLPipesAdaptor], name: "batch" }
    })
  var Co,
    cT = d(() => {
      "use strict"
      Co = ((r) => (
        (r[(r.ELEMENT_ARRAY_BUFFER = 34963)] = "ELEMENT_ARRAY_BUFFER"),
        (r[(r.ARRAY_BUFFER = 34962)] = "ARRAY_BUFFER"),
        (r[(r.UNIFORM_BUFFER = 35345)] = "UNIFORM_BUFFER"),
        r
      ))(Co || {})
    })
  var cl,
    hT = d(() => {
      "use strict"
      cl = class {
        constructor(e, t) {
          ;((this._lastBindBaseLocation = -1),
            (this._lastBindCallId = -1),
            (this.buffer = e || null),
            (this.updateID = -1),
            (this.byteLength = -1),
            (this.type = t))
        }
      }
    })
  var Eo,
    dT = d(() => {
      D()
      hr()
      cT()
      hT()
      Eo = class {
        constructor(e) {
          ;((this._gpuBuffers = Object.create(null)),
            (this._boundBufferBases = Object.create(null)),
            (this._minBaseLocation = 0),
            (this._nextBindBaseIndex = this._minBaseLocation),
            (this._bindCallId = 0),
            (this._renderer = e),
            this._renderer.renderableGC.addManagedHash(this, "_gpuBuffers"))
        }
        destroy() {
          ;((this._renderer = null),
            (this._gl = null),
            (this._gpuBuffers = null),
            (this._boundBufferBases = null))
        }
        contextChange() {
          let e = (this._gl = this._renderer.gl)
          ;((this._gpuBuffers = Object.create(null)),
            (this._maxBindings = e.MAX_UNIFORM_BUFFER_BINDINGS
              ? e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS)
              : 0))
        }
        getGlBuffer(e) {
          return this._gpuBuffers[e.uid] || this.createGLBuffer(e)
        }
        bind(e) {
          let { _gl: t } = this,
            i = this.getGlBuffer(e)
          t.bindBuffer(i.type, i.buffer)
        }
        bindBufferBase(e, t) {
          let { _gl: i } = this
          this._boundBufferBases[t] !== e &&
            ((this._boundBufferBases[t] = e),
            (e._lastBindBaseLocation = t),
            i.bindBufferBase(i.UNIFORM_BUFFER, t, e.buffer))
        }
        nextBindBase(e) {
          ;(this._bindCallId++,
            (this._minBaseLocation = 0),
            e &&
              ((this._boundBufferBases[0] = null),
              (this._minBaseLocation = 1),
              this._nextBindBaseIndex < 1 && (this._nextBindBaseIndex = 1)))
        }
        freeLocationForBufferBase(e) {
          let t = this.getLastBindBaseLocation(e)
          if (t >= this._minBaseLocation) return ((e._lastBindCallId = this._bindCallId), t)
          let i = 0,
            n = this._nextBindBaseIndex
          for (; i < 2; ) {
            n >= this._maxBindings && ((n = this._minBaseLocation), i++)
            let s = this._boundBufferBases[n]
            if (s && s._lastBindCallId === this._bindCallId) {
              n++
              continue
            }
            break
          }
          return (
            (t = n),
            (this._nextBindBaseIndex = n + 1),
            i >= 2
              ? -1
              : ((e._lastBindCallId = this._bindCallId), (this._boundBufferBases[t] = null), t)
          )
        }
        getLastBindBaseLocation(e) {
          let t = e._lastBindBaseLocation
          return this._boundBufferBases[t] === e ? t : -1
        }
        bindBufferRange(e, t, i, n) {
          let { _gl: s } = this
          ;(i || (i = 0),
            t || (t = 0),
            (this._boundBufferBases[t] = null),
            s.bindBufferRange(s.UNIFORM_BUFFER, t || 0, e.buffer, i * 256, n || 256))
        }
        updateBuffer(e) {
          let { _gl: t } = this,
            i = this.getGlBuffer(e)
          if (e._updateID === i.updateID) return i
          ;((i.updateID = e._updateID), t.bindBuffer(i.type, i.buffer))
          let n = e.data,
            s = e.descriptor.usage & Q.STATIC ? t.STATIC_DRAW : t.DYNAMIC_DRAW
          return (
            n
              ? i.byteLength >= n.byteLength
                ? t.bufferSubData(i.type, 0, n, 0, e._updateSize / n.BYTES_PER_ELEMENT)
                : ((i.byteLength = n.byteLength), t.bufferData(i.type, n, s))
              : ((i.byteLength = e.descriptor.size), t.bufferData(i.type, i.byteLength, s)),
            i
          )
        }
        destroyAll() {
          let e = this._gl
          for (let t in this._gpuBuffers) e.deleteBuffer(this._gpuBuffers[t].buffer)
          this._gpuBuffers = Object.create(null)
        }
        onBufferDestroy(e, t) {
          let i = this._gpuBuffers[e.uid],
            n = this._gl
          ;(t || n.deleteBuffer(i.buffer), (this._gpuBuffers[e.uid] = null))
        }
        createGLBuffer(e) {
          let { _gl: t } = this,
            i = Co.ARRAY_BUFFER
          e.descriptor.usage & Q.INDEX
            ? (i = Co.ELEMENT_ARRAY_BUFFER)
            : e.descriptor.usage & Q.UNIFORM && (i = Co.UNIFORM_BUFFER)
          let n = new cl(t.createBuffer(), i)
          return ((this._gpuBuffers[e.uid] = n), e.on("destroy", this.onBufferDestroy, this), n)
        }
        resetState() {
          this._boundBufferBases = Object.create(null)
        }
      }
      Eo.extension = { type: [_.WebGLSystem], name: "buffer" }
    })
  var Lf,
    pT,
    mT = d(() => {
      Ie()
      D()
      be()
      Lf = class fT {
        constructor(e) {
          ;((this.supports = {
            uint32Indices: !0,
            uniformBufferObject: !0,
            vertexArrayObject: !0,
            srgbTextures: !0,
            nonPowOf2wrapping: !0,
            msaa: !0,
            nonPowOf2mipmaps: !0,
          }),
            (this._renderer = e),
            (this.extensions = Object.create(null)),
            (this.handleContextLost = this.handleContextLost.bind(this)),
            (this.handleContextRestored = this.handleContextRestored.bind(this)))
        }
        get isLost() {
          return !this.gl || this.gl.isContextLost()
        }
        contextChange(e) {
          ;((this.gl = e), (this._renderer.gl = e))
        }
        init(e) {
          e = { ...fT.defaultOptions, ...e }
          let t = (this.multiView = e.multiView)
          if (
            (e.context &&
              t &&
              (H(
                "Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together.",
              ),
              (t = !1)),
            t
              ? (this.canvas = Z.get().createCanvas(
                  this._renderer.canvas.width,
                  this._renderer.canvas.height,
                ))
              : (this.canvas = this._renderer.view.canvas),
            e.context)
          )
            this.initFromContext(e.context)
          else {
            let i = this._renderer.background.alpha < 1,
              n = e.premultipliedAlpha ?? !0,
              s = e.antialias && !this._renderer.backBuffer.useBackBuffer
            this.createContext(e.preferWebGLVersion, {
              alpha: i,
              premultipliedAlpha: n,
              antialias: s,
              stencil: !0,
              preserveDrawingBuffer: e.preserveDrawingBuffer,
              powerPreference: e.powerPreference ?? "default",
            })
          }
        }
        ensureCanvasSize(e) {
          if (!this.multiView) {
            e !== this.canvas && H("multiView is disabled, but targetCanvas is not the main canvas")
            return
          }
          let { canvas: t } = this
          ;(t.width < e.width || t.height < e.height) &&
            ((t.width = Math.max(e.width, e.width)), (t.height = Math.max(e.height, e.height)))
        }
        initFromContext(e) {
          ;((this.gl = e),
            (this.webGLVersion = e instanceof Z.get().getWebGLRenderingContext() ? 1 : 2),
            this.getExtensions(),
            this.validateContext(e),
            this._renderer.runners.contextChange.emit(e))
          let t = this._renderer.view.canvas
          ;(t.addEventListener("webglcontextlost", this.handleContextLost, !1),
            t.addEventListener("webglcontextrestored", this.handleContextRestored, !1))
        }
        createContext(e, t) {
          let i,
            n = this.canvas
          if (
            (e === 2 && (i = n.getContext("webgl2", t)), !i && ((i = n.getContext("webgl", t)), !i))
          )
            throw new Error("This browser does not support WebGL. Try using the canvas renderer")
          ;((this.gl = i), this.initFromContext(this.gl))
        }
        getExtensions() {
          let { gl: e } = this,
            t = {
              anisotropicFiltering: e.getExtension("EXT_texture_filter_anisotropic"),
              floatTextureLinear: e.getExtension("OES_texture_float_linear"),
              s3tc: e.getExtension("WEBGL_compressed_texture_s3tc"),
              s3tc_sRGB: e.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
              etc: e.getExtension("WEBGL_compressed_texture_etc"),
              etc1: e.getExtension("WEBGL_compressed_texture_etc1"),
              pvrtc:
                e.getExtension("WEBGL_compressed_texture_pvrtc") ||
                e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
              atc: e.getExtension("WEBGL_compressed_texture_atc"),
              astc: e.getExtension("WEBGL_compressed_texture_astc"),
              bptc: e.getExtension("EXT_texture_compression_bptc"),
              rgtc: e.getExtension("EXT_texture_compression_rgtc"),
              loseContext: e.getExtension("WEBGL_lose_context"),
            }
          if (this.webGLVersion === 1)
            this.extensions = {
              ...t,
              drawBuffers: e.getExtension("WEBGL_draw_buffers"),
              depthTexture: e.getExtension("WEBGL_depth_texture"),
              vertexArrayObject:
                e.getExtension("OES_vertex_array_object") ||
                e.getExtension("MOZ_OES_vertex_array_object") ||
                e.getExtension("WEBKIT_OES_vertex_array_object"),
              uint32ElementIndex: e.getExtension("OES_element_index_uint"),
              floatTexture: e.getExtension("OES_texture_float"),
              floatTextureLinear: e.getExtension("OES_texture_float_linear"),
              textureHalfFloat: e.getExtension("OES_texture_half_float"),
              textureHalfFloatLinear: e.getExtension("OES_texture_half_float_linear"),
              vertexAttribDivisorANGLE: e.getExtension("ANGLE_instanced_arrays"),
              srgb: e.getExtension("EXT_sRGB"),
            }
          else {
            this.extensions = { ...t, colorBufferFloat: e.getExtension("EXT_color_buffer_float") }
            let i = e.getExtension("WEBGL_provoking_vertex")
            i && i.provokingVertexWEBGL(i.FIRST_VERTEX_CONVENTION_WEBGL)
          }
        }
        handleContextLost(e) {
          ;(e.preventDefault(),
            this._contextLossForced &&
              ((this._contextLossForced = !1),
              setTimeout(() => {
                this.gl.isContextLost() && this.extensions.loseContext?.restoreContext()
              }, 0)))
        }
        handleContextRestored() {
          ;(this.getExtensions(), this._renderer.runners.contextChange.emit(this.gl))
        }
        destroy() {
          let e = this._renderer.view.canvas
          ;((this._renderer = null),
            e.removeEventListener("webglcontextlost", this.handleContextLost),
            e.removeEventListener("webglcontextrestored", this.handleContextRestored),
            this.gl.useProgram(null),
            this.extensions.loseContext?.loseContext())
        }
        forceContextLoss() {
          ;(this.extensions.loseContext?.loseContext(), (this._contextLossForced = !0))
        }
        validateContext(e) {
          let t = e.getContextAttributes()
          t &&
            !t.stencil &&
            H(
              "Provided WebGL context does not have a stencil buffer, masks may not render correctly",
            )
          let i = this.supports,
            n = this.webGLVersion === 2,
            s = this.extensions
          ;((i.uint32Indices = n || !!s.uint32ElementIndex),
            (i.uniformBufferObject = n),
            (i.vertexArrayObject = n || !!s.vertexArrayObject),
            (i.srgbTextures = n || !!s.srgb),
            (i.nonPowOf2wrapping = n),
            (i.nonPowOf2mipmaps = n),
            (i.msaa = n),
            i.uint32Indices ||
              H(
                "Provided WebGL context does not support 32 index buffer, large scenes may not render correctly",
              ))
        }
      }
      Lf.extension = { type: [_.WebGLSystem], name: "context" }
      Lf.defaultOptions = {
        context: null,
        premultipliedAlpha: !0,
        preserveDrawingBuffer: !1,
        powerPreference: void 0,
        preferWebGLVersion: 2,
        multiView: !1,
      }
      pT = Lf
    })
  var hl,
    Nf,
    ue,
    Hf = d(() => {
      "use strict"
      ;((hl = ((r) => (
        (r[(r.RGBA = 6408)] = "RGBA"),
        (r[(r.RGB = 6407)] = "RGB"),
        (r[(r.RG = 33319)] = "RG"),
        (r[(r.RED = 6403)] = "RED"),
        (r[(r.RGBA_INTEGER = 36249)] = "RGBA_INTEGER"),
        (r[(r.RGB_INTEGER = 36248)] = "RGB_INTEGER"),
        (r[(r.RG_INTEGER = 33320)] = "RG_INTEGER"),
        (r[(r.RED_INTEGER = 36244)] = "RED_INTEGER"),
        (r[(r.ALPHA = 6406)] = "ALPHA"),
        (r[(r.LUMINANCE = 6409)] = "LUMINANCE"),
        (r[(r.LUMINANCE_ALPHA = 6410)] = "LUMINANCE_ALPHA"),
        (r[(r.DEPTH_COMPONENT = 6402)] = "DEPTH_COMPONENT"),
        (r[(r.DEPTH_STENCIL = 34041)] = "DEPTH_STENCIL"),
        r
      ))(hl || {})),
        (Nf = ((r) => (
          (r[(r.TEXTURE_2D = 3553)] = "TEXTURE_2D"),
          (r[(r.TEXTURE_CUBE_MAP = 34067)] = "TEXTURE_CUBE_MAP"),
          (r[(r.TEXTURE_2D_ARRAY = 35866)] = "TEXTURE_2D_ARRAY"),
          (r[(r.TEXTURE_CUBE_MAP_POSITIVE_X = 34069)] = "TEXTURE_CUBE_MAP_POSITIVE_X"),
          (r[(r.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070)] = "TEXTURE_CUBE_MAP_NEGATIVE_X"),
          (r[(r.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071)] = "TEXTURE_CUBE_MAP_POSITIVE_Y"),
          (r[(r.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072)] = "TEXTURE_CUBE_MAP_NEGATIVE_Y"),
          (r[(r.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073)] = "TEXTURE_CUBE_MAP_POSITIVE_Z"),
          (r[(r.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074)] = "TEXTURE_CUBE_MAP_NEGATIVE_Z"),
          r
        ))(Nf || {})),
        (ue = ((r) => (
          (r[(r.UNSIGNED_BYTE = 5121)] = "UNSIGNED_BYTE"),
          (r[(r.UNSIGNED_SHORT = 5123)] = "UNSIGNED_SHORT"),
          (r[(r.UNSIGNED_SHORT_5_6_5 = 33635)] = "UNSIGNED_SHORT_5_6_5"),
          (r[(r.UNSIGNED_SHORT_4_4_4_4 = 32819)] = "UNSIGNED_SHORT_4_4_4_4"),
          (r[(r.UNSIGNED_SHORT_5_5_5_1 = 32820)] = "UNSIGNED_SHORT_5_5_5_1"),
          (r[(r.UNSIGNED_INT = 5125)] = "UNSIGNED_INT"),
          (r[(r.UNSIGNED_INT_10F_11F_11F_REV = 35899)] = "UNSIGNED_INT_10F_11F_11F_REV"),
          (r[(r.UNSIGNED_INT_2_10_10_10_REV = 33640)] = "UNSIGNED_INT_2_10_10_10_REV"),
          (r[(r.UNSIGNED_INT_24_8 = 34042)] = "UNSIGNED_INT_24_8"),
          (r[(r.UNSIGNED_INT_5_9_9_9_REV = 35902)] = "UNSIGNED_INT_5_9_9_9_REV"),
          (r[(r.BYTE = 5120)] = "BYTE"),
          (r[(r.SHORT = 5122)] = "SHORT"),
          (r[(r.INT = 5124)] = "INT"),
          (r[(r.FLOAT = 5126)] = "FLOAT"),
          (r[(r.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269)] = "FLOAT_32_UNSIGNED_INT_24_8_REV"),
          (r[(r.HALF_FLOAT = 36193)] = "HALF_FLOAT"),
          r
        ))(ue || {})))
    })
  function xT(r) {
    return gT[r] ?? gT.float32
  }
  var gT,
    _T = d(() => {
      Hf()
      gT = {
        uint8x2: ue.UNSIGNED_BYTE,
        uint8x4: ue.UNSIGNED_BYTE,
        sint8x2: ue.BYTE,
        sint8x4: ue.BYTE,
        unorm8x2: ue.UNSIGNED_BYTE,
        unorm8x4: ue.UNSIGNED_BYTE,
        snorm8x2: ue.BYTE,
        snorm8x4: ue.BYTE,
        uint16x2: ue.UNSIGNED_SHORT,
        uint16x4: ue.UNSIGNED_SHORT,
        sint16x2: ue.SHORT,
        sint16x4: ue.SHORT,
        unorm16x2: ue.UNSIGNED_SHORT,
        unorm16x4: ue.UNSIGNED_SHORT,
        snorm16x2: ue.SHORT,
        snorm16x4: ue.SHORT,
        float16x2: ue.HALF_FLOAT,
        float16x4: ue.HALF_FLOAT,
        float32: ue.FLOAT,
        float32x2: ue.FLOAT,
        float32x3: ue.FLOAT,
        float32x4: ue.FLOAT,
        uint32: ue.UNSIGNED_INT,
        uint32x2: ue.UNSIGNED_INT,
        uint32x3: ue.UNSIGNED_INT,
        uint32x4: ue.UNSIGNED_INT,
        sint32: ue.INT,
        sint32x2: ue.INT,
        sint32x3: ue.INT,
        sint32x4: ue.INT,
      }
    })
  var UR,
    wo,
    yT = d(() => {
      D()
      hi()
      Bf()
      _T()
      ;((UR = {
        "point-list": 0,
        "line-list": 1,
        "line-strip": 3,
        "triangle-list": 4,
        "triangle-strip": 5,
      }),
        (wo = class {
          constructor(e) {
            ;((this._geometryVaoHash = Object.create(null)),
              (this._renderer = e),
              (this._activeGeometry = null),
              (this._activeVao = null),
              (this.hasVao = !0),
              (this.hasInstance = !0),
              this._renderer.renderableGC.addManagedHash(this, "_geometryVaoHash"))
          }
          contextChange() {
            let e = (this.gl = this._renderer.gl)
            if (!this._renderer.context.supports.vertexArrayObject)
              throw new Error("[PixiJS] Vertex Array Objects are not supported on this device")
            let t = this._renderer.context.extensions.vertexArrayObject
            t &&
              ((e.createVertexArray = () => t.createVertexArrayOES()),
              (e.bindVertexArray = (n) => t.bindVertexArrayOES(n)),
              (e.deleteVertexArray = (n) => t.deleteVertexArrayOES(n)))
            let i = this._renderer.context.extensions.vertexAttribDivisorANGLE
            ;(i &&
              ((e.drawArraysInstanced = (n, s, o, a) => {
                i.drawArraysInstancedANGLE(n, s, o, a)
              }),
              (e.drawElementsInstanced = (n, s, o, a, u) => {
                i.drawElementsInstancedANGLE(n, s, o, a, u)
              }),
              (e.vertexAttribDivisor = (n, s) => i.vertexAttribDivisorANGLE(n, s))),
              (this._activeGeometry = null),
              (this._activeVao = null),
              (this._geometryVaoHash = Object.create(null)))
          }
          bind(e, t) {
            let i = this.gl
            this._activeGeometry = e
            let n = this.getVao(e, t)
            ;(this._activeVao !== n && ((this._activeVao = n), i.bindVertexArray(n)),
              this.updateBuffers())
          }
          resetState() {
            this.unbind()
          }
          updateBuffers() {
            let e = this._activeGeometry,
              t = this._renderer.buffer
            for (let i = 0; i < e.buffers.length; i++) {
              let n = e.buffers[i]
              t.updateBuffer(n)
            }
          }
          checkCompatibility(e, t) {
            let i = e.attributes,
              n = t._attributeData
            for (let s in n)
              if (!i[s])
                throw new Error(
                  `shader and geometry incompatible, geometry missing the "${s}" attribute`,
                )
          }
          getSignature(e, t) {
            let i = e.attributes,
              n = t._attributeData,
              s = ["g", e.uid]
            for (let o in i) n[o] && s.push(o, n[o].location)
            return s.join("-")
          }
          getVao(e, t) {
            return this._geometryVaoHash[e.uid]?.[t._key] || this.initGeometryVao(e, t)
          }
          initGeometryVao(e, t, i = !0) {
            let n = this._renderer.gl,
              s = this._renderer.buffer
            ;(this._renderer.shader._getProgramData(t), this.checkCompatibility(e, t))
            let o = this.getSignature(e, t)
            this._geometryVaoHash[e.uid] ||
              ((this._geometryVaoHash[e.uid] = Object.create(null)),
              e.on("destroy", this.onGeometryDestroy, this))
            let a = this._geometryVaoHash[e.uid],
              u = a[o]
            if (u) return ((a[t._key] = u), u)
            sl(e, t._attributeData)
            let l = e.buffers
            ;((u = n.createVertexArray()), n.bindVertexArray(u))
            for (let c = 0; c < l.length; c++) {
              let h = l[c]
              s.bind(h)
            }
            return (this.activateVao(e, t), (a[t._key] = u), (a[o] = u), n.bindVertexArray(null), u)
          }
          onGeometryDestroy(e, t) {
            let i = this._geometryVaoHash[e.uid],
              n = this.gl
            if (i) {
              if (t)
                for (let s in i)
                  (this._activeVao !== i[s] && this.unbind(), n.deleteVertexArray(i[s]))
              this._geometryVaoHash[e.uid] = null
            }
          }
          destroyAll(e = !1) {
            let t = this.gl
            for (let i in this._geometryVaoHash) {
              if (e)
                for (let n in this._geometryVaoHash[i]) {
                  let s = this._geometryVaoHash[i]
                  ;(this._activeVao !== s && this.unbind(), t.deleteVertexArray(s[n]))
                }
              this._geometryVaoHash[i] = null
            }
          }
          activateVao(e, t) {
            let i = this._renderer.gl,
              n = this._renderer.buffer,
              s = e.attributes
            e.indexBuffer && n.bind(e.indexBuffer)
            let o = null
            for (let a in s) {
              let u = s[a],
                l = u.buffer,
                c = n.getGlBuffer(l),
                h = t._attributeData[a]
              if (h) {
                o !== c && (n.bind(l), (o = c))
                let f = h.location
                i.enableVertexAttribArray(f)
                let p = dt(u.format),
                  m = xT(u.format)
                if (
                  (h.format?.substring(1, 4) === "int"
                    ? i.vertexAttribIPointer(f, p.size, m, u.stride, u.offset)
                    : i.vertexAttribPointer(f, p.size, m, p.normalised, u.stride, u.offset),
                  u.instance)
                )
                  if (this.hasInstance) {
                    let g = u.divisor ?? 1
                    i.vertexAttribDivisor(f, g)
                  } else
                    throw new Error(
                      "geometry error, GPU Instancing is not supported on this device",
                    )
              }
            }
          }
          draw(e, t, i, n) {
            let { gl: s } = this._renderer,
              o = this._activeGeometry,
              a = UR[e || o.topology]
            if ((n ?? (n = o.instanceCount), o.indexBuffer)) {
              let u = o.indexBuffer.data.BYTES_PER_ELEMENT,
                l = u === 2 ? s.UNSIGNED_SHORT : s.UNSIGNED_INT
              n > 1
                ? s.drawElementsInstanced(a, t || o.indexBuffer.data.length, l, (i || 0) * u, n)
                : s.drawElements(a, t || o.indexBuffer.data.length, l, (i || 0) * u)
            } else
              n > 1
                ? s.drawArraysInstanced(a, i || 0, t || o.getSize(), n)
                : s.drawArrays(a, i || 0, t || o.getSize())
            return this
          }
          unbind() {
            ;(this.gl.bindVertexArray(null),
              (this._activeVao = null),
              (this._activeGeometry = null))
          }
          destroy() {
            ;((this._renderer = null),
              (this.gl = null),
              (this._activeVao = null),
              (this._activeGeometry = null))
          }
        }))
      wo.extension = { type: [_.WebGLSystem], name: "geometry" }
    })
  var OR,
    zf,
    vT,
    ST = d(() => {
      D()
      be()
      $i()
      Ut()
      Ot()
      ct()
      ge()
      ci()
      ;((OR = new Mt({ attributes: { aPosition: [-1, -1, 3, -1, -1, 3] } })),
        (zf = class bT {
          constructor(e) {
            ;((this.useBackBuffer = !1), (this._useBackBufferThisRender = !1), (this._renderer = e))
          }
          init(e = {}) {
            let { useBackBuffer: t, antialias: i } = { ...bT.defaultOptions, ...e }
            ;((this.useBackBuffer = t),
              (this._antialias = i),
              this._renderer.context.supports.msaa ||
                (H("antialiasing, is not supported on when using the back buffer"),
                (this._antialias = !1)),
              (this._state = Fe.for2d()))
            let n = new At({
              vertex: `
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`,
              fragment: `
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`,
              name: "big-triangle",
            })
            this._bigTriangleShader = new De({
              glProgram: n,
              resources: { uTexture: I.WHITE.source },
            })
          }
          renderStart(e) {
            let t = this._renderer.renderTarget.getRenderTarget(e.target)
            if (
              ((this._useBackBufferThisRender = this.useBackBuffer && !!t.isRoot),
              this._useBackBufferThisRender)
            ) {
              let i = this._renderer.renderTarget.getRenderTarget(e.target)
              ;((this._targetTexture = i.colorTexture),
                (e.target = this._getBackBufferTexture(i.colorTexture)))
            }
          }
          renderEnd() {
            this._presentBackBuffer()
          }
          _presentBackBuffer() {
            let e = this._renderer
            ;(e.renderTarget.finishRenderPass(),
              this._useBackBufferThisRender &&
                (e.renderTarget.bind(this._targetTexture, !1),
                (this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source),
                e.encoder.draw({
                  geometry: OR,
                  shader: this._bigTriangleShader,
                  state: this._state,
                })))
          }
          _getBackBufferTexture(e) {
            return (
              (this._backBufferTexture =
                this._backBufferTexture ||
                new I({
                  source: new ce({
                    width: e.width,
                    height: e.height,
                    resolution: e._resolution,
                    antialias: this._antialias,
                  }),
                })),
              this._backBufferTexture.source.resize(e.width, e.height, e._resolution),
              this._backBufferTexture
            )
          }
          destroy() {
            this._backBufferTexture &&
              (this._backBufferTexture.destroy(), (this._backBufferTexture = null))
          }
        }))
      zf.extension = { type: [_.WebGLSystem], name: "backBuffer", priority: 1 }
      zf.defaultOptions = { useBackBuffer: !1 }
      vT = zf
    })
  var Mo,
    TT = d(() => {
      D()
      Mo = class {
        constructor(e) {
          ;((this._colorMaskCache = 15), (this._renderer = e))
        }
        setMask(e) {
          this._colorMaskCache !== e &&
            ((this._colorMaskCache = e),
            this._renderer.gl.colorMask(!!(e & 8), !!(e & 4), !!(e & 2), !!(e & 1)))
        }
      }
      Mo.extension = { type: [_.WebGLSystem], name: "colorMask" }
    })
  var Ao,
    CT = d(() => {
      D()
      Ao = class {
        constructor(e) {
          ;((this.commandFinished = Promise.resolve()), (this._renderer = e))
        }
        setGeometry(e, t) {
          this._renderer.geometry.bind(e, t.glProgram)
        }
        finishRenderPass() {}
        draw(e) {
          let t = this._renderer,
            {
              geometry: i,
              shader: n,
              state: s,
              skipSync: o,
              topology: a,
              size: u,
              start: l,
              instanceCount: c,
            } = e
          ;(t.shader.bind(n, o),
            t.geometry.bind(i, t.shader._activeProgram),
            s && t.state.set(s),
            t.geometry.draw(a, u, l, c ?? i.instanceCount))
        }
        destroy() {
          this._renderer = null
        }
      }
      Ao.extension = { type: [_.WebGLSystem], name: "encoder" }
    })
  var Do,
    ET = d(() => {
      D()
      If()
      li()
      Do = class {
        constructor(e) {
          ;((this._stencilCache = { enabled: !1, stencilReference: 0, stencilMode: ye.NONE }),
            (this._renderTargetStencilState = Object.create(null)),
            e.renderTarget.onRenderTargetChange.add(this))
        }
        contextChange(e) {
          ;((this._gl = e),
            (this._comparisonFuncMapping = {
              always: e.ALWAYS,
              never: e.NEVER,
              equal: e.EQUAL,
              "not-equal": e.NOTEQUAL,
              less: e.LESS,
              "less-equal": e.LEQUAL,
              greater: e.GREATER,
              "greater-equal": e.GEQUAL,
            }),
            (this._stencilOpsMapping = {
              keep: e.KEEP,
              zero: e.ZERO,
              replace: e.REPLACE,
              invert: e.INVERT,
              "increment-clamp": e.INCR,
              "decrement-clamp": e.DECR,
              "increment-wrap": e.INCR_WRAP,
              "decrement-wrap": e.DECR_WRAP,
            }),
            this.resetState())
        }
        onRenderTargetChange(e) {
          if (this._activeRenderTarget === e) return
          this._activeRenderTarget = e
          let t = this._renderTargetStencilState[e.uid]
          ;(t ||
            (t = this._renderTargetStencilState[e.uid] =
              { stencilMode: ye.DISABLED, stencilReference: 0 }),
            this.setStencilMode(t.stencilMode, t.stencilReference))
        }
        resetState() {
          ;((this._stencilCache.enabled = !1),
            (this._stencilCache.stencilMode = ye.NONE),
            (this._stencilCache.stencilReference = 0))
        }
        setStencilMode(e, t) {
          let i = this._renderTargetStencilState[this._activeRenderTarget.uid],
            n = this._gl,
            s = rr[e],
            o = this._stencilCache
          if (((i.stencilMode = e), (i.stencilReference = t), e === ye.DISABLED)) {
            this._stencilCache.enabled &&
              ((this._stencilCache.enabled = !1), n.disable(n.STENCIL_TEST))
            return
          }
          ;(this._stencilCache.enabled ||
            ((this._stencilCache.enabled = !0), n.enable(n.STENCIL_TEST)),
            (e !== o.stencilMode || o.stencilReference !== t) &&
              ((o.stencilMode = e),
              (o.stencilReference = t),
              n.stencilFunc(this._comparisonFuncMapping[s.stencilBack.compare], t, 255),
              n.stencilOp(n.KEEP, n.KEEP, this._stencilOpsMapping[s.stencilBack.passOp])))
        }
      }
      Do.extension = { type: [_.WebGLSystem], name: "stencil" }
    })
  function wT(r) {
    let e = r.map((s) => ({ data: s, offset: 0, size: 0 })),
      t = 16,
      i = 0,
      n = 0
    for (let s = 0; s < e.length; s++) {
      let o = e[s]
      if (((i = Wf[o.data.type]), !i)) throw new Error(`Unknown type ${o.data.type}`)
      o.data.size > 1 && (i = Math.max(i, t) * o.data.size)
      let a = i === 12 ? 16 : i
      o.size = i
      let u = n % t
      ;(u > 0 && t - u < a ? (n += (t - u) % 16) : (n += (i - (u % i)) % i),
        (o.offset = n),
        (n += i))
    }
    return ((n = Math.ceil(n / 16) * 16), { uboElements: e, size: n })
  }
  var Wf,
    Vf = d(() => {
      "use strict"
      Wf = {
        f32: 4,
        i32: 4,
        "vec2<f32>": 8,
        "vec3<f32>": 12,
        "vec4<f32>": 16,
        "vec2<i32>": 8,
        "vec3<i32>": 12,
        "vec4<i32>": 16,
        "mat2x2<f32>": 32,
        "mat3x3<f32>": 48,
        "mat4x4<f32>": 64,
      }
    })
  function MT(r, e) {
    let t = Math.max(Wf[r.data.type] / 16, 1),
      i = r.data.value.length / r.data.size,
      n = (4 - (i % 4)) % 4,
      s = r.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data"
    return `
        v = uv.${r.data.name};
        offset += ${e};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${r.data.size * t}; i++)
        {
            for(var j = 0; j < ${i}; j++)
            {
                ${s}[arrayOffset++] = v[t++];
            }
            ${n !== 0 ? `arrayOffset += ${n};` : ""}
        }
    `
  }
  var AT = d(() => {
    Vf()
  })
  function DT(r) {
    return rl(r, "uboStd40", MT, Rf)
  }
  var PT = d(() => {
    Pf()
    Ff()
    AT()
  })
  var Po,
    RT = d(() => {
      D()
      Mf()
      Vf()
      PT()
      Po = class extends Tn {
        constructor() {
          super({ createUboElements: wT, generateUboSync: DT })
        }
      }
      Po.extension = { type: [_.WebGLSystem], name: "ubo" }
    })
  var dl,
    FT = d(() => {
      "use strict"
      dl = class {
        constructor() {
          ;((this.width = -1), (this.height = -1), (this.msaa = !1), (this.msaaRenderBuffer = []))
        }
      }
    })
  var fl,
    BT = d(() => {
      Ke()
      be()
      zi()
      _n()
      FT()
      fl = class {
        constructor() {
          ;((this._clearColorCache = [0, 0, 0, 0]), (this._viewPortCache = new ee()))
        }
        init(e, t) {
          ;((this._renderer = e), (this._renderTargetSystem = t), e.runners.contextChange.add(this))
        }
        contextChange() {
          ;((this._clearColorCache = [0, 0, 0, 0]), (this._viewPortCache = new ee()))
        }
        copyToTexture(e, t, i, n, s) {
          let o = this._renderTargetSystem,
            a = this._renderer,
            u = o.getGpuRenderTarget(e),
            l = a.gl
          return (
            this.finishRenderPass(e),
            l.bindFramebuffer(l.FRAMEBUFFER, u.resolveTargetFramebuffer),
            a.texture.bind(t, 0),
            l.copyTexSubImage2D(l.TEXTURE_2D, 0, s.x, s.y, i.x, i.y, n.width, n.height),
            t
          )
        }
        startRenderPass(e, t = !0, i, n) {
          let s = this._renderTargetSystem,
            o = e.colorTexture,
            a = s.getGpuRenderTarget(e),
            u = n.y
          ;(e.isRoot && (u = o.pixelHeight - n.height),
            e.colorTextures.forEach((h) => {
              this._renderer.texture.unbind(h)
            }))
          let l = this._renderer.gl
          l.bindFramebuffer(l.FRAMEBUFFER, a.framebuffer)
          let c = this._viewPortCache
          ;((c.x !== n.x || c.y !== u || c.width !== n.width || c.height !== n.height) &&
            ((c.x = n.x),
            (c.y = u),
            (c.width = n.width),
            (c.height = n.height),
            l.viewport(n.x, u, n.width, n.height)),
            !a.depthStencilRenderBuffer && (e.stencil || e.depth) && this._initStencil(a),
            this.clear(e, t, i))
        }
        finishRenderPass(e) {
          let i = this._renderTargetSystem.getGpuRenderTarget(e)
          if (!i.msaa) return
          let n = this._renderer.gl
          ;(n.bindFramebuffer(n.FRAMEBUFFER, i.resolveTargetFramebuffer),
            n.bindFramebuffer(n.READ_FRAMEBUFFER, i.framebuffer),
            n.blitFramebuffer(
              0,
              0,
              i.width,
              i.height,
              0,
              0,
              i.width,
              i.height,
              n.COLOR_BUFFER_BIT,
              n.NEAREST,
            ),
            n.bindFramebuffer(n.FRAMEBUFFER, i.framebuffer))
        }
        initGpuRenderTarget(e) {
          let i = this._renderer.gl,
            n = new dl(),
            s = e.colorTexture
          return et.test(s.resource)
            ? (this._renderer.context.ensureCanvasSize(e.colorTexture.resource),
              (n.framebuffer = null),
              n)
            : (this._initColor(e, n), i.bindFramebuffer(i.FRAMEBUFFER, null), n)
        }
        destroyGpuRenderTarget(e) {
          let t = this._renderer.gl
          ;(e.framebuffer && (t.deleteFramebuffer(e.framebuffer), (e.framebuffer = null)),
            e.resolveTargetFramebuffer &&
              (t.deleteFramebuffer(e.resolveTargetFramebuffer),
              (e.resolveTargetFramebuffer = null)),
            e.depthStencilRenderBuffer &&
              (t.deleteRenderbuffer(e.depthStencilRenderBuffer),
              (e.depthStencilRenderBuffer = null)),
            e.msaaRenderBuffer.forEach((i) => {
              t.deleteRenderbuffer(i)
            }),
            (e.msaaRenderBuffer = null))
        }
        clear(e, t, i) {
          if (!t) return
          let n = this._renderTargetSystem
          typeof t == "boolean" && (t = t ? ze.ALL : ze.NONE)
          let s = this._renderer.gl
          if (t & ze.COLOR) {
            i ?? (i = n.defaultClearColor)
            let o = this._clearColorCache,
              a = i
            ;(o[0] !== a[0] || o[1] !== a[1] || o[2] !== a[2] || o[3] !== a[3]) &&
              ((o[0] = a[0]),
              (o[1] = a[1]),
              (o[2] = a[2]),
              (o[3] = a[3]),
              s.clearColor(a[0], a[1], a[2], a[3]))
          }
          s.clear(t)
        }
        resizeGpuRenderTarget(e) {
          if (e.isRoot) return
          let i = this._renderTargetSystem.getGpuRenderTarget(e)
          ;(this._resizeColor(e, i), (e.stencil || e.depth) && this._resizeStencil(i))
        }
        _initColor(e, t) {
          let i = this._renderer,
            n = i.gl,
            s = n.createFramebuffer()
          if (
            ((t.resolveTargetFramebuffer = s),
            n.bindFramebuffer(n.FRAMEBUFFER, s),
            (t.width = e.colorTexture.source.pixelWidth),
            (t.height = e.colorTexture.source.pixelHeight),
            e.colorTextures.forEach((o, a) => {
              let u = o.source
              ;(u.antialias &&
                (i.context.supports.msaa
                  ? (t.msaa = !0)
                  : H("[RenderTexture] Antialiasing on textures is not supported in WebGL1")),
                i.texture.bindSource(u, 0))
              let c = i.texture.getGlSource(u).texture
              n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + a, 3553, c, 0)
            }),
            t.msaa)
          ) {
            let o = n.createFramebuffer()
            ;((t.framebuffer = o),
              n.bindFramebuffer(n.FRAMEBUFFER, o),
              e.colorTextures.forEach((a, u) => {
                let l = n.createRenderbuffer()
                t.msaaRenderBuffer[u] = l
              }))
          } else t.framebuffer = s
          this._resizeColor(e, t)
        }
        _resizeColor(e, t) {
          let i = e.colorTexture.source
          if (
            ((t.width = i.pixelWidth),
            (t.height = i.pixelHeight),
            e.colorTextures.forEach((n, s) => {
              s !== 0 && n.source.resize(i.width, i.height, i._resolution)
            }),
            t.msaa)
          ) {
            let n = this._renderer,
              s = n.gl,
              o = t.framebuffer
            ;(s.bindFramebuffer(s.FRAMEBUFFER, o),
              e.colorTextures.forEach((a, u) => {
                let l = a.source
                n.texture.bindSource(l, 0)
                let h = n.texture.getGlSource(l).internalFormat,
                  f = t.msaaRenderBuffer[u]
                ;(s.bindRenderbuffer(s.RENDERBUFFER, f),
                  s.renderbufferStorageMultisample(
                    s.RENDERBUFFER,
                    4,
                    h,
                    l.pixelWidth,
                    l.pixelHeight,
                  ),
                  s.framebufferRenderbuffer(
                    s.FRAMEBUFFER,
                    s.COLOR_ATTACHMENT0 + u,
                    s.RENDERBUFFER,
                    f,
                  ))
              }))
          }
        }
        _initStencil(e) {
          if (e.framebuffer === null) return
          let t = this._renderer.gl,
            i = t.createRenderbuffer()
          ;((e.depthStencilRenderBuffer = i),
            t.bindRenderbuffer(t.RENDERBUFFER, i),
            t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, i),
            this._resizeStencil(e))
        }
        _resizeStencil(e) {
          let t = this._renderer.gl
          ;(t.bindRenderbuffer(t.RENDERBUFFER, e.depthStencilRenderBuffer),
            e.msaa
              ? t.renderbufferStorageMultisample(
                  t.RENDERBUFFER,
                  4,
                  t.DEPTH24_STENCIL8,
                  e.width,
                  e.height,
                )
              : t.renderbufferStorage(
                  t.RENDERBUFFER,
                  this._renderer.context.webGLVersion === 2 ? t.DEPTH24_STENCIL8 : t.DEPTH_STENCIL,
                  e.width,
                  e.height,
                ))
        }
        prerender(e) {
          let t = e.colorTexture.resource
          this._renderer.context.multiView &&
            et.test(t) &&
            this._renderer.context.ensureCanvasSize(t)
        }
        postrender(e) {
          if (this._renderer.context.multiView && et.test(e.colorTexture.resource)) {
            let t = this._renderer.context.canvas,
              i = e.colorTexture
            i.context2D.drawImage(t, 0, i.pixelHeight - t.height)
          }
        }
      }
    })
  var Ro,
    IT = d(() => {
      D()
      Gf()
      BT()
      Ro = class extends En {
        constructor(e) {
          ;(super(e), (this.adaptor = new fl()), this.adaptor.init(e, this))
        }
      }
      Ro.extension = { type: [_.WebGLSystem], name: "renderTarget" }
    })
  function GT(r, e) {
    let t = [],
      i = [
        `
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `,
      ],
      n = !1,
      s = 0,
      o = e._getProgramData(r.glProgram)
    for (let u in r.groups) {
      let l = r.groups[u]
      t.push(`
            resources = g[${u}].resources;
        `)
      for (let c in l.resources) {
        let h = l.resources[c]
        if (h instanceof fe)
          if (h.ubo) {
            let f = r._uniformBindMap[u][Number(c)]
            t.push(`
                        sS.bindUniformBlock(
                            resources[${c}],
                            '${f}',
                            ${r.glProgram._uniformBlockData[f].index}
                        );
                    `)
          } else
            t.push(`
                        ugS.updateUniformGroup(resources[${c}], p, sD);
                    `)
        else if (h instanceof Ur) {
          let f = r._uniformBindMap[u][Number(c)]
          t.push(`
                    sS.bindUniformBlock(
                        resources[${c}],
                        '${f}',
                        ${r.glProgram._uniformBlockData[f].index}
                    );
                `)
        } else if (h instanceof ce) {
          let f = r._uniformBindMap[u][c],
            p = o.uniformData[f]
          p &&
            (n ||
              ((n = !0),
              i.push(`
                        var tS = r.texture;
                        `)),
            e._gl.uniform1i(p.location, s),
            t.push(`
                        tS.bind(resources[${c}], ${s});
                    `),
            s++)
        }
      }
    }
    let a = [...i, ...t].join(`
`)
    return new Function("r", "s", "sD", a)
  }
  var kT = d(() => {
    il()
    st()
    ct()
  })
  var pl,
    UT = d(() => {
      "use strict"
      pl = class {
        constructor(e, t) {
          ;((this.program = e),
            (this.uniformData = t),
            (this.uniformGroups = {}),
            (this.uniformDirtyGroups = {}),
            (this.uniformBlockBindings = {}))
        }
        destroy() {
          ;((this.uniformData = null),
            (this.uniformGroups = null),
            (this.uniformDirtyGroups = null),
            (this.uniformBlockBindings = null),
            (this.program = null))
        }
      }
    })
  function $f(r, e, t) {
    let i = r.createShader(e)
    return (r.shaderSource(i, t), r.compileShader(i), i)
  }
  var OT = d(() => {
    "use strict"
  })
  function Xf(r) {
    let e = new Array(r)
    for (let t = 0; t < e.length; t++) e[t] = !1
    return e
  }
  function ml(r, e) {
    switch (r) {
      case "float":
        return 0
      case "vec2":
        return new Float32Array(2 * e)
      case "vec3":
        return new Float32Array(3 * e)
      case "vec4":
        return new Float32Array(4 * e)
      case "int":
      case "uint":
      case "sampler2D":
      case "sampler2DArray":
        return 0
      case "ivec2":
        return new Int32Array(2 * e)
      case "ivec3":
        return new Int32Array(3 * e)
      case "ivec4":
        return new Int32Array(4 * e)
      case "uvec2":
        return new Uint32Array(2 * e)
      case "uvec3":
        return new Uint32Array(3 * e)
      case "uvec4":
        return new Uint32Array(4 * e)
      case "bool":
        return !1
      case "bvec2":
        return Xf(2 * e)
      case "bvec3":
        return Xf(3 * e)
      case "bvec4":
        return Xf(4 * e)
      case "mat2":
        return new Float32Array([1, 0, 0, 1])
      case "mat3":
        return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1])
      case "mat4":
        return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
    }
    return null
  }
  var Yf = d(() => {
    "use strict"
  })
  function Kf(r, e) {
    if (!gl) {
      let t = Object.keys(LT)
      gl = {}
      for (let i = 0; i < t.length; ++i) {
        let n = t[i]
        gl[r[n]] = LT[n]
      }
    }
    return gl[e]
  }
  function NT(r, e) {
    let t = Kf(r, e)
    return LR[t] || "float32"
  }
  var gl,
    LT,
    LR,
    jf = d(() => {
      "use strict"
      ;((gl = null),
        (LT = {
          FLOAT: "float",
          FLOAT_VEC2: "vec2",
          FLOAT_VEC3: "vec3",
          FLOAT_VEC4: "vec4",
          INT: "int",
          INT_VEC2: "ivec2",
          INT_VEC3: "ivec3",
          INT_VEC4: "ivec4",
          UNSIGNED_INT: "uint",
          UNSIGNED_INT_VEC2: "uvec2",
          UNSIGNED_INT_VEC3: "uvec3",
          UNSIGNED_INT_VEC4: "uvec4",
          BOOL: "bool",
          BOOL_VEC2: "bvec2",
          BOOL_VEC3: "bvec3",
          BOOL_VEC4: "bvec4",
          FLOAT_MAT2: "mat2",
          FLOAT_MAT3: "mat3",
          FLOAT_MAT4: "mat4",
          SAMPLER_2D: "sampler2D",
          INT_SAMPLER_2D: "sampler2D",
          UNSIGNED_INT_SAMPLER_2D: "sampler2D",
          SAMPLER_CUBE: "samplerCube",
          INT_SAMPLER_CUBE: "samplerCube",
          UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
          SAMPLER_2D_ARRAY: "sampler2DArray",
          INT_SAMPLER_2D_ARRAY: "sampler2DArray",
          UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray",
        }),
        (LR = {
          float: "float32",
          vec2: "float32x2",
          vec3: "float32x3",
          vec4: "float32x4",
          int: "sint32",
          ivec2: "sint32x2",
          ivec3: "sint32x3",
          ivec4: "sint32x4",
          uint: "uint32",
          uvec2: "uint32x2",
          uvec3: "uint32x3",
          uvec4: "uint32x4",
          bool: "uint32",
          bvec2: "uint32x2",
          bvec3: "uint32x3",
          bvec4: "uint32x4",
        }))
    })
  function HT(r, e, t = !1) {
    let i = {},
      n = e.getProgramParameter(r, e.ACTIVE_ATTRIBUTES)
    for (let o = 0; o < n; o++) {
      let a = e.getActiveAttrib(r, o)
      if (a.name.startsWith("gl_")) continue
      let u = NT(e, a.type)
      i[a.name] = {
        location: 0,
        format: u,
        stride: dt(u).stride,
        offset: 0,
        instance: !1,
        start: 0,
      }
    }
    let s = Object.keys(i)
    if (t) {
      s.sort((o, a) => (o > a ? 1 : -1))
      for (let o = 0; o < s.length; o++) ((i[s[o]].location = o), e.bindAttribLocation(r, o, s[o]))
      e.linkProgram(r)
    } else for (let o = 0; o < s.length; o++) i[s[o]].location = e.getAttribLocation(r, s[o])
    return i
  }
  var zT = d(() => {
    hi()
    jf()
  })
  function WT(r, e) {
    if (!e.ACTIVE_UNIFORM_BLOCKS) return {}
    let t = {},
      i = e.getProgramParameter(r, e.ACTIVE_UNIFORM_BLOCKS)
    for (let n = 0; n < i; n++) {
      let s = e.getActiveUniformBlockName(r, n),
        o = e.getUniformBlockIndex(r, s),
        a = e.getActiveUniformBlockParameter(r, n, e.UNIFORM_BLOCK_DATA_SIZE)
      t[s] = { name: s, index: o, size: a }
    }
    return t
  }
  var VT = d(() => {
    "use strict"
  })
  function $T(r, e) {
    let t = {},
      i = e.getProgramParameter(r, e.ACTIVE_UNIFORMS)
    for (let n = 0; n < i; n++) {
      let s = e.getActiveUniform(r, n),
        o = s.name.replace(/\[.*?\]$/, ""),
        a = !!s.name.match(/\[.*?\]$/),
        u = Kf(e, s.type)
      t[o] = { name: o, index: n, type: u, size: s.size, isArray: a, value: ml(u, s.size) }
    }
    return t
  }
  var XT = d(() => {
    Yf()
    jf()
  })
  function YT(r, e) {
    let t = r
        .getShaderSource(e)
        .split(
          `
`,
        )
        .map((l, c) => `${c}: ${l}`),
      i = r.getShaderInfoLog(e),
      n = i.split(`
`),
      s = {},
      o = n
        .map((l) => parseFloat(l.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1")))
        .filter((l) => (l && !s[l] ? ((s[l] = !0), !0) : !1)),
      a = [""]
    o.forEach((l) => {
      ;((t[l - 1] = `%c${t[l - 1]}%c`),
        a.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px"))
    })
    let u = t.join(`
`)
    ;((a[0] = u),
      console.error(i),
      console.groupCollapsed("click to view full shader code"),
      console.warn(...a),
      console.groupEnd())
  }
  function KT(r, e, t, i) {
    r.getProgramParameter(e, r.LINK_STATUS) ||
      (r.getShaderParameter(t, r.COMPILE_STATUS) || YT(r, t),
      r.getShaderParameter(i, r.COMPILE_STATUS) || YT(r, i),
      console.error("PixiJS Error: Could not initialize shader."),
      r.getProgramInfoLog(e) !== "" &&
        console.warn("PixiJS Warning: gl.getProgramInfoLog()", r.getProgramInfoLog(e)))
  }
  var jT = d(() => {
    "use strict"
  })
  function qT(r, e) {
    let t = $f(r, r.VERTEX_SHADER, e.vertex),
      i = $f(r, r.FRAGMENT_SHADER, e.fragment),
      n = r.createProgram()
    ;(r.attachShader(n, t), r.attachShader(n, i))
    let s = e.transformFeedbackVaryings
    ;(s &&
      (typeof r.transformFeedbackVaryings != "function"
        ? H("TransformFeedback is not supported but TransformFeedbackVaryings are given.")
        : r.transformFeedbackVaryings(
            n,
            s.names,
            s.bufferMode === "separate" ? r.SEPARATE_ATTRIBS : r.INTERLEAVED_ATTRIBS,
          )),
      r.linkProgram(n),
      r.getProgramParameter(n, r.LINK_STATUS) || KT(r, n, t, i),
      (e._attributeData = HT(
        n,
        r,
        !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e.vertex),
      )),
      (e._uniformData = $T(n, r)),
      (e._uniformBlockData = WT(n, r)),
      r.deleteShader(t),
      r.deleteShader(i))
    let o = {}
    for (let u in e._uniformData) {
      let l = e._uniformData[u]
      o[u] = { location: r.getUniformLocation(n, u), value: ml(l.type, l.size) }
    }
    return new pl(n, o)
  }
  var ZT = d(() => {
    be()
    UT()
    OT()
    Yf()
    zT()
    VT()
    XT()
    jT()
  })
  var xl,
    Fo,
    QT = d(() => {
      D()
      ui()
      kT()
      ZT()
      ;((xl = { textureCount: 0, blockIndex: 0 }),
        (Fo = class {
          constructor(e) {
            ;((this._activeProgram = null),
              (this._programDataHash = Object.create(null)),
              (this._shaderSyncFunctions = Object.create(null)),
              (this._renderer = e),
              this._renderer.renderableGC.addManagedHash(this, "_programDataHash"))
          }
          contextChange(e) {
            ;((this._gl = e),
              (this._programDataHash = Object.create(null)),
              (this._shaderSyncFunctions = Object.create(null)),
              (this._activeProgram = null),
              (this.maxTextures = wt()))
          }
          bind(e, t) {
            if ((this._setProgram(e.glProgram), t)) return
            ;((xl.textureCount = 0), (xl.blockIndex = 0))
            let i = this._shaderSyncFunctions[e.glProgram._key]
            ;(i ||
              (i = this._shaderSyncFunctions[e.glProgram._key] = this._generateShaderSync(e, this)),
              this._renderer.buffer.nextBindBase(!!e.glProgram.transformFeedbackVaryings),
              i(this._renderer, e, xl))
          }
          updateUniformGroup(e) {
            this._renderer.uniformGroup.updateUniformGroup(e, this._activeProgram, xl)
          }
          bindUniformBlock(e, t, i = 0) {
            let n = this._renderer.buffer,
              s = this._getProgramData(this._activeProgram),
              o = e._bufferResource
            o || this._renderer.ubo.updateUniformGroup(e)
            let a = e.buffer,
              u = n.updateBuffer(a),
              l = n.freeLocationForBufferBase(u)
            if (o) {
              let { offset: h, size: f } = e
              h === 0 && f === a.data.byteLength
                ? n.bindBufferBase(u, l)
                : n.bindBufferRange(u, l, h)
            } else n.getLastBindBaseLocation(u) !== l && n.bindBufferBase(u, l)
            let c = this._activeProgram._uniformBlockData[t].index
            s.uniformBlockBindings[i] !== l &&
              ((s.uniformBlockBindings[i] = l),
              this._renderer.gl.uniformBlockBinding(s.program, c, l))
          }
          _setProgram(e) {
            if (this._activeProgram === e) return
            this._activeProgram = e
            let t = this._getProgramData(e)
            this._gl.useProgram(t.program)
          }
          _getProgramData(e) {
            return this._programDataHash[e._key] || this._createProgramData(e)
          }
          _createProgramData(e) {
            let t = e._key
            return ((this._programDataHash[t] = qT(this._gl, e)), this._programDataHash[t])
          }
          destroy() {
            for (let e of Object.keys(this._programDataHash))
              (this._programDataHash[e].destroy(), (this._programDataHash[e] = null))
            this._programDataHash = null
          }
          _generateShaderSync(e, t) {
            return GT(e, t)
          }
          resetState() {
            this._activeProgram = null
          }
        }))
      Fo.extension = { type: [_.WebGLSystem], name: "shader" }
    })
  var JT,
    eC,
    tC = d(() => {
      "use strict"
      ;((JT = {
        f32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`,
        "vec2<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`,
        "vec3<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`,
        "vec4<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`,
        i32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
        "vec2<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
        "vec3<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
        "vec4<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
        u32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`,
        "vec2<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`,
        "vec3<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`,
        "vec4<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`,
        bool: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
        "vec2<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
        "vec3<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
        "vec4<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
        "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);",
        "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);",
        "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);",
      }),
        (eC = {
          f32: "gl.uniform1fv(location, v);",
          "vec2<f32>": "gl.uniform2fv(location, v);",
          "vec3<f32>": "gl.uniform3fv(location, v);",
          "vec4<f32>": "gl.uniform4fv(location, v);",
          "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);",
          "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);",
          "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);",
          i32: "gl.uniform1iv(location, v);",
          "vec2<i32>": "gl.uniform2iv(location, v);",
          "vec3<i32>": "gl.uniform3iv(location, v);",
          "vec4<i32>": "gl.uniform4iv(location, v);",
          u32: "gl.uniform1iv(location, v);",
          "vec2<u32>": "gl.uniform2iv(location, v);",
          "vec3<u32>": "gl.uniform3iv(location, v);",
          "vec4<u32>": "gl.uniform4iv(location, v);",
          bool: "gl.uniform1iv(location, v);",
          "vec2<bool>": "gl.uniform2iv(location, v);",
          "vec3<bool>": "gl.uniform3iv(location, v);",
          "vec4<bool>": "gl.uniform4iv(location, v);",
        }))
    })
  function rC(r, e) {
    let t = [
      `
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `,
    ]
    for (let i in r.uniforms) {
      if (!e[i]) {
        r.uniforms[i] instanceof fe
          ? r.uniforms[i].ubo
            ? t.push(`
                        renderer.shader.bindUniformBlock(uv.${i}, "${i}");
                    `)
            : t.push(`
                        renderer.shader.updateUniformGroup(uv.${i});
                    `)
          : r.uniforms[i] instanceof Ur &&
            t.push(`
                        renderer.shader.bindBufferResource(uv.${i}, "${i}");
                    `)
        continue
      }
      let n = r.uniformStructures[i],
        s = !1
      for (let o = 0; o < mr.length; o++) {
        let a = mr[o]
        if (n.type === a.type && a.test(n)) {
          ;(t.push(`name = "${i}";`, mr[o].uniform), (s = !0))
          break
        }
      }
      if (!s) {
        let a = (n.size === 1 ? JT : eC)[n.type].replace("location", `ud["${i}"].location`)
        t.push(`
            cu = ud["${i}"];
            cv = cu.value;
            v = uv["${i}"];
            ${a};`)
      }
    }
    return new Function(
      "ud",
      "uv",
      "renderer",
      "syncData",
      t.join(`
`),
    )
  }
  var iC = d(() => {
    il()
    st()
    Df()
    tC()
  })
  var Bo,
    nC = d(() => {
      D()
      iC()
      Bo = class {
        constructor(e) {
          ;((this._cache = {}),
            (this._uniformGroupSyncHash = {}),
            (this._renderer = e),
            (this.gl = null),
            (this._cache = {}))
        }
        contextChange(e) {
          this.gl = e
        }
        updateUniformGroup(e, t, i) {
          let n = this._renderer.shader._getProgramData(t)
          ;(!e.isStatic || e._dirtyId !== n.uniformDirtyGroups[e.uid]) &&
            ((n.uniformDirtyGroups[e.uid] = e._dirtyId),
            this._getUniformSyncFunction(e, t)(n.uniformData, e.uniforms, this._renderer, i))
        }
        _getUniformSyncFunction(e, t) {
          return (
            this._uniformGroupSyncHash[e._signature]?.[t._key] ||
            this._createUniformSyncFunction(e, t)
          )
        }
        _createUniformSyncFunction(e, t) {
          let i =
              this._uniformGroupSyncHash[e._signature] ||
              (this._uniformGroupSyncHash[e._signature] = {}),
            n = this._getSignature(e, t._uniformData, "u")
          return (
            this._cache[n] || (this._cache[n] = this._generateUniformsSync(e, t._uniformData)),
            (i[t._key] = this._cache[n]),
            i[t._key]
          )
        }
        _generateUniformsSync(e, t) {
          return rC(e, t)
        }
        _getSignature(e, t, i) {
          let n = e.uniforms,
            s = [`${i}-`]
          for (let o in n) (s.push(o), t[o] && s.push(t[o].type))
          return s.join("-")
        }
        destroy() {
          ;((this._renderer = null), (this._cache = null))
        }
      }
      Bo.extension = { type: [_.WebGLSystem], name: "uniformGroup" }
    })
  function sC(r) {
    let e = {}
    if (
      ((e.normal = [r.ONE, r.ONE_MINUS_SRC_ALPHA]),
      (e.add = [r.ONE, r.ONE]),
      (e.multiply = [r.DST_COLOR, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA]),
      (e.screen = [r.ONE, r.ONE_MINUS_SRC_COLOR, r.ONE, r.ONE_MINUS_SRC_ALPHA]),
      (e.none = [0, 0]),
      (e["normal-npm"] = [r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA]),
      (e["add-npm"] = [r.SRC_ALPHA, r.ONE, r.ONE, r.ONE]),
      (e["screen-npm"] = [r.SRC_ALPHA, r.ONE_MINUS_SRC_COLOR, r.ONE, r.ONE_MINUS_SRC_ALPHA]),
      (e.erase = [r.ZERO, r.ONE_MINUS_SRC_ALPHA]),
      !(r instanceof Z.get().getWebGLRenderingContext()))
    )
      ((e.min = [r.ONE, r.ONE, r.ONE, r.ONE, r.MIN, r.MIN]),
        (e.max = [r.ONE, r.ONE, r.ONE, r.ONE, r.MAX, r.MAX]))
    else {
      let i = r.getExtension("EXT_blend_minmax")
      i &&
        ((e.min = [r.ONE, r.ONE, r.ONE, r.ONE, i.MIN_EXT, i.MIN_EXT]),
        (e.max = [r.ONE, r.ONE, r.ONE, r.ONE, i.MAX_EXT, i.MAX_EXT]))
    }
    return e
  }
  var oC = d(() => {
    Ie()
  })
  var NR,
    HR,
    zR,
    WR,
    VR,
    $R,
    aC,
    uC,
    lC = d(() => {
      D()
      Ot()
      oC()
      ;((NR = 0),
        (HR = 1),
        (zR = 2),
        (WR = 3),
        (VR = 4),
        ($R = 5),
        (aC = class qf {
          constructor(e) {
            ;((this._invertFrontFace = !1),
              (this.gl = null),
              (this.stateId = 0),
              (this.polygonOffset = 0),
              (this.blendMode = "none"),
              (this._blendEq = !1),
              (this.map = []),
              (this.map[NR] = this.setBlend),
              (this.map[HR] = this.setOffset),
              (this.map[zR] = this.setCullFace),
              (this.map[WR] = this.setDepthTest),
              (this.map[VR] = this.setFrontFace),
              (this.map[$R] = this.setDepthMask),
              (this.checks = []),
              (this.defaultState = Fe.for2d()),
              e.renderTarget.onRenderTargetChange.add(this))
          }
          onRenderTargetChange(e) {
            ;((this._invertFrontFace = !e.isRoot),
              this._cullFace ? this.setFrontFace(this._frontFace) : (this._frontFaceDirty = !0))
          }
          contextChange(e) {
            ;((this.gl = e), (this.blendModesMap = sC(e)), this.resetState())
          }
          set(e) {
            if ((e || (e = this.defaultState), this.stateId !== e.data)) {
              let t = this.stateId ^ e.data,
                i = 0
              for (; t; ) (t & 1 && this.map[i].call(this, !!(e.data & (1 << i))), (t >>= 1), i++)
              this.stateId = e.data
            }
            for (let t = 0; t < this.checks.length; t++) this.checks[t](this, e)
          }
          forceState(e) {
            e || (e = this.defaultState)
            for (let t = 0; t < this.map.length; t++) this.map[t].call(this, !!(e.data & (1 << t)))
            for (let t = 0; t < this.checks.length; t++) this.checks[t](this, e)
            this.stateId = e.data
          }
          setBlend(e) {
            ;(this._updateCheck(qf._checkBlendMode, e),
              this.gl[e ? "enable" : "disable"](this.gl.BLEND))
          }
          setOffset(e) {
            ;(this._updateCheck(qf._checkPolygonOffset, e),
              this.gl[e ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL))
          }
          setDepthTest(e) {
            this.gl[e ? "enable" : "disable"](this.gl.DEPTH_TEST)
          }
          setDepthMask(e) {
            this.gl.depthMask(e)
          }
          setCullFace(e) {
            ;((this._cullFace = e),
              this.gl[e ? "enable" : "disable"](this.gl.CULL_FACE),
              this._cullFace && this._frontFaceDirty && this.setFrontFace(this._frontFace))
          }
          setFrontFace(e) {
            ;((this._frontFace = e), (this._frontFaceDirty = !1))
            let t = this._invertFrontFace ? !e : e
            this._glFrontFace !== t &&
              ((this._glFrontFace = t), this.gl.frontFace(this.gl[t ? "CW" : "CCW"]))
          }
          setBlendMode(e) {
            if ((this.blendModesMap[e] || (e = "normal"), e === this.blendMode)) return
            this.blendMode = e
            let t = this.blendModesMap[e],
              i = this.gl
            ;(t.length === 2
              ? i.blendFunc(t[0], t[1])
              : i.blendFuncSeparate(t[0], t[1], t[2], t[3]),
              t.length === 6
                ? ((this._blendEq = !0), i.blendEquationSeparate(t[4], t[5]))
                : this._blendEq &&
                  ((this._blendEq = !1), i.blendEquationSeparate(i.FUNC_ADD, i.FUNC_ADD)))
          }
          setPolygonOffset(e, t) {
            this.gl.polygonOffset(e, t)
          }
          resetState() {
            ;((this._glFrontFace = !1),
              (this._frontFace = !1),
              (this._cullFace = !1),
              (this._frontFaceDirty = !1),
              (this._invertFrontFace = !1),
              this.gl.frontFace(this.gl.CCW),
              this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1),
              this.forceState(this.defaultState),
              (this._blendEq = !0),
              (this.blendMode = ""),
              this.setBlendMode("normal"))
          }
          _updateCheck(e, t) {
            let i = this.checks.indexOf(e)
            t && i === -1 ? this.checks.push(e) : !t && i !== -1 && this.checks.splice(i, 1)
          }
          static _checkBlendMode(e, t) {
            e.setBlendMode(t.blendMode)
          }
          static _checkPolygonOffset(e, t) {
            e.setPolygonOffset(1, t.polygonOffset)
          }
          destroy() {
            ;((this.gl = null), (this.checks.length = 0))
          }
        }))
      aC.extension = { type: [_.WebGLSystem], name: "state" }
      uC = aC
    })
  var _l,
    cC = d(() => {
      Hf()
      _l = class {
        constructor(e) {
          ;((this.target = Nf.TEXTURE_2D),
            (this.texture = e),
            (this.width = -1),
            (this.height = -1),
            (this.type = ue.UNSIGNED_BYTE),
            (this.internalFormat = hl.RGBA),
            (this.format = hl.RGBA),
            (this.samplerType = 0))
        }
      }
    })
  var hC,
    dC = d(() => {
      "use strict"
      hC = {
        id: "buffer",
        upload(r, e, t) {
          ;(e.width === r.width || e.height === r.height
            ? t.texSubImage2D(
                t.TEXTURE_2D,
                0,
                0,
                0,
                r.width,
                r.height,
                e.format,
                e.type,
                r.resource,
              )
            : t.texImage2D(
                e.target,
                0,
                e.internalFormat,
                r.width,
                r.height,
                0,
                e.format,
                e.type,
                r.resource,
              ),
            (e.width = r.width),
            (e.height = r.height))
        },
      }
    })
  var XR,
    fC,
    pC = d(() => {
      "use strict"
      ;((XR = {
        "bc1-rgba-unorm": !0,
        "bc1-rgba-unorm-srgb": !0,
        "bc2-rgba-unorm": !0,
        "bc2-rgba-unorm-srgb": !0,
        "bc3-rgba-unorm": !0,
        "bc3-rgba-unorm-srgb": !0,
        "bc4-r-unorm": !0,
        "bc4-r-snorm": !0,
        "bc5-rg-unorm": !0,
        "bc5-rg-snorm": !0,
        "bc6h-rgb-ufloat": !0,
        "bc6h-rgb-float": !0,
        "bc7-rgba-unorm": !0,
        "bc7-rgba-unorm-srgb": !0,
        "etc2-rgb8unorm": !0,
        "etc2-rgb8unorm-srgb": !0,
        "etc2-rgb8a1unorm": !0,
        "etc2-rgb8a1unorm-srgb": !0,
        "etc2-rgba8unorm": !0,
        "etc2-rgba8unorm-srgb": !0,
        "eac-r11unorm": !0,
        "eac-r11snorm": !0,
        "eac-rg11unorm": !0,
        "eac-rg11snorm": !0,
        "astc-4x4-unorm": !0,
        "astc-4x4-unorm-srgb": !0,
        "astc-5x4-unorm": !0,
        "astc-5x4-unorm-srgb": !0,
        "astc-5x5-unorm": !0,
        "astc-5x5-unorm-srgb": !0,
        "astc-6x5-unorm": !0,
        "astc-6x5-unorm-srgb": !0,
        "astc-6x6-unorm": !0,
        "astc-6x6-unorm-srgb": !0,
        "astc-8x5-unorm": !0,
        "astc-8x5-unorm-srgb": !0,
        "astc-8x6-unorm": !0,
        "astc-8x6-unorm-srgb": !0,
        "astc-8x8-unorm": !0,
        "astc-8x8-unorm-srgb": !0,
        "astc-10x5-unorm": !0,
        "astc-10x5-unorm-srgb": !0,
        "astc-10x6-unorm": !0,
        "astc-10x6-unorm-srgb": !0,
        "astc-10x8-unorm": !0,
        "astc-10x8-unorm-srgb": !0,
        "astc-10x10-unorm": !0,
        "astc-10x10-unorm-srgb": !0,
        "astc-12x10-unorm": !0,
        "astc-12x10-unorm-srgb": !0,
        "astc-12x12-unorm": !0,
        "astc-12x12-unorm-srgb": !0,
      }),
        (fC = {
          id: "compressed",
          upload(r, e, t) {
            t.pixelStorei(t.UNPACK_ALIGNMENT, 4)
            let i = r.pixelWidth,
              n = r.pixelHeight,
              s = !!XR[r.format]
            for (let o = 0; o < r.resource.length; o++) {
              let a = r.resource[o]
              ;(s
                ? t.compressedTexImage2D(t.TEXTURE_2D, o, e.internalFormat, i, n, 0, a)
                : t.texImage2D(t.TEXTURE_2D, o, e.internalFormat, i, n, 0, e.format, e.type, a),
                (i = Math.max(i >> 1, 1)),
                (n = Math.max(n >> 1, 1)))
            }
          },
        }))
    })
  var yl,
    Zf = d(() => {
      "use strict"
      yl = {
        id: "image",
        upload(r, e, t, i) {
          let n = e.width,
            s = e.height,
            o = r.pixelWidth,
            a = r.pixelHeight,
            u = r.resourceWidth,
            l = r.resourceHeight
          ;(u < o || l < a
            ? ((n !== o || s !== a) &&
                t.texImage2D(e.target, 0, e.internalFormat, o, a, 0, e.format, e.type, null),
              i === 2
                ? t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, u, l, e.format, e.type, r.resource)
                : t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, e.format, e.type, r.resource))
            : n === o && s === a
              ? t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, e.format, e.type, r.resource)
              : i === 2
                ? t.texImage2D(e.target, 0, e.internalFormat, o, a, 0, e.format, e.type, r.resource)
                : t.texImage2D(e.target, 0, e.internalFormat, e.format, e.type, r.resource),
            (e.width = o),
            (e.height = a))
        },
      }
    })
  var mC,
    gC = d(() => {
      Zf()
      mC = {
        id: "video",
        upload(r, e, t, i) {
          if (!r.isValid) {
            t.texImage2D(e.target, 0, e.internalFormat, 1, 1, 0, e.format, e.type, null)
            return
          }
          yl.upload(r, e, t, i)
        },
      }
    })
  var Qf,
    xC,
    bl,
    _C,
    yC = d(() => {
      "use strict"
      ;((Qf = { linear: 9729, nearest: 9728 }),
        (xC = {
          linear: { linear: 9987, nearest: 9985 },
          nearest: { linear: 9986, nearest: 9984 },
        }),
        (bl = { "clamp-to-edge": 33071, repeat: 10497, "mirror-repeat": 33648 }),
        (_C = {
          never: 512,
          less: 513,
          equal: 514,
          "less-equal": 515,
          greater: 516,
          "not-equal": 517,
          "greater-equal": 518,
          always: 519,
        }))
    })
  function Jf(r, e, t, i, n, s, o, a) {
    let u = s
    if (
      !a ||
      r.addressModeU !== "repeat" ||
      r.addressModeV !== "repeat" ||
      r.addressModeW !== "repeat"
    ) {
      let l = bl[o ? "clamp-to-edge" : r.addressModeU],
        c = bl[o ? "clamp-to-edge" : r.addressModeV],
        h = bl[o ? "clamp-to-edge" : r.addressModeW]
      ;(e[n](u, e.TEXTURE_WRAP_S, l),
        e[n](u, e.TEXTURE_WRAP_T, c),
        e.TEXTURE_WRAP_R && e[n](u, e.TEXTURE_WRAP_R, h))
    }
    if (((!a || r.magFilter !== "linear") && e[n](u, e.TEXTURE_MAG_FILTER, Qf[r.magFilter]), t)) {
      if (!a || r.mipmapFilter !== "linear") {
        let l = xC[r.minFilter][r.mipmapFilter]
        e[n](u, e.TEXTURE_MIN_FILTER, l)
      }
    } else e[n](u, e.TEXTURE_MIN_FILTER, Qf[r.minFilter])
    if (i && r.maxAnisotropy > 1) {
      let l = Math.min(r.maxAnisotropy, e.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT))
      e[n](u, i.TEXTURE_MAX_ANISOTROPY_EXT, l)
    }
    r.compare && e[n](u, e.TEXTURE_COMPARE_FUNC, _C[r.compare])
  }
  var bC = d(() => {
    yC()
  })
  function vC(r) {
    return {
      r8unorm: r.RED,
      r8snorm: r.RED,
      r8uint: r.RED,
      r8sint: r.RED,
      r16uint: r.RED,
      r16sint: r.RED,
      r16float: r.RED,
      rg8unorm: r.RG,
      rg8snorm: r.RG,
      rg8uint: r.RG,
      rg8sint: r.RG,
      r32uint: r.RED,
      r32sint: r.RED,
      r32float: r.RED,
      rg16uint: r.RG,
      rg16sint: r.RG,
      rg16float: r.RG,
      rgba8unorm: r.RGBA,
      "rgba8unorm-srgb": r.RGBA,
      rgba8snorm: r.RGBA,
      rgba8uint: r.RGBA,
      rgba8sint: r.RGBA,
      bgra8unorm: r.RGBA,
      "bgra8unorm-srgb": r.RGBA,
      rgb9e5ufloat: r.RGB,
      rgb10a2unorm: r.RGBA,
      rg11b10ufloat: r.RGB,
      rg32uint: r.RG,
      rg32sint: r.RG,
      rg32float: r.RG,
      rgba16uint: r.RGBA,
      rgba16sint: r.RGBA,
      rgba16float: r.RGBA,
      rgba32uint: r.RGBA,
      rgba32sint: r.RGBA,
      rgba32float: r.RGBA,
      stencil8: r.STENCIL_INDEX8,
      depth16unorm: r.DEPTH_COMPONENT,
      depth24plus: r.DEPTH_COMPONENT,
      "depth24plus-stencil8": r.DEPTH_STENCIL,
      depth32float: r.DEPTH_COMPONENT,
      "depth32float-stencil8": r.DEPTH_STENCIL,
    }
  }
  var SC = d(() => {
    "use strict"
  })
  function TC(r, e) {
    let t = {},
      i = r.RGBA
    return (
      r instanceof Z.get().getWebGLRenderingContext()
        ? e.srgb &&
          (t = {
            "rgba8unorm-srgb": e.srgb.SRGB8_ALPHA8_EXT,
            "bgra8unorm-srgb": e.srgb.SRGB8_ALPHA8_EXT,
          })
        : ((t = { "rgba8unorm-srgb": r.SRGB8_ALPHA8, "bgra8unorm-srgb": r.SRGB8_ALPHA8 }),
          (i = r.RGBA8)),
      {
        r8unorm: r.R8,
        r8snorm: r.R8_SNORM,
        r8uint: r.R8UI,
        r8sint: r.R8I,
        r16uint: r.R16UI,
        r16sint: r.R16I,
        r16float: r.R16F,
        rg8unorm: r.RG8,
        rg8snorm: r.RG8_SNORM,
        rg8uint: r.RG8UI,
        rg8sint: r.RG8I,
        r32uint: r.R32UI,
        r32sint: r.R32I,
        r32float: r.R32F,
        rg16uint: r.RG16UI,
        rg16sint: r.RG16I,
        rg16float: r.RG16F,
        rgba8unorm: r.RGBA,
        ...t,
        rgba8snorm: r.RGBA8_SNORM,
        rgba8uint: r.RGBA8UI,
        rgba8sint: r.RGBA8I,
        bgra8unorm: i,
        rgb9e5ufloat: r.RGB9_E5,
        rgb10a2unorm: r.RGB10_A2,
        rg11b10ufloat: r.R11F_G11F_B10F,
        rg32uint: r.RG32UI,
        rg32sint: r.RG32I,
        rg32float: r.RG32F,
        rgba16uint: r.RGBA16UI,
        rgba16sint: r.RGBA16I,
        rgba16float: r.RGBA16F,
        rgba32uint: r.RGBA32UI,
        rgba32sint: r.RGBA32I,
        rgba32float: r.RGBA32F,
        stencil8: r.STENCIL_INDEX8,
        depth16unorm: r.DEPTH_COMPONENT16,
        depth24plus: r.DEPTH_COMPONENT24,
        "depth24plus-stencil8": r.DEPTH24_STENCIL8,
        depth32float: r.DEPTH_COMPONENT32F,
        "depth32float-stencil8": r.DEPTH32F_STENCIL8,
        ...(e.s3tc
          ? {
              "bc1-rgba-unorm": e.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,
              "bc2-rgba-unorm": e.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,
              "bc3-rgba-unorm": e.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT,
            }
          : {}),
        ...(e.s3tc_sRGB
          ? {
              "bc1-rgba-unorm-srgb": e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
              "bc2-rgba-unorm-srgb": e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
              "bc3-rgba-unorm-srgb": e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,
            }
          : {}),
        ...(e.rgtc
          ? {
              "bc4-r-unorm": e.rgtc.COMPRESSED_RED_RGTC1_EXT,
              "bc4-r-snorm": e.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,
              "bc5-rg-unorm": e.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,
              "bc5-rg-snorm": e.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT,
            }
          : {}),
        ...(e.bptc
          ? {
              "bc6h-rgb-float": e.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
              "bc6h-rgb-ufloat": e.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
              "bc7-rgba-unorm": e.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
              "bc7-rgba-unorm-srgb": e.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT,
            }
          : {}),
        ...(e.etc
          ? {
              "etc2-rgb8unorm": e.etc.COMPRESSED_RGB8_ETC2,
              "etc2-rgb8unorm-srgb": e.etc.COMPRESSED_SRGB8_ETC2,
              "etc2-rgb8a1unorm": e.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
              "etc2-rgb8a1unorm-srgb": e.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
              "etc2-rgba8unorm": e.etc.COMPRESSED_RGBA8_ETC2_EAC,
              "etc2-rgba8unorm-srgb": e.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
              "eac-r11unorm": e.etc.COMPRESSED_R11_EAC,
              "eac-rg11unorm": e.etc.COMPRESSED_SIGNED_RG11_EAC,
            }
          : {}),
        ...(e.astc
          ? {
              "astc-4x4-unorm": e.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
              "astc-4x4-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
              "astc-5x4-unorm": e.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,
              "astc-5x4-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,
              "astc-5x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,
              "astc-5x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
              "astc-6x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,
              "astc-6x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
              "astc-6x6-unorm": e.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,
              "astc-6x6-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
              "astc-8x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,
              "astc-8x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
              "astc-8x6-unorm": e.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,
              "astc-8x6-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
              "astc-8x8-unorm": e.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,
              "astc-8x8-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
              "astc-10x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,
              "astc-10x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
              "astc-10x6-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,
              "astc-10x6-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
              "astc-10x8-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,
              "astc-10x8-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
              "astc-10x10-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,
              "astc-10x10-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
              "astc-12x10-unorm": e.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,
              "astc-12x10-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
              "astc-12x12-unorm": e.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,
              "astc-12x12-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR,
            }
          : {}),
      }
    )
  }
  var CC = d(() => {
    Ie()
  })
  function EC(r) {
    return {
      r8unorm: r.UNSIGNED_BYTE,
      r8snorm: r.BYTE,
      r8uint: r.UNSIGNED_BYTE,
      r8sint: r.BYTE,
      r16uint: r.UNSIGNED_SHORT,
      r16sint: r.SHORT,
      r16float: r.HALF_FLOAT,
      rg8unorm: r.UNSIGNED_BYTE,
      rg8snorm: r.BYTE,
      rg8uint: r.UNSIGNED_BYTE,
      rg8sint: r.BYTE,
      r32uint: r.UNSIGNED_INT,
      r32sint: r.INT,
      r32float: r.FLOAT,
      rg16uint: r.UNSIGNED_SHORT,
      rg16sint: r.SHORT,
      rg16float: r.HALF_FLOAT,
      rgba8unorm: r.UNSIGNED_BYTE,
      "rgba8unorm-srgb": r.UNSIGNED_BYTE,
      rgba8snorm: r.BYTE,
      rgba8uint: r.UNSIGNED_BYTE,
      rgba8sint: r.BYTE,
      bgra8unorm: r.UNSIGNED_BYTE,
      "bgra8unorm-srgb": r.UNSIGNED_BYTE,
      rgb9e5ufloat: r.UNSIGNED_INT_5_9_9_9_REV,
      rgb10a2unorm: r.UNSIGNED_INT_2_10_10_10_REV,
      rg11b10ufloat: r.UNSIGNED_INT_10F_11F_11F_REV,
      rg32uint: r.UNSIGNED_INT,
      rg32sint: r.INT,
      rg32float: r.FLOAT,
      rgba16uint: r.UNSIGNED_SHORT,
      rgba16sint: r.SHORT,
      rgba16float: r.HALF_FLOAT,
      rgba32uint: r.UNSIGNED_INT,
      rgba32sint: r.INT,
      rgba32float: r.FLOAT,
      stencil8: r.UNSIGNED_BYTE,
      depth16unorm: r.UNSIGNED_SHORT,
      depth24plus: r.UNSIGNED_INT,
      "depth24plus-stencil8": r.UNSIGNED_INT_24_8,
      depth32float: r.FLOAT,
      "depth32float-stencil8": r.FLOAT_32_UNSIGNED_INT_24_8_REV,
    }
  }
  var wC = d(() => {
    "use strict"
  })
  var YR,
    Io,
    MC = d(() => {
      Ie()
      D()
      ge()
      cC()
      dC()
      pC()
      Zf()
      gC()
      bC()
      SC()
      CC()
      wC()
      ;((YR = 4),
        (Io = class {
          constructor(e) {
            ;((this.managedTextures = []),
              (this._glTextures = Object.create(null)),
              (this._glSamplers = Object.create(null)),
              (this._boundTextures = []),
              (this._activeTextureLocation = -1),
              (this._boundSamplers = Object.create(null)),
              (this._uploads = { image: yl, buffer: hC, video: mC, compressed: fC }),
              (this._premultiplyAlpha = !1),
              (this._useSeparateSamplers = !1),
              (this._renderer = e),
              this._renderer.renderableGC.addManagedHash(this, "_glTextures"),
              this._renderer.renderableGC.addManagedHash(this, "_glSamplers"))
          }
          contextChange(e) {
            ;((this._gl = e),
              this._mapFormatToInternalFormat ||
                ((this._mapFormatToInternalFormat = TC(e, this._renderer.context.extensions)),
                (this._mapFormatToType = EC(e)),
                (this._mapFormatToFormat = vC(e))),
              (this._glTextures = Object.create(null)),
              (this._glSamplers = Object.create(null)),
              (this._boundSamplers = Object.create(null)),
              (this._premultiplyAlpha = !1))
            for (let t = 0; t < 16; t++) this.bind(I.EMPTY, t)
          }
          initSource(e) {
            this.bind(e)
          }
          bind(e, t = 0) {
            let i = e.source
            e
              ? (this.bindSource(i, t), this._useSeparateSamplers && this._bindSampler(i.style, t))
              : (this.bindSource(null, t), this._useSeparateSamplers && this._bindSampler(null, t))
          }
          bindSource(e, t = 0) {
            let i = this._gl
            if (((e._touched = this._renderer.textureGC.count), this._boundTextures[t] !== e)) {
              ;((this._boundTextures[t] = e), this._activateLocation(t), e || (e = I.EMPTY.source))
              let n = this.getGlSource(e)
              i.bindTexture(n.target, n.texture)
            }
          }
          _bindSampler(e, t = 0) {
            let i = this._gl
            if (!e) {
              ;((this._boundSamplers[t] = null), i.bindSampler(t, null))
              return
            }
            let n = this._getGlSampler(e)
            this._boundSamplers[t] !== n && ((this._boundSamplers[t] = n), i.bindSampler(t, n))
          }
          unbind(e) {
            let t = e.source,
              i = this._boundTextures,
              n = this._gl
            for (let s = 0; s < i.length; s++)
              if (i[s] === t) {
                this._activateLocation(s)
                let o = this.getGlSource(t)
                ;(n.bindTexture(o.target, null), (i[s] = null))
              }
          }
          _activateLocation(e) {
            this._activeTextureLocation !== e &&
              ((this._activeTextureLocation = e), this._gl.activeTexture(this._gl.TEXTURE0 + e))
          }
          _initSource(e) {
            let t = this._gl,
              i = new _l(t.createTexture())
            if (
              ((i.type = this._mapFormatToType[e.format]),
              (i.internalFormat = this._mapFormatToInternalFormat[e.format]),
              (i.format = this._mapFormatToFormat[e.format]),
              e.autoGenerateMipmaps &&
                (this._renderer.context.supports.nonPowOf2mipmaps || e.isPowerOfTwo))
            ) {
              let n = Math.max(e.width, e.height)
              e.mipLevelCount = Math.floor(Math.log2(n)) + 1
            }
            return (
              (this._glTextures[e.uid] = i),
              this.managedTextures.includes(e) ||
                (e.on("update", this.onSourceUpdate, this),
                e.on("resize", this.onSourceUpdate, this),
                e.on("styleChange", this.onStyleChange, this),
                e.on("destroy", this.onSourceDestroy, this),
                e.on("unload", this.onSourceUnload, this),
                e.on("updateMipmaps", this.onUpdateMipmaps, this),
                this.managedTextures.push(e)),
              this.onSourceUpdate(e),
              this.updateStyle(e, !1),
              i
            )
          }
          onStyleChange(e) {
            this.updateStyle(e, !1)
          }
          updateStyle(e, t) {
            let i = this._gl,
              n = this.getGlSource(e)
            ;(i.bindTexture(i.TEXTURE_2D, n.texture),
              (this._boundTextures[this._activeTextureLocation] = e),
              Jf(
                e.style,
                i,
                e.mipLevelCount > 1,
                this._renderer.context.extensions.anisotropicFiltering,
                "texParameteri",
                i.TEXTURE_2D,
                !this._renderer.context.supports.nonPowOf2wrapping && !e.isPowerOfTwo,
                t,
              ))
          }
          onSourceUnload(e) {
            let t = this._glTextures[e.uid]
            t &&
              (this.unbind(e), (this._glTextures[e.uid] = null), this._gl.deleteTexture(t.texture))
          }
          onSourceUpdate(e) {
            let t = this._gl,
              i = this.getGlSource(e)
            ;(t.bindTexture(t.TEXTURE_2D, i.texture),
              (this._boundTextures[this._activeTextureLocation] = e))
            let n = e.alphaMode === "premultiply-alpha-on-upload"
            ;(this._premultiplyAlpha !== n &&
              ((this._premultiplyAlpha = n), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n)),
              this._uploads[e.uploadMethodId]
                ? this._uploads[e.uploadMethodId].upload(
                    e,
                    i,
                    t,
                    this._renderer.context.webGLVersion,
                  )
                : t.texImage2D(
                    t.TEXTURE_2D,
                    0,
                    t.RGBA,
                    e.pixelWidth,
                    e.pixelHeight,
                    0,
                    t.RGBA,
                    t.UNSIGNED_BYTE,
                    null,
                  ),
              e.autoGenerateMipmaps && e.mipLevelCount > 1 && this.onUpdateMipmaps(e, !1))
          }
          onUpdateMipmaps(e, t = !0) {
            t && this.bindSource(e, 0)
            let i = this.getGlSource(e)
            this._gl.generateMipmap(i.target)
          }
          onSourceDestroy(e) {
            ;(e.off("destroy", this.onSourceDestroy, this),
              e.off("update", this.onSourceUpdate, this),
              e.off("resize", this.onSourceUpdate, this),
              e.off("unload", this.onSourceUnload, this),
              e.off("styleChange", this.onStyleChange, this),
              e.off("updateMipmaps", this.onUpdateMipmaps, this),
              this.managedTextures.splice(this.managedTextures.indexOf(e), 1),
              this.onSourceUnload(e))
          }
          _initSampler(e) {
            let t = this._gl,
              i = this._gl.createSampler()
            return (
              (this._glSamplers[e._resourceId] = i),
              Jf(
                e,
                t,
                this._boundTextures[this._activeTextureLocation].mipLevelCount > 1,
                this._renderer.context.extensions.anisotropicFiltering,
                "samplerParameteri",
                i,
                !1,
                !0,
              ),
              this._glSamplers[e._resourceId]
            )
          }
          _getGlSampler(e) {
            return this._glSamplers[e._resourceId] || this._initSampler(e)
          }
          getGlSource(e) {
            return this._glTextures[e.uid] || this._initSource(e)
          }
          generateCanvas(e) {
            let { pixels: t, width: i, height: n } = this.getPixels(e),
              s = Z.get().createCanvas()
            ;((s.width = i), (s.height = n))
            let o = s.getContext("2d")
            if (o) {
              let a = o.createImageData(i, n)
              ;(a.data.set(t), o.putImageData(a, 0, 0))
            }
            return s
          }
          getPixels(e) {
            let t = e.source.resolution,
              i = e.frame,
              n = Math.max(Math.round(i.width * t), 1),
              s = Math.max(Math.round(i.height * t), 1),
              o = new Uint8Array(YR * n * s),
              a = this._renderer,
              u = a.renderTarget.getRenderTarget(e),
              l = a.renderTarget.getGpuRenderTarget(u),
              c = a.gl
            return (
              c.bindFramebuffer(c.FRAMEBUFFER, l.resolveTargetFramebuffer),
              c.readPixels(
                Math.round(i.x * t),
                Math.round(i.y * t),
                n,
                s,
                c.RGBA,
                c.UNSIGNED_BYTE,
                o,
              ),
              { pixels: new Uint8ClampedArray(o.buffer), width: n, height: s }
            )
          }
          destroy() {
            ;(this.managedTextures.slice().forEach((e) => this.onSourceDestroy(e)),
              (this.managedTextures = null),
              (this._renderer = null))
          }
          resetState() {
            ;((this._activeTextureLocation = -1),
              this._boundTextures.fill(I.EMPTY.source),
              (this._boundSamplers = Object.create(null)))
            let e = this._gl
            ;((this._premultiplyAlpha = !1),
              e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiplyAlpha))
          }
        }))
      Io.extension = { type: [_.WebGLSystem], name: "texture" }
    })
  var RC = {}
  uc(RC, { WebGLRenderer: () => ep })
  var KR,
    jR,
    qR,
    AC,
    DC,
    PC,
    ep,
    FC = d(() => {
      D()
      aT()
      uT()
      lT()
      Ls()
      wf()
      Qt()
      dT()
      mT()
      yT()
      ST()
      TT()
      CT()
      ET()
      RT()
      IT()
      QT()
      nC()
      lC()
      MC()
      ;((KR = [...el, Po, vT, pT, Eo, Io, Ro, wo, Bo, Fo, Ao, uC, Do, Mo]),
        (jR = [...tl]),
        (qR = [To, So, vo]),
        (AC = []),
        (DC = []),
        (PC = []))
      L.handleByNamedList(_.WebGLSystem, AC)
      L.handleByNamedList(_.WebGLPipes, DC)
      L.handleByNamedList(_.WebGLPipesAdaptor, PC)
      L.add(...KR, ...jR, ...qR)
      ep = class extends kr {
        constructor() {
          let e = {
            name: "webgl",
            type: ke.WEBGL,
            systems: AC,
            renderPipes: DC,
            renderPipeAdaptors: PC,
          }
          super(e)
        }
      }
    })
  async function IC(r) {
    let e = []
    r.preference
      ? (e.push(r.preference),
        BC.forEach((s) => {
          s !== r.preference && e.push(s)
        }))
      : (e = BC.slice())
    let t,
      i = {}
    for (let s = 0; s < e.length; s++) {
      let o = e[s]
      if (o === "webgpu" && (await yv())) {
        let { WebGPURenderer: a } = await Promise.resolve().then(() => (oT(), sT))
        ;((t = a), (i = { ...r, ...r.webgpu }))
        break
      } else if (
        o === "webgl" &&
        xv(r.failIfMajorPerformanceCaveat ?? kr.defaultOptions.failIfMajorPerformanceCaveat)
      ) {
        let { WebGLRenderer: a } = await Promise.resolve().then(() => (FC(), RC))
        ;((t = a), (i = { ...r, ...r.webgl }))
        break
      } else if (o === "canvas")
        throw ((i = { ...r }), new Error("CanvasRenderer is not yet implemented"))
    }
    if ((delete i.webgpu, delete i.webgl, !t))
      throw new Error("No available renderer for the current environment")
    let n = new t()
    return (await n.init(i), n)
  }
  var BC,
    GC = d(() => {
      _v()
      bv()
      Ls()
      BC = ["webgl", "webgpu", "canvas"]
    })
  var kC,
    vl,
    UC = d(() => {
      D()
      GC()
      Gt()
      ff()
      Te()
      kC = class tp {
        constructor(...e) {
          ;((this.stage = new xe()),
            e[0] !== void 0 &&
              z(
                K,
                "Application constructor options are deprecated, please use Application.init() instead.",
              ))
        }
        async init(e) {
          ;((e = { ...e }),
            (this.renderer = await IC(e)),
            tp._plugins.forEach((t) => {
              t.init.call(this, e)
            }))
        }
        render() {
          this.renderer.render({ container: this.stage })
        }
        get canvas() {
          return this.renderer.canvas
        }
        get view() {
          return (
            z(K, "Application.view is deprecated, please use Application.canvas instead."),
            this.renderer.canvas
          )
        }
        get screen() {
          return this.renderer.screen
        }
        destroy(e = !1, t = !1) {
          let i = tp._plugins.slice(0)
          ;(i.reverse(),
            i.forEach((n) => {
              n.destroy.call(this)
            }),
            this.stage.destroy(t),
            (this.stage = null),
            this.renderer.destroy(e),
            (this.renderer = null))
        }
      }
      kC._plugins = []
      vl = kC
      L.handleByList(_.Application, vl._plugins)
      L.add(js)
    })
  function OC(r, e) {
    let t = r[0] ?? {}
    return (
      (typeof t == "string" || r[1]) &&
        (z(K, `use new ${e}({ text: "hi!", style }) instead`), (t = { text: t, style: r[1] })),
      t
    )
  }
  var Sl,
    LC = d(() => {
      Da()
      Te()
      Ka()
      Sl = class extends wr {
        constructor(e, t) {
          let {
            text: i,
            resolution: n,
            style: s,
            anchor: o,
            width: a,
            height: u,
            roundPixels: l,
            ...c
          } = e
          ;(super({ ...c }),
            (this.batched = !0),
            (this._resolution = null),
            (this._autoResolution = !0),
            (this._didTextUpdate = !0),
            (this._styleClass = t),
            (this.text = i ?? ""),
            (this.style = s),
            (this.resolution = n ?? null),
            (this.allowChildren = !1),
            (this._anchor = new Xe({
              _onUpdate: () => {
                this.onViewUpdate()
              },
            })),
            o && (this.anchor = o),
            (this.roundPixels = l ?? !1),
            a !== void 0 && (this.width = a),
            u !== void 0 && (this.height = u))
        }
        get anchor() {
          return this._anchor
        }
        set anchor(e) {
          typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e)
        }
        set text(e) {
          ;((e = e.toString()), this._text !== e && ((this._text = e), this.onViewUpdate()))
        }
        get text() {
          return this._text
        }
        set resolution(e) {
          ;((this._autoResolution = e === null), (this._resolution = e), this.onViewUpdate())
        }
        get resolution() {
          return this._resolution
        }
        get style() {
          return this._style
        }
        set style(e) {
          ;(e || (e = {}),
            this._style?.off("update", this.onViewUpdate, this),
            e instanceof this._styleClass
              ? (this._style = e)
              : (this._style = new this._styleClass(e)),
            this._style.on("update", this.onViewUpdate, this),
            this.onViewUpdate())
        }
        get width() {
          return Math.abs(this.scale.x) * this.bounds.width
        }
        set width(e) {
          this._setWidth(e, this.bounds.width)
        }
        get height() {
          return Math.abs(this.scale.y) * this.bounds.height
        }
        set height(e) {
          this._setHeight(e, this.bounds.height)
        }
        getSize(e) {
          return (
            e || (e = {}),
            (e.width = Math.abs(this.scale.x) * this.bounds.width),
            (e.height = Math.abs(this.scale.y) * this.bounds.height),
            e
          )
        }
        setSize(e, t) {
          ;(typeof e == "object" ? ((t = e.height ?? e.width), (e = e.width)) : (t ?? (t = e)),
            e !== void 0 && this._setWidth(e, this.bounds.width),
            t !== void 0 && this._setHeight(t, this.bounds.height))
        }
        containsPoint(e) {
          let t = this.bounds.width,
            i = this.bounds.height,
            n = -t * this.anchor.x,
            s = 0
          return e.x >= n && e.x <= n + t && ((s = -i * this.anchor.y), e.y >= s && e.y <= s + i)
        }
        onViewUpdate() {
          ;(this.didViewUpdate || (this._didTextUpdate = !0), super.onViewUpdate())
        }
        _getKey() {
          return `${this.text}:${this._style.styleKey}:${this._resolution}`
        }
        destroy(e = !1) {
          ;(super.destroy(e),
            (this.owner = null),
            (this._bounds = null),
            (this._anchor = null),
            (typeof e == "boolean" ? e : e?.style) && this._style.destroy(e),
            (this._style = null),
            (this._text = null))
        }
      }
    })
  var Go,
    NC = d(() => {
      LC()
      Gu()
      hn()
      Go = class extends Sl {
        constructor(...e) {
          let t = OC(e, "Text")
          ;(super(t, mt), (this.renderPipeId = "text"))
        }
        updateBounds() {
          let e = this._bounds,
            t = this._anchor,
            i = Pt.measureText(this._text, this._style),
            { width: n, height: s } = i
          ;((e.minX = -t._x * n),
            (e.maxX = e.minX + n),
            (e.minY = -t._y * s),
            (e.maxY = e.minY + s))
        }
      }
    })
  var ZR,
    HC = d(() => {
      ov()
      lv()
      D()
      tu()
      ja()
      UC()
      bd()
      Sh()
      Gt()
      Hd()
      NC()
      Je()
      ZR = Un(qh(), 1)
      L.add(sv, uv)
    })
  var zC = d(() => {})
  var WC = d(() => {})
  function $C() {
    for (var r = 0, e = arguments.length, t = {}, i; r < e; ++r) {
      if (!(i = arguments[r] + "") || i in t || /[\s.]/.test(i))
        throw new Error("illegal type: " + i)
      t[i] = []
    }
    return new Tl(t)
  }
  function Tl(r) {
    this._ = r
  }
  function JR(r, e) {
    return r
      .trim()
      .split(/^|\s+/)
      .map(function (t) {
        var i = "",
          n = t.indexOf(".")
        if ((n >= 0 && ((i = t.slice(n + 1)), (t = t.slice(0, n))), t && !e.hasOwnProperty(t)))
          throw new Error("unknown type: " + t)
        return { type: t, name: i }
      })
  }
  function eF(r, e) {
    for (var t = 0, i = r.length, n; t < i; ++t) if ((n = r[t]).name === e) return n.value
  }
  function VC(r, e, t) {
    for (var i = 0, n = r.length; i < n; ++i)
      if (r[i].name === e) {
        ;((r[i] = QR), (r = r.slice(0, i).concat(r.slice(i + 1))))
        break
      }
    return (t != null && r.push({ name: e, value: t }), r)
  }
  var QR,
    yi,
    XC = d(() => {
      QR = { value: () => {} }
      Tl.prototype = $C.prototype = {
        constructor: Tl,
        on: function (r, e) {
          var t = this._,
            i = JR(r + "", t),
            n,
            s = -1,
            o = i.length
          if (arguments.length < 2) {
            for (; ++s < o; ) if ((n = (r = i[s]).type) && (n = eF(t[n], r.name))) return n
            return
          }
          if (e != null && typeof e != "function") throw new Error("invalid callback: " + e)
          for (; ++s < o; )
            if ((n = (r = i[s]).type)) t[n] = VC(t[n], r.name, e)
            else if (e == null) for (n in t) t[n] = VC(t[n], r.name, null)
          return this
        },
        copy: function () {
          var r = {},
            e = this._
          for (var t in e) r[t] = e[t].slice()
          return new Tl(r)
        },
        call: function (r, e) {
          if ((n = arguments.length - 2) > 0)
            for (var t = new Array(n), i = 0, n, s; i < n; ++i) t[i] = arguments[i + 2]
          if (!this._.hasOwnProperty(r)) throw new Error("unknown type: " + r)
          for (s = this._[r], i = 0, n = s.length; i < n; ++i) s[i].value.apply(e, t)
        },
        apply: function (r, e, t) {
          if (!this._.hasOwnProperty(r)) throw new Error("unknown type: " + r)
          for (var i = this._[r], n = 0, s = i.length; n < s; ++n) i[n].value.apply(e, t)
        },
      }
      yi = $C
    })
  var ko = d(() => {
    XC()
  })
  var Cl,
    rp,
    ip = d(() => {
      ;((Cl = "http://www.w3.org/1999/xhtml"),
        (rp = {
          svg: "http://www.w3.org/2000/svg",
          xhtml: Cl,
          xlink: "http://www.w3.org/1999/xlink",
          xml: "http://www.w3.org/XML/1998/namespace",
          xmlns: "http://www.w3.org/2000/xmlns/",
        }))
    })
  function gr(r) {
    var e = (r += ""),
      t = e.indexOf(":")
    return (
      t >= 0 && (e = r.slice(0, t)) !== "xmlns" && (r = r.slice(t + 1)),
      rp.hasOwnProperty(e) ? { space: rp[e], local: r } : r
    )
  }
  var El = d(() => {
    ip()
  })
  function tF(r) {
    return function () {
      var e = this.ownerDocument,
        t = this.namespaceURI
      return t === Cl && e.documentElement.namespaceURI === Cl
        ? e.createElement(r)
        : e.createElementNS(t, r)
    }
  }
  function rF(r) {
    return function () {
      return this.ownerDocument.createElementNS(r.space, r.local)
    }
  }
  function wl(r) {
    var e = gr(r)
    return (e.local ? rF : tF)(e)
  }
  var np = d(() => {
    El()
    ip()
  })
  function iF() {}
  function bi(r) {
    return r == null
      ? iF
      : function () {
          return this.querySelector(r)
        }
  }
  var Ml = d(() => {})
  function YC(r) {
    typeof r != "function" && (r = bi(r))
    for (var e = this._groups, t = e.length, i = new Array(t), n = 0; n < t; ++n)
      for (var s = e[n], o = s.length, a = (i[n] = new Array(o)), u, l, c = 0; c < o; ++c)
        (u = s[c]) &&
          (l = r.call(u, u.__data__, c, s)) &&
          ("__data__" in u && (l.__data__ = u.__data__), (a[c] = l))
    return new Pe(i, this._parents)
  }
  var KC = d(() => {
    Nt()
    Ml()
  })
  function sp(r) {
    return r == null ? [] : Array.isArray(r) ? r : Array.from(r)
  }
  var jC = d(() => {})
  function nF() {
    return []
  }
  function Uo(r) {
    return r == null
      ? nF
      : function () {
          return this.querySelectorAll(r)
        }
  }
  var op = d(() => {})
  function sF(r) {
    return function () {
      return sp(r.apply(this, arguments))
    }
  }
  function qC(r) {
    typeof r == "function" ? (r = sF(r)) : (r = Uo(r))
    for (var e = this._groups, t = e.length, i = [], n = [], s = 0; s < t; ++s)
      for (var o = e[s], a = o.length, u, l = 0; l < a; ++l)
        (u = o[l]) && (i.push(r.call(u, u.__data__, l, o)), n.push(u))
    return new Pe(i, n)
  }
  var ZC = d(() => {
    Nt()
    jC()
    op()
  })
  function Oo(r) {
    return function () {
      return this.matches(r)
    }
  }
  function Al(r) {
    return function (e) {
      return e.matches(r)
    }
  }
  var Lo = d(() => {})
  function aF(r) {
    return function () {
      return oF.call(this.children, r)
    }
  }
  function uF() {
    return this.firstElementChild
  }
  function QC(r) {
    return this.select(r == null ? uF : aF(typeof r == "function" ? r : Al(r)))
  }
  var oF,
    JC = d(() => {
      Lo()
      oF = Array.prototype.find
    })
  function cF() {
    return Array.from(this.children)
  }
  function hF(r) {
    return function () {
      return lF.call(this.children, r)
    }
  }
  function eE(r) {
    return this.selectAll(r == null ? cF : hF(typeof r == "function" ? r : Al(r)))
  }
  var lF,
    tE = d(() => {
      Lo()
      lF = Array.prototype.filter
    })
  function rE(r) {
    typeof r != "function" && (r = Oo(r))
    for (var e = this._groups, t = e.length, i = new Array(t), n = 0; n < t; ++n)
      for (var s = e[n], o = s.length, a = (i[n] = []), u, l = 0; l < o; ++l)
        (u = s[l]) && r.call(u, u.__data__, l, s) && a.push(u)
    return new Pe(i, this._parents)
  }
  var iE = d(() => {
    Nt()
    Lo()
  })
  function Dl(r) {
    return new Array(r.length)
  }
  var ap = d(() => {})
  function nE() {
    return new Pe(this._enter || this._groups.map(Dl), this._parents)
  }
  function No(r, e) {
    ;((this.ownerDocument = r.ownerDocument),
      (this.namespaceURI = r.namespaceURI),
      (this._next = null),
      (this._parent = r),
      (this.__data__ = e))
  }
  var up = d(() => {
    ap()
    Nt()
    No.prototype = {
      constructor: No,
      appendChild: function (r) {
        return this._parent.insertBefore(r, this._next)
      },
      insertBefore: function (r, e) {
        return this._parent.insertBefore(r, e)
      },
      querySelector: function (r) {
        return this._parent.querySelector(r)
      },
      querySelectorAll: function (r) {
        return this._parent.querySelectorAll(r)
      },
    }
  })
  function sE(r) {
    return function () {
      return r
    }
  }
  var oE = d(() => {})
  function dF(r, e, t, i, n, s) {
    for (var o = 0, a, u = e.length, l = s.length; o < l; ++o)
      (a = e[o]) ? ((a.__data__ = s[o]), (i[o] = a)) : (t[o] = new No(r, s[o]))
    for (; o < u; ++o) (a = e[o]) && (n[o] = a)
  }
  function fF(r, e, t, i, n, s, o) {
    var a,
      u,
      l = new Map(),
      c = e.length,
      h = s.length,
      f = new Array(c),
      p
    for (a = 0; a < c; ++a)
      (u = e[a]) &&
        ((f[a] = p = o.call(u, u.__data__, a, e) + ""), l.has(p) ? (n[a] = u) : l.set(p, u))
    for (a = 0; a < h; ++a)
      ((p = o.call(r, s[a], a, s) + ""),
        (u = l.get(p)) ? ((i[a] = u), (u.__data__ = s[a]), l.delete(p)) : (t[a] = new No(r, s[a])))
    for (a = 0; a < c; ++a) (u = e[a]) && l.get(f[a]) === u && (n[a] = u)
  }
  function pF(r) {
    return r.__data__
  }
  function aE(r, e) {
    if (!arguments.length) return Array.from(this, pF)
    var t = e ? fF : dF,
      i = this._parents,
      n = this._groups
    typeof r != "function" && (r = sE(r))
    for (
      var s = n.length, o = new Array(s), a = new Array(s), u = new Array(s), l = 0;
      l < s;
      ++l
    ) {
      var c = i[l],
        h = n[l],
        f = h.length,
        p = mF(r.call(c, c && c.__data__, l, i)),
        m = p.length,
        g = (a[l] = new Array(m)),
        x = (o[l] = new Array(m)),
        y = (u[l] = new Array(f))
      t(c, h, g, x, y, p, e)
      for (var v = 0, S = 0, b, M; v < m; ++v)
        if ((b = g[v])) {
          for (v >= S && (S = v + 1); !(M = x[S]) && ++S < m; );
          b._next = M || null
        }
    }
    return ((o = new Pe(o, i)), (o._enter = a), (o._exit = u), o)
  }
  function mF(r) {
    return typeof r == "object" && "length" in r ? r : Array.from(r)
  }
  var uE = d(() => {
    Nt()
    up()
    oE()
  })
  function lE() {
    return new Pe(this._exit || this._groups.map(Dl), this._parents)
  }
  var cE = d(() => {
    ap()
    Nt()
  })
  function hE(r, e, t) {
    var i = this.enter(),
      n = this,
      s = this.exit()
    return (
      typeof r == "function" ? ((i = r(i)), i && (i = i.selection())) : (i = i.append(r + "")),
      e != null && ((n = e(n)), n && (n = n.selection())),
      t == null ? s.remove() : t(s),
      i && n ? i.merge(n).order() : n
    )
  }
  var dE = d(() => {})
  function fE(r) {
    for (
      var e = r.selection ? r.selection() : r,
        t = this._groups,
        i = e._groups,
        n = t.length,
        s = i.length,
        o = Math.min(n, s),
        a = new Array(n),
        u = 0;
      u < o;
      ++u
    )
      for (var l = t[u], c = i[u], h = l.length, f = (a[u] = new Array(h)), p, m = 0; m < h; ++m)
        (p = l[m] || c[m]) && (f[m] = p)
    for (; u < n; ++u) a[u] = t[u]
    return new Pe(a, this._parents)
  }
  var pE = d(() => {
    Nt()
  })
  function mE() {
    for (var r = this._groups, e = -1, t = r.length; ++e < t; )
      for (var i = r[e], n = i.length - 1, s = i[n], o; --n >= 0; )
        (o = i[n]) &&
          (s && o.compareDocumentPosition(s) ^ 4 && s.parentNode.insertBefore(o, s), (s = o))
    return this
  }
  var gE = d(() => {})
  function xE(r) {
    r || (r = gF)
    function e(h, f) {
      return h && f ? r(h.__data__, f.__data__) : !h - !f
    }
    for (var t = this._groups, i = t.length, n = new Array(i), s = 0; s < i; ++s) {
      for (var o = t[s], a = o.length, u = (n[s] = new Array(a)), l, c = 0; c < a; ++c)
        (l = o[c]) && (u[c] = l)
      u.sort(e)
    }
    return new Pe(n, this._parents).order()
  }
  function gF(r, e) {
    return r < e ? -1 : r > e ? 1 : r >= e ? 0 : NaN
  }
  var _E = d(() => {
    Nt()
  })
  function yE() {
    var r = arguments[0]
    return ((arguments[0] = this), r.apply(null, arguments), this)
  }
  var bE = d(() => {})
  function vE() {
    return Array.from(this)
  }
  var SE = d(() => {})
  function TE() {
    for (var r = this._groups, e = 0, t = r.length; e < t; ++e)
      for (var i = r[e], n = 0, s = i.length; n < s; ++n) {
        var o = i[n]
        if (o) return o
      }
    return null
  }
  var CE = d(() => {})
  function EE() {
    let r = 0
    for (let e of this) ++r
    return r
  }
  var wE = d(() => {})
  function ME() {
    return !this.node()
  }
  var AE = d(() => {})
  function DE(r) {
    for (var e = this._groups, t = 0, i = e.length; t < i; ++t)
      for (var n = e[t], s = 0, o = n.length, a; s < o; ++s)
        (a = n[s]) && r.call(a, a.__data__, s, n)
    return this
  }
  var PE = d(() => {})
  function xF(r) {
    return function () {
      this.removeAttribute(r)
    }
  }
  function _F(r) {
    return function () {
      this.removeAttributeNS(r.space, r.local)
    }
  }
  function yF(r, e) {
    return function () {
      this.setAttribute(r, e)
    }
  }
  function bF(r, e) {
    return function () {
      this.setAttributeNS(r.space, r.local, e)
    }
  }
  function vF(r, e) {
    return function () {
      var t = e.apply(this, arguments)
      t == null ? this.removeAttribute(r) : this.setAttribute(r, t)
    }
  }
  function SF(r, e) {
    return function () {
      var t = e.apply(this, arguments)
      t == null
        ? this.removeAttributeNS(r.space, r.local)
        : this.setAttributeNS(r.space, r.local, t)
    }
  }
  function RE(r, e) {
    var t = gr(r)
    if (arguments.length < 2) {
      var i = this.node()
      return t.local ? i.getAttributeNS(t.space, t.local) : i.getAttribute(t)
    }
    return this.each(
      (e == null
        ? t.local
          ? _F
          : xF
        : typeof e == "function"
          ? t.local
            ? SF
            : vF
          : t.local
            ? bF
            : yF)(t, e),
    )
  }
  var FE = d(() => {
    El()
  })
  function Pl(r) {
    return (r.ownerDocument && r.ownerDocument.defaultView) || (r.document && r) || r.defaultView
  }
  var lp = d(() => {})
  function TF(r) {
    return function () {
      this.style.removeProperty(r)
    }
  }
  function CF(r, e, t) {
    return function () {
      this.style.setProperty(r, e, t)
    }
  }
  function EF(r, e, t) {
    return function () {
      var i = e.apply(this, arguments)
      i == null ? this.style.removeProperty(r) : this.style.setProperty(r, i, t)
    }
  }
  function BE(r, e, t) {
    return arguments.length > 1
      ? this.each((e == null ? TF : typeof e == "function" ? EF : CF)(r, e, t ?? ""))
      : Lr(this.node(), r)
  }
  function Lr(r, e) {
    return r.style.getPropertyValue(e) || Pl(r).getComputedStyle(r, null).getPropertyValue(e)
  }
  var cp = d(() => {
    lp()
  })
  function wF(r) {
    return function () {
      delete this[r]
    }
  }
  function MF(r, e) {
    return function () {
      this[r] = e
    }
  }
  function AF(r, e) {
    return function () {
      var t = e.apply(this, arguments)
      t == null ? delete this[r] : (this[r] = t)
    }
  }
  function IE(r, e) {
    return arguments.length > 1
      ? this.each((e == null ? wF : typeof e == "function" ? AF : MF)(r, e))
      : this.node()[r]
  }
  var GE = d(() => {})
  function kE(r) {
    return r.trim().split(/^|\s+/)
  }
  function hp(r) {
    return r.classList || new UE(r)
  }
  function UE(r) {
    ;((this._node = r), (this._names = kE(r.getAttribute("class") || "")))
  }
  function OE(r, e) {
    for (var t = hp(r), i = -1, n = e.length; ++i < n; ) t.add(e[i])
  }
  function LE(r, e) {
    for (var t = hp(r), i = -1, n = e.length; ++i < n; ) t.remove(e[i])
  }
  function DF(r) {
    return function () {
      OE(this, r)
    }
  }
  function PF(r) {
    return function () {
      LE(this, r)
    }
  }
  function RF(r, e) {
    return function () {
      ;(e.apply(this, arguments) ? OE : LE)(this, r)
    }
  }
  function NE(r, e) {
    var t = kE(r + "")
    if (arguments.length < 2) {
      for (var i = hp(this.node()), n = -1, s = t.length; ++n < s; )
        if (!i.contains(t[n])) return !1
      return !0
    }
    return this.each((typeof e == "function" ? RF : e ? DF : PF)(t, e))
  }
  var HE = d(() => {
    UE.prototype = {
      add: function (r) {
        var e = this._names.indexOf(r)
        e < 0 && (this._names.push(r), this._node.setAttribute("class", this._names.join(" ")))
      },
      remove: function (r) {
        var e = this._names.indexOf(r)
        e >= 0 &&
          (this._names.splice(e, 1), this._node.setAttribute("class", this._names.join(" ")))
      },
      contains: function (r) {
        return this._names.indexOf(r) >= 0
      },
    }
  })
  function FF() {
    this.textContent = ""
  }
  function BF(r) {
    return function () {
      this.textContent = r
    }
  }
  function IF(r) {
    return function () {
      var e = r.apply(this, arguments)
      this.textContent = e ?? ""
    }
  }
  function zE(r) {
    return arguments.length
      ? this.each(r == null ? FF : (typeof r == "function" ? IF : BF)(r))
      : this.node().textContent
  }
  var WE = d(() => {})
  function GF() {
    this.innerHTML = ""
  }
  function kF(r) {
    return function () {
      this.innerHTML = r
    }
  }
  function UF(r) {
    return function () {
      var e = r.apply(this, arguments)
      this.innerHTML = e ?? ""
    }
  }
  function VE(r) {
    return arguments.length
      ? this.each(r == null ? GF : (typeof r == "function" ? UF : kF)(r))
      : this.node().innerHTML
  }
  var $E = d(() => {})
  function OF() {
    this.nextSibling && this.parentNode.appendChild(this)
  }
  function XE() {
    return this.each(OF)
  }
  var YE = d(() => {})
  function LF() {
    this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild)
  }
  function KE() {
    return this.each(LF)
  }
  var jE = d(() => {})
  function qE(r) {
    var e = typeof r == "function" ? r : wl(r)
    return this.select(function () {
      return this.appendChild(e.apply(this, arguments))
    })
  }
  var ZE = d(() => {
    np()
  })
  function NF() {
    return null
  }
  function QE(r, e) {
    var t = typeof r == "function" ? r : wl(r),
      i = e == null ? NF : typeof e == "function" ? e : bi(e)
    return this.select(function () {
      return this.insertBefore(t.apply(this, arguments), i.apply(this, arguments) || null)
    })
  }
  var JE = d(() => {
    np()
    Ml()
  })
  function HF() {
    var r = this.parentNode
    r && r.removeChild(this)
  }
  function ew() {
    return this.each(HF)
  }
  var tw = d(() => {})
  function zF() {
    var r = this.cloneNode(!1),
      e = this.parentNode
    return e ? e.insertBefore(r, this.nextSibling) : r
  }
  function WF() {
    var r = this.cloneNode(!0),
      e = this.parentNode
    return e ? e.insertBefore(r, this.nextSibling) : r
  }
  function rw(r) {
    return this.select(r ? WF : zF)
  }
  var iw = d(() => {})
  function nw(r) {
    return arguments.length ? this.property("__data__", r) : this.node().__data__
  }
  var sw = d(() => {})
  function VF(r) {
    return function (e) {
      r.call(this, e, this.__data__)
    }
  }
  function $F(r) {
    return r
      .trim()
      .split(/^|\s+/)
      .map(function (e) {
        var t = "",
          i = e.indexOf(".")
        return (i >= 0 && ((t = e.slice(i + 1)), (e = e.slice(0, i))), { type: e, name: t })
      })
  }
  function XF(r) {
    return function () {
      var e = this.__on
      if (e) {
        for (var t = 0, i = -1, n = e.length, s; t < n; ++t)
          ((s = e[t]),
            (!r.type || s.type === r.type) && s.name === r.name
              ? this.removeEventListener(s.type, s.listener, s.options)
              : (e[++i] = s))
        ++i ? (e.length = i) : delete this.__on
      }
    }
  }
  function YF(r, e, t) {
    return function () {
      var i = this.__on,
        n,
        s = VF(e)
      if (i) {
        for (var o = 0, a = i.length; o < a; ++o)
          if ((n = i[o]).type === r.type && n.name === r.name) {
            ;(this.removeEventListener(n.type, n.listener, n.options),
              this.addEventListener(n.type, (n.listener = s), (n.options = t)),
              (n.value = e))
            return
          }
      }
      ;(this.addEventListener(r.type, s, t),
        (n = { type: r.type, name: r.name, value: e, listener: s, options: t }),
        i ? i.push(n) : (this.__on = [n]))
    }
  }
  function ow(r, e, t) {
    var i = $F(r + ""),
      n,
      s = i.length,
      o
    if (arguments.length < 2) {
      var a = this.node().__on
      if (a) {
        for (var u = 0, l = a.length, c; u < l; ++u)
          for (n = 0, c = a[u]; n < s; ++n)
            if ((o = i[n]).type === c.type && o.name === c.name) return c.value
      }
      return
    }
    for (a = e ? YF : XF, n = 0; n < s; ++n) this.each(a(i[n], e, t))
    return this
  }
  var aw = d(() => {})
  function uw(r, e, t) {
    var i = Pl(r),
      n = i.CustomEvent
    ;(typeof n == "function"
      ? (n = new n(e, t))
      : ((n = i.document.createEvent("Event")),
        t
          ? (n.initEvent(e, t.bubbles, t.cancelable), (n.detail = t.detail))
          : n.initEvent(e, !1, !1)),
      r.dispatchEvent(n))
  }
  function KF(r, e) {
    return function () {
      return uw(this, r, e)
    }
  }
  function jF(r, e) {
    return function () {
      return uw(this, r, e.apply(this, arguments))
    }
  }
  function lw(r, e) {
    return this.each((typeof e == "function" ? jF : KF)(r, e))
  }
  var cw = d(() => {
    lp()
  })
  function* hw() {
    for (var r = this._groups, e = 0, t = r.length; e < t; ++e)
      for (var i = r[e], n = 0, s = i.length, o; n < s; ++n) (o = i[n]) && (yield o)
  }
  var dw = d(() => {})
  function Pe(r, e) {
    ;((this._groups = r), (this._parents = e))
  }
  function fw() {
    return new Pe([[document.documentElement]], dp)
  }
  function qF() {
    return this
  }
  var dp,
    xr,
    Nt = d(() => {
      KC()
      ZC()
      JC()
      tE()
      iE()
      uE()
      up()
      cE()
      dE()
      pE()
      gE()
      _E()
      bE()
      SE()
      CE()
      wE()
      AE()
      PE()
      FE()
      cp()
      GE()
      HE()
      WE()
      $E()
      YE()
      jE()
      ZE()
      JE()
      tw()
      iw()
      sw()
      aw()
      cw()
      dw()
      dp = [null]
      Pe.prototype = fw.prototype = {
        constructor: Pe,
        select: YC,
        selectAll: qC,
        selectChild: QC,
        selectChildren: eE,
        filter: rE,
        data: aE,
        enter: nE,
        exit: lE,
        join: hE,
        merge: fE,
        selection: qF,
        order: mE,
        sort: xE,
        call: yE,
        nodes: vE,
        node: TE,
        size: EE,
        empty: ME,
        each: DE,
        attr: RE,
        style: BE,
        property: IE,
        classed: NE,
        text: zE,
        html: VE,
        raise: XE,
        lower: KE,
        append: qE,
        insert: QE,
        remove: ew,
        clone: rw,
        datum: nw,
        on: ow,
        dispatch: lw,
        [Symbol.iterator]: hw,
      }
      xr = fw
    })
  function je(r) {
    return typeof r == "string"
      ? new Pe([[document.querySelector(r)]], [document.documentElement])
      : new Pe([[r]], dp)
  }
  var pw = d(() => {
    Nt()
  })
  function mw(r) {
    let e
    for (; (e = r.sourceEvent); ) r = e
    return r
  }
  var gw = d(() => {})
  function Rt(r, e) {
    if (((r = mw(r)), e === void 0 && (e = r.currentTarget), e)) {
      var t = e.ownerSVGElement || e
      if (t.createSVGPoint) {
        var i = t.createSVGPoint()
        return (
          (i.x = r.clientX),
          (i.y = r.clientY),
          (i = i.matrixTransform(e.getScreenCTM().inverse())),
          [i.x, i.y]
        )
      }
      if (e.getBoundingClientRect) {
        var n = e.getBoundingClientRect()
        return [r.clientX - n.left - e.clientLeft, r.clientY - n.top - e.clientTop]
      }
    }
    return [r.pageX, r.pageY]
  }
  var xw = d(() => {
    gw()
  })
  var gt = d(() => {
    Lo()
    El()
    xw()
    pw()
    Nt()
    Ml()
    op()
    cp()
  })
  function Rl(r) {
    r.stopImmediatePropagation()
  }
  function Nr(r) {
    ;(r.preventDefault(), r.stopImmediatePropagation())
  }
  var _w,
    vi,
    fp = d(() => {
      ;((_w = { passive: !1 }), (vi = { capture: !0, passive: !1 }))
    })
  function Ho(r) {
    var e = r.document.documentElement,
      t = je(r).on("dragstart.drag", Nr, vi)
    "onselectstart" in e
      ? t.on("selectstart.drag", Nr, vi)
      : ((e.__noselect = e.style.MozUserSelect), (e.style.MozUserSelect = "none"))
  }
  function zo(r, e) {
    var t = r.document.documentElement,
      i = je(r).on("dragstart.drag", null)
    ;(e &&
      (i.on("click.drag", Nr, vi),
      setTimeout(function () {
        i.on("click.drag", null)
      }, 0)),
      "onselectstart" in t
        ? i.on("selectstart.drag", null)
        : ((t.style.MozUserSelect = t.__noselect), delete t.__noselect))
  }
  var pp = d(() => {
    gt()
    fp()
  })
  var Wo,
    yw = d(() => {
      Wo = (r) => () => r
    })
  function Vo(
    r,
    {
      sourceEvent: e,
      subject: t,
      target: i,
      identifier: n,
      active: s,
      x: o,
      y: a,
      dx: u,
      dy: l,
      dispatch: c,
    },
  ) {
    Object.defineProperties(this, {
      type: { value: r, enumerable: !0, configurable: !0 },
      sourceEvent: { value: e, enumerable: !0, configurable: !0 },
      subject: { value: t, enumerable: !0, configurable: !0 },
      target: { value: i, enumerable: !0, configurable: !0 },
      identifier: { value: n, enumerable: !0, configurable: !0 },
      active: { value: s, enumerable: !0, configurable: !0 },
      x: { value: o, enumerable: !0, configurable: !0 },
      y: { value: a, enumerable: !0, configurable: !0 },
      dx: { value: u, enumerable: !0, configurable: !0 },
      dy: { value: l, enumerable: !0, configurable: !0 },
      _: { value: c },
    })
  }
  var bw = d(() => {
    Vo.prototype.on = function () {
      var r = this._.on.apply(this._, arguments)
      return r === this._ ? this : r
    }
  })
  function ZF(r) {
    return !r.ctrlKey && !r.button
  }
  function QF() {
    return this.parentNode
  }
  function JF(r, e) {
    return e ?? { x: r.x, y: r.y }
  }
  function eB() {
    return navigator.maxTouchPoints || "ontouchstart" in this
  }
  function mp() {
    var r = ZF,
      e = QF,
      t = JF,
      i = eB,
      n = {},
      s = yi("start", "drag", "end"),
      o = 0,
      a,
      u,
      l,
      c,
      h = 0
    function f(b) {
      b.on("mousedown.drag", p)
        .filter(i)
        .on("touchstart.drag", x)
        .on("touchmove.drag", y, _w)
        .on("touchend.drag touchcancel.drag", v)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)")
    }
    function p(b, M) {
      if (!(c || !r.call(this, b, M))) {
        var C = S(this, e.call(this, b, M), b, M, "mouse")
        C &&
          (je(b.view).on("mousemove.drag", m, vi).on("mouseup.drag", g, vi),
          Ho(b.view),
          Rl(b),
          (l = !1),
          (a = b.clientX),
          (u = b.clientY),
          C("start", b))
      }
    }
    function m(b) {
      if ((Nr(b), !l)) {
        var M = b.clientX - a,
          C = b.clientY - u
        l = M * M + C * C > h
      }
      n.mouse("drag", b)
    }
    function g(b) {
      ;(je(b.view).on("mousemove.drag mouseup.drag", null), zo(b.view, l), Nr(b), n.mouse("end", b))
    }
    function x(b, M) {
      if (r.call(this, b, M)) {
        var C = b.changedTouches,
          w = e.call(this, b, M),
          B = C.length,
          O,
          G
        for (O = 0; O < B; ++O)
          (G = S(this, w, b, M, C[O].identifier, C[O])) && (Rl(b), G("start", b, C[O]))
      }
    }
    function y(b) {
      var M = b.changedTouches,
        C = M.length,
        w,
        B
      for (w = 0; w < C; ++w) (B = n[M[w].identifier]) && (Nr(b), B("drag", b, M[w]))
    }
    function v(b) {
      var M = b.changedTouches,
        C = M.length,
        w,
        B
      for (
        c && clearTimeout(c),
          c = setTimeout(function () {
            c = null
          }, 500),
          w = 0;
        w < C;
        ++w
      )
        (B = n[M[w].identifier]) && (Rl(b), B("end", b, M[w]))
    }
    function S(b, M, C, w, B, O) {
      var G = s.copy(),
        A = Rt(O || C, M),
        W,
        Y,
        T
      if (
        (T = t.call(
          b,
          new Vo("beforestart", {
            sourceEvent: C,
            target: f,
            identifier: B,
            active: o,
            x: A[0],
            y: A[1],
            dx: 0,
            dy: 0,
            dispatch: G,
          }),
          w,
        )) != null
      )
        return (
          (W = T.x - A[0] || 0),
          (Y = T.y - A[1] || 0),
          function N(E, P, $) {
            var k = A,
              X
            switch (E) {
              case "start":
                ;((n[B] = N), (X = o++))
                break
              case "end":
                ;(delete n[B], --o)
              case "drag":
                ;((A = Rt($ || P, M)), (X = o))
                break
            }
            G.call(
              E,
              b,
              new Vo(E, {
                sourceEvent: P,
                subject: T,
                target: f,
                identifier: B,
                active: X,
                x: A[0] + W,
                y: A[1] + Y,
                dx: A[0] - k[0],
                dy: A[1] - k[1],
                dispatch: G,
              }),
              w,
            )
          }
        )
    }
    return (
      (f.filter = function (b) {
        return arguments.length ? ((r = typeof b == "function" ? b : Wo(!!b)), f) : r
      }),
      (f.container = function (b) {
        return arguments.length ? ((e = typeof b == "function" ? b : Wo(b)), f) : e
      }),
      (f.subject = function (b) {
        return arguments.length ? ((t = typeof b == "function" ? b : Wo(b)), f) : t
      }),
      (f.touchable = function (b) {
        return arguments.length ? ((i = typeof b == "function" ? b : Wo(!!b)), f) : i
      }),
      (f.on = function () {
        var b = s.on.apply(s, arguments)
        return b === s ? f : b
      }),
      (f.clickDistance = function (b) {
        return arguments.length ? ((h = (b = +b) * b), f) : Math.sqrt(h)
      }),
      f
    )
  }
  var vw = d(() => {
    ko()
    gt()
    pp()
    fp()
    yw()
    bw()
  })
  var gp = d(() => {
    vw()
    pp()
  })
  function Fl(r, e, t) {
    ;((r.prototype = e.prototype = t), (t.constructor = r))
  }
  function xp(r, e) {
    var t = Object.create(r.prototype)
    for (var i in e) t[i] = e[i]
    return t
  }
  var Sw = d(() => {})
  function Yo() {}
  function Cw() {
    return this.rgb().formatHex()
  }
  function uB() {
    return this.rgb().formatHex8()
  }
  function lB() {
    return Rw(this).formatHsl()
  }
  function Ew() {
    return this.rgb().formatRgb()
  }
  function Hr(r) {
    var e, t
    return (
      (r = (r + "").trim().toLowerCase()),
      (e = tB.exec(r))
        ? ((t = e[1].length),
          (e = parseInt(e[1], 16)),
          t === 6
            ? ww(e)
            : t === 3
              ? new xt(
                  ((e >> 8) & 15) | ((e >> 4) & 240),
                  ((e >> 4) & 15) | (e & 240),
                  ((e & 15) << 4) | (e & 15),
                  1,
                )
              : t === 8
                ? Bl((e >> 24) & 255, (e >> 16) & 255, (e >> 8) & 255, (e & 255) / 255)
                : t === 4
                  ? Bl(
                      ((e >> 12) & 15) | ((e >> 8) & 240),
                      ((e >> 8) & 15) | ((e >> 4) & 240),
                      ((e >> 4) & 15) | (e & 240),
                      (((e & 15) << 4) | (e & 15)) / 255,
                    )
                  : null)
        : (e = rB.exec(r))
          ? new xt(e[1], e[2], e[3], 1)
          : (e = iB.exec(r))
            ? new xt((e[1] * 255) / 100, (e[2] * 255) / 100, (e[3] * 255) / 100, 1)
            : (e = nB.exec(r))
              ? Bl(e[1], e[2], e[3], e[4])
              : (e = sB.exec(r))
                ? Bl((e[1] * 255) / 100, (e[2] * 255) / 100, (e[3] * 255) / 100, e[4])
                : (e = oB.exec(r))
                  ? Dw(e[1], e[2] / 100, e[3] / 100, 1)
                  : (e = aB.exec(r))
                    ? Dw(e[1], e[2] / 100, e[3] / 100, e[4])
                    : Tw.hasOwnProperty(r)
                      ? ww(Tw[r])
                      : r === "transparent"
                        ? new xt(NaN, NaN, NaN, 0)
                        : null
    )
  }
  function ww(r) {
    return new xt((r >> 16) & 255, (r >> 8) & 255, r & 255, 1)
  }
  function Bl(r, e, t, i) {
    return (i <= 0 && (r = e = t = NaN), new xt(r, e, t, i))
  }
  function cB(r) {
    return (
      r instanceof Yo || (r = Hr(r)),
      r ? ((r = r.rgb()), new xt(r.r, r.g, r.b, r.opacity)) : new xt()
    )
  }
  function Mn(r, e, t, i) {
    return arguments.length === 1 ? cB(r) : new xt(r, e, t, i ?? 1)
  }
  function xt(r, e, t, i) {
    ;((this.r = +r), (this.g = +e), (this.b = +t), (this.opacity = +i))
  }
  function Mw() {
    return `#${Si(this.r)}${Si(this.g)}${Si(this.b)}`
  }
  function hB() {
    return `#${Si(this.r)}${Si(this.g)}${Si(this.b)}${Si((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`
  }
  function Aw() {
    let r = kl(this.opacity)
    return `${r === 1 ? "rgb(" : "rgba("}${Ti(this.r)}, ${Ti(this.g)}, ${Ti(this.b)}${r === 1 ? ")" : `, ${r})`}`
  }
  function kl(r) {
    return isNaN(r) ? 1 : Math.max(0, Math.min(1, r))
  }
  function Ti(r) {
    return Math.max(0, Math.min(255, Math.round(r) || 0))
  }
  function Si(r) {
    return ((r = Ti(r)), (r < 16 ? "0" : "") + r.toString(16))
  }
  function Dw(r, e, t, i) {
    return (
      i <= 0 ? (r = e = t = NaN) : t <= 0 || t >= 1 ? (r = e = NaN) : e <= 0 && (r = NaN),
      new Ht(r, e, t, i)
    )
  }
  function Rw(r) {
    if (r instanceof Ht) return new Ht(r.h, r.s, r.l, r.opacity)
    if ((r instanceof Yo || (r = Hr(r)), !r)) return new Ht()
    if (r instanceof Ht) return r
    r = r.rgb()
    var e = r.r / 255,
      t = r.g / 255,
      i = r.b / 255,
      n = Math.min(e, t, i),
      s = Math.max(e, t, i),
      o = NaN,
      a = s - n,
      u = (s + n) / 2
    return (
      a
        ? (e === s
            ? (o = (t - i) / a + (t < i) * 6)
            : t === s
              ? (o = (i - e) / a + 2)
              : (o = (e - t) / a + 4),
          (a /= u < 0.5 ? s + n : 2 - s - n),
          (o *= 60))
        : (a = u > 0 && u < 1 ? 0 : o),
      new Ht(o, a, u, r.opacity)
    )
  }
  function Fw(r, e, t, i) {
    return arguments.length === 1 ? Rw(r) : new Ht(r, e, t, i ?? 1)
  }
  function Ht(r, e, t, i) {
    ;((this.h = +r), (this.s = +e), (this.l = +t), (this.opacity = +i))
  }
  function Pw(r) {
    return ((r = (r || 0) % 360), r < 0 ? r + 360 : r)
  }
  function Il(r) {
    return Math.max(0, Math.min(1, r || 0))
  }
  function _p(r, e, t) {
    return (
      (r < 60
        ? e + ((t - e) * r) / 60
        : r < 180
          ? t
          : r < 240
            ? e + ((t - e) * (240 - r)) / 60
            : e) * 255
    )
  }
  var $o,
    Gl,
    wn,
    Xo,
    ir,
    tB,
    rB,
    iB,
    nB,
    sB,
    oB,
    aB,
    Tw,
    Bw = d(() => {
      Sw()
      ;(($o = 0.7),
        (Gl = 1 / $o),
        (wn = "\\s*([+-]?\\d+)\\s*"),
        (Xo = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*"),
        (ir = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*"),
        (tB = /^#([0-9a-f]{3,8})$/),
        (rB = new RegExp(`^rgb\\(${wn},${wn},${wn}\\)$`)),
        (iB = new RegExp(`^rgb\\(${ir},${ir},${ir}\\)$`)),
        (nB = new RegExp(`^rgba\\(${wn},${wn},${wn},${Xo}\\)$`)),
        (sB = new RegExp(`^rgba\\(${ir},${ir},${ir},${Xo}\\)$`)),
        (oB = new RegExp(`^hsl\\(${Xo},${ir},${ir}\\)$`)),
        (aB = new RegExp(`^hsla\\(${Xo},${ir},${ir},${Xo}\\)$`)),
        (Tw = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        }))
      Fl(Yo, Hr, {
        copy(r) {
          return Object.assign(new this.constructor(), this, r)
        },
        displayable() {
          return this.rgb().displayable()
        },
        hex: Cw,
        formatHex: Cw,
        formatHex8: uB,
        formatHsl: lB,
        formatRgb: Ew,
        toString: Ew,
      })
      Fl(
        xt,
        Mn,
        xp(Yo, {
          brighter(r) {
            return (
              (r = r == null ? Gl : Math.pow(Gl, r)),
              new xt(this.r * r, this.g * r, this.b * r, this.opacity)
            )
          },
          darker(r) {
            return (
              (r = r == null ? $o : Math.pow($o, r)),
              new xt(this.r * r, this.g * r, this.b * r, this.opacity)
            )
          },
          rgb() {
            return this
          },
          clamp() {
            return new xt(Ti(this.r), Ti(this.g), Ti(this.b), kl(this.opacity))
          },
          displayable() {
            return (
              -0.5 <= this.r &&
              this.r < 255.5 &&
              -0.5 <= this.g &&
              this.g < 255.5 &&
              -0.5 <= this.b &&
              this.b < 255.5 &&
              0 <= this.opacity &&
              this.opacity <= 1
            )
          },
          hex: Mw,
          formatHex: Mw,
          formatHex8: hB,
          formatRgb: Aw,
          toString: Aw,
        }),
      )
      Fl(
        Ht,
        Fw,
        xp(Yo, {
          brighter(r) {
            return (
              (r = r == null ? Gl : Math.pow(Gl, r)),
              new Ht(this.h, this.s, this.l * r, this.opacity)
            )
          },
          darker(r) {
            return (
              (r = r == null ? $o : Math.pow($o, r)),
              new Ht(this.h, this.s, this.l * r, this.opacity)
            )
          },
          rgb() {
            var r = (this.h % 360) + (this.h < 0) * 360,
              e = isNaN(r) || isNaN(this.s) ? 0 : this.s,
              t = this.l,
              i = t + (t < 0.5 ? t : 1 - t) * e,
              n = 2 * t - i
            return new xt(
              _p(r >= 240 ? r - 240 : r + 120, n, i),
              _p(r, n, i),
              _p(r < 120 ? r + 240 : r - 120, n, i),
              this.opacity,
            )
          },
          clamp() {
            return new Ht(Pw(this.h), Il(this.s), Il(this.l), kl(this.opacity))
          },
          displayable() {
            return (
              ((0 <= this.s && this.s <= 1) || isNaN(this.s)) &&
              0 <= this.l &&
              this.l <= 1 &&
              0 <= this.opacity &&
              this.opacity <= 1
            )
          },
          formatHsl() {
            let r = kl(this.opacity)
            return `${r === 1 ? "hsl(" : "hsla("}${Pw(this.h)}, ${Il(this.s) * 100}%, ${Il(this.l) * 100}%${r === 1 ? ")" : `, ${r})`}`
          },
        }),
      )
    })
  var Ul = d(() => {
    Bw()
  })
  function yp(r, e, t, i, n) {
    var s = r * r,
      o = s * r
    return (
      ((1 - 3 * r + 3 * s - o) * e +
        (4 - 6 * s + 3 * o) * t +
        (1 + 3 * r + 3 * s - 3 * o) * i +
        o * n) /
      6
    )
  }
  function Iw(r) {
    var e = r.length - 1
    return function (t) {
      var i = t <= 0 ? (t = 0) : t >= 1 ? ((t = 1), e - 1) : Math.floor(t * e),
        n = r[i],
        s = r[i + 1],
        o = i > 0 ? r[i - 1] : 2 * n - s,
        a = i < e - 1 ? r[i + 2] : 2 * s - n
      return yp((t - i / e) * e, o, n, s, a)
    }
  }
  var bp = d(() => {})
  function Gw(r) {
    var e = r.length
    return function (t) {
      var i = Math.floor(((t %= 1) < 0 ? ++t : t) * e),
        n = r[(i + e - 1) % e],
        s = r[i % e],
        o = r[(i + 1) % e],
        a = r[(i + 2) % e]
      return yp((t - i / e) * e, n, s, o, a)
    }
  }
  var kw = d(() => {
    bp()
  })
  var vp,
    Uw = d(() => {
      vp = (r) => () => r
    })
  function dB(r, e) {
    return function (t) {
      return r + t * e
    }
  }
  function fB(r, e, t) {
    return (
      (r = Math.pow(r, t)),
      (e = Math.pow(e, t) - r),
      (t = 1 / t),
      function (i) {
        return Math.pow(r + i * e, t)
      }
    )
  }
  function Ow(r) {
    return (r = +r) == 1
      ? Ol
      : function (e, t) {
          return t - e ? fB(e, t, r) : vp(isNaN(e) ? t : e)
        }
  }
  function Ol(r, e) {
    var t = e - r
    return t ? dB(r, t) : vp(isNaN(r) ? e : r)
  }
  var Lw = d(() => {
    Uw()
  })
  function Nw(r) {
    return function (e) {
      var t = e.length,
        i = new Array(t),
        n = new Array(t),
        s = new Array(t),
        o,
        a
      for (o = 0; o < t; ++o)
        ((a = Mn(e[o])), (i[o] = a.r || 0), (n[o] = a.g || 0), (s[o] = a.b || 0))
      return (
        (i = r(i)),
        (n = r(n)),
        (s = r(s)),
        (a.opacity = 1),
        function (u) {
          return ((a.r = i(u)), (a.g = n(u)), (a.b = s(u)), a + "")
        }
      )
    }
  }
  var Ll,
    pB,
    mB,
    Hw = d(() => {
      Ul()
      bp()
      kw()
      Lw()
      Ll = (function r(e) {
        var t = Ow(e)
        function i(n, s) {
          var o = t((n = Mn(n)).r, (s = Mn(s)).r),
            a = t(n.g, s.g),
            u = t(n.b, s.b),
            l = Ol(n.opacity, s.opacity)
          return function (c) {
            return ((n.r = o(c)), (n.g = a(c)), (n.b = u(c)), (n.opacity = l(c)), n + "")
          }
        }
        return ((i.gamma = r), i)
      })(1)
      ;((pB = Nw(Iw)), (mB = Nw(Gw)))
    })
  function Ft(r, e) {
    return (
      (r = +r),
      (e = +e),
      function (t) {
        return r * (1 - t) + e * t
      }
    )
  }
  var Nl = d(() => {})
  function gB(r) {
    return function () {
      return r
    }
  }
  function xB(r) {
    return function (e) {
      return r(e) + ""
    }
  }
  function Cp(r, e) {
    var t = (Tp.lastIndex = Sp.lastIndex = 0),
      i,
      n,
      s,
      o = -1,
      a = [],
      u = []
    for (r = r + "", e = e + ""; (i = Tp.exec(r)) && (n = Sp.exec(e)); )
      ((s = n.index) > t && ((s = e.slice(t, s)), a[o] ? (a[o] += s) : (a[++o] = s)),
        (i = i[0]) === (n = n[0])
          ? a[o]
            ? (a[o] += n)
            : (a[++o] = n)
          : ((a[++o] = null), u.push({ i: o, x: Ft(i, n) })),
        (t = Sp.lastIndex))
    return (
      t < e.length && ((s = e.slice(t)), a[o] ? (a[o] += s) : (a[++o] = s)),
      a.length < 2
        ? u[0]
          ? xB(u[0].x)
          : gB(e)
        : ((e = u.length),
          function (l) {
            for (var c = 0, h; c < e; ++c) a[(h = u[c]).i] = h.x(l)
            return a.join("")
          })
    )
  }
  var Tp,
    Sp,
    zw = d(() => {
      Nl()
      ;((Tp = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g), (Sp = new RegExp(Tp.source, "g")))
    })
  function Ep(r, e, t, i, n, s) {
    var o, a, u
    return (
      (o = Math.sqrt(r * r + e * e)) && ((r /= o), (e /= o)),
      (u = r * t + e * i) && ((t -= r * u), (i -= e * u)),
      (a = Math.sqrt(t * t + i * i)) && ((t /= a), (i /= a), (u /= a)),
      r * i < e * t && ((r = -r), (e = -e), (u = -u), (o = -o)),
      {
        translateX: n,
        translateY: s,
        rotate: Math.atan2(e, r) * Ww,
        skewX: Math.atan(u) * Ww,
        scaleX: o,
        scaleY: a,
      }
    )
  }
  var Ww,
    Hl,
    Vw = d(() => {
      ;((Ww = 180 / Math.PI),
        (Hl = { translateX: 0, translateY: 0, rotate: 0, skewX: 0, scaleX: 1, scaleY: 1 }))
    })
  function $w(r) {
    let e = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(r + "")
    return e.isIdentity ? Hl : Ep(e.a, e.b, e.c, e.d, e.e, e.f)
  }
  function Xw(r) {
    return r == null
      ? Hl
      : (zl || (zl = document.createElementNS("http://www.w3.org/2000/svg", "g")),
        zl.setAttribute("transform", r),
        (r = zl.transform.baseVal.consolidate())
          ? ((r = r.matrix), Ep(r.a, r.b, r.c, r.d, r.e, r.f))
          : Hl)
  }
  var zl,
    Yw = d(() => {
      Vw()
    })
  function Kw(r, e, t, i) {
    function n(l) {
      return l.length ? l.pop() + " " : ""
    }
    function s(l, c, h, f, p, m) {
      if (l !== h || c !== f) {
        var g = p.push("translate(", null, e, null, t)
        m.push({ i: g - 4, x: Ft(l, h) }, { i: g - 2, x: Ft(c, f) })
      } else (h || f) && p.push("translate(" + h + e + f + t)
    }
    function o(l, c, h, f) {
      l !== c
        ? (l - c > 180 ? (c += 360) : c - l > 180 && (l += 360),
          f.push({ i: h.push(n(h) + "rotate(", null, i) - 2, x: Ft(l, c) }))
        : c && h.push(n(h) + "rotate(" + c + i)
    }
    function a(l, c, h, f) {
      l !== c
        ? f.push({ i: h.push(n(h) + "skewX(", null, i) - 2, x: Ft(l, c) })
        : c && h.push(n(h) + "skewX(" + c + i)
    }
    function u(l, c, h, f, p, m) {
      if (l !== h || c !== f) {
        var g = p.push(n(p) + "scale(", null, ",", null, ")")
        m.push({ i: g - 4, x: Ft(l, h) }, { i: g - 2, x: Ft(c, f) })
      } else (h !== 1 || f !== 1) && p.push(n(p) + "scale(" + h + "," + f + ")")
    }
    return function (l, c) {
      var h = [],
        f = []
      return (
        (l = r(l)),
        (c = r(c)),
        s(l.translateX, l.translateY, c.translateX, c.translateY, h, f),
        o(l.rotate, c.rotate, h, f),
        a(l.skewX, c.skewX, h, f),
        u(l.scaleX, l.scaleY, c.scaleX, c.scaleY, h, f),
        (l = c = null),
        function (p) {
          for (var m = -1, g = f.length, x; ++m < g; ) h[(x = f[m]).i] = x.x(p)
          return h.join("")
        }
      )
    }
  }
  var wp,
    Mp,
    jw = d(() => {
      Nl()
      Yw()
      ;((wp = Kw($w, "px, ", "px)", "deg)")), (Mp = Kw(Xw, ", ", ")", ")")))
    })
  function qw(r) {
    return ((r = Math.exp(r)) + 1 / r) / 2
  }
  function yB(r) {
    return ((r = Math.exp(r)) - 1 / r) / 2
  }
  function bB(r) {
    return ((r = Math.exp(2 * r)) - 1) / (r + 1)
  }
  var _B,
    Ap,
    Zw = d(() => {
      _B = 1e-12
      Ap = (function r(e, t, i) {
        function n(s, o) {
          var a = s[0],
            u = s[1],
            l = s[2],
            c = o[0],
            h = o[1],
            f = o[2],
            p = c - a,
            m = h - u,
            g = p * p + m * m,
            x,
            y
          if (g < _B)
            ((y = Math.log(f / l) / e),
              (x = function (w) {
                return [a + w * p, u + w * m, l * Math.exp(e * w * y)]
              }))
          else {
            var v = Math.sqrt(g),
              S = (f * f - l * l + i * g) / (2 * l * t * v),
              b = (f * f - l * l - i * g) / (2 * f * t * v),
              M = Math.log(Math.sqrt(S * S + 1) - S),
              C = Math.log(Math.sqrt(b * b + 1) - b)
            ;((y = (C - M) / e),
              (x = function (w) {
                var B = w * y,
                  O = qw(M),
                  G = (l / (t * v)) * (O * bB(e * B + M) - yB(M))
                return [a + G * p, u + G * m, (l * O) / qw(e * B + M)]
              }))
          }
          return ((x.duration = (y * 1e3 * e) / Math.SQRT2), x)
        }
        return (
          (n.rho = function (s) {
            var o = Math.max(0.001, +s),
              a = o * o,
              u = a * a
            return r(o, a, u)
          }),
          n
        )
      })(Math.SQRT2, 2, 4)
    })
  var An = d(() => {
    Nl()
    zw()
    jw()
    Zw()
    Hw()
  })
  function Jo() {
    return Ci || (e1(vB), (Ci = Zo.now() + $l))
  }
  function vB() {
    Ci = 0
  }
  function Qo() {
    this._call = this._time = this._next = null
  }
  function Xl(r, e, t) {
    var i = new Qo()
    return (i.restart(r, e, t), i)
  }
  function t1() {
    ;(Jo(), ++Dn)
    for (var r = Wl, e; r; ) ((e = Ci - r._time) >= 0 && r._call.call(void 0, e), (r = r._next))
    --Dn
  }
  function Qw() {
    ;((Ci = (Vl = Zo.now()) + $l), (Dn = jo = 0))
    try {
      t1()
    } finally {
      ;((Dn = 0), TB(), (Ci = 0))
    }
  }
  function SB() {
    var r = Zo.now(),
      e = r - Vl
    e > Jw && (($l -= e), (Vl = r))
  }
  function TB() {
    for (var r, e = Wl, t, i = 1 / 0; e; )
      e._call
        ? (i > e._time && (i = e._time), (r = e), (e = e._next))
        : ((t = e._next), (e._next = null), (e = r ? (r._next = t) : (Wl = t)))
    ;((qo = r), Dp(i))
  }
  function Dp(r) {
    if (!Dn) {
      jo && (jo = clearTimeout(jo))
      var e = r - Ci
      e > 24
        ? (r < 1 / 0 && (jo = setTimeout(Qw, r - Zo.now() - $l)), Ko && (Ko = clearInterval(Ko)))
        : (Ko || ((Vl = Zo.now()), (Ko = setInterval(SB, Jw))), (Dn = 1), e1(Qw))
    }
  }
  var Dn,
    jo,
    Ko,
    Jw,
    Wl,
    qo,
    Vl,
    Ci,
    $l,
    Zo,
    e1,
    Pp = d(() => {
      ;((Dn = 0),
        (jo = 0),
        (Ko = 0),
        (Jw = 1e3),
        (Vl = 0),
        (Ci = 0),
        ($l = 0),
        (Zo = typeof performance == "object" && performance.now ? performance : Date),
        (e1 =
          typeof window == "object" && window.requestAnimationFrame
            ? window.requestAnimationFrame.bind(window)
            : function (r) {
                setTimeout(r, 17)
              }))
      Qo.prototype = Xl.prototype = {
        constructor: Qo,
        restart: function (r, e, t) {
          if (typeof r != "function") throw new TypeError("callback is not a function")
          ;((t = (t == null ? Jo() : +t) + (e == null ? 0 : +e)),
            !this._next && qo !== this && (qo ? (qo._next = this) : (Wl = this), (qo = this)),
            (this._call = r),
            (this._time = t),
            Dp())
        },
        stop: function () {
          this._call && ((this._call = null), (this._time = 1 / 0), Dp())
        },
      }
    })
  function Yl(r, e, t) {
    var i = new Qo()
    return (
      (e = e == null ? 0 : +e),
      i.restart(
        (n) => {
          ;(i.stop(), r(n + e))
        },
        e,
        t,
      ),
      i
    )
  }
  var r1 = d(() => {
    Pp()
  })
  var Kl = d(() => {
    Pp()
    r1()
  })
  function zr(r, e, t, i, n, s) {
    var o = r.__transition
    if (!o) r.__transition = {}
    else if (t in o) return
    wB(r, t, {
      name: e,
      index: i,
      group: n,
      on: CB,
      tween: EB,
      time: s.time,
      delay: s.delay,
      duration: s.duration,
      ease: s.ease,
      timer: null,
      state: s1,
    })
  }
  function ta(r, e) {
    var t = Ue(r, e)
    if (t.state > s1) throw new Error("too late; already scheduled")
    return t
  }
  function qe(r, e) {
    var t = Ue(r, e)
    if (t.state > jl) throw new Error("too late; already running")
    return t
  }
  function Ue(r, e) {
    var t = r.__transition
    if (!t || !(t = t[e])) throw new Error("transition not found")
    return t
  }
  function wB(r, e, t) {
    var i = r.__transition,
      n
    ;((i[e] = t), (t.timer = Xl(s, 0, t.time)))
    function s(l) {
      ;((t.state = i1), t.timer.restart(o, t.delay, t.time), t.delay <= l && o(l - t.delay))
    }
    function o(l) {
      var c, h, f, p
      if (t.state !== i1) return u()
      for (c in i)
        if (((p = i[c]), p.name === t.name)) {
          if (p.state === jl) return Yl(o)
          p.state === n1
            ? ((p.state = ea),
              p.timer.stop(),
              p.on.call("interrupt", r, r.__data__, p.index, p.group),
              delete i[c])
            : +c < e &&
              ((p.state = ea),
              p.timer.stop(),
              p.on.call("cancel", r, r.__data__, p.index, p.group),
              delete i[c])
        }
      if (
        (Yl(function () {
          t.state === jl && ((t.state = n1), t.timer.restart(a, t.delay, t.time), a(l))
        }),
        (t.state = ql),
        t.on.call("start", r, r.__data__, t.index, t.group),
        t.state === ql)
      ) {
        for (t.state = jl, n = new Array((f = t.tween.length)), c = 0, h = -1; c < f; ++c)
          (p = t.tween[c].value.call(r, r.__data__, t.index, t.group)) && (n[++h] = p)
        n.length = h + 1
      }
    }
    function a(l) {
      for (
        var c =
            l < t.duration
              ? t.ease.call(null, l / t.duration)
              : (t.timer.restart(u), (t.state = Zl), 1),
          h = -1,
          f = n.length;
        ++h < f;

      )
        n[h].call(r, c)
      t.state === Zl && (t.on.call("end", r, r.__data__, t.index, t.group), u())
    }
    function u() {
      ;((t.state = ea), t.timer.stop(), delete i[e])
      for (var l in i) return
      delete r.__transition
    }
  }
  var CB,
    EB,
    s1,
    i1,
    ql,
    jl,
    n1,
    Zl,
    ea,
    _t = d(() => {
      ko()
      Kl()
      ;((CB = yi("start", "end", "cancel", "interrupt")),
        (EB = []),
        (s1 = 0),
        (i1 = 1),
        (ql = 2),
        (jl = 3),
        (n1 = 4),
        (Zl = 5),
        (ea = 6))
    })
  function Wr(r, e) {
    var t = r.__transition,
      i,
      n,
      s = !0,
      o
    if (t) {
      e = e == null ? null : e + ""
      for (o in t) {
        if ((i = t[o]).name !== e) {
          s = !1
          continue
        }
        ;((n = i.state > ql && i.state < Zl),
          (i.state = ea),
          i.timer.stop(),
          i.on.call(n ? "interrupt" : "cancel", r, r.__data__, i.index, i.group),
          delete t[o])
      }
      s && delete r.__transition
    }
  }
  var Rp = d(() => {
    _t()
  })
  function o1(r) {
    return this.each(function () {
      Wr(this, r)
    })
  }
  var a1 = d(() => {
    Rp()
  })
  function MB(r, e) {
    var t, i
    return function () {
      var n = qe(this, r),
        s = n.tween
      if (s !== t) {
        i = t = s
        for (var o = 0, a = i.length; o < a; ++o)
          if (i[o].name === e) {
            ;((i = i.slice()), i.splice(o, 1))
            break
          }
      }
      n.tween = i
    }
  }
  function AB(r, e, t) {
    var i, n
    if (typeof t != "function") throw new Error()
    return function () {
      var s = qe(this, r),
        o = s.tween
      if (o !== i) {
        n = (i = o).slice()
        for (var a = { name: e, value: t }, u = 0, l = n.length; u < l; ++u)
          if (n[u].name === e) {
            n[u] = a
            break
          }
        u === l && n.push(a)
      }
      s.tween = n
    }
  }
  function u1(r, e) {
    var t = this._id
    if (((r += ""), arguments.length < 2)) {
      for (var i = Ue(this.node(), t).tween, n = 0, s = i.length, o; n < s; ++n)
        if ((o = i[n]).name === r) return o.value
      return null
    }
    return this.each((e == null ? MB : AB)(t, r, e))
  }
  function Pn(r, e, t) {
    var i = r._id
    return (
      r.each(function () {
        var n = qe(this, i)
        ;(n.value || (n.value = {}))[e] = t.apply(this, arguments)
      }),
      function (n) {
        return Ue(n, i).value[e]
      }
    )
  }
  var ra = d(() => {
    _t()
  })
  function Ql(r, e) {
    var t
    return (typeof e == "number" ? Ft : e instanceof Hr ? Ll : (t = Hr(e)) ? ((e = t), Ll) : Cp)(
      r,
      e,
    )
  }
  var Fp = d(() => {
    Ul()
    An()
  })
  function DB(r) {
    return function () {
      this.removeAttribute(r)
    }
  }
  function PB(r) {
    return function () {
      this.removeAttributeNS(r.space, r.local)
    }
  }
  function RB(r, e, t) {
    var i,
      n = t + "",
      s
    return function () {
      var o = this.getAttribute(r)
      return o === n ? null : o === i ? s : (s = e((i = o), t))
    }
  }
  function FB(r, e, t) {
    var i,
      n = t + "",
      s
    return function () {
      var o = this.getAttributeNS(r.space, r.local)
      return o === n ? null : o === i ? s : (s = e((i = o), t))
    }
  }
  function BB(r, e, t) {
    var i, n, s
    return function () {
      var o,
        a = t(this),
        u
      return a == null
        ? void this.removeAttribute(r)
        : ((o = this.getAttribute(r)),
          (u = a + ""),
          o === u ? null : o === i && u === n ? s : ((n = u), (s = e((i = o), a))))
    }
  }
  function IB(r, e, t) {
    var i, n, s
    return function () {
      var o,
        a = t(this),
        u
      return a == null
        ? void this.removeAttributeNS(r.space, r.local)
        : ((o = this.getAttributeNS(r.space, r.local)),
          (u = a + ""),
          o === u ? null : o === i && u === n ? s : ((n = u), (s = e((i = o), a))))
    }
  }
  function l1(r, e) {
    var t = gr(r),
      i = t === "transform" ? Mp : Ql
    return this.attrTween(
      r,
      typeof e == "function"
        ? (t.local ? IB : BB)(t, i, Pn(this, "attr." + r, e))
        : e == null
          ? (t.local ? PB : DB)(t)
          : (t.local ? FB : RB)(t, i, e),
    )
  }
  var c1 = d(() => {
    An()
    gt()
    ra()
    Fp()
  })
  function GB(r, e) {
    return function (t) {
      this.setAttribute(r, e.call(this, t))
    }
  }
  function kB(r, e) {
    return function (t) {
      this.setAttributeNS(r.space, r.local, e.call(this, t))
    }
  }
  function UB(r, e) {
    var t, i
    function n() {
      var s = e.apply(this, arguments)
      return (s !== i && (t = (i = s) && kB(r, s)), t)
    }
    return ((n._value = e), n)
  }
  function OB(r, e) {
    var t, i
    function n() {
      var s = e.apply(this, arguments)
      return (s !== i && (t = (i = s) && GB(r, s)), t)
    }
    return ((n._value = e), n)
  }
  function h1(r, e) {
    var t = "attr." + r
    if (arguments.length < 2) return (t = this.tween(t)) && t._value
    if (e == null) return this.tween(t, null)
    if (typeof e != "function") throw new Error()
    var i = gr(r)
    return this.tween(t, (i.local ? UB : OB)(i, e))
  }
  var d1 = d(() => {
    gt()
  })
  function LB(r, e) {
    return function () {
      ta(this, r).delay = +e.apply(this, arguments)
    }
  }
  function NB(r, e) {
    return (
      (e = +e),
      function () {
        ta(this, r).delay = e
      }
    )
  }
  function f1(r) {
    var e = this._id
    return arguments.length
      ? this.each((typeof r == "function" ? LB : NB)(e, r))
      : Ue(this.node(), e).delay
  }
  var p1 = d(() => {
    _t()
  })
  function HB(r, e) {
    return function () {
      qe(this, r).duration = +e.apply(this, arguments)
    }
  }
  function zB(r, e) {
    return (
      (e = +e),
      function () {
        qe(this, r).duration = e
      }
    )
  }
  function m1(r) {
    var e = this._id
    return arguments.length
      ? this.each((typeof r == "function" ? HB : zB)(e, r))
      : Ue(this.node(), e).duration
  }
  var g1 = d(() => {
    _t()
  })
  function WB(r, e) {
    if (typeof e != "function") throw new Error()
    return function () {
      qe(this, r).ease = e
    }
  }
  function x1(r) {
    var e = this._id
    return arguments.length ? this.each(WB(e, r)) : Ue(this.node(), e).ease
  }
  var _1 = d(() => {
    _t()
  })
  function VB(r, e) {
    return function () {
      var t = e.apply(this, arguments)
      if (typeof t != "function") throw new Error()
      qe(this, r).ease = t
    }
  }
  function y1(r) {
    if (typeof r != "function") throw new Error()
    return this.each(VB(this._id, r))
  }
  var b1 = d(() => {
    _t()
  })
  function v1(r) {
    typeof r != "function" && (r = Oo(r))
    for (var e = this._groups, t = e.length, i = new Array(t), n = 0; n < t; ++n)
      for (var s = e[n], o = s.length, a = (i[n] = []), u, l = 0; l < o; ++l)
        (u = s[l]) && r.call(u, u.__data__, l, s) && a.push(u)
    return new at(i, this._parents, this._name, this._id)
  }
  var S1 = d(() => {
    gt()
    Ei()
  })
  function T1(r) {
    if (r._id !== this._id) throw new Error()
    for (
      var e = this._groups,
        t = r._groups,
        i = e.length,
        n = t.length,
        s = Math.min(i, n),
        o = new Array(i),
        a = 0;
      a < s;
      ++a
    )
      for (var u = e[a], l = t[a], c = u.length, h = (o[a] = new Array(c)), f, p = 0; p < c; ++p)
        (f = u[p] || l[p]) && (h[p] = f)
    for (; a < i; ++a) o[a] = e[a]
    return new at(o, this._parents, this._name, this._id)
  }
  var C1 = d(() => {
    Ei()
  })
  function $B(r) {
    return (r + "")
      .trim()
      .split(/^|\s+/)
      .every(function (e) {
        var t = e.indexOf(".")
        return (t >= 0 && (e = e.slice(0, t)), !e || e === "start")
      })
  }
  function XB(r, e, t) {
    var i,
      n,
      s = $B(e) ? ta : qe
    return function () {
      var o = s(this, r),
        a = o.on
      ;(a !== i && (n = (i = a).copy()).on(e, t), (o.on = n))
    }
  }
  function E1(r, e) {
    var t = this._id
    return arguments.length < 2 ? Ue(this.node(), t).on.on(r) : this.each(XB(t, r, e))
  }
  var w1 = d(() => {
    _t()
  })
  function YB(r) {
    return function () {
      var e = this.parentNode
      for (var t in this.__transition) if (+t !== r) return
      e && e.removeChild(this)
    }
  }
  function M1() {
    return this.on("end.remove", YB(this._id))
  }
  var A1 = d(() => {})
  function D1(r) {
    var e = this._name,
      t = this._id
    typeof r != "function" && (r = bi(r))
    for (var i = this._groups, n = i.length, s = new Array(n), o = 0; o < n; ++o)
      for (var a = i[o], u = a.length, l = (s[o] = new Array(u)), c, h, f = 0; f < u; ++f)
        (c = a[f]) &&
          (h = r.call(c, c.__data__, f, a)) &&
          ("__data__" in c && (h.__data__ = c.__data__), (l[f] = h), zr(l[f], e, t, f, l, Ue(c, t)))
    return new at(s, this._parents, e, t)
  }
  var P1 = d(() => {
    gt()
    Ei()
    _t()
  })
  function R1(r) {
    var e = this._name,
      t = this._id
    typeof r != "function" && (r = Uo(r))
    for (var i = this._groups, n = i.length, s = [], o = [], a = 0; a < n; ++a)
      for (var u = i[a], l = u.length, c, h = 0; h < l; ++h)
        if ((c = u[h])) {
          for (
            var f = r.call(c, c.__data__, h, u), p, m = Ue(c, t), g = 0, x = f.length;
            g < x;
            ++g
          )
            (p = f[g]) && zr(p, e, t, g, f, m)
          ;(s.push(f), o.push(c))
        }
    return new at(s, o, e, t)
  }
  var F1 = d(() => {
    gt()
    Ei()
    _t()
  })
  function B1() {
    return new KB(this._groups, this._parents)
  }
  var KB,
    I1 = d(() => {
      gt()
      KB = xr.prototype.constructor
    })
  function jB(r, e) {
    var t, i, n
    return function () {
      var s = Lr(this, r),
        o = (this.style.removeProperty(r), Lr(this, r))
      return s === o ? null : s === t && o === i ? n : (n = e((t = s), (i = o)))
    }
  }
  function G1(r) {
    return function () {
      this.style.removeProperty(r)
    }
  }
  function qB(r, e, t) {
    var i,
      n = t + "",
      s
    return function () {
      var o = Lr(this, r)
      return o === n ? null : o === i ? s : (s = e((i = o), t))
    }
  }
  function ZB(r, e, t) {
    var i, n, s
    return function () {
      var o = Lr(this, r),
        a = t(this),
        u = a + ""
      return (
        a == null && (u = a = (this.style.removeProperty(r), Lr(this, r))),
        o === u ? null : o === i && u === n ? s : ((n = u), (s = e((i = o), a)))
      )
    }
  }
  function QB(r, e) {
    var t,
      i,
      n,
      s = "style." + e,
      o = "end." + s,
      a
    return function () {
      var u = qe(this, r),
        l = u.on,
        c = u.value[s] == null ? a || (a = G1(e)) : void 0
      ;((l !== t || n !== c) && (i = (t = l).copy()).on(o, (n = c)), (u.on = i))
    }
  }
  function k1(r, e, t) {
    var i = (r += "") == "transform" ? wp : Ql
    return e == null
      ? this.styleTween(r, jB(r, i)).on("end.style." + r, G1(r))
      : typeof e == "function"
        ? this.styleTween(r, ZB(r, i, Pn(this, "style." + r, e))).each(QB(this._id, r))
        : this.styleTween(r, qB(r, i, e), t).on("end.style." + r, null)
  }
  var U1 = d(() => {
    An()
    gt()
    _t()
    ra()
    Fp()
  })
  function JB(r, e, t) {
    return function (i) {
      this.style.setProperty(r, e.call(this, i), t)
    }
  }
  function e2(r, e, t) {
    var i, n
    function s() {
      var o = e.apply(this, arguments)
      return (o !== n && (i = (n = o) && JB(r, o, t)), i)
    }
    return ((s._value = e), s)
  }
  function O1(r, e, t) {
    var i = "style." + (r += "")
    if (arguments.length < 2) return (i = this.tween(i)) && i._value
    if (e == null) return this.tween(i, null)
    if (typeof e != "function") throw new Error()
    return this.tween(i, e2(r, e, t ?? ""))
  }
  var L1 = d(() => {})
  function t2(r) {
    return function () {
      this.textContent = r
    }
  }
  function r2(r) {
    return function () {
      var e = r(this)
      this.textContent = e ?? ""
    }
  }
  function N1(r) {
    return this.tween(
      "text",
      typeof r == "function" ? r2(Pn(this, "text", r)) : t2(r == null ? "" : r + ""),
    )
  }
  var H1 = d(() => {
    ra()
  })
  function i2(r) {
    return function (e) {
      this.textContent = r.call(this, e)
    }
  }
  function n2(r) {
    var e, t
    function i() {
      var n = r.apply(this, arguments)
      return (n !== t && (e = (t = n) && i2(n)), e)
    }
    return ((i._value = r), i)
  }
  function z1(r) {
    var e = "text"
    if (arguments.length < 1) return (e = this.tween(e)) && e._value
    if (r == null) return this.tween(e, null)
    if (typeof r != "function") throw new Error()
    return this.tween(e, n2(r))
  }
  var W1 = d(() => {})
  function V1() {
    for (
      var r = this._name, e = this._id, t = Jl(), i = this._groups, n = i.length, s = 0;
      s < n;
      ++s
    )
      for (var o = i[s], a = o.length, u, l = 0; l < a; ++l)
        if ((u = o[l])) {
          var c = Ue(u, e)
          zr(u, r, t, l, o, {
            time: c.time + c.delay + c.duration,
            delay: 0,
            duration: c.duration,
            ease: c.ease,
          })
        }
    return new at(i, this._parents, r, t)
  }
  var $1 = d(() => {
    Ei()
    _t()
  })
  function X1() {
    var r,
      e,
      t = this,
      i = t._id,
      n = t.size()
    return new Promise(function (s, o) {
      var a = { value: o },
        u = {
          value: function () {
            --n === 0 && s()
          },
        }
      ;(t.each(function () {
        var l = qe(this, i),
          c = l.on
        ;(c !== r &&
          ((e = (r = c).copy()), e._.cancel.push(a), e._.interrupt.push(a), e._.end.push(u)),
          (l.on = e))
      }),
        n === 0 && s())
    })
  }
  var Y1 = d(() => {
    _t()
  })
  function at(r, e, t, i) {
    ;((this._groups = r), (this._parents = e), (this._name = t), (this._id = i))
  }
  function K1(r) {
    return xr().transition(r)
  }
  function Jl() {
    return ++s2
  }
  var s2,
    _r,
    Ei = d(() => {
      gt()
      c1()
      d1()
      p1()
      g1()
      _1()
      b1()
      S1()
      C1()
      w1()
      A1()
      P1()
      F1()
      I1()
      U1()
      L1()
      H1()
      W1()
      $1()
      ra()
      Y1()
      s2 = 0
      _r = xr.prototype
      at.prototype = K1.prototype = {
        constructor: at,
        select: D1,
        selectAll: R1,
        selectChild: _r.selectChild,
        selectChildren: _r.selectChildren,
        filter: v1,
        merge: T1,
        selection: B1,
        transition: V1,
        call: _r.call,
        nodes: _r.nodes,
        node: _r.node,
        size: _r.size,
        empty: _r.empty,
        each: _r.each,
        on: E1,
        attr: l1,
        attrTween: h1,
        style: k1,
        styleTween: O1,
        text: N1,
        textTween: z1,
        remove: M1,
        tween: u1,
        delay: f1,
        duration: m1,
        ease: x1,
        easeVarying: y1,
        end: X1,
        [Symbol.iterator]: _r[Symbol.iterator],
      }
    })
  function ec(r) {
    return ((r *= 2) <= 1 ? r * r * r : (r -= 2) * r * r + 2) / 2
  }
  var j1 = d(() => {})
  var Bp = d(() => {
    j1()
  })
  function a2(r, e) {
    for (var t; !(t = r.__transition) || !(t = t[e]); )
      if (!(r = r.parentNode)) throw new Error(`transition ${e} not found`)
    return t
  }
  function q1(r) {
    var e, t
    r instanceof at
      ? ((e = r._id), (r = r._name))
      : ((e = Jl()), ((t = o2).time = Jo()), (r = r == null ? null : r + ""))
    for (var i = this._groups, n = i.length, s = 0; s < n; ++s)
      for (var o = i[s], a = o.length, u, l = 0; l < a; ++l)
        (u = o[l]) && zr(u, r, e, l, o, t || a2(u, e))
    return new at(i, this._parents, r, e)
  }
  var o2,
    Z1 = d(() => {
      Ei()
      _t()
      Bp()
      Kl()
      o2 = { time: null, delay: 0, duration: 250, ease: ec }
    })
  var Q1 = d(() => {
    gt()
    a1()
    Z1()
    xr.prototype.interrupt = o1
    xr.prototype.transition = q1
  })
  var tc = d(() => {
    Q1()
    Rp()
  })
  var J1 = d(() => {})
  var eM = d(() => {})
  var tM = d(() => {})
  function rM(r) {
    return [+r[0], +r[1]]
  }
  function u2(r) {
    return [rM(r[0]), rM(r[1])]
  }
  function Ip(r) {
    return { type: r }
  }
  var Woe,
    Voe,
    $oe,
    Xoe,
    Yoe,
    Koe,
    iM = d(() => {
      tc()
      J1()
      eM()
      tM()
      ;({ abs: Woe, max: Voe, min: $oe } = Math)
      ;((Xoe = {
        name: "x",
        handles: ["w", "e"].map(Ip),
        input: function (r, e) {
          return r == null
            ? null
            : [
                [+r[0], e[0][1]],
                [+r[1], e[1][1]],
              ]
        },
        output: function (r) {
          return r && [r[0][0], r[1][0]]
        },
      }),
        (Yoe = {
          name: "y",
          handles: ["n", "s"].map(Ip),
          input: function (r, e) {
            return r == null
              ? null
              : [
                  [e[0][0], +r[0]],
                  [e[1][0], +r[1]],
                ]
          },
          output: function (r) {
            return r && [r[0][1], r[1][1]]
          },
        }),
        (Koe = {
          name: "xy",
          handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(Ip),
          input: function (r) {
            return r == null ? null : u2(r)
          },
          output: function (r) {
            return r
          },
        }))
    })
  var nM = d(() => {
    iM()
  })
  var sM = d(() => {})
  var oM = d(() => {})
  var aM = d(() => {})
  var uM = d(() => {})
  var lM = d(() => {})
  var cM = d(() => {})
  var hM = d(() => {})
  var dM = d(() => {})
  function fM(r) {
    return Math.abs((r = Math.round(r))) >= 1e21
      ? r.toLocaleString("en").replace(/,/g, "")
      : r.toString(10)
  }
  function wi(r, e) {
    if ((t = (r = e ? r.toExponential(e - 1) : r.toExponential()).indexOf("e")) < 0) return null
    var t,
      i = r.slice(0, t)
    return [i.length > 1 ? i[0] + i.slice(2) : i, +r.slice(t + 1)]
  }
  var ia = d(() => {})
  function pM(r) {
    return ((r = wi(Math.abs(r))), r ? r[1] : NaN)
  }
  var mM = d(() => {
    ia()
  })
  function gM(r, e) {
    return function (t, i) {
      for (
        var n = t.length, s = [], o = 0, a = r[0], u = 0;
        n > 0 &&
        a > 0 &&
        (u + a + 1 > i && (a = Math.max(1, i - u)),
        s.push(t.substring((n -= a), n + a)),
        !((u += a + 1) > i));

      )
        a = r[(o = (o + 1) % r.length)]
      return s.reverse().join(e)
    }
  }
  var xM = d(() => {})
  function _M(r) {
    return function (e) {
      return e.replace(/[0-9]/g, function (t) {
        return r[+t]
      })
    }
  }
  var yM = d(() => {})
  function na(r) {
    if (!(e = l2.exec(r))) throw new Error("invalid format: " + r)
    var e
    return new Gp({
      fill: e[1],
      align: e[2],
      sign: e[3],
      symbol: e[4],
      zero: e[5],
      width: e[6],
      comma: e[7],
      precision: e[8] && e[8].slice(1),
      trim: e[9],
      type: e[10],
    })
  }
  function Gp(r) {
    ;((this.fill = r.fill === void 0 ? " " : r.fill + ""),
      (this.align = r.align === void 0 ? ">" : r.align + ""),
      (this.sign = r.sign === void 0 ? "-" : r.sign + ""),
      (this.symbol = r.symbol === void 0 ? "" : r.symbol + ""),
      (this.zero = !!r.zero),
      (this.width = r.width === void 0 ? void 0 : +r.width),
      (this.comma = !!r.comma),
      (this.precision = r.precision === void 0 ? void 0 : +r.precision),
      (this.trim = !!r.trim),
      (this.type = r.type === void 0 ? "" : r.type + ""))
  }
  var l2,
    bM = d(() => {
      l2 = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i
      na.prototype = Gp.prototype
      Gp.prototype.toString = function () {
        return (
          this.fill +
          this.align +
          this.sign +
          this.symbol +
          (this.zero ? "0" : "") +
          (this.width === void 0 ? "" : Math.max(1, this.width | 0)) +
          (this.comma ? "," : "") +
          (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) +
          (this.trim ? "~" : "") +
          this.type
        )
      }
    })
  function vM(r) {
    e: for (var e = r.length, t = 1, i = -1, n; t < e; ++t)
      switch (r[t]) {
        case ".":
          i = n = t
          break
        case "0":
          ;(i === 0 && (i = t), (n = t))
          break
        default:
          if (!+r[t]) break e
          i > 0 && (i = 0)
          break
      }
    return i > 0 ? r.slice(0, i) + r.slice(n + 1) : r
  }
  var SM = d(() => {})
  function TM(r, e) {
    var t = wi(r, e)
    if (!t) return r + ""
    var i = t[0],
      n = t[1],
      s = n - (kp = Math.max(-8, Math.min(8, Math.floor(n / 3))) * 3) + 1,
      o = i.length
    return s === o
      ? i
      : s > o
        ? i + new Array(s - o + 1).join("0")
        : s > 0
          ? i.slice(0, s) + "." + i.slice(s)
          : "0." + new Array(1 - s).join("0") + wi(r, Math.max(0, e + s - 1))[0]
  }
  var kp,
    Up = d(() => {
      ia()
    })
  function Op(r, e) {
    var t = wi(r, e)
    if (!t) return r + ""
    var i = t[0],
      n = t[1]
    return n < 0
      ? "0." + new Array(-n).join("0") + i
      : i.length > n + 1
        ? i.slice(0, n + 1) + "." + i.slice(n + 1)
        : i + new Array(n - i.length + 2).join("0")
  }
  var CM = d(() => {
    ia()
  })
  var Lp,
    EM = d(() => {
      ia()
      Up()
      CM()
      Lp = {
        "%": (r, e) => (r * 100).toFixed(e),
        b: (r) => Math.round(r).toString(2),
        c: (r) => r + "",
        d: fM,
        e: (r, e) => r.toExponential(e),
        f: (r, e) => r.toFixed(e),
        g: (r, e) => r.toPrecision(e),
        o: (r) => Math.round(r).toString(8),
        p: (r, e) => Op(r * 100, e),
        r: Op,
        s: TM,
        X: (r) => Math.round(r).toString(16).toUpperCase(),
        x: (r) => Math.round(r).toString(16),
      }
    })
  function Np(r) {
    return r
  }
  var wM = d(() => {})
  function DM(r) {
    var e =
        r.grouping === void 0 || r.thousands === void 0
          ? Np
          : gM(MM.call(r.grouping, Number), r.thousands + ""),
      t = r.currency === void 0 ? "" : r.currency[0] + "",
      i = r.currency === void 0 ? "" : r.currency[1] + "",
      n = r.decimal === void 0 ? "." : r.decimal + "",
      s = r.numerals === void 0 ? Np : _M(MM.call(r.numerals, String)),
      o = r.percent === void 0 ? "%" : r.percent + "",
      a = r.minus === void 0 ? "\u2212" : r.minus + "",
      u = r.nan === void 0 ? "NaN" : r.nan + ""
    function l(h) {
      h = na(h)
      var f = h.fill,
        p = h.align,
        m = h.sign,
        g = h.symbol,
        x = h.zero,
        y = h.width,
        v = h.comma,
        S = h.precision,
        b = h.trim,
        M = h.type
      ;(M === "n"
        ? ((v = !0), (M = "g"))
        : Lp[M] || (S === void 0 && (S = 12), (b = !0), (M = "g")),
        (x || (f === "0" && p === "=")) && ((x = !0), (f = "0"), (p = "=")))
      var C = g === "$" ? t : g === "#" && /[boxX]/.test(M) ? "0" + M.toLowerCase() : "",
        w = g === "$" ? i : /[%p]/.test(M) ? o : "",
        B = Lp[M],
        O = /[defgprs%]/.test(M)
      S =
        S === void 0
          ? 6
          : /[gprs]/.test(M)
            ? Math.max(1, Math.min(21, S))
            : Math.max(0, Math.min(20, S))
      function G(A) {
        var W = C,
          Y = w,
          T,
          N,
          E
        if (M === "c") ((Y = B(A) + Y), (A = ""))
        else {
          A = +A
          var P = A < 0 || 1 / A < 0
          if (
            ((A = isNaN(A) ? u : B(Math.abs(A), S)),
            b && (A = vM(A)),
            P && +A == 0 && m !== "+" && (P = !1),
            (W = (P ? (m === "(" ? m : a) : m === "-" || m === "(" ? "" : m) + W),
            (Y = (M === "s" ? AM[8 + kp / 3] : "") + Y + (P && m === "(" ? ")" : "")),
            O)
          ) {
            for (T = -1, N = A.length; ++T < N; )
              if (((E = A.charCodeAt(T)), 48 > E || E > 57)) {
                ;((Y = (E === 46 ? n + A.slice(T + 1) : A.slice(T)) + Y), (A = A.slice(0, T)))
                break
              }
          }
        }
        v && !x && (A = e(A, 1 / 0))
        var $ = W.length + A.length + Y.length,
          k = $ < y ? new Array(y - $ + 1).join(f) : ""
        switch ((v && x && ((A = e(k + A, k.length ? y - Y.length : 1 / 0)), (k = "")), p)) {
          case "<":
            A = W + A + Y + k
            break
          case "=":
            A = W + k + A + Y
            break
          case "^":
            A = k.slice(0, ($ = k.length >> 1)) + W + A + Y + k.slice($)
            break
          default:
            A = k + W + A + Y
            break
        }
        return s(A)
      }
      return (
        (G.toString = function () {
          return h + ""
        }),
        G
      )
    }
    function c(h, f) {
      var p = l(((h = na(h)), (h.type = "f"), h)),
        m = Math.max(-8, Math.min(8, Math.floor(pM(f) / 3))) * 3,
        g = Math.pow(10, -m),
        x = AM[8 + m / 3]
      return function (y) {
        return p(g * y) + x
      }
    }
    return { format: l, formatPrefix: c }
  }
  var MM,
    AM,
    PM = d(() => {
      mM()
      xM()
      yM()
      bM()
      SM()
      EM()
      Up()
      wM()
      ;((MM = Array.prototype.map),
        (AM = [
          "y",
          "z",
          "a",
          "f",
          "p",
          "n",
          "\xB5",
          "m",
          "",
          "k",
          "M",
          "G",
          "T",
          "P",
          "E",
          "Z",
          "Y",
        ]))
    })
  function Hp(r) {
    return ((rc = DM(r)), (RM = rc.format), (FM = rc.formatPrefix), rc)
  }
  var rc,
    RM,
    FM,
    BM = d(() => {
      PM()
      Hp({ thousands: ",", grouping: [3], currency: ["$", ""] })
    })
  var IM = d(() => {
    BM()
  })
  var GM = d(() => {})
  var kM = d(() => {})
  var UM = d(() => {})
  var OM = d(() => {})
  function Tt(r, e, t, i) {
    function n(s) {
      return (r((s = arguments.length === 0 ? new Date() : new Date(+s))), s)
    }
    return (
      (n.floor = (s) => (r((s = new Date(+s))), s)),
      (n.ceil = (s) => (r((s = new Date(s - 1))), e(s, 1), r(s), s)),
      (n.round = (s) => {
        let o = n(s),
          a = n.ceil(s)
        return s - o < a - s ? o : a
      }),
      (n.offset = (s, o) => (e((s = new Date(+s)), o == null ? 1 : Math.floor(o)), s)),
      (n.range = (s, o, a) => {
        let u = []
        if (((s = n.ceil(s)), (a = a == null ? 1 : Math.floor(a)), !(s < o) || !(a > 0))) return u
        let l
        do (u.push((l = new Date(+s))), e(s, a), r(s))
        while (l < s && s < o)
        return u
      }),
      (n.filter = (s) =>
        Tt(
          (o) => {
            if (o >= o) for (; r(o), !s(o); ) o.setTime(o - 1)
          },
          (o, a) => {
            if (o >= o)
              if (a < 0) for (; ++a <= 0; ) for (; e(o, -1), !s(o); );
              else for (; --a >= 0; ) for (; e(o, 1), !s(o); );
          },
        )),
      t &&
        ((n.count = (s, o) => (
          zp.setTime(+s),
          Wp.setTime(+o),
          r(zp),
          r(Wp),
          Math.floor(t(zp, Wp))
        )),
        (n.every = (s) => (
          (s = Math.floor(s)),
          !isFinite(s) || !(s > 0)
            ? null
            : s > 1
              ? n.filter(i ? (o) => i(o) % s === 0 : (o) => n.count(0, o) % s === 0)
              : n
        ))),
      n
    )
  }
  var zp,
    Wp,
    ic = d(() => {
      ;((zp = new Date()), (Wp = new Date()))
    })
  var sa,
    h2,
    oa,
    d2,
    LM,
    f2,
    NM = d(() => {
      ic()
      ;((sa = Tt(
        (r) => r.setHours(0, 0, 0, 0),
        (r, e) => r.setDate(r.getDate() + e),
        (r, e) => (e - r - (e.getTimezoneOffset() - r.getTimezoneOffset()) * 6e4) / 864e5,
        (r) => r.getDate() - 1,
      )),
        (h2 = sa.range),
        (oa = Tt(
          (r) => {
            r.setUTCHours(0, 0, 0, 0)
          },
          (r, e) => {
            r.setUTCDate(r.getUTCDate() + e)
          },
          (r, e) => (e - r) / 864e5,
          (r) => r.getUTCDate() - 1,
        )),
        (d2 = oa.range),
        (LM = Tt(
          (r) => {
            r.setUTCHours(0, 0, 0, 0)
          },
          (r, e) => {
            r.setUTCDate(r.getUTCDate() + e)
          },
          (r, e) => (e - r) / 864e5,
          (r) => Math.floor(r / 864e5),
        )),
        (f2 = LM.range))
    })
  function Mi(r) {
    return Tt(
      (e) => {
        ;(e.setDate(e.getDate() - ((e.getDay() + 7 - r) % 7)), e.setHours(0, 0, 0, 0))
      },
      (e, t) => {
        e.setDate(e.getDate() + t * 7)
      },
      (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * 6e4) / 6048e5,
    )
  }
  function Ai(r) {
    return Tt(
      (e) => {
        ;(e.setUTCDate(e.getUTCDate() - ((e.getUTCDay() + 7 - r) % 7)), e.setUTCHours(0, 0, 0, 0))
      },
      (e, t) => {
        e.setUTCDate(e.getUTCDate() + t * 7)
      },
      (e, t) => (t - e) / 6048e5,
    )
  }
  var aa,
    Rn,
    HM,
    zM,
    Vr,
    WM,
    VM,
    $M,
    m2,
    g2,
    x2,
    _2,
    y2,
    b2,
    ua,
    Fn,
    XM,
    YM,
    $r,
    KM,
    jM,
    qM,
    v2,
    S2,
    T2,
    C2,
    E2,
    w2,
    ZM = d(() => {
      ic()
      ;((aa = Mi(0)),
        (Rn = Mi(1)),
        (HM = Mi(2)),
        (zM = Mi(3)),
        (Vr = Mi(4)),
        (WM = Mi(5)),
        (VM = Mi(6)),
        ($M = aa.range),
        (m2 = Rn.range),
        (g2 = HM.range),
        (x2 = zM.range),
        (_2 = Vr.range),
        (y2 = WM.range),
        (b2 = VM.range))
      ;((ua = Ai(0)),
        (Fn = Ai(1)),
        (XM = Ai(2)),
        (YM = Ai(3)),
        ($r = Ai(4)),
        (KM = Ai(5)),
        (jM = Ai(6)),
        (qM = ua.range),
        (v2 = Fn.range),
        (S2 = XM.range),
        (T2 = YM.range),
        (C2 = $r.range),
        (E2 = KM.range),
        (w2 = jM.range))
    })
  var yr,
    M2,
    br,
    A2,
    QM = d(() => {
      ic()
      yr = Tt(
        (r) => {
          ;(r.setMonth(0, 1), r.setHours(0, 0, 0, 0))
        },
        (r, e) => {
          r.setFullYear(r.getFullYear() + e)
        },
        (r, e) => e.getFullYear() - r.getFullYear(),
        (r) => r.getFullYear(),
      )
      yr.every = (r) =>
        !isFinite((r = Math.floor(r))) || !(r > 0)
          ? null
          : Tt(
              (e) => {
                ;(e.setFullYear(Math.floor(e.getFullYear() / r) * r),
                  e.setMonth(0, 1),
                  e.setHours(0, 0, 0, 0))
              },
              (e, t) => {
                e.setFullYear(e.getFullYear() + t * r)
              },
            )
      ;((M2 = yr.range),
        (br = Tt(
          (r) => {
            ;(r.setUTCMonth(0, 1), r.setUTCHours(0, 0, 0, 0))
          },
          (r, e) => {
            r.setUTCFullYear(r.getUTCFullYear() + e)
          },
          (r, e) => e.getUTCFullYear() - r.getUTCFullYear(),
          (r) => r.getUTCFullYear(),
        )))
      br.every = (r) =>
        !isFinite((r = Math.floor(r))) || !(r > 0)
          ? null
          : Tt(
              (e) => {
                ;(e.setUTCFullYear(Math.floor(e.getUTCFullYear() / r) * r),
                  e.setUTCMonth(0, 1),
                  e.setUTCHours(0, 0, 0, 0))
              },
              (e, t) => {
                e.setUTCFullYear(e.getUTCFullYear() + t * r)
              },
            )
      A2 = br.range
    })
  var $p = d(() => {
    NM()
    ZM()
    QM()
  })
  function Xp(r) {
    if (0 <= r.y && r.y < 100) {
      var e = new Date(-1, r.m, r.d, r.H, r.M, r.S, r.L)
      return (e.setFullYear(r.y), e)
    }
    return new Date(r.y, r.m, r.d, r.H, r.M, r.S, r.L)
  }
  function Yp(r) {
    if (0 <= r.y && r.y < 100) {
      var e = new Date(Date.UTC(-1, r.m, r.d, r.H, r.M, r.S, r.L))
      return (e.setUTCFullYear(r.y), e)
    }
    return new Date(Date.UTC(r.y, r.m, r.d, r.H, r.M, r.S, r.L))
  }
  function la(r, e, t) {
    return { y: r, m: e, d: t, H: 0, M: 0, S: 0, L: 0 }
  }
  function Kp(r) {
    var e = r.dateTime,
      t = r.date,
      i = r.time,
      n = r.periods,
      s = r.days,
      o = r.shortDays,
      a = r.months,
      u = r.shortMonths,
      l = ca(n),
      c = ha(n),
      h = ca(s),
      f = ha(s),
      p = ca(o),
      m = ha(o),
      g = ca(a),
      x = ha(a),
      y = ca(u),
      v = ha(u),
      S = {
        a: P,
        A: $,
        b: k,
        B: X,
        c: null,
        d: nA,
        e: nA,
        f: Z2,
        g: aI,
        G: lI,
        H: K2,
        I: j2,
        j: q2,
        L: lA,
        m: Q2,
        M: J2,
        p: oe,
        q: he,
        Q: aA,
        s: uA,
        S: eI,
        u: tI,
        U: rI,
        V: iI,
        w: nI,
        W: sI,
        x: null,
        X: null,
        y: oI,
        Y: uI,
        Z: cI,
        "%": oA,
      },
      b = {
        a: Oe,
        A: we,
        b: Le,
        B: Ve,
        c: null,
        d: sA,
        e: sA,
        f: pI,
        g: CI,
        G: wI,
        H: hI,
        I: dI,
        j: fI,
        L: hA,
        m: mI,
        M: gI,
        p: Ze,
        q: ut,
        Q: aA,
        s: uA,
        S: xI,
        u: _I,
        U: yI,
        V: bI,
        w: vI,
        W: SI,
        x: null,
        X: null,
        y: TI,
        Y: EI,
        Z: MI,
        "%": oA,
      },
      M = {
        a: G,
        A,
        b: W,
        B: Y,
        c: T,
        d: rA,
        e: rA,
        f: V2,
        g: tA,
        G: eA,
        H: iA,
        I: iA,
        j: N2,
        L: W2,
        m: L2,
        M: H2,
        p: O,
        q: O2,
        Q: X2,
        s: Y2,
        S: z2,
        u: B2,
        U: I2,
        V: G2,
        w: F2,
        W: k2,
        x: N,
        X: E,
        y: tA,
        Y: eA,
        Z: U2,
        "%": $2,
      }
    ;((S.x = C(t, S)),
      (S.X = C(i, S)),
      (S.c = C(e, S)),
      (b.x = C(t, b)),
      (b.X = C(i, b)),
      (b.c = C(e, b)))
    function C(U, J) {
      return function (ne) {
        var R = [],
          Me = -1,
          ae = 0,
          Re = U.length,
          tt,
          Wt,
          ma
        for (ne instanceof Date || (ne = new Date(+ne)); ++Me < Re; )
          U.charCodeAt(Me) === 37 &&
            (R.push(U.slice(ae, Me)),
            (Wt = JM[(tt = U.charAt(++Me))]) != null
              ? (tt = U.charAt(++Me))
              : (Wt = tt === "e" ? " " : "0"),
            (ma = J[tt]) && (tt = ma(ne, Wt)),
            R.push(tt),
            (ae = Me + 1))
        return (R.push(U.slice(ae, Me)), R.join(""))
      }
    }
    function w(U, J) {
      return function (ne) {
        var R = la(1900, void 0, 1),
          Me = B(R, U, (ne += ""), 0),
          ae,
          Re
        if (Me != ne.length) return null
        if ("Q" in R) return new Date(R.Q)
        if ("s" in R) return new Date(R.s * 1e3 + ("L" in R ? R.L : 0))
        if (
          (J && !("Z" in R) && (R.Z = 0),
          "p" in R && (R.H = (R.H % 12) + R.p * 12),
          R.m === void 0 && (R.m = "q" in R ? R.q : 0),
          "V" in R)
        ) {
          if (R.V < 1 || R.V > 53) return null
          ;("w" in R || (R.w = 1),
            "Z" in R
              ? ((ae = Yp(la(R.y, 0, 1))),
                (Re = ae.getUTCDay()),
                (ae = Re > 4 || Re === 0 ? Fn.ceil(ae) : Fn(ae)),
                (ae = oa.offset(ae, (R.V - 1) * 7)),
                (R.y = ae.getUTCFullYear()),
                (R.m = ae.getUTCMonth()),
                (R.d = ae.getUTCDate() + ((R.w + 6) % 7)))
              : ((ae = Xp(la(R.y, 0, 1))),
                (Re = ae.getDay()),
                (ae = Re > 4 || Re === 0 ? Rn.ceil(ae) : Rn(ae)),
                (ae = sa.offset(ae, (R.V - 1) * 7)),
                (R.y = ae.getFullYear()),
                (R.m = ae.getMonth()),
                (R.d = ae.getDate() + ((R.w + 6) % 7))))
        } else
          ("W" in R || "U" in R) &&
            ("w" in R || (R.w = "u" in R ? R.u % 7 : "W" in R ? 1 : 0),
            (Re = "Z" in R ? Yp(la(R.y, 0, 1)).getUTCDay() : Xp(la(R.y, 0, 1)).getDay()),
            (R.m = 0),
            (R.d =
              "W" in R
                ? ((R.w + 6) % 7) + R.W * 7 - ((Re + 5) % 7)
                : R.w + R.U * 7 - ((Re + 6) % 7)))
        return "Z" in R ? ((R.H += (R.Z / 100) | 0), (R.M += R.Z % 100), Yp(R)) : Xp(R)
      }
    }
    function B(U, J, ne, R) {
      for (var Me = 0, ae = J.length, Re = ne.length, tt, Wt; Me < ae; ) {
        if (R >= Re) return -1
        if (((tt = J.charCodeAt(Me++)), tt === 37)) {
          if (
            ((tt = J.charAt(Me++)),
            (Wt = M[tt in JM ? J.charAt(Me++) : tt]),
            !Wt || (R = Wt(U, ne, R)) < 0)
          )
            return -1
        } else if (tt != ne.charCodeAt(R++)) return -1
      }
      return R
    }
    function O(U, J, ne) {
      var R = l.exec(J.slice(ne))
      return R ? ((U.p = c.get(R[0].toLowerCase())), ne + R[0].length) : -1
    }
    function G(U, J, ne) {
      var R = p.exec(J.slice(ne))
      return R ? ((U.w = m.get(R[0].toLowerCase())), ne + R[0].length) : -1
    }
    function A(U, J, ne) {
      var R = h.exec(J.slice(ne))
      return R ? ((U.w = f.get(R[0].toLowerCase())), ne + R[0].length) : -1
    }
    function W(U, J, ne) {
      var R = y.exec(J.slice(ne))
      return R ? ((U.m = v.get(R[0].toLowerCase())), ne + R[0].length) : -1
    }
    function Y(U, J, ne) {
      var R = g.exec(J.slice(ne))
      return R ? ((U.m = x.get(R[0].toLowerCase())), ne + R[0].length) : -1
    }
    function T(U, J, ne) {
      return B(U, e, J, ne)
    }
    function N(U, J, ne) {
      return B(U, t, J, ne)
    }
    function E(U, J, ne) {
      return B(U, i, J, ne)
    }
    function P(U) {
      return o[U.getDay()]
    }
    function $(U) {
      return s[U.getDay()]
    }
    function k(U) {
      return u[U.getMonth()]
    }
    function X(U) {
      return a[U.getMonth()]
    }
    function oe(U) {
      return n[+(U.getHours() >= 12)]
    }
    function he(U) {
      return 1 + ~~(U.getMonth() / 3)
    }
    function Oe(U) {
      return o[U.getUTCDay()]
    }
    function we(U) {
      return s[U.getUTCDay()]
    }
    function Le(U) {
      return u[U.getUTCMonth()]
    }
    function Ve(U) {
      return a[U.getUTCMonth()]
    }
    function Ze(U) {
      return n[+(U.getUTCHours() >= 12)]
    }
    function ut(U) {
      return 1 + ~~(U.getUTCMonth() / 3)
    }
    return {
      format: function (U) {
        var J = C((U += ""), S)
        return (
          (J.toString = function () {
            return U
          }),
          J
        )
      },
      parse: function (U) {
        var J = w((U += ""), !1)
        return (
          (J.toString = function () {
            return U
          }),
          J
        )
      },
      utcFormat: function (U) {
        var J = C((U += ""), b)
        return (
          (J.toString = function () {
            return U
          }),
          J
        )
      },
      utcParse: function (U) {
        var J = w((U += ""), !0)
        return (
          (J.toString = function () {
            return U
          }),
          J
        )
      },
    }
  }
  function le(r, e, t) {
    var i = r < 0 ? "-" : "",
      n = (i ? -r : r) + "",
      s = n.length
    return i + (s < t ? new Array(t - s + 1).join(e) + n : n)
  }
  function R2(r) {
    return r.replace(P2, "\\$&")
  }
  function ca(r) {
    return new RegExp("^(?:" + r.map(R2).join("|") + ")", "i")
  }
  function ha(r) {
    return new Map(r.map((e, t) => [e.toLowerCase(), t]))
  }
  function F2(r, e, t) {
    var i = We.exec(e.slice(t, t + 1))
    return i ? ((r.w = +i[0]), t + i[0].length) : -1
  }
  function B2(r, e, t) {
    var i = We.exec(e.slice(t, t + 1))
    return i ? ((r.u = +i[0]), t + i[0].length) : -1
  }
  function I2(r, e, t) {
    var i = We.exec(e.slice(t, t + 2))
    return i ? ((r.U = +i[0]), t + i[0].length) : -1
  }
  function G2(r, e, t) {
    var i = We.exec(e.slice(t, t + 2))
    return i ? ((r.V = +i[0]), t + i[0].length) : -1
  }
  function k2(r, e, t) {
    var i = We.exec(e.slice(t, t + 2))
    return i ? ((r.W = +i[0]), t + i[0].length) : -1
  }
  function eA(r, e, t) {
    var i = We.exec(e.slice(t, t + 4))
    return i ? ((r.y = +i[0]), t + i[0].length) : -1
  }
  function tA(r, e, t) {
    var i = We.exec(e.slice(t, t + 2))
    return i ? ((r.y = +i[0] + (+i[0] > 68 ? 1900 : 2e3)), t + i[0].length) : -1
  }
  function U2(r, e, t) {
    var i = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(e.slice(t, t + 6))
    return i ? ((r.Z = i[1] ? 0 : -(i[2] + (i[3] || "00"))), t + i[0].length) : -1
  }
  function O2(r, e, t) {
    var i = We.exec(e.slice(t, t + 1))
    return i ? ((r.q = i[0] * 3 - 3), t + i[0].length) : -1
  }
  function L2(r, e, t) {
    var i = We.exec(e.slice(t, t + 2))
    return i ? ((r.m = i[0] - 1), t + i[0].length) : -1
  }
  function rA(r, e, t) {
    var i = We.exec(e.slice(t, t + 2))
    return i ? ((r.d = +i[0]), t + i[0].length) : -1
  }
  function N2(r, e, t) {
    var i = We.exec(e.slice(t, t + 3))
    return i ? ((r.m = 0), (r.d = +i[0]), t + i[0].length) : -1
  }
  function iA(r, e, t) {
    var i = We.exec(e.slice(t, t + 2))
    return i ? ((r.H = +i[0]), t + i[0].length) : -1
  }
  function H2(r, e, t) {
    var i = We.exec(e.slice(t, t + 2))
    return i ? ((r.M = +i[0]), t + i[0].length) : -1
  }
  function z2(r, e, t) {
    var i = We.exec(e.slice(t, t + 2))
    return i ? ((r.S = +i[0]), t + i[0].length) : -1
  }
  function W2(r, e, t) {
    var i = We.exec(e.slice(t, t + 3))
    return i ? ((r.L = +i[0]), t + i[0].length) : -1
  }
  function V2(r, e, t) {
    var i = We.exec(e.slice(t, t + 6))
    return i ? ((r.L = Math.floor(i[0] / 1e3)), t + i[0].length) : -1
  }
  function $2(r, e, t) {
    var i = D2.exec(e.slice(t, t + 1))
    return i ? t + i[0].length : -1
  }
  function X2(r, e, t) {
    var i = We.exec(e.slice(t))
    return i ? ((r.Q = +i[0]), t + i[0].length) : -1
  }
  function Y2(r, e, t) {
    var i = We.exec(e.slice(t))
    return i ? ((r.s = +i[0]), t + i[0].length) : -1
  }
  function nA(r, e) {
    return le(r.getDate(), e, 2)
  }
  function K2(r, e) {
    return le(r.getHours(), e, 2)
  }
  function j2(r, e) {
    return le(r.getHours() % 12 || 12, e, 2)
  }
  function q2(r, e) {
    return le(1 + sa.count(yr(r), r), e, 3)
  }
  function lA(r, e) {
    return le(r.getMilliseconds(), e, 3)
  }
  function Z2(r, e) {
    return lA(r, e) + "000"
  }
  function Q2(r, e) {
    return le(r.getMonth() + 1, e, 2)
  }
  function J2(r, e) {
    return le(r.getMinutes(), e, 2)
  }
  function eI(r, e) {
    return le(r.getSeconds(), e, 2)
  }
  function tI(r) {
    var e = r.getDay()
    return e === 0 ? 7 : e
  }
  function rI(r, e) {
    return le(aa.count(yr(r) - 1, r), e, 2)
  }
  function cA(r) {
    var e = r.getDay()
    return e >= 4 || e === 0 ? Vr(r) : Vr.ceil(r)
  }
  function iI(r, e) {
    return ((r = cA(r)), le(Vr.count(yr(r), r) + (yr(r).getDay() === 4), e, 2))
  }
  function nI(r) {
    return r.getDay()
  }
  function sI(r, e) {
    return le(Rn.count(yr(r) - 1, r), e, 2)
  }
  function oI(r, e) {
    return le(r.getFullYear() % 100, e, 2)
  }
  function aI(r, e) {
    return ((r = cA(r)), le(r.getFullYear() % 100, e, 2))
  }
  function uI(r, e) {
    return le(r.getFullYear() % 1e4, e, 4)
  }
  function lI(r, e) {
    var t = r.getDay()
    return ((r = t >= 4 || t === 0 ? Vr(r) : Vr.ceil(r)), le(r.getFullYear() % 1e4, e, 4))
  }
  function cI(r) {
    var e = r.getTimezoneOffset()
    return (e > 0 ? "-" : ((e *= -1), "+")) + le((e / 60) | 0, "0", 2) + le(e % 60, "0", 2)
  }
  function sA(r, e) {
    return le(r.getUTCDate(), e, 2)
  }
  function hI(r, e) {
    return le(r.getUTCHours(), e, 2)
  }
  function dI(r, e) {
    return le(r.getUTCHours() % 12 || 12, e, 2)
  }
  function fI(r, e) {
    return le(1 + oa.count(br(r), r), e, 3)
  }
  function hA(r, e) {
    return le(r.getUTCMilliseconds(), e, 3)
  }
  function pI(r, e) {
    return hA(r, e) + "000"
  }
  function mI(r, e) {
    return le(r.getUTCMonth() + 1, e, 2)
  }
  function gI(r, e) {
    return le(r.getUTCMinutes(), e, 2)
  }
  function xI(r, e) {
    return le(r.getUTCSeconds(), e, 2)
  }
  function _I(r) {
    var e = r.getUTCDay()
    return e === 0 ? 7 : e
  }
  function yI(r, e) {
    return le(ua.count(br(r) - 1, r), e, 2)
  }
  function dA(r) {
    var e = r.getUTCDay()
    return e >= 4 || e === 0 ? $r(r) : $r.ceil(r)
  }
  function bI(r, e) {
    return ((r = dA(r)), le($r.count(br(r), r) + (br(r).getUTCDay() === 4), e, 2))
  }
  function vI(r) {
    return r.getUTCDay()
  }
  function SI(r, e) {
    return le(Fn.count(br(r) - 1, r), e, 2)
  }
  function TI(r, e) {
    return le(r.getUTCFullYear() % 100, e, 2)
  }
  function CI(r, e) {
    return ((r = dA(r)), le(r.getUTCFullYear() % 100, e, 2))
  }
  function EI(r, e) {
    return le(r.getUTCFullYear() % 1e4, e, 4)
  }
  function wI(r, e) {
    var t = r.getUTCDay()
    return ((r = t >= 4 || t === 0 ? $r(r) : $r.ceil(r)), le(r.getUTCFullYear() % 1e4, e, 4))
  }
  function MI() {
    return "+0000"
  }
  function oA() {
    return "%"
  }
  function aA(r) {
    return +r
  }
  function uA(r) {
    return Math.floor(+r / 1e3)
  }
  var JM,
    We,
    D2,
    P2,
    fA = d(() => {
      $p()
      ;((JM = { "-": "", _: " ", 0: "0" }),
        (We = /^\s*\d+/),
        (D2 = /^%/),
        (P2 = /[\\^$*+?|[\]().{}]/g))
    })
  function jp(r) {
    return (
      (Bn = Kp(r)),
      (pA = Bn.format),
      (mA = Bn.parse),
      (gA = Bn.utcFormat),
      (xA = Bn.utcParse),
      Bn
    )
  }
  var Bn,
    pA,
    mA,
    gA,
    xA,
    _A = d(() => {
      fA()
      jp({
        dateTime: "%x, %X",
        date: "%-m/%-d/%Y",
        time: "%-I:%M:%S %p",
        periods: ["AM", "PM"],
        days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        months: [
          "January",
          "February",
          "March",
          "April",
          "May",
          "June",
          "July",
          "August",
          "September",
          "October",
          "November",
          "December",
        ],
        shortMonths: [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "May",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Oct",
          "Nov",
          "Dec",
        ],
      })
    })
  var yA = d(() => {
    _A()
  })
  var bA = d(() => {})
  var vA = d(() => {})
  var SA = d(() => {})
  var da,
    TA = d(() => {
      da = (r) => () => r
    })
  function qp(r, { sourceEvent: e, target: t, transform: i, dispatch: n }) {
    Object.defineProperties(this, {
      type: { value: r, enumerable: !0, configurable: !0 },
      sourceEvent: { value: e, enumerable: !0, configurable: !0 },
      target: { value: t, enumerable: !0, configurable: !0 },
      transform: { value: i, enumerable: !0, configurable: !0 },
      _: { value: n },
    })
  }
  var CA = d(() => {})
  function zt(r, e, t) {
    ;((this.k = r), (this.x = e), (this.y = t))
  }
  function Zp(r) {
    for (; !r.__zoom; ) if (!(r = r.parentNode)) return fa
    return r.__zoom
  }
  var fa,
    Qp = d(() => {
      zt.prototype = {
        constructor: zt,
        scale: function (r) {
          return r === 1 ? this : new zt(this.k * r, this.x, this.y)
        },
        translate: function (r, e) {
          return (r === 0) & (e === 0)
            ? this
            : new zt(this.k, this.x + this.k * r, this.y + this.k * e)
        },
        apply: function (r) {
          return [r[0] * this.k + this.x, r[1] * this.k + this.y]
        },
        applyX: function (r) {
          return r * this.k + this.x
        },
        applyY: function (r) {
          return r * this.k + this.y
        },
        invert: function (r) {
          return [(r[0] - this.x) / this.k, (r[1] - this.y) / this.k]
        },
        invertX: function (r) {
          return (r - this.x) / this.k
        },
        invertY: function (r) {
          return (r - this.y) / this.k
        },
        rescaleX: function (r) {
          return r.copy().domain(r.range().map(this.invertX, this).map(r.invert, r))
        },
        rescaleY: function (r) {
          return r.copy().domain(r.range().map(this.invertY, this).map(r.invert, r))
        },
        toString: function () {
          return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")"
        },
      }
      fa = new zt(1, 0, 0)
      Zp.prototype = zt.prototype
    })
  function nc(r) {
    r.stopImmediatePropagation()
  }
  function In(r) {
    ;(r.preventDefault(), r.stopImmediatePropagation())
  }
  var EA = d(() => {})
  function AI(r) {
    return (!r.ctrlKey || r.type === "wheel") && !r.button
  }
  function DI() {
    var r = this
    return r instanceof SVGElement
      ? ((r = r.ownerSVGElement || r),
        r.hasAttribute("viewBox")
          ? ((r = r.viewBox.baseVal),
            [
              [r.x, r.y],
              [r.x + r.width, r.y + r.height],
            ])
          : [
              [0, 0],
              [r.width.baseVal.value, r.height.baseVal.value],
            ])
      : [
          [0, 0],
          [r.clientWidth, r.clientHeight],
        ]
  }
  function wA() {
    return this.__zoom || fa
  }
  function PI(r) {
    return -r.deltaY * (r.deltaMode === 1 ? 0.05 : r.deltaMode ? 1 : 0.002) * (r.ctrlKey ? 10 : 1)
  }
  function RI() {
    return navigator.maxTouchPoints || "ontouchstart" in this
  }
  function FI(r, e, t) {
    var i = r.invertX(e[0][0]) - t[0][0],
      n = r.invertX(e[1][0]) - t[1][0],
      s = r.invertY(e[0][1]) - t[0][1],
      o = r.invertY(e[1][1]) - t[1][1]
    return r.translate(
      n > i ? (i + n) / 2 : Math.min(0, i) || Math.max(0, n),
      o > s ? (s + o) / 2 : Math.min(0, s) || Math.max(0, o),
    )
  }
  function Jp() {
    var r = AI,
      e = DI,
      t = FI,
      i = PI,
      n = RI,
      s = [0, 1 / 0],
      o = [
        [-1 / 0, -1 / 0],
        [1 / 0, 1 / 0],
      ],
      a = 250,
      u = Ap,
      l = yi("start", "zoom", "end"),
      c,
      h,
      f,
      p = 500,
      m = 150,
      g = 0,
      x = 10
    function y(T) {
      T.property("__zoom", wA)
        .on("wheel.zoom", B, { passive: !1 })
        .on("mousedown.zoom", O)
        .on("dblclick.zoom", G)
        .filter(n)
        .on("touchstart.zoom", A)
        .on("touchmove.zoom", W)
        .on("touchend.zoom touchcancel.zoom", Y)
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)")
    }
    ;((y.transform = function (T, N, E, P) {
      var $ = T.selection ? T.selection() : T
      ;($.property("__zoom", wA),
        T !== $
          ? M(T, N, E, P)
          : $.interrupt().each(function () {
              C(this, arguments)
                .event(P)
                .start()
                .zoom(null, typeof N == "function" ? N.apply(this, arguments) : N)
                .end()
            }))
    }),
      (y.scaleBy = function (T, N, E, P) {
        y.scaleTo(
          T,
          function () {
            var $ = this.__zoom.k,
              k = typeof N == "function" ? N.apply(this, arguments) : N
            return $ * k
          },
          E,
          P,
        )
      }),
      (y.scaleTo = function (T, N, E, P) {
        y.transform(
          T,
          function () {
            var $ = e.apply(this, arguments),
              k = this.__zoom,
              X = E == null ? b($) : typeof E == "function" ? E.apply(this, arguments) : E,
              oe = k.invert(X),
              he = typeof N == "function" ? N.apply(this, arguments) : N
            return t(S(v(k, he), X, oe), $, o)
          },
          E,
          P,
        )
      }),
      (y.translateBy = function (T, N, E, P) {
        y.transform(
          T,
          function () {
            return t(
              this.__zoom.translate(
                typeof N == "function" ? N.apply(this, arguments) : N,
                typeof E == "function" ? E.apply(this, arguments) : E,
              ),
              e.apply(this, arguments),
              o,
            )
          },
          null,
          P,
        )
      }),
      (y.translateTo = function (T, N, E, P, $) {
        y.transform(
          T,
          function () {
            var k = e.apply(this, arguments),
              X = this.__zoom,
              oe = P == null ? b(k) : typeof P == "function" ? P.apply(this, arguments) : P
            return t(
              fa
                .translate(oe[0], oe[1])
                .scale(X.k)
                .translate(
                  typeof N == "function" ? -N.apply(this, arguments) : -N,
                  typeof E == "function" ? -E.apply(this, arguments) : -E,
                ),
              k,
              o,
            )
          },
          P,
          $,
        )
      }))
    function v(T, N) {
      return ((N = Math.max(s[0], Math.min(s[1], N))), N === T.k ? T : new zt(N, T.x, T.y))
    }
    function S(T, N, E) {
      var P = N[0] - E[0] * T.k,
        $ = N[1] - E[1] * T.k
      return P === T.x && $ === T.y ? T : new zt(T.k, P, $)
    }
    function b(T) {
      return [(+T[0][0] + +T[1][0]) / 2, (+T[0][1] + +T[1][1]) / 2]
    }
    function M(T, N, E, P) {
      T.on("start.zoom", function () {
        C(this, arguments).event(P).start()
      })
        .on("interrupt.zoom end.zoom", function () {
          C(this, arguments).event(P).end()
        })
        .tween("zoom", function () {
          var $ = this,
            k = arguments,
            X = C($, k).event(P),
            oe = e.apply($, k),
            he = E == null ? b(oe) : typeof E == "function" ? E.apply($, k) : E,
            Oe = Math.max(oe[1][0] - oe[0][0], oe[1][1] - oe[0][1]),
            we = $.__zoom,
            Le = typeof N == "function" ? N.apply($, k) : N,
            Ve = u(we.invert(he).concat(Oe / we.k), Le.invert(he).concat(Oe / Le.k))
          return function (Ze) {
            if (Ze === 1) Ze = Le
            else {
              var ut = Ve(Ze),
                U = Oe / ut[2]
              Ze = new zt(U, he[0] - ut[0] * U, he[1] - ut[1] * U)
            }
            X.zoom(null, Ze)
          }
        })
    }
    function C(T, N, E) {
      return (!E && T.__zooming) || new w(T, N)
    }
    function w(T, N) {
      ;((this.that = T),
        (this.args = N),
        (this.active = 0),
        (this.sourceEvent = null),
        (this.extent = e.apply(T, N)),
        (this.taps = 0))
    }
    w.prototype = {
      event: function (T) {
        return (T && (this.sourceEvent = T), this)
      },
      start: function () {
        return (++this.active === 1 && ((this.that.__zooming = this), this.emit("start")), this)
      },
      zoom: function (T, N) {
        return (
          this.mouse && T !== "mouse" && (this.mouse[1] = N.invert(this.mouse[0])),
          this.touch0 && T !== "touch" && (this.touch0[1] = N.invert(this.touch0[0])),
          this.touch1 && T !== "touch" && (this.touch1[1] = N.invert(this.touch1[0])),
          (this.that.__zoom = N),
          this.emit("zoom"),
          this
        )
      },
      end: function () {
        return (--this.active === 0 && (delete this.that.__zooming, this.emit("end")), this)
      },
      emit: function (T) {
        var N = je(this.that).datum()
        l.call(
          T,
          this.that,
          new qp(T, {
            sourceEvent: this.sourceEvent,
            target: y,
            type: T,
            transform: this.that.__zoom,
            dispatch: l,
          }),
          N,
        )
      },
    }
    function B(T, ...N) {
      if (!r.apply(this, arguments)) return
      var E = C(this, N).event(T),
        P = this.__zoom,
        $ = Math.max(s[0], Math.min(s[1], P.k * Math.pow(2, i.apply(this, arguments)))),
        k = Rt(T)
      if (E.wheel)
        ((E.mouse[0][0] !== k[0] || E.mouse[0][1] !== k[1]) &&
          (E.mouse[1] = P.invert((E.mouse[0] = k))),
          clearTimeout(E.wheel))
      else {
        if (P.k === $) return
        ;((E.mouse = [k, P.invert(k)]), Wr(this), E.start())
      }
      ;(In(T),
        (E.wheel = setTimeout(X, m)),
        E.zoom("mouse", t(S(v(P, $), E.mouse[0], E.mouse[1]), E.extent, o)))
      function X() {
        ;((E.wheel = null), E.end())
      }
    }
    function O(T, ...N) {
      if (f || !r.apply(this, arguments)) return
      var E = T.currentTarget,
        P = C(this, N, !0).event(T),
        $ = je(T.view).on("mousemove.zoom", he, !0).on("mouseup.zoom", Oe, !0),
        k = Rt(T, E),
        X = T.clientX,
        oe = T.clientY
      ;(Ho(T.view), nc(T), (P.mouse = [k, this.__zoom.invert(k)]), Wr(this), P.start())
      function he(we) {
        if ((In(we), !P.moved)) {
          var Le = we.clientX - X,
            Ve = we.clientY - oe
          P.moved = Le * Le + Ve * Ve > g
        }
        P.event(we).zoom(
          "mouse",
          t(S(P.that.__zoom, (P.mouse[0] = Rt(we, E)), P.mouse[1]), P.extent, o),
        )
      }
      function Oe(we) {
        ;($.on("mousemove.zoom mouseup.zoom", null),
          zo(we.view, P.moved),
          In(we),
          P.event(we).end())
      }
    }
    function G(T, ...N) {
      if (r.apply(this, arguments)) {
        var E = this.__zoom,
          P = Rt(T.changedTouches ? T.changedTouches[0] : T, this),
          $ = E.invert(P),
          k = E.k * (T.shiftKey ? 0.5 : 2),
          X = t(S(v(E, k), P, $), e.apply(this, N), o)
        ;(In(T),
          a > 0
            ? je(this).transition().duration(a).call(M, X, P, T)
            : je(this).call(y.transform, X, P, T))
      }
    }
    function A(T, ...N) {
      if (r.apply(this, arguments)) {
        var E = T.touches,
          P = E.length,
          $ = C(this, N, T.changedTouches.length === P).event(T),
          k,
          X,
          oe,
          he
        for (nc(T), X = 0; X < P; ++X)
          ((oe = E[X]),
            (he = Rt(oe, this)),
            (he = [he, this.__zoom.invert(he), oe.identifier]),
            $.touch0
              ? !$.touch1 && $.touch0[2] !== he[2] && (($.touch1 = he), ($.taps = 0))
              : (($.touch0 = he), (k = !0), ($.taps = 1 + !!c)))
        ;(c && (c = clearTimeout(c)),
          k &&
            ($.taps < 2 &&
              ((h = he[0]),
              (c = setTimeout(function () {
                c = null
              }, p))),
            Wr(this),
            $.start()))
      }
    }
    function W(T, ...N) {
      if (this.__zooming) {
        var E = C(this, N).event(T),
          P = T.changedTouches,
          $ = P.length,
          k,
          X,
          oe,
          he
        for (In(T), k = 0; k < $; ++k)
          ((X = P[k]),
            (oe = Rt(X, this)),
            E.touch0 && E.touch0[2] === X.identifier
              ? (E.touch0[0] = oe)
              : E.touch1 && E.touch1[2] === X.identifier && (E.touch1[0] = oe))
        if (((X = E.that.__zoom), E.touch1)) {
          var Oe = E.touch0[0],
            we = E.touch0[1],
            Le = E.touch1[0],
            Ve = E.touch1[1],
            Ze = (Ze = Le[0] - Oe[0]) * Ze + (Ze = Le[1] - Oe[1]) * Ze,
            ut = (ut = Ve[0] - we[0]) * ut + (ut = Ve[1] - we[1]) * ut
          ;((X = v(X, Math.sqrt(Ze / ut))),
            (oe = [(Oe[0] + Le[0]) / 2, (Oe[1] + Le[1]) / 2]),
            (he = [(we[0] + Ve[0]) / 2, (we[1] + Ve[1]) / 2]))
        } else if (E.touch0) ((oe = E.touch0[0]), (he = E.touch0[1]))
        else return
        E.zoom("touch", t(S(X, oe, he), E.extent, o))
      }
    }
    function Y(T, ...N) {
      if (this.__zooming) {
        var E = C(this, N).event(T),
          P = T.changedTouches,
          $ = P.length,
          k,
          X
        for (
          nc(T),
            f && clearTimeout(f),
            f = setTimeout(function () {
              f = null
            }, p),
            k = 0;
          k < $;
          ++k
        )
          ((X = P[k]),
            E.touch0 && E.touch0[2] === X.identifier
              ? delete E.touch0
              : E.touch1 && E.touch1[2] === X.identifier && delete E.touch1)
        if ((E.touch1 && !E.touch0 && ((E.touch0 = E.touch1), delete E.touch1), E.touch0))
          E.touch0[1] = this.__zoom.invert(E.touch0[0])
        else if (
          (E.end(), E.taps === 2 && ((X = Rt(X, this)), Math.hypot(h[0] - X[0], h[1] - X[1]) < x))
        ) {
          var oe = je(this).on("dblclick.zoom")
          oe && oe.apply(this, arguments)
        }
      }
    }
    return (
      (y.wheelDelta = function (T) {
        return arguments.length ? ((i = typeof T == "function" ? T : da(+T)), y) : i
      }),
      (y.filter = function (T) {
        return arguments.length ? ((r = typeof T == "function" ? T : da(!!T)), y) : r
      }),
      (y.touchable = function (T) {
        return arguments.length ? ((n = typeof T == "function" ? T : da(!!T)), y) : n
      }),
      (y.extent = function (T) {
        return arguments.length
          ? ((e =
              typeof T == "function"
                ? T
                : da([
                    [+T[0][0], +T[0][1]],
                    [+T[1][0], +T[1][1]],
                  ])),
            y)
          : e
      }),
      (y.scaleExtent = function (T) {
        return arguments.length ? ((s[0] = +T[0]), (s[1] = +T[1]), y) : [s[0], s[1]]
      }),
      (y.translateExtent = function (T) {
        return arguments.length
          ? ((o[0][0] = +T[0][0]),
            (o[1][0] = +T[1][0]),
            (o[0][1] = +T[0][1]),
            (o[1][1] = +T[1][1]),
            y)
          : [
              [o[0][0], o[0][1]],
              [o[1][0], o[1][1]],
            ]
      }),
      (y.constrain = function (T) {
        return arguments.length ? ((t = T), y) : t
      }),
      (y.duration = function (T) {
        return arguments.length ? ((a = +T), y) : a
      }),
      (y.interpolate = function (T) {
        return arguments.length ? ((u = T), y) : u
      }),
      (y.on = function () {
        var T = l.on.apply(l, arguments)
        return T === l ? y : T
      }),
      (y.clickDistance = function (T) {
        return arguments.length ? ((g = (T = +T) * T), y) : Math.sqrt(g)
      }),
      (y.tapDistance = function (T) {
        return arguments.length ? ((x = +T), y) : x
      }),
      y
    )
  }
  var MA = d(() => {
    ko()
    gp()
    An()
    gt()
    tc()
    TA()
    CA()
    Qp()
    EA()
  })
  var AA = d(() => {
    MA()
    Qp()
  })
  var DA = d(() => {
    zC()
    WC()
    nM()
    oM()
    Ul()
    aM()
    uM()
    ko()
    gp()
    lM()
    Bp()
    cM()
    dM()
    IM()
    GM()
    kM()
    An()
    sM()
    UM()
    hM()
    OM()
    bA()
    vA()
    gt()
    SA()
    $p()
    yA()
    Kl()
    tc()
    AA()
  })
  var me,
    PA,
    em,
    pa = d(() => {
      "use strict"
      ;((me = {
        MIN_HEIGHT: 250,
        DEVICE_PIXEL_RATIO_MULTIPLIER: 4,
        BASE_NODE_RADIUS: 2,
        NODE_RADIUS_SCALE_FACTOR: 1,
        NODE_HOVER_SCALE: 1.2,
        NODE_NORMAL_ALPHA: 0.8,
        NODE_HOVER_ALPHA: 1,
        NODE_STROKE_WIDTH: 2,
        REPULSIVE_FORCE: -100,
        LINK_DISTANCE: 30,
        COLLISION_ITERATIONS: 3,
        RADIAL_RADIUS: 50,
        RADIAL_STRENGTH: 0.3,
        LINK_WIDTH_DIVISOR: 25,
        LINK_ALPHA: 0.5,
        ZOOM_SCALE_EXTENT: [0.25, 4],
        FONT_SIZE_MULTIPLIER: 15,
        LABEL_ANCHOR: { x: 0.5, y: 1.2 },
        TAG_PREFIX: "tags/",
        TAG_DISPLAY_PREFIX: "#",
        FALLBACK_COLOR: 6710886,
      }),
        (PA = [
          "--secondary",
          "--tertiary",
          "--gray",
          "--light",
          "--lightgray",
          "--dark",
          "--darkgray",
          "--bodyFont",
        ]),
        (em = { GRAPH_VISITED: "graph-visited", NAVIGATION_HISTORY: "navigation-history" }))
    })
  function Xr(r) {
    if (!r || r.trim() === "")
      return (console.warn("Empty CSS color provided, using fallback"), me.FALLBACK_COLOR)
    try {
      let t = document.createElement("canvas").getContext("2d")
      t.fillStyle = r.trim()
      let i = t.fillStyle,
        n = i.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/)
      if (n) {
        let s = parseInt(n[1]),
          o = parseInt(n[2]),
          a = parseInt(n[3])
        return (s << 16) | (o << 8) | a
      }
      if (i.startsWith("#")) {
        let s = i.substring(1),
          o = parseInt(s, 16)
        if (!isNaN(o)) return o
      }
      return (console.warn(`Failed to parse color: ${r}, using fallback`), me.FALLBACK_COLOR)
    } catch (e) {
      return (console.error(`Error converting CSS color ${r}:`, e), me.FALLBACK_COLOR)
    }
  }
  function RA() {
    let r = PA.reduce((e, t) => {
      let i = getComputedStyle(document.documentElement).getPropertyValue(t).trim()
      return ((e[t] = i), i || console.warn(`CSS variable ${t} is empty or not found`), e)
    }, {})
    return (console.log("CSS variables loaded:", r), r)
  }
  function FA(r, e) {
    let t = e.links.filter((i) => i.source.id === r.id || i.target.id === r.id).length
    return me.BASE_NODE_RADIUS + Math.sqrt(t) * me.NODE_RADIUS_SCALE_FACTOR
  }
  function BA(r, e, t, i) {
    return r.id === e
      ? Xr(i["--secondary"])
      : t.has(r.id) || r.id.startsWith(me.TAG_PREFIX)
        ? Xr(i["--tertiary"])
        : Xr(i["--gray"])
  }
  function IA(r) {
    return r.startsWith(me.TAG_PREFIX)
  }
  async function GA() {
    let r = await navigator.gpu?.requestAdapter().catch(() => null)
    return r && r.features.has("float32-blendable") ? "webgpu" : "webgl"
  }
  var kA = d(() => {
    "use strict"
    pa()
  })
  var sc,
    UA = d(() => {
      "use strict"
      sc = class {
        constructor(e, t) {
          this.graphData = e
          this.config = t
        }
        worker = null
        onTickCallback = null
        initialize(e) {
          ;(this.worker && (this.worker.terminate(), (this.worker = null)),
            (this.onTickCallback = e),
            (this.worker = new Worker("/simulation.worker.js", { type: "module" })),
            (this.worker.onmessage = (t) => {
              this.onTickCallback && this.onTickCallback(t.data.nodes, t.data.links)
            }),
            this.worker.postMessage({
              type: "initialize",
              graphData: this.graphData,
              config: this.config,
            }))
        }
        stop() {
          this.worker && (this.worker.terminate(), (this.worker = null))
        }
        restart() {
          this.worker && this.worker.postMessage({ type: "restart" })
        }
        updateConfig(e) {
          ;((this.config = { ...this.config, ...e }),
            this.worker && this.worker.postMessage({ type: "updateConfig", newConfig: e }))
        }
        getSimulation() {
          return null
        }
      }
    })
  var Gn,
    tm = d(() => {
      "use strict"
      HC()
      DA()
      pa()
      kA()
      UA()
      nr()
      Gn = class {
        constructor(e, t, i) {
          this.container = e
          this.graphData = t
          this.config = i
          ;((this.app = new vl()),
            (this.cssVars = RA()),
            (this.simulationManager = new sc(this.graphData, this.config)))
        }
        app
        cssVars
        nodeGraphics = new Map()
        nodeLabels = new Map()
        linkGraphics = []
        linkRenderData = []
        simulationManager
        cleanupCallbacks = []
        currentTransform = { k: 1, x: 0, y: 0 }
        dragStartTime = 0
        hoveredNodeId = null
        async initialize() {
          let e = this.container.offsetWidth,
            t = Math.max(this.container.offsetHeight, me.MIN_HEIGHT)
          try {
            ;(await this.app.init({
              width: e,
              height: t,
              antialias: !0,
              autoStart: !1,
              autoDensity: !0,
              backgroundAlpha: 0,
              preference: await GA(),
              resolution: window.devicePixelRatio,
              eventMode: "static",
            }),
              console.log("PIXI Application initialized successfully"))
          } catch (i) {
            throw (console.error("Failed to initialize PIXI Application:", i), i)
          }
          ;(this.container.appendChild(this.app.canvas),
            console.log("Canvas appended to container"),
            this.setupContainers(),
            this.renderElements(),
            this.setupSimulation(),
            this.setupInteractions(),
            this.registerCleanup())
        }
        setupContainers() {
          let e = new xe({ zIndex: 3, isRenderGroup: !0 }),
            t = new xe({ zIndex: 2, isRenderGroup: !0 }),
            i = new xe({ zIndex: 1, isRenderGroup: !0 })
          ;(this.app.stage.addChild(t, e, i),
            (this.app.stage.userData = { nodeContainer: t, labelsContainer: e, linkContainer: i }))
        }
        renderElements() {
          ;(this.renderLinks(), this.renderNodes())
        }
        renderLinks() {
          let e = this.app.stage.userData.linkContainer
          this.graphData.links.forEach((t) => {
            let i = new Gr({ interactive: !1, eventMode: "none" })
            ;(e.addChild(i), this.linkGraphics.push(i))
            let n = {
              gfx: i,
              simulationData: t,
              color: Xr(this.cssVars["--lightgray"]),
              alpha: 1,
              active: !1,
            }
            this.linkRenderData.push(n)
          })
        }
        renderNodes() {
          let { nodeContainer: e, labelsContainer: t } = this.app.stage.userData
          this.graphData.nodes.forEach((i) => {
            let { nodeGfx: n, label: s } = this.createNodeElements(i)
            ;(e.addChild(n),
              t.addChild(s),
              this.nodeGraphics.set(i.id, n),
              this.nodeLabels.set(i.id, s),
              this.setupNodeInteractions(n, s, i))
          })
        }
        createNodeElements(e) {
          let t = e.id,
            i = FA(e, this.graphData),
            n = IA(t),
            s = BA(e, this.config.currentSlug, this.config.visited, this.cssVars),
            o = new Go({
              interactive: !1,
              eventMode: "none",
              text: e.text,
              alpha: 0,
              anchor: me.LABEL_ANCHOR,
              style: {
                fontSize: this.config.fontSize * me.FONT_SIZE_MULTIPLIER,
                fill: Xr(this.cssVars["--dark"]),
                fontFamily: this.cssVars["--bodyFont"],
              },
              resolution: window.devicePixelRatio * me.DEVICE_PIXEL_RATIO_MULTIPLIER,
            })
          o.scale.set(1 / this.config.scale)
          let a = new Gr({
            interactive: !0,
            label: t,
            eventMode: "static",
            hitArea: new mi(0, 0, i),
            cursor: "pointer",
          })
            .circle(0, 0, i)
            .fill({ color: n ? Xr(this.cssVars["--light"]) : s })
          return (
            n && a.stroke({ width: me.NODE_STROKE_WIDTH, color: Xr(this.cssVars["--tertiary"]) }),
            (a.alpha = me.NODE_NORMAL_ALPHA),
            { nodeGfx: a, label: o }
          )
        }
        setupNodeInteractions(e, t, i) {
          ;(e.on("pointerover", () => {
            ;(this.hoveredNodeId !== i.id &&
              ((this.hoveredNodeId = i.id),
              this.simulationManager.updateConfig({ alphaTarget: 1 })),
              (e.alpha = me.NODE_HOVER_ALPHA),
              (t.alpha = me.NODE_HOVER_ALPHA),
              this.config.focusOnHover && e.scale.set(me.NODE_HOVER_SCALE))
          }),
            e.on("pointerout", () => {
              ;(this.hoveredNodeId === i.id &&
                ((this.hoveredNodeId = null),
                this.simulationManager.updateConfig({ alphaTarget: 0 })),
                (e.alpha = me.NODE_NORMAL_ALPHA),
                (t.alpha = 0),
                this.config.focusOnHover && e.scale.set(1))
            }),
            this.config.enableDrag ||
              e.on("pointerdown", () => {
                this.navigateToNode(i)
              }))
        }
        navigateToNode(e) {
          if (e.id.startsWith(me.TAG_PREFIX)) {
            let t = e.id.substring(me.TAG_PREFIX.length)
            window.spaNavigate(new URL(`/tags/${t}`, window.location.href).pathname)
          } else window.spaNavigate(new URL(`/${e.id}`, window.location.href).pathname)
        }
        setupSimulation() {
          ;(this.simulationManager.initialize((e, t) => {
            ;(e.forEach((i) => {
              let n = this.graphData.nodes.find((s) => s.id === i.id)
              n &&
                ((n.x = i.x),
                (n.y = i.y),
                (n.vx = i.vx),
                (n.vy = i.vy),
                (n.fx = i.fx),
                (n.fy = i.fy))
            }),
              t.forEach((i, n) => {
                let s = this.graphData.links[n]
                s && i.source && i.target && ((s.source = i.source), (s.target = i.target))
              }),
              this.updateLinkPositions(),
              this.updateNodePositions())
          }),
            this.cleanupCallbacks.push(() => {
              this.simulationManager.stop()
            }))
        }
        updateLinkPositions() {
          let e = this.container.offsetWidth,
            t = Math.max(this.container.offsetHeight, 250)
          this.linkRenderData.forEach((i, n) => {
            let { gfx: s, color: o, alpha: a } = i,
              u = this.graphData.links[n]
            s &&
            u &&
            u.source &&
            u.target &&
            typeof u.source == "object" &&
            typeof u.target == "object" &&
            u.source.x !== void 0 &&
            u.source.y !== void 0 &&
            u.target.x !== void 0 &&
            u.target.y !== void 0
              ? (s.clear(),
                s.moveTo(u.source.x + e / 2, u.source.y + t / 2),
                s.lineTo(u.target.x + e / 2, u.target.y + t / 2),
                s.stroke({ color: o, width: 1, alpha: a }))
              : console.warn("Link data missing coordinates for rendering:", { link: u, index: n })
          })
        }
        updateNodePositions() {
          let e = this.container.offsetWidth,
            t = Math.max(this.container.offsetHeight, 250)
          this.graphData.nodes.forEach((i) => {
            let n = this.nodeGraphics.get(i.id),
              s = this.nodeLabels.get(i.id)
            if (n && i.x !== void 0 && i.y !== void 0) {
              let o = i.x + e / 2,
                a = i.y + t / 2
              ;(n.position.set(o, a), s && s.position.set(o, a))
            } else console.warn("Node data missing coordinates for rendering:", i)
          })
        }
        setupInteractions() {
          let e = je(this.app.canvas)
          if (this.config.enableDrag) {
            let t = mp()
              .container(() => this.app.canvas)
              .subject(() => this.graphData.nodes.find((i) => i.id === this.hoveredNodeId))
              .on("start", (i) => {
                ;((this.dragStartTime = Date.now()),
                  i.active || this.simulationManager.updateConfig({ alphaTarget: 1 }),
                  i.subject && (i.subject.__initialDragPos = { x: i.x, y: i.y }))
              })
              .on("drag", (i) => {
                if (i.subject) {
                  let n = i.subject.__initialDragPos
                  ;((i.subject.fx = n.x + (i.x - n.x) / this.currentTransform.k),
                    (i.subject.fy = n.y + (i.y - n.y) / this.currentTransform.k))
                }
              })
              .on("end", (i) => {
                ;(i.active || this.simulationManager.updateConfig({ alphaTarget: 0 }),
                  i.subject && ((i.subject.fx = null), (i.subject.fy = null)),
                  Date.now() - this.dragStartTime < 500 &&
                    i.subject &&
                    this.navigateToNode(i.subject))
              })
            e.call(t)
          }
          if (this.config.enableZoom) {
            let t = this.container.offsetWidth,
              i = Math.max(this.container.offsetHeight, 250),
              n = Jp()
                .extent([
                  [0, 0],
                  [t, i],
                ])
                .scaleExtent(me.ZOOM_SCALE_EXTENT)
                .on("zoom", (s) => {
                  let { transform: o } = s
                  ;((this.currentTransform = o),
                    this.app.stage.scale.set(o.k),
                    this.app.stage.position.set(o.x, o.y))
                  let a = o.k * this.config.opacityScale,
                    u = Math.max((a - 1) / 3.75, 0)
                  this.nodeLabels.forEach((l, c) => {
                    let h = this.nodeGraphics.get(c)
                    h && h.alpha < me.NODE_HOVER_ALPHA && (l.alpha = u)
                  })
                })
            e.call(n)
          }
        }
        registerCleanup() {
          let e = () => {
            ;(this.simulationManager.stop(),
              this.app &&
                this.app.canvas &&
                (je(this.app.canvas).on(".zoom", null),
                je(this.app.canvas).on(".drag", null),
                this.app.destroy(!0, { children: !0, texture: !0 })))
          }
          ;(Bt.instance.addCleanupTask(e), this.cleanupCallbacks.push(e))
        }
        destroy() {
          if (this.cleanupCallbacks.length > 0) {
            let e = [...this.cleanupCallbacks]
            ;((this.cleanupCallbacks = []),
              e.forEach((t) => {
                try {
                  t()
                } catch (i) {
                  console.error("Error during cleanup:", i)
                }
              }))
          }
        }
      }
    })
  var kn,
    LA = d(() => {
      "use strict"
      $n()
      pa()
      bc()
      pa()
      nr()
      kn = class {
        static localStorageKey = _e.generateSystemKey(em.GRAPH_VISITED, em.NAVIGATION_HISTORY)
        static getVisited() {
          return new Set(JSON.parse(Sr.instance.getItem("local", this.localStorageKey) ?? "[]"))
        }
        static async fetchGraphData() {
          try {
            let e = await fetchData
            if (!e) throw new Error("fetchData resolved to null or undefined")
            return e
          } catch (e) {
            throw (
              console.error("Failed to fetch graph data:", e),
              new Error("Failed to load graph data")
            )
          }
        }
        static processGraphData(e, t) {
          let i = new Map(Object.entries(e).map(([c, h]) => [Zr(c), h])),
            n = [],
            s = [],
            o = new Set(i.keys())
          for (let [c, h] of i.entries()) {
            let f = h.links ?? []
            for (let p of f) o.has(p) && n.push({ source: c, target: p })
            if (t.showTags) {
              let p = h.tags
                .filter((m) => !t.removeTags.includes(m))
                .map((m) => Zr(me.TAG_PREFIX + m))
              s.push(...p.filter((m) => !s.includes(m)))
              for (let m of p) n.push({ source: c, target: m })
            }
          }
          let a = this.calculateNeighbourhood(n, t.currentSlug, t.depth, o, s, t.showTags),
            u = [...a].map((c) => {
              let h = c.startsWith(me.TAG_PREFIX)
                ? me.TAG_DISPLAY_PREFIX + c.substring(me.TAG_PREFIX.length)
                : (i.get(c)?.title ?? c)
              return { id: c, text: h, tags: i.get(c)?.tags ?? [] }
            }),
            l = {
              nodes: u,
              links: n
                .filter((c) => a.has(c.source) && a.has(c.target))
                .map((c) => ({
                  source: u.find((h) => h.id === c.source),
                  target: u.find((h) => h.id === c.target),
                })),
            }
          return (
            console.log(`Graph data prepared: ${l.nodes.length} nodes, ${l.links.length} links`),
            l
          )
        }
        static calculateNeighbourhood(e, t, i, n, s, o) {
          let a = new Set(),
            u = [t, "__SENTINEL"]
          if (i >= 0)
            for (; i >= 0 && u.length > 0; ) {
              let l = u.shift()
              if (l === "__SENTINEL") (i--, u.push("__SENTINEL"))
              else {
                a.add(l)
                let c = e.filter((f) => f.source === l),
                  h = e.filter((f) => f.target === l)
                u.push(...c.map((f) => f.target), ...h.map((f) => f.source))
              }
            }
          else (n.forEach((l) => a.add(l)), o && s.forEach((l) => a.add(l)))
          return a
        }
      }
    })
  var im,
    NA,
    HA = d(() => {
      "use strict"
      $n()
      Ea()
      LA()
      tm()
      ;((im = class {
        renderer = null
        isInitialized = !1
        async initialize(e) {
          let { container: t, fullSlug: i, config: n } = e,
            s = Zr(i),
            o = kn.getVisited()
          gm(t)
          try {
            let a = this.parseGraphConfig(t, n),
              u = {
                ...a,
                visited: o,
                currentSlug: s,
                enableDrag: a.enableDrag ?? !0,
                enableZoom: a.enableZoom ?? !0,
              },
              l = await kn.fetchGraphData(),
              c = kn.processGraphData(l, {
                showTags: a.showTags,
                removeTags: a.removeTags,
                depth: a.depth,
                currentSlug: s,
              })
            if (c.nodes.length === 0) {
              ;(console.warn("No nodes found in graph data"),
                this.showErrorMessage(t, "No graph data available"))
              return
            }
            ;((this.renderer = new Gn(t, c, u)),
              await this.renderer.initialize(),
              (this.isInitialized = !0),
              console.log(`Graph initialized successfully: ${s}`))
          } catch (a) {
            throw (
              console.error("Failed to initialize graph:", a),
              this.showErrorMessage(t, "Failed to load graph visualization"),
              a
            )
          }
        }
        parseGraphConfig(e, t) {
          let i = JSON.parse(e.dataset.cfg || "{}"),
            s = {
              ...{
                drag: !0,
                zoom: !0,
                depth: 1,
                scale: 1.1,
                repelForce: 0.5,
                centerForce: 0.3,
                linkDistance: 30,
                fontSize: 0.6,
                opacityScale: 1,
                removeTags: [],
                showTags: !0,
                focusOnHover: !0,
                enableRadial: !1,
              },
              ...i,
              ...t,
            }
          return {
            ...s,
            enableDrag: s.drag ?? s.enableDrag ?? !0,
            enableZoom: s.zoom ?? s.enableZoom ?? !0,
          }
        }
        showErrorMessage(e, t) {
          e.innerHTML = `<div class="graph-error">${t}</div>`
        }
        destroy() {
          ;(this.renderer && (this.renderer.destroy(), (this.renderer = null)),
            (this.isInitialized = !1))
        }
        get initialized() {
          return this.isInitialized
        }
        getRenderer() {
          return this.renderer
        }
      }),
        (NA = new im()))
    })
  var zA = {}
  uc(zA, { initializeGraph: () => BI })
  async function BI(r, e) {
    try {
      ;(console.log("Initializing graph with simplified logic for:", e),
        await NA.initialize({ container: r, fullSlug: e }),
        console.log("Graph initialized successfully"))
    } catch (t) {
      throw (
        console.error("Failed to initialize graph:", t),
        (r.innerHTML = '<div class="graph-error">Failed to load graph visualization</div>'),
        t
      )
    }
  }
  var WA = d(() => {
    "use strict"
    HA()
  })
  nr()
  bc()
  var Sa = class {
      config
      state
      resourceManager = Bt.instance
      storageManager = Sr.instance
      cacheManager = qr.instance
      constructor(e) {
        ;((this.config = {
          debug: !1,
          cacheConfig: { prefix: e.name.toLowerCase(), ttl: 36e5 },
          ...e,
        }),
          (this.state = {
            initialized: !1,
            eventListenersSetup: !1,
            elements: new Set(),
            cleanupTasks: [],
          }),
          this.log("BaseComponentManager created"))
      }
      async initialize() {
        if (this.state.initialized) {
          this.log("Component already initialized, skipping")
          return
        }
        try {
          ;(this.log("Initializing component..."),
            this.validateGlobalInstances(),
            this.setupEventListeners(),
            await this.onInitialize(),
            this.setupPage(),
            (this.state.initialized = !0),
            this.log("Component initialized successfully"))
        } catch (e) {
          throw (console.error(`[${this.config.name}] Initialization failed:`, e), e)
        }
      }
      setupEventListeners() {
        if (!this.resourceManager)
          throw new Error(`[${this.config.name}] ResourceManager not available`)
        if (this.state.eventListenersSetup) {
          this.log("Event listeners already setup, skipping")
          return
        }
        ;(this.log("Setting up event listeners..."),
          this.resourceManager.addEventListener(document, "nav", () => this.setupPage()),
          this.resourceManager.addEventListener(document, "DOMContentLoaded", () =>
            this.setupPage(),
          ),
          this.resourceManager.addCleanupTask(() => {
            this.cleanup()
          }),
          this.onSetupEventListeners(),
          (this.state.eventListenersSetup = !0),
          this.log("Event listeners setup completed"))
      }
      setupPage() {
        try {
          this.log("Setting up page...")
          let e = this.findComponentElements()
          ;(this.state.elements.clear(),
            e.forEach((t) => this.state.elements.add(t)),
            this.onSetupPage(e),
            this.log(`Page setup completed, found ${e.length} elements`))
        } catch (e) {
          console.error(`[${this.config.name}] Page setup failed:`, e)
        }
      }
      cleanup() {
        this.log("Cleaning up component...")
        try {
          ;(this.onCleanup(),
            this.state.cleanupTasks.forEach((e) => {
              try {
                e()
              } catch (t) {
                console.error(`[${this.config.name}] Cleanup task failed:`, t)
              }
            }),
            this.state.elements.clear(),
            (this.state.cleanupTasks.length = 0),
            this.log("Component cleanup completed"))
        } catch (e) {
          console.error(`[${this.config.name}] Cleanup failed:`, e)
        }
      }
      generateCacheKey(...e) {
        return _e.generateSystemKey(this.config.cacheConfig.prefix, ...e)
      }
      generateUserCacheKey(e) {
        return _e.generateUserKey(this.config.cacheConfig.prefix, e)
      }
      generateContentCacheKey(e) {
        return _e.generateContentKey(e)
      }
      setStorageItem(e, t) {
        if (!this.storageManager)
          throw new Error(`[${this.config.name}] StorageManager not available`)
        this.storageManager.setItem("local", e, t)
      }
      getStorageItem(e, t) {
        if (!this.storageManager)
          throw new Error(`[${this.config.name}] StorageManager not available`)
        let i = this.storageManager.getItem("local", e)
        return i !== null ? i : (t ?? null)
      }
      setCacheItem(e, t, i) {
        if (!this.cacheManager) throw new Error(`[${this.config.name}] CacheManager not available`)
        this.cacheManager.set(e, t, i ?? this.config.cacheConfig.ttl)
      }
      getCacheItem(e) {
        if (!this.cacheManager) throw new Error(`[${this.config.name}] CacheManager not available`)
        return this.cacheManager.get(e)
      }
      addCleanupTask(e) {
        this.state.cleanupTasks.push(e)
      }
      addEventListener(e, t, i, n) {
        this.resourceManager
          ? this.resourceManager.addEventListener(e, t, i, n)
          : (e.addEventListener(t, i, n),
            this.addCleanupTask(() => {
              e.removeEventListener(t, i, n)
            }))
      }
      log(e, ...t) {
        this.config.debug && console.log(`[${this.config.name}] ${e}`, ...t)
      }
      error(e, ...t) {
        console.error(`[${this.config.name}] ${e}`, ...t)
      }
      validateGlobalInstances() {
        if (!this.resourceManager)
          throw new Error(`[${this.config.name}] ResourceManager not available`)
        if (!this.storageManager)
          throw new Error(`[${this.config.name}] StorageManager not available`)
        if (!this.cacheManager) throw new Error(`[${this.config.name}] CacheManager not available`)
      }
    },
    Vn = class {
      static instances = new Map()
      static register(e, t) {
        this.instances.set(e, t)
      }
      static get(e) {
        return this.instances.get(e)
      }
      static async initialize(e) {
        let t = this.get(e)
        if (!t) throw new Error(`Component manager '${e}' not registered`)
        await t.initialize()
      }
      static async initializeAll() {
        let e = Array.from(this.instances.values()).map((t) =>
          t.initialize().catch((i) => {
            console.error("Component manager initialization failed:", i)
          }),
        )
        await Promise.all(e)
      }
      static getRegisteredComponents() {
        return Array.from(this.instances.keys())
      }
    }
  $n()
  Ea()
  Ea()
  tm()
  $n()
  nr()
  var rm = class {
      globalGraphCleanups = []
      isInitialized = !1
      currentRenderer = null
      initialize() {
        this.isInitialized ||
          (this.setupGlobalGraphHandlers(),
          this.setupKeyboardShortcuts(),
          this.setupIconClickHandlers(),
          (this.isInitialized = !0),
          console.log("Global graph manager initialized"))
      }
      setupGlobalGraphHandlers() {
        let e = [...document.getElementsByClassName("global-graph-outer")]
        if (e.length === 0) {
          console.warn("No global graph containers found")
          return
        }
        let t = async () => {
          let i = Ta(window)
          for (let n of e) {
            n.classList.add("active")
            let s = n.closest(".sidebar")
            s && (s.style.zIndex = "1")
            let o = n.querySelector(".global-graph-container")
            if (o) {
              Ca(n, this.hideGlobalGraph.bind(this))
              try {
                this.cleanupGlobalGraphs()
                let a = { nodes: [], links: [] }
                ;((this.currentRenderer = new Gn(o, a, {
                  depth: -1,
                  showTags: !0,
                  enableDrag: !0,
                  enableZoom: !0,
                  scale: 1,
                  repelForce: 1,
                  centerForce: 1,
                  linkDistance: 30,
                  fontSize: 16,
                  opacityScale: 1,
                  removeTags: [],
                  focusOnHover: !0,
                  enableRadial: !1,
                  currentSlug: Zr(i),
                  visited: new Set(),
                })),
                  await this.currentRenderer.initialize(),
                  this.globalGraphCleanups.push(() => {
                    this.currentRenderer &&
                      (this.currentRenderer.destroy(), (this.currentRenderer = null))
                  }),
                  console.log("Global graph rendered successfully"))
              } catch (a) {
                ;(console.error("Failed to render global graph:", a),
                  (o.innerHTML = '<div class="graph-error">Failed to load global graph</div>'))
              }
            }
          }
        }
        this.renderGlobalGraph = t
      }
      hideGlobalGraph() {
        this.cleanupGlobalGraphs()
        let e = [...document.getElementsByClassName("global-graph-outer")]
        for (let t of e) {
          t.classList.remove("active")
          let i = t.closest(".sidebar")
          i && (i.style.zIndex = "")
        }
        console.log("Global graph hidden")
      }
      cleanupGlobalGraphs() {
        if (this.globalGraphCleanups.length > 0) {
          let e = [...this.globalGraphCleanups]
          ;((this.globalGraphCleanups = []),
            e.forEach((t) => {
              try {
                t()
              } catch (i) {
                console.error("Error during global graph cleanup:", i)
              }
            }))
        }
        if (this.currentRenderer) {
          try {
            this.currentRenderer.destroy()
          } catch (e) {
            console.error("Error destroying current renderer:", e)
          }
          this.currentRenderer = null
        }
      }
      setupKeyboardShortcuts() {
        let e = (t) => {
          t.key === "g" &&
            (t.ctrlKey || t.metaKey) &&
            !t.shiftKey &&
            (t.preventDefault(),
            [...document.getElementsByClassName("global-graph-outer")].some((s) =>
              s.classList.contains("active"),
            )
              ? this.hideGlobalGraph()
              : this.renderGlobalGraph?.())
        }
        ;(document.addEventListener("keydown", e),
          Bt.instance.addCleanupTask(() => {
            ;(document.removeEventListener("keydown", e), this.cleanupGlobalGraphs())
          }))
      }
      setupIconClickHandlers() {
        let e = document.getElementsByClassName("global-graph-icon")
        ;(Array.from(e).forEach((t) => {
          let i = () => {
            this.renderGlobalGraph?.()
          }
          ;(t.addEventListener("click", i),
            Bt.instance.addCleanupTask(() => {
              t.removeEventListener("click", i)
            }))
        }),
          console.log(`Setup ${e.length} global graph icon handlers`))
      }
      renderGlobalGraph
      destroy() {
        ;(this.cleanupGlobalGraphs(),
          this.currentRenderer && (this.currentRenderer.destroy(), (this.currentRenderer = null)),
          (this.isInitialized = !1))
      }
    },
    OA = new rm()
  var oc = class extends Sa {
    constructor(e = {}) {
      ;(super({
        name: "Graph",
        debug: !1,
        enableLazyLoad: !0,
        lazyLoadRootMargin: "50px",
        lazyLoadThreshold: 0.1,
        enablePreload: !0,
        preloadDelay: 2e3,
        cacheConfig: { prefix: "graph", ttl: 18e5 },
        ...e,
      }),
        (this.state.currentSlug = null),
        (this.state.loadingStates = new Map()),
        (this.state.initializedStates = new Map()),
        (this.state.currentObserver = null),
        (this.state.graphModulePromise = null))
    }
    findComponentElements() {
      return Array.from(document.querySelectorAll(".graph-container, .global-graph-container"))
    }
    async onInitialize() {
      ;((this.state.currentSlug = Ta(window)),
        OA.initialize(),
        this.log("Graph component initialized for slug:", this.state.currentSlug))
    }
    onSetupEventListeners() {
      this.setupEscapeHandler()
    }
    onSetupPage(e) {
      if (e.length === 0) {
        this.log("No graph containers found")
        return
      }
      this.cleanupObserver()
      let t = e.filter((i) => !this.state.initializedStates.get(i))
      if (t.length === 0) {
        this.log("All graph elements already initialized, skipping setup")
        return
      }
      ;(this.config.enableLazyLoad
        ? this.setupLazyLoading(t)
        : t.forEach((i) => {
            this.initializeGraphElement(i)
          }),
        this.config.enablePreload && this.schedulePreload(),
        this.log(`Graph page setup completed: ${t.length} elements to initialize`))
    }
    onCleanup() {
      ;(this.state.loadingStates.clear(),
        this.state.initializedStates.clear(),
        (this.state.currentSlug = null),
        (this.state.graphModulePromise = null),
        this.cleanupObserver(),
        this.log("Graph cleanup completed"))
    }
    setupLazyLoading(e) {
      ;((this.state.currentObserver = new IntersectionObserver(
        (t) => {
          t.forEach((i) => {
            if (i.isIntersecting) {
              let n = i.target
              ;(this.state.currentObserver?.unobserve(n), this.initializeGraphElement(n))
            }
          })
        },
        { rootMargin: this.config.lazyLoadRootMargin, threshold: this.config.lazyLoadThreshold },
      )),
        e.forEach((t) => {
          this.state.currentObserver?.observe(t)
        }),
        this.addCleanupTask(() => {
          this.cleanupObserver()
        }))
    }
    async initializeGraphElement(e) {
      if (!(this.state.loadingStates.get(e) || this.state.initializedStates.get(e))) {
        this.state.loadingStates.set(e, !0)
        try {
          this.showLoadingState(e)
          let t = await this.preloadGraphModule()
          ;(this.state.currentSlug && (await t.initializeGraph(e, this.state.currentSlug)),
            this.state.initializedStates.set(e, !0),
            this.log("Graph initialized successfully for element:", e.className))
        } catch (t) {
          ;(this.error("Failed to load graph module:", t), this.showErrorState(e))
        } finally {
          this.state.loadingStates.set(e, !1)
        }
      }
    }
    preloadGraphModule() {
      return (
        this.state.graphModulePromise ||
          (this.state.graphModulePromise = Promise.resolve().then(() => (WA(), zA))),
        this.state.graphModulePromise
      )
    }
    schedulePreload() {
      "requestIdleCallback" in window
        ? requestIdleCallback(() => {
            this.preloadGraphModule().catch(() => {})
          })
        : setTimeout(() => {
            this.preloadGraphModule().catch(() => {})
          }, this.config.preloadDelay)
    }
    showLoadingState(e) {
      e.innerHTML = `
      <div class="graph-loading">
        <div class="loading-spinner"></div>
        <p>Loading graph visualization...</p>
      </div>
    `
    }
    showErrorState(e) {
      e.innerHTML = `
      <div class="graph-error">
        <p>Failed to load graph visualization</p>
        <button onclick="location.reload()">Retry</button>
      </div>
    `
    }
    cleanupObserver() {
      this.state.currentObserver &&
        (this.state.currentObserver.disconnect(), (this.state.currentObserver = null))
    }
    setupEscapeHandler() {
      Ca(document, () => {
        document.querySelectorAll(".graph.active").forEach((t) => {
          t.classList.remove("active")
        })
      })
    }
  }
  function II() {
    let r = new oc({
      name: "graph",
      debug: !1,
      enableLazyLoad: !0,
      lazyLoadRootMargin: "50px",
      enablePreload: !0,
      preloadDelay: 2e3,
    })
    ;(Vn.register("graph", r),
      Vn.initialize("graph").catch((e) => {
        console.error("Graph component initialization failed:", e)
      }))
  }
  window.initGraph = II
})()
