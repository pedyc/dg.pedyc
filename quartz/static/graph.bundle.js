"use strict"
;(() => {
  var qE = Object.create
  var Cl = Object.defineProperty
  var ZE = Object.getOwnPropertyDescriptor
  var QE = Object.getOwnPropertyNames
  var JE = Object.getPrototypeOf,
    t1 = Object.prototype.hasOwnProperty
  var p = (r, t) => () => (r && (t = r((r = 0))), t)
  var El = (r, t) => () => (t || r((t = { exports: {} }).exports, t), t.exports),
    Xd = (r, t) => {
      for (var e in t) Cl(r, e, { get: t[e], enumerable: !0 })
    },
    e1 = (r, t, e, i) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let n of QE(t))
          !t1.call(r, n) &&
            n !== e &&
            Cl(r, n, { get: () => t[n], enumerable: !(i = ZE(t, n)) || i.enumerable })
      return r
    }
  var wl = (r, t, e) => (
    (e = r != null ? qE(JE(r)) : {}),
    e1(t || !r || !r.__esModule ? Cl(e, "default", { value: r, enumerable: !0 }) : e, r)
  )
  var tp = El(($F, Jd) => {
    "use strict"
    Jd.exports = l1
    function vi(r) {
      return r instanceof Buffer
        ? Buffer.from(r)
        : new r.constructor(r.buffer.slice(), r.byteOffset, r.length)
    }
    function l1(r) {
      if (((r = r || {}), r.circles)) return c1(r)
      let t = new Map()
      if (
        (t.set(Date, (o) => new Date(o)),
        t.set(Map, (o, a) => new Map(i(Array.from(o), a))),
        t.set(Set, (o, a) => new Set(i(Array.from(o), a))),
        r.constructorHandlers)
      )
        for (let o of r.constructorHandlers) t.set(o[0], o[1])
      let e = null
      return r.proto ? s : n
      function i(o, a) {
        let u = Object.keys(o),
          l = new Array(u.length)
        for (let c = 0; c < u.length; c++) {
          let h = u[c],
            f = o[h]
          typeof f != "object" || f === null
            ? (l[h] = f)
            : f.constructor !== Object && (e = t.get(f.constructor))
              ? (l[h] = e(f, a))
              : ArrayBuffer.isView(f)
                ? (l[h] = vi(f))
                : (l[h] = a(f))
        }
        return l
      }
      function n(o) {
        if (typeof o != "object" || o === null) return o
        if (Array.isArray(o)) return i(o, n)
        if (o.constructor !== Object && (e = t.get(o.constructor))) return e(o, n)
        let a = {}
        for (let u in o) {
          if (Object.hasOwnProperty.call(o, u) === !1) continue
          let l = o[u]
          typeof l != "object" || l === null
            ? (a[u] = l)
            : l.constructor !== Object && (e = t.get(l.constructor))
              ? (a[u] = e(l, n))
              : ArrayBuffer.isView(l)
                ? (a[u] = vi(l))
                : (a[u] = n(l))
        }
        return a
      }
      function s(o) {
        if (typeof o != "object" || o === null) return o
        if (Array.isArray(o)) return i(o, s)
        if (o.constructor !== Object && (e = t.get(o.constructor))) return e(o, s)
        let a = {}
        for (let u in o) {
          let l = o[u]
          typeof l != "object" || l === null
            ? (a[u] = l)
            : l.constructor !== Object && (e = t.get(l.constructor))
              ? (a[u] = e(l, s))
              : ArrayBuffer.isView(l)
                ? (a[u] = vi(l))
                : (a[u] = s(l))
        }
        return a
      }
    }
    function c1(r) {
      let t = [],
        e = [],
        i = new Map()
      if (
        (i.set(Date, (u) => new Date(u)),
        i.set(Map, (u, l) => new Map(s(Array.from(u), l))),
        i.set(Set, (u, l) => new Set(s(Array.from(u), l))),
        r.constructorHandlers)
      )
        for (let u of r.constructorHandlers) i.set(u[0], u[1])
      let n = null
      return r.proto ? a : o
      function s(u, l) {
        let c = Object.keys(u),
          h = new Array(c.length)
        for (let f = 0; f < c.length; f++) {
          let d = c[f],
            g = u[d]
          if (typeof g != "object" || g === null) h[d] = g
          else if (g.constructor !== Object && (n = i.get(g.constructor))) h[d] = n(g, l)
          else if (ArrayBuffer.isView(g)) h[d] = vi(g)
          else {
            let x = t.indexOf(g)
            x !== -1 ? (h[d] = e[x]) : (h[d] = l(g))
          }
        }
        return h
      }
      function o(u) {
        if (typeof u != "object" || u === null) return u
        if (Array.isArray(u)) return s(u, o)
        if (u.constructor !== Object && (n = i.get(u.constructor))) return n(u, o)
        let l = {}
        ;(t.push(u), e.push(l))
        for (let c in u) {
          if (Object.hasOwnProperty.call(u, c) === !1) continue
          let h = u[c]
          if (typeof h != "object" || h === null) l[c] = h
          else if (h.constructor !== Object && (n = i.get(h.constructor))) l[c] = n(h, o)
          else if (ArrayBuffer.isView(h)) l[c] = vi(h)
          else {
            let f = t.indexOf(h)
            f !== -1 ? (l[c] = e[f]) : (l[c] = o(h))
          }
        }
        return (t.pop(), e.pop(), l)
      }
      function a(u) {
        if (typeof u != "object" || u === null) return u
        if (Array.isArray(u)) return s(u, a)
        if (u.constructor !== Object && (n = i.get(u.constructor))) return n(u, a)
        let l = {}
        ;(t.push(u), e.push(l))
        for (let c in u) {
          let h = u[c]
          if (typeof h != "object" || h === null) l[c] = h
          else if (h.constructor !== Object && (n = i.get(h.constructor))) l[c] = n(h, a)
          else if (ArrayBuffer.isView(h)) l[c] = vi(h)
          else {
            let f = t.indexOf(h)
            f !== -1 ? (l[c] = e[f]) : (l[c] = a(h))
          }
        }
        return (t.pop(), e.pop(), l)
      }
    }
  })
  var b,
    ac,
    wa,
    L,
    A = p(() => {
      "use strict"
      ;((b = ((r) => (
        (r.Application = "application"),
        (r.WebGLPipes = "webgl-pipes"),
        (r.WebGLPipesAdaptor = "webgl-pipes-adaptor"),
        (r.WebGLSystem = "webgl-system"),
        (r.WebGPUPipes = "webgpu-pipes"),
        (r.WebGPUPipesAdaptor = "webgpu-pipes-adaptor"),
        (r.WebGPUSystem = "webgpu-system"),
        (r.CanvasSystem = "canvas-system"),
        (r.CanvasPipesAdaptor = "canvas-pipes-adaptor"),
        (r.CanvasPipes = "canvas-pipes"),
        (r.Asset = "asset"),
        (r.LoadParser = "load-parser"),
        (r.ResolveParser = "resolve-parser"),
        (r.CacheParser = "cache-parser"),
        (r.DetectionParser = "detection-parser"),
        (r.MaskEffect = "mask-effect"),
        (r.BlendMode = "blend-mode"),
        (r.TextureSource = "texture-source"),
        (r.Environment = "environment"),
        (r.ShapeBuilder = "shape-builder"),
        (r.Batcher = "batcher"),
        r
      ))(b || {})),
        (ac = (r) => {
          if (typeof r == "function" || (typeof r == "object" && r.extension)) {
            if (!r.extension) throw new Error("Extension class must have an extension object")
            r = {
              ...(typeof r.extension != "object" ? { type: r.extension } : r.extension),
              ref: r,
            }
          }
          if (typeof r == "object") r = { ...r }
          else throw new Error("Invalid extension type")
          return (typeof r.type == "string" && (r.type = [r.type]), r)
        }),
        (wa = (r, t) => ac(r).priority ?? t),
        (L = {
          _addHandlers: {},
          _removeHandlers: {},
          _queue: {},
          remove(...r) {
            return (
              r.map(ac).forEach((t) => {
                t.type.forEach((e) => this._removeHandlers[e]?.(t))
              }),
              this
            )
          },
          add(...r) {
            return (
              r.map(ac).forEach((t) => {
                t.type.forEach((e) => {
                  let i = this._addHandlers,
                    n = this._queue
                  i[e] ? i[e]?.(t) : ((n[e] = n[e] || []), n[e]?.push(t))
                })
              }),
              this
            )
          },
          handle(r, t, e) {
            let i = this._addHandlers,
              n = this._removeHandlers
            if (i[r] || n[r]) throw new Error(`Extension type ${r} already has a handler`)
            ;((i[r] = t), (n[r] = e))
            let s = this._queue
            return (s[r] && (s[r]?.forEach((o) => t(o)), delete s[r]), this)
          },
          handleByMap(r, t) {
            return this.handle(
              r,
              (e) => {
                e.name && (t[e.name] = e.ref)
              },
              (e) => {
                e.name && delete t[e.name]
              },
            )
          },
          handleByNamedList(r, t, e = -1) {
            return this.handle(
              r,
              (i) => {
                t.findIndex((s) => s.name === i.name) >= 0 ||
                  (t.push({ name: i.name, value: i.ref }),
                  t.sort((s, o) => wa(o.value, e) - wa(s.value, e)))
              },
              (i) => {
                let n = t.findIndex((s) => s.name === i.name)
                n !== -1 && t.splice(n, 1)
              },
            )
          },
          handleByList(r, t, e = -1) {
            return this.handle(
              r,
              (i) => {
                t.includes(i.ref) || (t.push(i.ref), t.sort((n, s) => wa(s, e) - wa(n, e)))
              },
              (i) => {
                let n = t.indexOf(i.ref)
                n !== -1 && t.splice(n, 1)
              },
            )
          },
          mixin(r, ...t) {
            for (let e of t)
              Object.defineProperties(r.prototype, Object.getOwnPropertyDescriptors(e))
          },
        }))
    })
  var mg = El((DO, uc) => {
    "use strict"
    var UM = Object.prototype.hasOwnProperty,
      Qt = "~"
    function qn() {}
    Object.create && ((qn.prototype = Object.create(null)), new qn().__proto__ || (Qt = !1))
    function OM(r, t, e) {
      ;((this.fn = r), (this.context = t), (this.once = e || !1))
    }
    function pg(r, t, e, i, n) {
      if (typeof e != "function") throw new TypeError("The listener must be a function")
      var s = new OM(e, i || r, n),
        o = Qt ? Qt + t : t
      return (
        r._events[o]
          ? r._events[o].fn
            ? (r._events[o] = [r._events[o], s])
            : r._events[o].push(s)
          : ((r._events[o] = s), r._eventsCount++),
        r
      )
    }
    function Ma(r, t) {
      --r._eventsCount === 0 ? (r._events = new qn()) : delete r._events[t]
    }
    function Xt() {
      ;((this._events = new qn()), (this._eventsCount = 0))
    }
    Xt.prototype.eventNames = function () {
      var t = [],
        e,
        i
      if (this._eventsCount === 0) return t
      for (i in (e = this._events)) UM.call(e, i) && t.push(Qt ? i.slice(1) : i)
      return Object.getOwnPropertySymbols ? t.concat(Object.getOwnPropertySymbols(e)) : t
    }
    Xt.prototype.listeners = function (t) {
      var e = Qt ? Qt + t : t,
        i = this._events[e]
      if (!i) return []
      if (i.fn) return [i.fn]
      for (var n = 0, s = i.length, o = new Array(s); n < s; n++) o[n] = i[n].fn
      return o
    }
    Xt.prototype.listenerCount = function (t) {
      var e = Qt ? Qt + t : t,
        i = this._events[e]
      return i ? (i.fn ? 1 : i.length) : 0
    }
    Xt.prototype.emit = function (t, e, i, n, s, o) {
      var a = Qt ? Qt + t : t
      if (!this._events[a]) return !1
      var u = this._events[a],
        l = arguments.length,
        c,
        h
      if (u.fn) {
        switch ((u.once && this.removeListener(t, u.fn, void 0, !0), l)) {
          case 1:
            return (u.fn.call(u.context), !0)
          case 2:
            return (u.fn.call(u.context, e), !0)
          case 3:
            return (u.fn.call(u.context, e, i), !0)
          case 4:
            return (u.fn.call(u.context, e, i, n), !0)
          case 5:
            return (u.fn.call(u.context, e, i, n, s), !0)
          case 6:
            return (u.fn.call(u.context, e, i, n, s, o), !0)
        }
        for (h = 1, c = new Array(l - 1); h < l; h++) c[h - 1] = arguments[h]
        u.fn.apply(u.context, c)
      } else {
        var f = u.length,
          d
        for (h = 0; h < f; h++)
          switch ((u[h].once && this.removeListener(t, u[h].fn, void 0, !0), l)) {
            case 1:
              u[h].fn.call(u[h].context)
              break
            case 2:
              u[h].fn.call(u[h].context, e)
              break
            case 3:
              u[h].fn.call(u[h].context, e, i)
              break
            case 4:
              u[h].fn.call(u[h].context, e, i, n)
              break
            default:
              if (!c) for (d = 1, c = new Array(l - 1); d < l; d++) c[d - 1] = arguments[d]
              u[h].fn.apply(u[h].context, c)
          }
      }
      return !0
    }
    Xt.prototype.on = function (t, e, i) {
      return pg(this, t, e, i, !1)
    }
    Xt.prototype.once = function (t, e, i) {
      return pg(this, t, e, i, !0)
    }
    Xt.prototype.removeListener = function (t, e, i, n) {
      var s = Qt ? Qt + t : t
      if (!this._events[s]) return this
      if (!e) return (Ma(this, s), this)
      var o = this._events[s]
      if (o.fn) o.fn === e && (!n || o.once) && (!i || o.context === i) && Ma(this, s)
      else {
        for (var a = 0, u = [], l = o.length; a < l; a++)
          (o[a].fn !== e || (n && !o[a].once) || (i && o[a].context !== i)) && u.push(o[a])
        u.length ? (this._events[s] = u.length === 1 ? u[0] : u) : Ma(this, s)
      }
      return this
    }
    Xt.prototype.removeAllListeners = function (t) {
      var e
      return (
        t
          ? ((e = Qt ? Qt + t : t), this._events[e] && Ma(this, e))
          : ((this._events = new qn()), (this._eventsCount = 0)),
        this
      )
    }
    Xt.prototype.off = Xt.prototype.removeListener
    Xt.prototype.addListener = Xt.prototype.on
    Xt.prefixed = Qt
    Xt.EventEmitter = Xt
    typeof uc < "u" && (uc.exports = Xt)
  })
  var gg,
    lt,
    Wt = p(() => {
      ;((gg = wl(mg(), 1)), (lt = gg.default))
    })
  var LM,
    Qe,
    Ut,
    xe,
    Cg,
    xg,
    lc,
    NM,
    Aa,
    Eg,
    wg,
    _g,
    yg,
    bg,
    Zn,
    HM,
    zM,
    WM,
    VM,
    fc,
    vg,
    $M,
    cc,
    hc,
    Sg,
    dc,
    Ce,
    Tg,
    Mg,
    Ag = p(() => {
      ;((LM = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) }),
        (Qe = function (r) {
          return typeof r == "string" ? r.length > 0 : typeof r == "number"
        }),
        (Ut = function (r, t, e) {
          return (
            t === void 0 && (t = 0),
            e === void 0 && (e = Math.pow(10, t)),
            Math.round(e * r) / e + 0
          )
        }),
        (xe = function (r, t, e) {
          return (t === void 0 && (t = 0), e === void 0 && (e = 1), r > e ? e : r > t ? r : t)
        }),
        (Cg = function (r) {
          return (r = isFinite(r) ? r % 360 : 0) > 0 ? r : r + 360
        }),
        (xg = function (r) {
          return { r: xe(r.r, 0, 255), g: xe(r.g, 0, 255), b: xe(r.b, 0, 255), a: xe(r.a) }
        }),
        (lc = function (r) {
          return { r: Ut(r.r), g: Ut(r.g), b: Ut(r.b), a: Ut(r.a, 3) }
        }),
        (NM = /^#([0-9a-f]{3,8})$/i),
        (Aa = function (r) {
          var t = r.toString(16)
          return t.length < 2 ? "0" + t : t
        }),
        (Eg = function (r) {
          var t = r.r,
            e = r.g,
            i = r.b,
            n = r.a,
            s = Math.max(t, e, i),
            o = s - Math.min(t, e, i),
            a = o ? (s === t ? (e - i) / o : s === e ? 2 + (i - t) / o : 4 + (t - e) / o) : 0
          return { h: 60 * (a < 0 ? a + 6 : a), s: s ? (o / s) * 100 : 0, v: (s / 255) * 100, a: n }
        }),
        (wg = function (r) {
          var t = r.h,
            e = r.s,
            i = r.v,
            n = r.a
          ;((t = (t / 360) * 6), (e /= 100), (i /= 100))
          var s = Math.floor(t),
            o = i * (1 - e),
            a = i * (1 - (t - s) * e),
            u = i * (1 - (1 - t + s) * e),
            l = s % 6
          return {
            r: 255 * [i, a, o, o, u, i][l],
            g: 255 * [u, i, i, a, o, o][l],
            b: 255 * [o, o, u, i, i, a][l],
            a: n,
          }
        }),
        (_g = function (r) {
          return { h: Cg(r.h), s: xe(r.s, 0, 100), l: xe(r.l, 0, 100), a: xe(r.a) }
        }),
        (yg = function (r) {
          return { h: Ut(r.h), s: Ut(r.s), l: Ut(r.l), a: Ut(r.a, 3) }
        }),
        (bg = function (r) {
          return wg(
            ((e = (t = r).s),
            {
              h: t.h,
              s: (e *= ((i = t.l) < 50 ? i : 100 - i) / 100) > 0 ? ((2 * e) / (i + e)) * 100 : 0,
              v: i + e,
              a: t.a,
            }),
          )
          var t, e, i
        }),
        (Zn = function (r) {
          return {
            h: (t = Eg(r)).h,
            s:
              (n = ((200 - (e = t.s)) * (i = t.v)) / 100) > 0 && n < 200
                ? ((e * i) / 100 / (n <= 100 ? n : 200 - n)) * 100
                : 0,
            l: n / 2,
            a: t.a,
          }
          var t, e, i, n
        }),
        (HM =
          /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i),
        (zM =
          /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i),
        (WM =
          /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i),
        (VM =
          /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i),
        (fc = {
          string: [
            [
              function (r) {
                var t = NM.exec(r)
                return t
                  ? (r = t[1]).length <= 4
                    ? {
                        r: parseInt(r[0] + r[0], 16),
                        g: parseInt(r[1] + r[1], 16),
                        b: parseInt(r[2] + r[2], 16),
                        a: r.length === 4 ? Ut(parseInt(r[3] + r[3], 16) / 255, 2) : 1,
                      }
                    : r.length === 6 || r.length === 8
                      ? {
                          r: parseInt(r.substr(0, 2), 16),
                          g: parseInt(r.substr(2, 2), 16),
                          b: parseInt(r.substr(4, 2), 16),
                          a: r.length === 8 ? Ut(parseInt(r.substr(6, 2), 16) / 255, 2) : 1,
                        }
                      : null
                  : null
              },
              "hex",
            ],
            [
              function (r) {
                var t = WM.exec(r) || VM.exec(r)
                return t
                  ? t[2] !== t[4] || t[4] !== t[6]
                    ? null
                    : xg({
                        r: Number(t[1]) / (t[2] ? 100 / 255 : 1),
                        g: Number(t[3]) / (t[4] ? 100 / 255 : 1),
                        b: Number(t[5]) / (t[6] ? 100 / 255 : 1),
                        a: t[7] === void 0 ? 1 : Number(t[7]) / (t[8] ? 100 : 1),
                      })
                  : null
              },
              "rgb",
            ],
            [
              function (r) {
                var t = HM.exec(r) || zM.exec(r)
                if (!t) return null
                var e,
                  i,
                  n = _g({
                    h:
                      ((e = t[1]),
                      (i = t[2]),
                      i === void 0 && (i = "deg"),
                      Number(e) * (LM[i] || 1)),
                    s: Number(t[3]),
                    l: Number(t[4]),
                    a: t[5] === void 0 ? 1 : Number(t[5]) / (t[6] ? 100 : 1),
                  })
                return bg(n)
              },
              "hsl",
            ],
          ],
          object: [
            [
              function (r) {
                var t = r.r,
                  e = r.g,
                  i = r.b,
                  n = r.a,
                  s = n === void 0 ? 1 : n
                return Qe(t) && Qe(e) && Qe(i)
                  ? xg({ r: Number(t), g: Number(e), b: Number(i), a: Number(s) })
                  : null
              },
              "rgb",
            ],
            [
              function (r) {
                var t = r.h,
                  e = r.s,
                  i = r.l,
                  n = r.a,
                  s = n === void 0 ? 1 : n
                if (!Qe(t) || !Qe(e) || !Qe(i)) return null
                var o = _g({ h: Number(t), s: Number(e), l: Number(i), a: Number(s) })
                return bg(o)
              },
              "hsl",
            ],
            [
              function (r) {
                var t = r.h,
                  e = r.s,
                  i = r.v,
                  n = r.a,
                  s = n === void 0 ? 1 : n
                if (!Qe(t) || !Qe(e) || !Qe(i)) return null
                var o = (function (a) {
                  return { h: Cg(a.h), s: xe(a.s, 0, 100), v: xe(a.v, 0, 100), a: xe(a.a) }
                })({ h: Number(t), s: Number(e), v: Number(i), a: Number(s) })
                return wg(o)
              },
              "hsv",
            ],
          ],
        }),
        (vg = function (r, t) {
          for (var e = 0; e < t.length; e++) {
            var i = t[e][0](r)
            if (i) return [i, t[e][1]]
          }
          return [null, void 0]
        }),
        ($M = function (r) {
          return typeof r == "string"
            ? vg(r.trim(), fc.string)
            : typeof r == "object" && r !== null
              ? vg(r, fc.object)
              : [null, void 0]
        }),
        (cc = function (r, t) {
          var e = Zn(r)
          return { h: e.h, s: xe(e.s + 100 * t, 0, 100), l: e.l, a: e.a }
        }),
        (hc = function (r) {
          return (299 * r.r + 587 * r.g + 114 * r.b) / 1e3 / 255
        }),
        (Sg = function (r, t) {
          var e = Zn(r)
          return { h: e.h, s: e.s, l: xe(e.l + 100 * t, 0, 100), a: e.a }
        }),
        (dc = (function () {
          function r(t) {
            ;((this.parsed = $M(t)[0]), (this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 }))
          }
          return (
            (r.prototype.isValid = function () {
              return this.parsed !== null
            }),
            (r.prototype.brightness = function () {
              return Ut(hc(this.rgba), 2)
            }),
            (r.prototype.isDark = function () {
              return hc(this.rgba) < 0.5
            }),
            (r.prototype.isLight = function () {
              return hc(this.rgba) >= 0.5
            }),
            (r.prototype.toHex = function () {
              return (
                (t = lc(this.rgba)),
                (e = t.r),
                (i = t.g),
                (n = t.b),
                (o = (s = t.a) < 1 ? Aa(Ut(255 * s)) : ""),
                "#" + Aa(e) + Aa(i) + Aa(n) + o
              )
              var t, e, i, n, s, o
            }),
            (r.prototype.toRgb = function () {
              return lc(this.rgba)
            }),
            (r.prototype.toRgbString = function () {
              return (
                (t = lc(this.rgba)),
                (e = t.r),
                (i = t.g),
                (n = t.b),
                (s = t.a) < 1
                  ? "rgba(" + e + ", " + i + ", " + n + ", " + s + ")"
                  : "rgb(" + e + ", " + i + ", " + n + ")"
              )
              var t, e, i, n, s
            }),
            (r.prototype.toHsl = function () {
              return yg(Zn(this.rgba))
            }),
            (r.prototype.toHslString = function () {
              return (
                (t = yg(Zn(this.rgba))),
                (e = t.h),
                (i = t.s),
                (n = t.l),
                (s = t.a) < 1
                  ? "hsla(" + e + ", " + i + "%, " + n + "%, " + s + ")"
                  : "hsl(" + e + ", " + i + "%, " + n + "%)"
              )
              var t, e, i, n, s
            }),
            (r.prototype.toHsv = function () {
              return ((t = Eg(this.rgba)), { h: Ut(t.h), s: Ut(t.s), v: Ut(t.v), a: Ut(t.a, 3) })
              var t
            }),
            (r.prototype.invert = function () {
              return Ce({ r: 255 - (t = this.rgba).r, g: 255 - t.g, b: 255 - t.b, a: t.a })
              var t
            }),
            (r.prototype.saturate = function (t) {
              return (t === void 0 && (t = 0.1), Ce(cc(this.rgba, t)))
            }),
            (r.prototype.desaturate = function (t) {
              return (t === void 0 && (t = 0.1), Ce(cc(this.rgba, -t)))
            }),
            (r.prototype.grayscale = function () {
              return Ce(cc(this.rgba, -1))
            }),
            (r.prototype.lighten = function (t) {
              return (t === void 0 && (t = 0.1), Ce(Sg(this.rgba, t)))
            }),
            (r.prototype.darken = function (t) {
              return (t === void 0 && (t = 0.1), Ce(Sg(this.rgba, -t)))
            }),
            (r.prototype.rotate = function (t) {
              return (t === void 0 && (t = 15), this.hue(this.hue() + t))
            }),
            (r.prototype.alpha = function (t) {
              return typeof t == "number"
                ? Ce({ r: (e = this.rgba).r, g: e.g, b: e.b, a: t })
                : Ut(this.rgba.a, 3)
              var e
            }),
            (r.prototype.hue = function (t) {
              var e = Zn(this.rgba)
              return typeof t == "number" ? Ce({ h: t, s: e.s, l: e.l, a: e.a }) : Ut(e.h)
            }),
            (r.prototype.isEqual = function (t) {
              return this.toHex() === Ce(t).toHex()
            }),
            r
          )
        })()),
        (Ce = function (r) {
          return r instanceof dc ? r : new dc(r)
        }),
        (Tg = []),
        (Mg = function (r) {
          r.forEach(function (t) {
            Tg.indexOf(t) < 0 && (t(dc, fc), Tg.push(t))
          })
        }))
    })
  function Dg(r, t) {
    var e = {
        white: "#ffffff",
        bisque: "#ffe4c4",
        blue: "#0000ff",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        azure: "#f0ffff",
        whitesmoke: "#f5f5f5",
        papayawhip: "#ffefd5",
        plum: "#dda0dd",
        blanchedalmond: "#ffebcd",
        black: "#000000",
        gold: "#ffd700",
        goldenrod: "#daa520",
        gainsboro: "#dcdcdc",
        cornsilk: "#fff8dc",
        cornflowerblue: "#6495ed",
        burlywood: "#deb887",
        aquamarine: "#7fffd4",
        beige: "#f5f5dc",
        crimson: "#dc143c",
        cyan: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkkhaki: "#bdb76b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkgrey: "#a9a9a9",
        peachpuff: "#ffdab9",
        darkmagenta: "#8b008b",
        darkred: "#8b0000",
        darkorchid: "#9932cc",
        darkorange: "#ff8c00",
        darkslateblue: "#483d8b",
        gray: "#808080",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        wheat: "#f5deb3",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        ghostwhite: "#f8f8ff",
        darkviolet: "#9400d3",
        magenta: "#ff00ff",
        green: "#008000",
        dodgerblue: "#1e90ff",
        grey: "#808080",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        blueviolet: "#8a2be2",
        forestgreen: "#228b22",
        lawngreen: "#7cfc00",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        fuchsia: "#ff00ff",
        brown: "#a52a2a",
        maroon: "#800000",
        mediumblue: "#0000cd",
        lightcoral: "#f08080",
        darkturquoise: "#00ced1",
        lightcyan: "#e0ffff",
        ivory: "#fffff0",
        lightyellow: "#ffffe0",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        linen: "#faf0e6",
        mediumaquamarine: "#66cdaa",
        lemonchiffon: "#fffacd",
        lime: "#00ff00",
        khaki: "#f0e68c",
        mediumseagreen: "#3cb371",
        limegreen: "#32cd32",
        mediumspringgreen: "#00fa9a",
        lightskyblue: "#87cefa",
        lightblue: "#add8e6",
        midnightblue: "#191970",
        lightpink: "#ffb6c1",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        mintcream: "#f5fffa",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        navajowhite: "#ffdead",
        navy: "#000080",
        mediumvioletred: "#c71585",
        powderblue: "#b0e0e6",
        palegoldenrod: "#eee8aa",
        oldlace: "#fdf5e6",
        paleturquoise: "#afeeee",
        mediumturquoise: "#48d1cc",
        mediumorchid: "#ba55d3",
        rebeccapurple: "#663399",
        lightsteelblue: "#b0c4de",
        mediumslateblue: "#7b68ee",
        thistle: "#d8bfd8",
        tan: "#d2b48c",
        orchid: "#da70d6",
        mediumpurple: "#9370db",
        purple: "#800080",
        pink: "#ffc0cb",
        skyblue: "#87ceeb",
        springgreen: "#00ff7f",
        palegreen: "#98fb98",
        red: "#ff0000",
        yellow: "#ffff00",
        slateblue: "#6a5acd",
        lavenderblush: "#fff0f5",
        peru: "#cd853f",
        palevioletred: "#db7093",
        violet: "#ee82ee",
        teal: "#008080",
        slategray: "#708090",
        slategrey: "#708090",
        aliceblue: "#f0f8ff",
        darkseagreen: "#8fbc8f",
        darkolivegreen: "#556b2f",
        greenyellow: "#adff2f",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        tomato: "#ff6347",
        silver: "#c0c0c0",
        sienna: "#a0522d",
        lavender: "#e6e6fa",
        lightgreen: "#90ee90",
        orange: "#ffa500",
        orangered: "#ff4500",
        steelblue: "#4682b4",
        royalblue: "#4169e1",
        turquoise: "#40e0d0",
        yellowgreen: "#9acd32",
        salmon: "#fa8072",
        saddlebrown: "#8b4513",
        sandybrown: "#f4a460",
        rosybrown: "#bc8f8f",
        darksalmon: "#e9967a",
        lightgoldenrodyellow: "#fafad2",
        snow: "#fffafa",
        lightgrey: "#d3d3d3",
        lightgray: "#d3d3d3",
        dimgray: "#696969",
        dimgrey: "#696969",
        olivedrab: "#6b8e23",
        olive: "#808000",
      },
      i = {}
    for (var n in e) i[e[n]] = n
    var s = {}
    ;((r.prototype.toName = function (o) {
      if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent"
      var a,
        u,
        l = i[this.toHex()]
      if (l) return l
      if (o?.closest) {
        var c = this.toRgb(),
          h = 1 / 0,
          f = "black"
        if (!s.length) for (var d in e) s[d] = new r(e[d]).toRgb()
        for (var g in e) {
          var x =
            ((a = c),
            (u = s[g]),
            Math.pow(a.r - u.r, 2) + Math.pow(a.g - u.g, 2) + Math.pow(a.b - u.b, 2))
          x < h && ((h = x), (f = g))
        }
        return f
      }
    }),
      t.string.push([
        function (o) {
          var a = o.toLowerCase(),
            u = a === "transparent" ? "#0000" : e[a]
          return u ? new r(u).toRgb() : null
        },
        "name",
      ]))
  }
  var Pg = p(() => {})
  var Ai,
    q,
    Vt = p(() => {
      Ag()
      Pg()
      Mg([Dg])
      Ai = class Qn {
        constructor(t = 16777215) {
          ;((this._value = null),
            (this._components = new Float32Array(4)),
            this._components.fill(1),
            (this._int = 16777215),
            (this.value = t))
        }
        get red() {
          return this._components[0]
        }
        get green() {
          return this._components[1]
        }
        get blue() {
          return this._components[2]
        }
        get alpha() {
          return this._components[3]
        }
        setValue(t) {
          return ((this.value = t), this)
        }
        set value(t) {
          if (t instanceof Qn)
            ((this._value = this._cloneSource(t._value)),
              (this._int = t._int),
              this._components.set(t._components))
          else {
            if (t === null) throw new Error("Cannot set Color#value to null")
            ;(this._value === null || !this._isSourceEqual(this._value, t)) &&
              ((this._value = this._cloneSource(t)), this._normalize(this._value))
          }
        }
        get value() {
          return this._value
        }
        _cloneSource(t) {
          return typeof t == "string" || typeof t == "number" || t instanceof Number || t === null
            ? t
            : Array.isArray(t) || ArrayBuffer.isView(t)
              ? t.slice(0)
              : typeof t == "object" && t !== null
                ? { ...t }
                : t
        }
        _isSourceEqual(t, e) {
          let i = typeof t
          if (i !== typeof e) return !1
          if (i === "number" || i === "string" || t instanceof Number) return t === e
          if (
            (Array.isArray(t) && Array.isArray(e)) ||
            (ArrayBuffer.isView(t) && ArrayBuffer.isView(e))
          )
            return t.length !== e.length ? !1 : t.every((s, o) => s === e[o])
          if (t !== null && e !== null) {
            let s = Object.keys(t),
              o = Object.keys(e)
            return s.length !== o.length ? !1 : s.every((a) => t[a] === e[a])
          }
          return t === e
        }
        toRgba() {
          let [t, e, i, n] = this._components
          return { r: t, g: e, b: i, a: n }
        }
        toRgb() {
          let [t, e, i] = this._components
          return { r: t, g: e, b: i }
        }
        toRgbaString() {
          let [t, e, i] = this.toUint8RgbArray()
          return `rgba(${t},${e},${i},${this.alpha})`
        }
        toUint8RgbArray(t) {
          let [e, i, n] = this._components
          return (
            this._arrayRgb || (this._arrayRgb = []),
            t || (t = this._arrayRgb),
            (t[0] = Math.round(e * 255)),
            (t[1] = Math.round(i * 255)),
            (t[2] = Math.round(n * 255)),
            t
          )
        }
        toArray(t) {
          ;(this._arrayRgba || (this._arrayRgba = []), t || (t = this._arrayRgba))
          let [e, i, n, s] = this._components
          return ((t[0] = e), (t[1] = i), (t[2] = n), (t[3] = s), t)
        }
        toRgbArray(t) {
          ;(this._arrayRgb || (this._arrayRgb = []), t || (t = this._arrayRgb))
          let [e, i, n] = this._components
          return ((t[0] = e), (t[1] = i), (t[2] = n), t)
        }
        toNumber() {
          return this._int
        }
        toBgrNumber() {
          let [t, e, i] = this.toUint8RgbArray()
          return (i << 16) + (e << 8) + t
        }
        toLittleEndianNumber() {
          let t = this._int
          return (t >> 16) + (t & 65280) + ((t & 255) << 16)
        }
        multiply(t) {
          let [e, i, n, s] = Qn._temp.setValue(t)._components
          return (
            (this._components[0] *= e),
            (this._components[1] *= i),
            (this._components[2] *= n),
            (this._components[3] *= s),
            this._refreshInt(),
            (this._value = null),
            this
          )
        }
        premultiply(t, e = !0) {
          return (
            e &&
              ((this._components[0] *= t), (this._components[1] *= t), (this._components[2] *= t)),
            (this._components[3] = t),
            this._refreshInt(),
            (this._value = null),
            this
          )
        }
        toPremultiplied(t, e = !0) {
          if (t === 1) return (255 << 24) + this._int
          if (t === 0) return e ? 0 : this._int
          let i = (this._int >> 16) & 255,
            n = (this._int >> 8) & 255,
            s = this._int & 255
          return (
            e && ((i = (i * t + 0.5) | 0), (n = (n * t + 0.5) | 0), (s = (s * t + 0.5) | 0)),
            ((t * 255) << 24) + (i << 16) + (n << 8) + s
          )
        }
        toHex() {
          let t = this._int.toString(16)
          return `#${"000000".substring(0, 6 - t.length) + t}`
        }
        toHexa() {
          let e = Math.round(this._components[3] * 255).toString(16)
          return this.toHex() + "00".substring(0, 2 - e.length) + e
        }
        setAlpha(t) {
          return ((this._components[3] = this._clamp(t)), this)
        }
        _normalize(t) {
          let e, i, n, s
          if ((typeof t == "number" || t instanceof Number) && t >= 0 && t <= 16777215) {
            let o = t
            ;((e = ((o >> 16) & 255) / 255),
              (i = ((o >> 8) & 255) / 255),
              (n = (o & 255) / 255),
              (s = 1))
          } else if (
            (Array.isArray(t) || t instanceof Float32Array) &&
            t.length >= 3 &&
            t.length <= 4
          )
            ((t = this._clamp(t)), ([e, i, n, s = 1] = t))
          else if (
            (t instanceof Uint8Array || t instanceof Uint8ClampedArray) &&
            t.length >= 3 &&
            t.length <= 4
          )
            ((t = this._clamp(t, 0, 255)),
              ([e, i, n, s = 255] = t),
              (e /= 255),
              (i /= 255),
              (n /= 255),
              (s /= 255))
          else if (typeof t == "string" || typeof t == "object") {
            if (typeof t == "string") {
              let a = Qn.HEX_PATTERN.exec(t)
              a && (t = `#${a[2]}`)
            }
            let o = Ce(t)
            o.isValid() &&
              (({ r: e, g: i, b: n, a: s } = o.rgba), (e /= 255), (i /= 255), (n /= 255))
          }
          if (e !== void 0)
            ((this._components[0] = e),
              (this._components[1] = i),
              (this._components[2] = n),
              (this._components[3] = s),
              this._refreshInt())
          else throw new Error(`Unable to convert color ${t}`)
        }
        _refreshInt() {
          this._clamp(this._components)
          let [t, e, i] = this._components
          this._int = ((t * 255) << 16) + ((e * 255) << 8) + ((i * 255) | 0)
        }
        _clamp(t, e = 0, i = 1) {
          return typeof t == "number"
            ? Math.min(Math.max(t, e), i)
            : (t.forEach((n, s) => {
                t[s] = Math.min(Math.max(n, e), i)
              }),
              t)
        }
        static isColorLike(t) {
          return (
            typeof t == "number" ||
            typeof t == "string" ||
            t instanceof Number ||
            t instanceof Qn ||
            Array.isArray(t) ||
            t instanceof Uint8Array ||
            t instanceof Uint8ClampedArray ||
            t instanceof Float32Array ||
            (t.r !== void 0 && t.g !== void 0 && t.b !== void 0) ||
            (t.r !== void 0 && t.g !== void 0 && t.b !== void 0 && t.a !== void 0) ||
            (t.h !== void 0 && t.s !== void 0 && t.l !== void 0) ||
            (t.h !== void 0 && t.s !== void 0 && t.l !== void 0 && t.a !== void 0) ||
            (t.h !== void 0 && t.s !== void 0 && t.v !== void 0) ||
            (t.h !== void 0 && t.s !== void 0 && t.v !== void 0 && t.a !== void 0)
          )
        }
      }
      Ai.shared = new Ai()
      Ai._temp = new Ai()
      Ai.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i
      q = Ai
    })
  var Fg,
    Rg = p(() => {
      "use strict"
      Fg = { cullArea: null, cullable: !1, cullableChildren: !0 }
    })
  var Bg,
    Ig,
    kg,
    pc = p(() => {
      "use strict"
      ;((Bg = Math.PI * 2), (Ig = 180 / Math.PI), (kg = Math.PI / 180))
    })
  var rt,
    mc,
    Ee = p(() => {
      "use strict"
      ;((rt = class r {
        constructor(t = 0, e = 0) {
          ;((this.x = 0), (this.y = 0), (this.x = t), (this.y = e))
        }
        clone() {
          return new r(this.x, this.y)
        }
        copyFrom(t) {
          return (this.set(t.x, t.y), this)
        }
        copyTo(t) {
          return (t.set(this.x, this.y), t)
        }
        equals(t) {
          return t.x === this.x && t.y === this.y
        }
        set(t = 0, e = t) {
          return ((this.x = t), (this.y = e), this)
        }
        toString() {
          return `[pixi.js/math:Point x=${this.x} y=${this.y}]`
        }
        static get shared() {
          return ((mc.x = 0), (mc.y = 0), mc)
        }
      }),
        (mc = new rt()))
    })
  var I,
    XM,
    YM,
    nt = p(() => {
      pc()
      Ee()
      ;((I = class r {
        constructor(t = 1, e = 0, i = 0, n = 1, s = 0, o = 0) {
          ;((this.array = null),
            (this.a = t),
            (this.b = e),
            (this.c = i),
            (this.d = n),
            (this.tx = s),
            (this.ty = o))
        }
        fromArray(t) {
          ;((this.a = t[0]),
            (this.b = t[1]),
            (this.c = t[3]),
            (this.d = t[4]),
            (this.tx = t[2]),
            (this.ty = t[5]))
        }
        set(t, e, i, n, s, o) {
          return (
            (this.a = t),
            (this.b = e),
            (this.c = i),
            (this.d = n),
            (this.tx = s),
            (this.ty = o),
            this
          )
        }
        toArray(t, e) {
          this.array || (this.array = new Float32Array(9))
          let i = e || this.array
          return (
            t
              ? ((i[0] = this.a),
                (i[1] = this.b),
                (i[2] = 0),
                (i[3] = this.c),
                (i[4] = this.d),
                (i[5] = 0),
                (i[6] = this.tx),
                (i[7] = this.ty),
                (i[8] = 1))
              : ((i[0] = this.a),
                (i[1] = this.c),
                (i[2] = this.tx),
                (i[3] = this.b),
                (i[4] = this.d),
                (i[5] = this.ty),
                (i[6] = 0),
                (i[7] = 0),
                (i[8] = 1)),
            i
          )
        }
        apply(t, e) {
          e = e || new rt()
          let i = t.x,
            n = t.y
          return (
            (e.x = this.a * i + this.c * n + this.tx),
            (e.y = this.b * i + this.d * n + this.ty),
            e
          )
        }
        applyInverse(t, e) {
          e = e || new rt()
          let i = this.a,
            n = this.b,
            s = this.c,
            o = this.d,
            a = this.tx,
            u = this.ty,
            l = 1 / (i * o + s * -n),
            c = t.x,
            h = t.y
          return (
            (e.x = o * l * c + -s * l * h + (u * s - a * o) * l),
            (e.y = i * l * h + -n * l * c + (-u * i + a * n) * l),
            e
          )
        }
        translate(t, e) {
          return ((this.tx += t), (this.ty += e), this)
        }
        scale(t, e) {
          return (
            (this.a *= t),
            (this.d *= e),
            (this.c *= t),
            (this.b *= e),
            (this.tx *= t),
            (this.ty *= e),
            this
          )
        }
        rotate(t) {
          let e = Math.cos(t),
            i = Math.sin(t),
            n = this.a,
            s = this.c,
            o = this.tx
          return (
            (this.a = n * e - this.b * i),
            (this.b = n * i + this.b * e),
            (this.c = s * e - this.d * i),
            (this.d = s * i + this.d * e),
            (this.tx = o * e - this.ty * i),
            (this.ty = o * i + this.ty * e),
            this
          )
        }
        append(t) {
          let e = this.a,
            i = this.b,
            n = this.c,
            s = this.d
          return (
            (this.a = t.a * e + t.b * n),
            (this.b = t.a * i + t.b * s),
            (this.c = t.c * e + t.d * n),
            (this.d = t.c * i + t.d * s),
            (this.tx = t.tx * e + t.ty * n + this.tx),
            (this.ty = t.tx * i + t.ty * s + this.ty),
            this
          )
        }
        appendFrom(t, e) {
          let i = t.a,
            n = t.b,
            s = t.c,
            o = t.d,
            a = t.tx,
            u = t.ty,
            l = e.a,
            c = e.b,
            h = e.c,
            f = e.d
          return (
            (this.a = i * l + n * h),
            (this.b = i * c + n * f),
            (this.c = s * l + o * h),
            (this.d = s * c + o * f),
            (this.tx = a * l + u * h + e.tx),
            (this.ty = a * c + u * f + e.ty),
            this
          )
        }
        setTransform(t, e, i, n, s, o, a, u, l) {
          return (
            (this.a = Math.cos(a + l) * s),
            (this.b = Math.sin(a + l) * s),
            (this.c = -Math.sin(a - u) * o),
            (this.d = Math.cos(a - u) * o),
            (this.tx = t - (i * this.a + n * this.c)),
            (this.ty = e - (i * this.b + n * this.d)),
            this
          )
        }
        prepend(t) {
          let e = this.tx
          if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {
            let i = this.a,
              n = this.c
            ;((this.a = i * t.a + this.b * t.c),
              (this.b = i * t.b + this.b * t.d),
              (this.c = n * t.a + this.d * t.c),
              (this.d = n * t.b + this.d * t.d))
          }
          return (
            (this.tx = e * t.a + this.ty * t.c + t.tx),
            (this.ty = e * t.b + this.ty * t.d + t.ty),
            this
          )
        }
        decompose(t) {
          let e = this.a,
            i = this.b,
            n = this.c,
            s = this.d,
            o = t.pivot,
            a = -Math.atan2(-n, s),
            u = Math.atan2(i, e),
            l = Math.abs(a + u)
          return (
            l < 1e-5 || Math.abs(Bg - l) < 1e-5
              ? ((t.rotation = u), (t.skew.x = t.skew.y = 0))
              : ((t.rotation = 0), (t.skew.x = a), (t.skew.y = u)),
            (t.scale.x = Math.sqrt(e * e + i * i)),
            (t.scale.y = Math.sqrt(n * n + s * s)),
            (t.position.x = this.tx + (o.x * e + o.y * n)),
            (t.position.y = this.ty + (o.x * i + o.y * s)),
            t
          )
        }
        invert() {
          let t = this.a,
            e = this.b,
            i = this.c,
            n = this.d,
            s = this.tx,
            o = t * n - e * i
          return (
            (this.a = n / o),
            (this.b = -e / o),
            (this.c = -i / o),
            (this.d = t / o),
            (this.tx = (i * this.ty - n * s) / o),
            (this.ty = -(t * this.ty - e * s) / o),
            this
          )
        }
        isIdentity() {
          return (
            this.a === 1 &&
            this.b === 0 &&
            this.c === 0 &&
            this.d === 1 &&
            this.tx === 0 &&
            this.ty === 0
          )
        }
        identity() {
          return (
            (this.a = 1),
            (this.b = 0),
            (this.c = 0),
            (this.d = 1),
            (this.tx = 0),
            (this.ty = 0),
            this
          )
        }
        clone() {
          let t = new r()
          return (
            (t.a = this.a),
            (t.b = this.b),
            (t.c = this.c),
            (t.d = this.d),
            (t.tx = this.tx),
            (t.ty = this.ty),
            t
          )
        }
        copyTo(t) {
          return (
            (t.a = this.a),
            (t.b = this.b),
            (t.c = this.c),
            (t.d = this.d),
            (t.tx = this.tx),
            (t.ty = this.ty),
            t
          )
        }
        copyFrom(t) {
          return (
            (this.a = t.a),
            (this.b = t.b),
            (this.c = t.c),
            (this.d = t.d),
            (this.tx = t.tx),
            (this.ty = t.ty),
            this
          )
        }
        equals(t) {
          return (
            t.a === this.a &&
            t.b === this.b &&
            t.c === this.c &&
            t.d === this.d &&
            t.tx === this.tx &&
            t.ty === this.ty
          )
        }
        toString() {
          return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`
        }
        static get IDENTITY() {
          return YM.identity()
        }
        static get shared() {
          return XM.identity()
        }
      }),
        (XM = new I()),
        (YM = new I()))
    })
  var Pt,
    Da = p(() => {
      "use strict"
      Pt = class r {
        constructor(t, e, i) {
          ;((this._x = e || 0), (this._y = i || 0), (this._observer = t))
        }
        clone(t) {
          return new r(t ?? this._observer, this._x, this._y)
        }
        set(t = 0, e = t) {
          return (
            (this._x !== t || this._y !== e) &&
              ((this._x = t), (this._y = e), this._observer._onUpdate(this)),
            this
          )
        }
        copyFrom(t) {
          return (
            (this._x !== t.x || this._y !== t.y) &&
              ((this._x = t.x), (this._y = t.y), this._observer._onUpdate(this)),
            this
          )
        }
        copyTo(t) {
          return (t.set(this._x, this._y), t)
        }
        equals(t) {
          return t.x === this._x && t.y === this._y
        }
        toString() {
          return `[pixi.js/math:ObservablePoint x=${this._x} y=${this._y} scope=${this._observer}]`
        }
        get x() {
          return this._x
        }
        set x(t) {
          this._x !== t && ((this._x = t), this._observer._onUpdate(this))
        }
        get y() {
          return this._y
        }
        set y(t) {
          this._y !== t && ((this._y = t), this._observer._onUpdate(this))
        }
      }
    })
  function J(r = "default") {
    return (gc[r] === void 0 && (gc[r] = -1), ++gc[r])
  }
  var gc,
    Ot = p(() => {
      "use strict"
      gc = { default: -1 }
    })
  function z(r, t, e = 3) {
    if (Gg[t]) return
    let i = new Error().stack
    ;(typeof i > "u"
      ? console.warn(
          "PixiJS Deprecation Warning: ",
          `${t}
Deprecated since v${r}`,
        )
      : ((i = i
          .split(
            `
`,
          )
          .splice(e).join(`
`)),
        console.groupCollapsed
          ? (console.groupCollapsed(
              "%cPixiJS Deprecation Warning: %c%s",
              "color:#614108;background:#fffbe6",
              "font-weight:normal;color:#614108;background:#fffbe6",
              `${t}
Deprecated since v${r}`,
            ),
            console.warn(i),
            console.groupEnd())
          : (console.warn(
              "PixiJS Deprecation Warning: ",
              `${t}
Deprecated since v${r}`,
            ),
            console.warn(i))),
      (Gg[t] = !0))
  }
  var Gg,
    K,
    Ug,
    gt = p(() => {
      "use strict"
      ;((Gg = {}), (K = "8.0.0"), (Ug = "8.3.4"))
    })
  function N(...r) {
    xc !== Og &&
      (xc++,
      xc === Og
        ? console.warn(
            "PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.",
          )
        : console.warn("PixiJS Warning: ", ...r))
  }
  var xc,
    Og,
    ft = p(() => {
      "use strict"
      ;((xc = 0), (Og = 500))
    })
  var jr,
    _c = p(() => {
      "use strict"
      jr = class {
        constructor(t, e) {
          ;((this._pool = []),
            (this._count = 0),
            (this._index = 0),
            (this._classType = t),
            e && this.prepopulate(e))
        }
        prepopulate(t) {
          for (let e = 0; e < t; e++) this._pool[this._index++] = new this._classType()
          this._count += t
        }
        get(t) {
          let e
          return (
            this._index > 0 ? (e = this._pool[--this._index]) : (e = new this._classType()),
            e.init?.(t),
            e
          )
        }
        return(t) {
          ;(t.reset?.(), (this._pool[this._index++] = t))
        }
        get totalSize() {
          return this._count
        }
        get totalFree() {
          return this._index
        }
        get totalUsed() {
          return this._count - this._index
        }
        clear() {
          ;((this._pool.length = 0), (this._index = 0))
        }
      }
    })
  var yc,
    xt,
    Je = p(() => {
      _c()
      ;((yc = class {
        constructor() {
          this._poolsByClass = new Map()
        }
        prepopulate(t, e) {
          this.getPool(t).prepopulate(e)
        }
        get(t, e) {
          return this.getPool(t).get(e)
        }
        return(t) {
          this.getPool(t.constructor).return(t)
        }
        getPool(t) {
          return (
            this._poolsByClass.has(t) || this._poolsByClass.set(t, new jr(t)),
            this._poolsByClass.get(t)
          )
        }
        stats() {
          let t = {}
          return (
            this._poolsByClass.forEach((e) => {
              let i = t[e._classType.name] ? e._classType.name + e._classType.ID : e._classType.name
              t[i] = { free: e.totalFree, used: e.totalUsed, size: e.totalSize }
            }),
            t
          )
        }
      }),
        (xt = new yc()))
    })
  var Lg,
    Ng = p(() => {
      gt()
      Lg = {
        get isCachedAsTexture() {
          return !!this.renderGroup?.isCachedAsTexture
        },
        cacheAsTexture(r) {
          typeof r == "boolean" && r === !1
            ? this.disableRenderGroup()
            : (this.enableRenderGroup(), this.renderGroup.enableCacheAsTexture(r === !0 ? {} : r))
        },
        updateCacheTexture() {
          this.renderGroup?.updateCacheTexture()
        },
        get cacheAsBitmap() {
          return this.isCachedAsTexture
        },
        set cacheAsBitmap(r) {
          ;(z("v8.6.0", "cacheAsBitmap is deprecated, use cacheAsTexture instead."),
            this.cacheAsTexture(r))
        },
      }
    })
  function Pa(r, t, e) {
    let i = r.length,
      n
    if (t >= i || e === 0) return
    e = t + e > i ? i - t : e
    let s = i - e
    for (n = t; n < s; ++n) r[n] = r[n + e]
    r.length = s
  }
  var bc = p(() => {
    "use strict"
  })
  var Hg,
    zg = p(() => {
      bc()
      gt()
      Hg = {
        allowChildren: !0,
        removeChildren(r = 0, t) {
          let e = t ?? this.children.length,
            i = e - r,
            n = []
          if (i > 0 && i <= e) {
            for (let o = e - 1; o >= r; o--) {
              let a = this.children[o]
              a && (n.push(a), (a.parent = null))
            }
            Pa(this.children, r, e)
            let s = this.renderGroup || this.parentRenderGroup
            s && s.removeChildren(n)
            for (let o = 0; o < n.length; ++o) {
              let a = n[o]
              ;(a.parentRenderLayer?.detach(a),
                this.emit("childRemoved", a, this, o),
                n[o].emit("removed", this))
            }
            return (n.length > 0 && this._didViewChangeTick++, n)
          } else if (i === 0 && this.children.length === 0) return n
          throw new RangeError("removeChildren: numeric values are outside the acceptable range.")
        },
        removeChildAt(r) {
          let t = this.getChildAt(r)
          return this.removeChild(t)
        },
        getChildAt(r) {
          if (r < 0 || r >= this.children.length)
            throw new Error(`getChildAt: Index (${r}) does not exist.`)
          return this.children[r]
        },
        setChildIndex(r, t) {
          if (t < 0 || t >= this.children.length)
            throw new Error(`The index ${t} supplied is out of bounds ${this.children.length}`)
          ;(this.getChildIndex(r), this.addChildAt(r, t))
        },
        getChildIndex(r) {
          let t = this.children.indexOf(r)
          if (t === -1) throw new Error("The supplied Container must be a child of the caller")
          return t
        },
        addChildAt(r, t) {
          this.allowChildren ||
            z(K, "addChildAt: Only Containers will be allowed to add children in v8.0.0")
          let { children: e } = this
          if (t < 0 || t > e.length)
            throw new Error(`${r}addChildAt: The index ${t} supplied is out of bounds ${e.length}`)
          if (r.parent) {
            let n = r.parent.children.indexOf(r)
            if (r.parent === this && n === t) return r
            n !== -1 && r.parent.children.splice(n, 1)
          }
          ;(t === e.length ? e.push(r) : e.splice(t, 0, r),
            (r.parent = this),
            (r.didChange = !0),
            (r._updateFlags = 15))
          let i = this.renderGroup || this.parentRenderGroup
          return (
            i && i.addChild(r),
            this.sortableChildren && (this.sortDirty = !0),
            this.emit("childAdded", r, this, t),
            r.emit("added", this),
            r
          )
        },
        swapChildren(r, t) {
          if (r === t) return
          let e = this.getChildIndex(r),
            i = this.getChildIndex(t)
          ;((this.children[e] = t), (this.children[i] = r))
          let n = this.renderGroup || this.parentRenderGroup
          ;(n && (n.structureDidChange = !0), this._didContainerChangeTick++)
        },
        removeFromParent() {
          this.parent?.removeChild(this)
        },
        reparentChild(...r) {
          return r.length === 1
            ? this.reparentChildAt(r[0], this.children.length)
            : (r.forEach((t) => this.reparentChildAt(t, this.children.length)), r[0])
        },
        reparentChildAt(r, t) {
          if (r.parent === this) return (this.setChildIndex(r, t), r)
          let e = r.worldTransform.clone()
          ;(r.removeFromParent(), this.addChildAt(r, t))
          let i = this.worldTransform.clone()
          return (i.invert(), e.prepend(i), r.setFromMatrix(e), r)
        },
        replaceChild(r, t) {
          ;(r.updateLocalTransform(),
            this.addChildAt(t, this.getChildIndex(r)),
            t.setFromMatrix(r.localTransform),
            t.updateLocalTransform(),
            this.removeChild(r))
        },
      }
    })
  var Wg,
    Vg = p(() => {
      "use strict"
      Wg = {
        collectRenderables(r, t, e) {
          ;(this.parentRenderLayer && this.parentRenderLayer !== e) ||
            this.globalDisplayStatus < 7 ||
            !this.includeInBuild ||
            (this.sortableChildren && this.sortChildren(),
            this.isSimple
              ? this.collectRenderablesSimple(r, t, e)
              : this.renderGroup
                ? t.renderPipes.renderGroup.addRenderGroup(this.renderGroup, r)
                : this.collectRenderablesWithEffects(r, t, e))
        },
        collectRenderablesSimple(r, t, e) {
          let i = this.children,
            n = i.length
          for (let s = 0; s < n; s++) i[s].collectRenderables(r, t, e)
        },
        collectRenderablesWithEffects(r, t, e) {
          let { renderPipes: i } = t
          for (let n = 0; n < this.effects.length; n++) {
            let s = this.effects[n]
            i[s.pipe].push(s, this, r)
          }
          this.collectRenderablesSimple(r, t, e)
          for (let n = this.effects.length - 1; n >= 0; n--) {
            let s = this.effects[n]
            i[s.pipe].pop(s, this, r)
          }
        },
      }
    })
  var tr,
    Fa = p(() => {
      "use strict"
      tr = class {
        constructor() {
          ;((this.pipe = "filter"), (this.priority = 1))
        }
        destroy() {
          for (let t = 0; t < this.filters.length; t++) this.filters[t].destroy()
          ;((this.filters = null), (this.filterArea = null))
        }
      }
    })
  var vc,
    Ra,
    $g = p(() => {
      A()
      Je()
      ;((vc = class {
        constructor() {
          ;((this._effectClasses = []), (this._tests = []), (this._initialized = !1))
        }
        init() {
          this._initialized ||
            ((this._initialized = !0),
            this._effectClasses.forEach((t) => {
              this.add({ test: t.test, maskClass: t })
            }))
        }
        add(t) {
          this._tests.push(t)
        }
        getMaskEffect(t) {
          this._initialized || this.init()
          for (let e = 0; e < this._tests.length; e++) {
            let i = this._tests[e]
            if (i.test(t)) return xt.get(i.maskClass, t)
          }
          return t
        }
        returnMaskEffect(t) {
          xt.return(t)
        }
      }),
        (Ra = new vc()))
      L.handleByList(b.MaskEffect, Ra._effectClasses)
    })
  var Xg,
    Yg = p(() => {
      Fa()
      $g()
      Xg = {
        _maskEffect: null,
        _maskOptions: { inverse: !1 },
        _filterEffect: null,
        effects: [],
        _markStructureAsChanged() {
          let r = this.renderGroup || this.parentRenderGroup
          r && (r.structureDidChange = !0)
        },
        addEffect(r) {
          this.effects.indexOf(r) === -1 &&
            (this.effects.push(r),
            this.effects.sort((e, i) => e.priority - i.priority),
            this._markStructureAsChanged(),
            this._updateIsSimple())
        },
        removeEffect(r) {
          let t = this.effects.indexOf(r)
          t !== -1 &&
            (this.effects.splice(t, 1), this._markStructureAsChanged(), this._updateIsSimple())
        },
        set mask(r) {
          let t = this._maskEffect
          t?.mask !== r &&
            (t && (this.removeEffect(t), Ra.returnMaskEffect(t), (this._maskEffect = null)),
            r != null &&
              ((this._maskEffect = Ra.getMaskEffect(r)), this.addEffect(this._maskEffect)))
        },
        get mask() {
          return this._maskEffect?.mask
        },
        setMask(r) {
          ;((this._maskOptions = { ...this._maskOptions, ...r }),
            r.mask && (this.mask = r.mask),
            this._markStructureAsChanged())
        },
        set filters(r) {
          !Array.isArray(r) && r && (r = [r])
          let t = this._filterEffect || (this._filterEffect = new tr())
          r = r
          let e = r?.length > 0,
            i = t.filters?.length > 0,
            n = e !== i
          ;((r = Array.isArray(r) ? r.slice(0) : r),
            (t.filters = Object.freeze(r)),
            n && (e ? this.addEffect(t) : (this.removeEffect(t), (t.filters = r ?? null))))
        },
        get filters() {
          return this._filterEffect?.filters
        },
        set filterArea(r) {
          ;(this._filterEffect || (this._filterEffect = new tr()),
            (this._filterEffect.filterArea = r))
        },
        get filterArea() {
          return this._filterEffect?.filterArea
        },
      }
    })
  var jg,
    Kg = p(() => {
      gt()
      jg = {
        label: null,
        get name() {
          return (
            z(K, "Container.name property has been removed, use Container.label instead"),
            this.label
          )
        },
        set name(r) {
          ;(z(K, "Container.name property has been removed, use Container.label instead"),
            (this.label = r))
        },
        getChildByName(r, t = !1) {
          return this.getChildByLabel(r, t)
        },
        getChildByLabel(r, t = !1) {
          let e = this.children
          for (let i = 0; i < e.length; i++) {
            let n = e[i]
            if (n.label === r || (r instanceof RegExp && r.test(n.label))) return n
          }
          if (t)
            for (let i = 0; i < e.length; i++) {
              let s = e[i].getChildByLabel(r, !0)
              if (s) return s
            }
          return null
        },
        getChildrenByLabel(r, t = !1, e = []) {
          let i = this.children
          for (let n = 0; n < i.length; n++) {
            let s = i[n]
            ;(s.label === r || (r instanceof RegExp && r.test(s.label))) && e.push(s)
          }
          if (t) for (let n = 0; n < i.length; n++) i[n].getChildrenByLabel(r, !0, e)
          return e
        },
      }
    })
  var Ba,
    Q,
    Lt = p(() => {
      Ee()
      ;((Ba = [new rt(), new rt(), new rt(), new rt()]),
        (Q = class r {
          constructor(t = 0, e = 0, i = 0, n = 0) {
            ;((this.type = "rectangle"),
              (this.x = Number(t)),
              (this.y = Number(e)),
              (this.width = Number(i)),
              (this.height = Number(n)))
          }
          get left() {
            return this.x
          }
          get right() {
            return this.x + this.width
          }
          get top() {
            return this.y
          }
          get bottom() {
            return this.y + this.height
          }
          isEmpty() {
            return this.left === this.right || this.top === this.bottom
          }
          static get EMPTY() {
            return new r(0, 0, 0, 0)
          }
          clone() {
            return new r(this.x, this.y, this.width, this.height)
          }
          copyFromBounds(t) {
            return (
              (this.x = t.minX),
              (this.y = t.minY),
              (this.width = t.maxX - t.minX),
              (this.height = t.maxY - t.minY),
              this
            )
          }
          copyFrom(t) {
            return (
              (this.x = t.x),
              (this.y = t.y),
              (this.width = t.width),
              (this.height = t.height),
              this
            )
          }
          copyTo(t) {
            return (t.copyFrom(this), t)
          }
          contains(t, e) {
            return this.width <= 0 || this.height <= 0
              ? !1
              : t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height
          }
          strokeContains(t, e, i, n = 0.5) {
            let { width: s, height: o } = this
            if (s <= 0 || o <= 0) return !1
            let a = this.x,
              u = this.y,
              l = i * (1 - n),
              c = i - l,
              h = a - l,
              f = a + s + l,
              d = u - l,
              g = u + o + l,
              x = a + c,
              m = a + s - c,
              _ = u + c,
              v = u + o - c
            return t >= h && t <= f && e >= d && e <= g && !(t > x && t < m && e > _ && e < v)
          }
          intersects(t, e) {
            if (!e) {
              let G = this.x < t.x ? t.x : this.x
              if ((this.right > t.right ? t.right : this.right) <= G) return !1
              let P = this.y < t.y ? t.y : this.y
              return (this.bottom > t.bottom ? t.bottom : this.bottom) > P
            }
            let i = this.left,
              n = this.right,
              s = this.top,
              o = this.bottom
            if (n <= i || o <= s) return !1
            let a = Ba[0].set(t.left, t.top),
              u = Ba[1].set(t.left, t.bottom),
              l = Ba[2].set(t.right, t.top),
              c = Ba[3].set(t.right, t.bottom)
            if (l.x <= a.x || u.y <= a.y) return !1
            let h = Math.sign(e.a * e.d - e.b * e.c)
            if (
              h === 0 ||
              (e.apply(a, a),
              e.apply(u, u),
              e.apply(l, l),
              e.apply(c, c),
              Math.max(a.x, u.x, l.x, c.x) <= i ||
                Math.min(a.x, u.x, l.x, c.x) >= n ||
                Math.max(a.y, u.y, l.y, c.y) <= s ||
                Math.min(a.y, u.y, l.y, c.y) >= o)
            )
              return !1
            let f = h * (u.y - a.y),
              d = h * (a.x - u.x),
              g = f * i + d * s,
              x = f * n + d * s,
              m = f * i + d * o,
              _ = f * n + d * o
            if (
              Math.max(g, x, m, _) <= f * a.x + d * a.y ||
              Math.min(g, x, m, _) >= f * c.x + d * c.y
            )
              return !1
            let v = h * (a.y - l.y),
              S = h * (l.x - a.x),
              y = v * i + S * s,
              M = v * n + S * s,
              T = v * i + S * o,
              E = v * n + S * o
            return !(
              Math.max(y, M, T, E) <= v * a.x + S * a.y || Math.min(y, M, T, E) >= v * c.x + S * c.y
            )
          }
          pad(t = 0, e = t) {
            return (
              (this.x -= t),
              (this.y -= e),
              (this.width += t * 2),
              (this.height += e * 2),
              this
            )
          }
          fit(t) {
            let e = Math.max(this.x, t.x),
              i = Math.min(this.x + this.width, t.x + t.width),
              n = Math.max(this.y, t.y),
              s = Math.min(this.y + this.height, t.y + t.height)
            return (
              (this.x = e),
              (this.width = Math.max(i - e, 0)),
              (this.y = n),
              (this.height = Math.max(s - n, 0)),
              this
            )
          }
          ceil(t = 1, e = 0.001) {
            let i = Math.ceil((this.x + this.width - e) * t) / t,
              n = Math.ceil((this.y + this.height - e) * t) / t
            return (
              (this.x = Math.floor((this.x + e) * t) / t),
              (this.y = Math.floor((this.y + e) * t) / t),
              (this.width = i - this.x),
              (this.height = n - this.y),
              this
            )
          }
          enlarge(t) {
            let e = Math.min(this.x, t.x),
              i = Math.max(this.x + this.width, t.x + t.width),
              n = Math.min(this.y, t.y),
              s = Math.max(this.y + this.height, t.y + t.height)
            return ((this.x = e), (this.width = i - e), (this.y = n), (this.height = s - n), this)
          }
          getBounds(t) {
            return (t || (t = new r()), t.copyFrom(this), t)
          }
          containsRect(t) {
            if (this.width <= 0 || this.height <= 0) return !1
            let e = t.x,
              i = t.y,
              n = t.x + t.width,
              s = t.y + t.height
            return (
              e >= this.x &&
              e < this.x + this.width &&
              i >= this.y &&
              i < this.y + this.height &&
              n >= this.x &&
              n < this.x + this.width &&
              s >= this.y &&
              s < this.y + this.height
            )
          }
          set(t, e, i, n) {
            return ((this.x = t), (this.y = e), (this.width = i), (this.height = n), this)
          }
          toString() {
            return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`
          }
        }))
    })
  var qg,
    ct,
    se = p(() => {
      nt()
      Lt()
      ;((qg = new I()),
        (ct = class r {
          constructor(t = 1 / 0, e = 1 / 0, i = -1 / 0, n = -1 / 0) {
            ;((this.minX = 1 / 0),
              (this.minY = 1 / 0),
              (this.maxX = -1 / 0),
              (this.maxY = -1 / 0),
              (this.matrix = qg),
              (this.minX = t),
              (this.minY = e),
              (this.maxX = i),
              (this.maxY = n))
          }
          isEmpty() {
            return this.minX > this.maxX || this.minY > this.maxY
          }
          get rectangle() {
            this._rectangle || (this._rectangle = new Q())
            let t = this._rectangle
            return (
              this.minX > this.maxX || this.minY > this.maxY
                ? ((t.x = 0), (t.y = 0), (t.width = 0), (t.height = 0))
                : t.copyFromBounds(this),
              t
            )
          }
          clear() {
            return (
              (this.minX = 1 / 0),
              (this.minY = 1 / 0),
              (this.maxX = -1 / 0),
              (this.maxY = -1 / 0),
              (this.matrix = qg),
              this
            )
          }
          set(t, e, i, n) {
            ;((this.minX = t), (this.minY = e), (this.maxX = i), (this.maxY = n))
          }
          addFrame(t, e, i, n, s) {
            s || (s = this.matrix)
            let o = s.a,
              a = s.b,
              u = s.c,
              l = s.d,
              c = s.tx,
              h = s.ty,
              f = this.minX,
              d = this.minY,
              g = this.maxX,
              x = this.maxY,
              m = o * t + u * e + c,
              _ = a * t + l * e + h
            ;(m < f && (f = m),
              _ < d && (d = _),
              m > g && (g = m),
              _ > x && (x = _),
              (m = o * i + u * e + c),
              (_ = a * i + l * e + h),
              m < f && (f = m),
              _ < d && (d = _),
              m > g && (g = m),
              _ > x && (x = _),
              (m = o * t + u * n + c),
              (_ = a * t + l * n + h),
              m < f && (f = m),
              _ < d && (d = _),
              m > g && (g = m),
              _ > x && (x = _),
              (m = o * i + u * n + c),
              (_ = a * i + l * n + h),
              m < f && (f = m),
              _ < d && (d = _),
              m > g && (g = m),
              _ > x && (x = _),
              (this.minX = f),
              (this.minY = d),
              (this.maxX = g),
              (this.maxY = x))
          }
          addRect(t, e) {
            this.addFrame(t.x, t.y, t.x + t.width, t.y + t.height, e)
          }
          addBounds(t, e) {
            this.addFrame(t.minX, t.minY, t.maxX, t.maxY, e)
          }
          addBoundsMask(t) {
            ;((this.minX = this.minX > t.minX ? this.minX : t.minX),
              (this.minY = this.minY > t.minY ? this.minY : t.minY),
              (this.maxX = this.maxX < t.maxX ? this.maxX : t.maxX),
              (this.maxY = this.maxY < t.maxY ? this.maxY : t.maxY))
          }
          applyMatrix(t) {
            let e = this.minX,
              i = this.minY,
              n = this.maxX,
              s = this.maxY,
              { a: o, b: a, c: u, d: l, tx: c, ty: h } = t,
              f = o * e + u * i + c,
              d = a * e + l * i + h
            ;((this.minX = f),
              (this.minY = d),
              (this.maxX = f),
              (this.maxY = d),
              (f = o * n + u * i + c),
              (d = a * n + l * i + h),
              (this.minX = f < this.minX ? f : this.minX),
              (this.minY = d < this.minY ? d : this.minY),
              (this.maxX = f > this.maxX ? f : this.maxX),
              (this.maxY = d > this.maxY ? d : this.maxY),
              (f = o * e + u * s + c),
              (d = a * e + l * s + h),
              (this.minX = f < this.minX ? f : this.minX),
              (this.minY = d < this.minY ? d : this.minY),
              (this.maxX = f > this.maxX ? f : this.maxX),
              (this.maxY = d > this.maxY ? d : this.maxY),
              (f = o * n + u * s + c),
              (d = a * n + l * s + h),
              (this.minX = f < this.minX ? f : this.minX),
              (this.minY = d < this.minY ? d : this.minY),
              (this.maxX = f > this.maxX ? f : this.maxX),
              (this.maxY = d > this.maxY ? d : this.maxY))
          }
          fit(t) {
            return (
              this.minX < t.left && (this.minX = t.left),
              this.maxX > t.right && (this.maxX = t.right),
              this.minY < t.top && (this.minY = t.top),
              this.maxY > t.bottom && (this.maxY = t.bottom),
              this
            )
          }
          fitBounds(t, e, i, n) {
            return (
              this.minX < t && (this.minX = t),
              this.maxX > e && (this.maxX = e),
              this.minY < i && (this.minY = i),
              this.maxY > n && (this.maxY = n),
              this
            )
          }
          pad(t, e = t) {
            return ((this.minX -= t), (this.maxX += t), (this.minY -= e), (this.maxY += e), this)
          }
          ceil() {
            return (
              (this.minX = Math.floor(this.minX)),
              (this.minY = Math.floor(this.minY)),
              (this.maxX = Math.ceil(this.maxX)),
              (this.maxY = Math.ceil(this.maxY)),
              this
            )
          }
          clone() {
            return new r(this.minX, this.minY, this.maxX, this.maxY)
          }
          scale(t, e = t) {
            return ((this.minX *= t), (this.minY *= e), (this.maxX *= t), (this.maxY *= e), this)
          }
          get x() {
            return this.minX
          }
          set x(t) {
            let e = this.maxX - this.minX
            ;((this.minX = t), (this.maxX = t + e))
          }
          get y() {
            return this.minY
          }
          set y(t) {
            let e = this.maxY - this.minY
            ;((this.minY = t), (this.maxY = t + e))
          }
          get width() {
            return this.maxX - this.minX
          }
          set width(t) {
            this.maxX = this.minX + t
          }
          get height() {
            return this.maxY - this.minY
          }
          set height(t) {
            this.maxY = this.minY + t
          }
          get left() {
            return this.minX
          }
          get right() {
            return this.maxX
          }
          get top() {
            return this.minY
          }
          get bottom() {
            return this.maxY
          }
          get isPositive() {
            return this.maxX - this.minX > 0 && this.maxY - this.minY > 0
          }
          get isValid() {
            return this.minX + this.minY !== 1 / 0
          }
          addVertexData(t, e, i, n) {
            let s = this.minX,
              o = this.minY,
              a = this.maxX,
              u = this.maxY
            n || (n = this.matrix)
            let l = n.a,
              c = n.b,
              h = n.c,
              f = n.d,
              d = n.tx,
              g = n.ty
            for (let x = e; x < i; x += 2) {
              let m = t[x],
                _ = t[x + 1],
                v = l * m + h * _ + d,
                S = c * m + f * _ + g
              ;((s = v < s ? v : s), (o = S < o ? S : o), (a = v > a ? v : a), (u = S > u ? S : u))
            }
            ;((this.minX = s), (this.minY = o), (this.maxX = a), (this.maxY = u))
          }
          containsPoint(t, e) {
            return this.minX <= t && this.minY <= e && this.maxX >= t && this.maxY >= e
          }
          toString() {
            return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`
          }
          copyFrom(t) {
            return (
              (this.minX = t.minX),
              (this.minY = t.minY),
              (this.maxX = t.maxX),
              (this.maxY = t.maxY),
              this
            )
          }
        }))
    })
  var Ft,
    he,
    Kr = p(() => {
      nt()
      _c()
      se()
      ;((Ft = new jr(I)), (he = new jr(ct)))
    })
  var jM,
    Zg,
    Qg = p(() => {
      nt()
      se()
      Kr()
      ;((jM = new I()),
        (Zg = {
          getFastGlobalBounds(r, t) {
            ;(t || (t = new ct()),
              t.clear(),
              this._getGlobalBoundsRecursive(!!r, t, this.parentRenderLayer),
              t.isValid || t.set(0, 0, 0, 0))
            let e = this.renderGroup || this.parentRenderGroup
            return (t.applyMatrix(e.worldTransform), t)
          },
          _getGlobalBoundsRecursive(r, t, e) {
            let i = t
            if (
              (r && this.parentRenderLayer && this.parentRenderLayer !== e) ||
              this.localDisplayStatus !== 7 ||
              !this.measurable
            )
              return
            let n = !!this.effects.length
            if (((this.renderGroup || n) && (i = he.get().clear()), this.boundsArea))
              t.addRect(this.boundsArea, this.worldTransform)
            else {
              if (this.renderPipeId) {
                let o = this.bounds
                i.addFrame(o.minX, o.minY, o.maxX, o.maxY, this.groupTransform)
              }
              let s = this.children
              for (let o = 0; o < s.length; o++) s[o]._getGlobalBoundsRecursive(r, i, e)
            }
            if (n) {
              let s = !1,
                o = this.renderGroup || this.parentRenderGroup
              for (let a = 0; a < this.effects.length; a++)
                this.effects[a].addBounds &&
                  (s || ((s = !0), i.applyMatrix(o.worldTransform)),
                  this.effects[a].addBounds(i, !0))
              ;(s &&
                (i.applyMatrix(o.worldTransform.copyTo(jM).invert()),
                t.addBounds(i, this.relativeGroupTransform)),
                t.addBounds(i),
                he.return(i))
            } else this.renderGroup && (t.addBounds(i, this.relativeGroupTransform), he.return(i))
          },
        }))
    })
  function Di(r, t, e) {
    e.clear()
    let i, n
    return (
      r.parent
        ? t
          ? (i = r.parent.worldTransform)
          : ((n = Ft.get().identity()), (i = Ia(r, n)))
        : (i = I.IDENTITY),
      Jg(r, e, i, t),
      n && Ft.return(n),
      e.isValid || e.set(0, 0, 0, 0),
      e
    )
  }
  function Jg(r, t, e, i) {
    if (!r.visible || !r.measurable) return
    let n
    i
      ? (n = r.worldTransform)
      : (r.updateLocalTransform(), (n = Ft.get()), n.appendFrom(r.localTransform, e))
    let s = t,
      o = !!r.effects.length
    if ((o && (t = he.get().clear()), r.boundsArea)) t.addRect(r.boundsArea, n)
    else {
      r.bounds && ((t.matrix = n), t.addBounds(r.bounds))
      for (let a = 0; a < r.children.length; a++) Jg(r.children[a], t, n, i)
    }
    if (o) {
      for (let a = 0; a < r.effects.length; a++) r.effects[a].addBounds?.(t)
      ;(s.addBounds(t, I.IDENTITY), he.return(t))
    }
    i || Ft.return(n)
  }
  function Ia(r, t) {
    let e = r.parent
    return (e && (Ia(e, t), e.updateLocalTransform(), t.append(e.localTransform)), t)
  }
  var Jn = p(() => {
    nt()
    Kr()
  })
  function ka(r, t) {
    if (r === 16777215 || !t) return t
    if (t === 16777215 || !r) return r
    let e = (r >> 16) & 255,
      i = (r >> 8) & 255,
      n = r & 255,
      s = (t >> 16) & 255,
      o = (t >> 8) & 255,
      a = t & 255,
      u = ((e * s) / 255) | 0,
      l = ((i * o) / 255) | 0,
      c = ((n * a) / 255) | 0
    return (u << 16) + (l << 8) + c
  }
  var Sc = p(() => {
    "use strict"
  })
  function Pi(r, t) {
    return r === tx ? t : t === tx ? r : ka(r, t)
  }
  var tx,
    Tc = p(() => {
      Sc()
      tx = 16777215
    })
  function ts(r) {
    return ((r & 255) << 16) + (r & 65280) + ((r >> 16) & 255)
  }
  var ex,
    rx = p(() => {
      Jn()
      Kr()
      Tc()
      ex = {
        getGlobalAlpha(r) {
          if (r)
            return this.renderGroup
              ? this.renderGroup.worldAlpha
              : this.parentRenderGroup
                ? this.parentRenderGroup.worldAlpha * this.alpha
                : this.alpha
          let t = this.alpha,
            e = this.parent
          for (; e; ) ((t *= e.alpha), (e = e.parent))
          return t
        },
        getGlobalTransform(r, t) {
          if (t) return r.copyFrom(this.worldTransform)
          this.updateLocalTransform()
          let e = Ia(this, Ft.get().identity())
          return (r.appendFrom(this.localTransform, e), Ft.return(e), r)
        },
        getGlobalTint(r) {
          if (r)
            return this.renderGroup
              ? ts(this.renderGroup.worldColor)
              : this.parentRenderGroup
                ? ts(Pi(this.localColor, this.parentRenderGroup.worldColor))
                : this.tint
          let t = this.localColor,
            e = this.parent
          for (; e; ) ((t = Pi(t, e.localColor)), (e = e.parent))
          return ts(t)
        },
      }
    })
  function Fi(r, t, e) {
    return (t.clear(), e || (e = I.IDENTITY), ix(r, t, e, r, !0), t.isValid || t.set(0, 0, 0, 0), t)
  }
  function ix(r, t, e, i, n) {
    let s
    if (n) ((s = Ft.get()), (s = e.copyTo(s)))
    else {
      if (!r.visible || !r.measurable) return
      r.updateLocalTransform()
      let u = r.localTransform
      ;((s = Ft.get()), s.appendFrom(u, e))
    }
    let o = t,
      a = !!r.effects.length
    if ((a && (t = he.get().clear()), r.boundsArea)) t.addRect(r.boundsArea, s)
    else {
      r.renderPipeId && ((t.matrix = s), t.addBounds(r.bounds))
      let u = r.children
      for (let l = 0; l < u.length; l++) ix(u[l], t, s, i, !1)
    }
    if (a) {
      for (let u = 0; u < r.effects.length; u++) r.effects[u].addLocalBounds?.(t, i)
      ;(o.addBounds(t, I.IDENTITY), he.return(t))
    }
    Ft.return(s)
  }
  var Ga = p(() => {
    nt()
    Kr()
  })
  function Cc(r, t) {
    let e = r.children
    for (let i = 0; i < e.length; i++) {
      let n = e[i],
        s = n.uid,
        o = ((n._didViewChangeTick & 65535) << 16) | (n._didContainerChangeTick & 65535),
        a = t.index
      ;((t.data[a] !== s || t.data[a + 1] !== o) &&
        ((t.data[t.index] = s), (t.data[t.index + 1] = o), (t.didChange = !0)),
        (t.index = a + 2),
        n.children.length && Cc(n, t))
    }
    return t.didChange
  }
  var nx = p(() => {
    "use strict"
  })
  var KM,
    sx,
    ox = p(() => {
      nt()
      se()
      Jn()
      Ga()
      nx()
      ;((KM = new I()),
        (sx = {
          _localBoundsCacheId: -1,
          _localBoundsCacheData: null,
          _setWidth(r, t) {
            let e = Math.sign(this.scale.x) || 1
            t !== 0 ? (this.scale.x = (r / t) * e) : (this.scale.x = e)
          },
          _setHeight(r, t) {
            let e = Math.sign(this.scale.y) || 1
            t !== 0 ? (this.scale.y = (r / t) * e) : (this.scale.y = e)
          },
          getLocalBounds() {
            this._localBoundsCacheData ||
              (this._localBoundsCacheData = {
                data: [],
                index: 1,
                didChange: !1,
                localBounds: new ct(),
              })
            let r = this._localBoundsCacheData
            return (
              (r.index = 1),
              (r.didChange = !1),
              r.data[0] !== this._didViewChangeTick &&
                ((r.didChange = !0), (r.data[0] = this._didViewChangeTick)),
              Cc(this, r),
              r.didChange && Fi(this, r.localBounds, KM),
              r.localBounds
            )
          },
          getBounds(r, t) {
            return Di(this, r, t || new ct())
          },
        }))
    })
  var ax,
    ux = p(() => {
      "use strict"
      ax = {
        _onRender: null,
        set onRender(r) {
          let t = this.renderGroup || this.parentRenderGroup
          if (!r) {
            ;(this._onRender && t?.removeOnRender(this), (this._onRender = null))
            return
          }
          ;(this._onRender || t?.addOnRender(this), (this._onRender = r))
        },
        get onRender() {
          return this._onRender
        },
      }
    })
  function qM(r, t) {
    return r._zIndex - t._zIndex
  }
  var lx,
    cx = p(() => {
      "use strict"
      lx = {
        _zIndex: 0,
        sortDirty: !1,
        sortableChildren: !1,
        get zIndex() {
          return this._zIndex
        },
        set zIndex(r) {
          this._zIndex !== r && ((this._zIndex = r), this.depthOfChildModified())
        },
        depthOfChildModified() {
          ;(this.parent && ((this.parent.sortableChildren = !0), (this.parent.sortDirty = !0)),
            this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0))
        },
        sortChildren() {
          this.sortDirty && ((this.sortDirty = !1), this.children.sort(qM))
        },
      }
    })
  var hx,
    fx = p(() => {
      Ee()
      Kr()
      hx = {
        getGlobalPosition(r = new rt(), t = !1) {
          return (
            this.parent
              ? this.parent.toGlobal(this._position, r, t)
              : ((r.x = this._position.x), (r.y = this._position.y)),
            r
          )
        },
        toGlobal(r, t, e = !1) {
          let i = this.getGlobalTransform(Ft.get(), e)
          return ((t = i.apply(r, t)), Ft.return(i), t)
        },
        toLocal(r, t, e, i) {
          t && (r = t.toGlobal(r, e, i))
          let n = this.getGlobalTransform(Ft.get(), i)
          return ((e = n.applyInverse(r, e)), Ft.return(n), e)
        },
      }
    })
  var Ri,
    Ec = p(() => {
      Ot()
      Ri = class {
        constructor() {
          ;((this.uid = J("instructionSet")),
            (this.instructions = []),
            (this.instructionSize = 0),
            (this.renderables = []),
            (this.gcTick = 0))
        }
        reset() {
          this.instructionSize = 0
        }
        add(t) {
          this.instructions[this.instructionSize++] = t
        }
        log() {
          ;((this.instructions.length = this.instructionSize),
            console.table(this.instructions, ["type", "action"]))
        }
      }
    })
  function er(r) {
    return (
      (r += r === 0 ? 1 : 0),
      --r,
      (r |= r >>> 1),
      (r |= r >>> 2),
      (r |= r >>> 4),
      (r |= r >>> 8),
      (r |= r >>> 16),
      r + 1
    )
  }
  function wc(r) {
    return !(r & (r - 1)) && !!r
  }
  var es = p(() => {
    "use strict"
  })
  function Ua(r) {
    let t = {}
    for (let e in r) r[e] !== void 0 && (t[e] = r[e])
    return t
  }
  var Mc = p(() => {
    "use strict"
  })
  function ZM(r) {
    let t = dx[r]
    return (t === void 0 && (dx[r] = J("resource")), t)
  }
  var dx,
    px,
    Jt,
    qr = p(() => {
      Wt()
      Ot()
      gt()
      dx = Object.create(null)
      px = class mx extends lt {
        constructor(t = {}) {
          ;(super(),
            (this._resourceType = "textureSampler"),
            (this._touched = 0),
            (this._maxAnisotropy = 1),
            (this.destroyed = !1),
            (t = { ...mx.defaultOptions, ...t }),
            (this.addressMode = t.addressMode),
            (this.addressModeU = t.addressModeU ?? this.addressModeU),
            (this.addressModeV = t.addressModeV ?? this.addressModeV),
            (this.addressModeW = t.addressModeW ?? this.addressModeW),
            (this.scaleMode = t.scaleMode),
            (this.magFilter = t.magFilter ?? this.magFilter),
            (this.minFilter = t.minFilter ?? this.minFilter),
            (this.mipmapFilter = t.mipmapFilter ?? this.mipmapFilter),
            (this.lodMinClamp = t.lodMinClamp),
            (this.lodMaxClamp = t.lodMaxClamp),
            (this.compare = t.compare),
            (this.maxAnisotropy = t.maxAnisotropy ?? 1))
        }
        set addressMode(t) {
          ;((this.addressModeU = t), (this.addressModeV = t), (this.addressModeW = t))
        }
        get addressMode() {
          return this.addressModeU
        }
        set wrapMode(t) {
          ;(z(K, "TextureStyle.wrapMode is now TextureStyle.addressMode"), (this.addressMode = t))
        }
        get wrapMode() {
          return this.addressMode
        }
        set scaleMode(t) {
          ;((this.magFilter = t), (this.minFilter = t), (this.mipmapFilter = t))
        }
        get scaleMode() {
          return this.magFilter
        }
        set maxAnisotropy(t) {
          ;((this._maxAnisotropy = Math.min(t, 16)),
            this._maxAnisotropy > 1 && (this.scaleMode = "linear"))
        }
        get maxAnisotropy() {
          return this._maxAnisotropy
        }
        get _resourceId() {
          return this._sharedResourceId || this._generateResourceId()
        }
        update() {
          ;(this.emit("change", this), (this._sharedResourceId = null))
        }
        _generateResourceId() {
          let t = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`
          return ((this._sharedResourceId = ZM(t)), this._resourceId)
        }
        destroy() {
          ;((this.destroyed = !0),
            this.emit("destroy", this),
            this.emit("change", this),
            this.removeAllListeners())
        }
      }
      px.defaultOptions = { addressMode: "clamp-to-edge", scaleMode: "linear" }
      Jt = px
    })
  var gx,
    ot,
    te = p(() => {
      Wt()
      es()
      Mc()
      Ot()
      qr()
      gx = class xx extends lt {
        constructor(t = {}) {
          ;(super(),
            (this.options = t),
            (this.uid = J("textureSource")),
            (this._resourceType = "textureSource"),
            (this._resourceId = J("resource")),
            (this.uploadMethodId = "unknown"),
            (this._resolution = 1),
            (this.pixelWidth = 1),
            (this.pixelHeight = 1),
            (this.width = 1),
            (this.height = 1),
            (this.sampleCount = 1),
            (this.mipLevelCount = 1),
            (this.autoGenerateMipmaps = !1),
            (this.format = "rgba8unorm"),
            (this.dimension = "2d"),
            (this.antialias = !1),
            (this._touched = 0),
            (this._batchTick = -1),
            (this._textureBindLocation = -1),
            (t = { ...xx.defaultOptions, ...t }),
            (this.label = t.label ?? ""),
            (this.resource = t.resource),
            (this.autoGarbageCollect = t.autoGarbageCollect),
            (this._resolution = t.resolution),
            t.width
              ? (this.pixelWidth = t.width * this._resolution)
              : (this.pixelWidth = this.resource ? (this.resourceWidth ?? 1) : 1),
            t.height
              ? (this.pixelHeight = t.height * this._resolution)
              : (this.pixelHeight = this.resource ? (this.resourceHeight ?? 1) : 1),
            (this.width = this.pixelWidth / this._resolution),
            (this.height = this.pixelHeight / this._resolution),
            (this.format = t.format),
            (this.dimension = t.dimensions),
            (this.mipLevelCount = t.mipLevelCount),
            (this.autoGenerateMipmaps = t.autoGenerateMipmaps),
            (this.sampleCount = t.sampleCount),
            (this.antialias = t.antialias),
            (this.alphaMode = t.alphaMode),
            (this.style = new Jt(Ua(t))),
            (this.destroyed = !1),
            this._refreshPOT())
        }
        get source() {
          return this
        }
        get style() {
          return this._style
        }
        set style(t) {
          this.style !== t &&
            (this._style?.off("change", this._onStyleChange, this),
            (this._style = t),
            this._style?.on("change", this._onStyleChange, this),
            this._onStyleChange())
        }
        get addressMode() {
          return this._style.addressMode
        }
        set addressMode(t) {
          this._style.addressMode = t
        }
        get repeatMode() {
          return this._style.addressMode
        }
        set repeatMode(t) {
          this._style.addressMode = t
        }
        get magFilter() {
          return this._style.magFilter
        }
        set magFilter(t) {
          this._style.magFilter = t
        }
        get minFilter() {
          return this._style.minFilter
        }
        set minFilter(t) {
          this._style.minFilter = t
        }
        get mipmapFilter() {
          return this._style.mipmapFilter
        }
        set mipmapFilter(t) {
          this._style.mipmapFilter = t
        }
        get lodMinClamp() {
          return this._style.lodMinClamp
        }
        set lodMinClamp(t) {
          this._style.lodMinClamp = t
        }
        get lodMaxClamp() {
          return this._style.lodMaxClamp
        }
        set lodMaxClamp(t) {
          this._style.lodMaxClamp = t
        }
        _onStyleChange() {
          this.emit("styleChange", this)
        }
        update() {
          if (this.resource) {
            let t = this._resolution
            if (this.resize(this.resourceWidth / t, this.resourceHeight / t)) return
          }
          this.emit("update", this)
        }
        destroy() {
          ;((this.destroyed = !0),
            this.emit("destroy", this),
            this.emit("change", this),
            this._style && (this._style.destroy(), (this._style = null)),
            (this.uploadMethodId = null),
            (this.resource = null),
            this.removeAllListeners())
        }
        unload() {
          ;((this._resourceId = J("resource")),
            this.emit("change", this),
            this.emit("unload", this))
        }
        get resourceWidth() {
          let { resource: t } = this
          return t.naturalWidth || t.videoWidth || t.displayWidth || t.width
        }
        get resourceHeight() {
          let { resource: t } = this
          return t.naturalHeight || t.videoHeight || t.displayHeight || t.height
        }
        get resolution() {
          return this._resolution
        }
        set resolution(t) {
          this._resolution !== t &&
            ((this._resolution = t),
            (this.width = this.pixelWidth / t),
            (this.height = this.pixelHeight / t))
        }
        resize(t, e, i) {
          ;(i || (i = this._resolution), t || (t = this.width), e || (e = this.height))
          let n = Math.round(t * i),
            s = Math.round(e * i)
          return (
            (this.width = n / i),
            (this.height = s / i),
            (this._resolution = i),
            this.pixelWidth === n && this.pixelHeight === s
              ? !1
              : (this._refreshPOT(),
                (this.pixelWidth = n),
                (this.pixelHeight = s),
                this.emit("resize", this),
                (this._resourceId = J("resource")),
                this.emit("change", this),
                !0)
          )
        }
        updateMipmaps() {
          this.autoGenerateMipmaps && this.mipLevelCount > 1 && this.emit("updateMipmaps", this)
        }
        set wrapMode(t) {
          this._style.wrapMode = t
        }
        get wrapMode() {
          return this._style.wrapMode
        }
        set scaleMode(t) {
          this._style.scaleMode = t
        }
        get scaleMode() {
          return this._style.scaleMode
        }
        _refreshPOT() {
          this.isPowerOfTwo = wc(this.pixelWidth) && wc(this.pixelHeight)
        }
        static test(t) {
          throw new Error("Unimplemented")
        }
      }
      gx.defaultOptions = {
        resolution: 1,
        format: "bgra8unorm",
        alphaMode: "premultiply-alpha-on-upload",
        dimensions: "2d",
        mipLevelCount: 1,
        autoGenerateMipmaps: !1,
        sampleCount: 1,
        antialias: !1,
        autoGarbageCollect: !1,
      }
      ot = gx
    })
  function QM() {
    for (let r = 0; r < 16; r++) {
      let t = []
      Ac.push(t)
      for (let e = 0; e < 16; e++) {
        let i = Oa(Zr[r] * Zr[e] + Jr[r] * Qr[e]),
          n = Oa(Qr[r] * Zr[e] + ti[r] * Qr[e]),
          s = Oa(Zr[r] * Jr[e] + Jr[r] * ti[e]),
          o = Oa(Qr[r] * Jr[e] + ti[r] * ti[e])
        for (let a = 0; a < 16; a++)
          if (Zr[a] === i && Qr[a] === n && Jr[a] === s && ti[a] === o) {
            t.push(a)
            break
          }
      }
    }
    for (let r = 0; r < 16; r++) {
      let t = new I()
      ;(t.set(Zr[r], Qr[r], Jr[r], ti[r], 0, 0), _x.push(t))
    }
  }
  var Zr,
    Qr,
    Jr,
    ti,
    Ac,
    _x,
    Oa,
    yt,
    yx = p(() => {
      nt()
      ;((Zr = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1]),
        (Qr = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1]),
        (Jr = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1]),
        (ti = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1]),
        (Ac = []),
        (_x = []),
        (Oa = Math.sign))
      QM()
      yt = {
        E: 0,
        SE: 1,
        S: 2,
        SW: 3,
        W: 4,
        NW: 5,
        N: 6,
        NE: 7,
        MIRROR_VERTICAL: 8,
        MAIN_DIAGONAL: 10,
        MIRROR_HORIZONTAL: 12,
        REVERSE_DIAGONAL: 14,
        uX: (r) => Zr[r],
        uY: (r) => Qr[r],
        vX: (r) => Jr[r],
        vY: (r) => ti[r],
        inv: (r) => (r & 8 ? r & 15 : -r & 7),
        add: (r, t) => Ac[r][t],
        sub: (r, t) => Ac[r][yt.inv(t)],
        rotate180: (r) => r ^ 4,
        isVertical: (r) => (r & 3) === 2,
        byDirection: (r, t) =>
          Math.abs(r) * 2 <= Math.abs(t)
            ? t >= 0
              ? yt.S
              : yt.N
            : Math.abs(t) * 2 <= Math.abs(r)
              ? r > 0
                ? yt.E
                : yt.W
              : t > 0
                ? r > 0
                  ? yt.SE
                  : yt.SW
                : r > 0
                  ? yt.NE
                  : yt.NW,
        matrixAppendRotationInv: (r, t, e = 0, i = 0) => {
          let n = _x[yt.inv(t)]
          ;((n.tx = e), (n.ty = i), r.append(n))
        },
      }
    })
  var Dc,
    bx = p(() => {
      "use strict"
      Dc = () => {}
    })
  var ei,
    Pc = p(() => {
      A()
      te()
      ei = class extends ot {
        constructor(t) {
          let e = t.resource || new Float32Array(t.width * t.height * 4),
            i = t.format
          ;(i ||
            (e instanceof Float32Array
              ? (i = "rgba32float")
              : e instanceof Int32Array || e instanceof Uint32Array
                ? (i = "rgba32uint")
                : e instanceof Int16Array || e instanceof Uint16Array
                  ? (i = "rgba16uint")
                  : (e instanceof Int8Array, (i = "bgra8unorm"))),
            super({ ...t, resource: e, format: i }),
            (this.uploadMethodId = "buffer"))
        }
        static test(t) {
          return (
            t instanceof Int8Array ||
            t instanceof Uint8Array ||
            t instanceof Uint8ClampedArray ||
            t instanceof Int16Array ||
            t instanceof Uint16Array ||
            t instanceof Int32Array ||
            t instanceof Uint32Array ||
            t instanceof Float32Array
          )
        }
      }
      ei.extension = b.TextureSource
    })
  var vx,
    Bi,
    Fc = p(() => {
      nt()
      ;((vx = new I()),
        (Bi = class {
          constructor(t, e) {
            ;((this.mapCoord = new I()),
              (this.uClampFrame = new Float32Array(4)),
              (this.uClampOffset = new Float32Array(2)),
              (this._textureID = -1),
              (this._updateID = 0),
              (this.clampOffset = 0),
              typeof e > "u" ? (this.clampMargin = t.width < 10 ? 0 : 0.5) : (this.clampMargin = e),
              (this.isSimple = !1),
              (this.texture = t))
          }
          get texture() {
            return this._texture
          }
          set texture(t) {
            this.texture !== t &&
              (this._texture?.removeListener("update", this.update, this),
              (this._texture = t),
              this._texture.addListener("update", this.update, this),
              this.update())
          }
          multiplyUvs(t, e) {
            e === void 0 && (e = t)
            let i = this.mapCoord
            for (let n = 0; n < t.length; n += 2) {
              let s = t[n],
                o = t[n + 1]
              ;((e[n] = s * i.a + o * i.c + i.tx), (e[n + 1] = s * i.b + o * i.d + i.ty))
            }
            return e
          }
          update() {
            let t = this._texture
            this._updateID++
            let e = t.uvs
            this.mapCoord.set(e.x1 - e.x0, e.y1 - e.y0, e.x3 - e.x0, e.y3 - e.y0, e.x0, e.y0)
            let i = t.orig,
              n = t.trim
            n &&
              (vx.set(
                i.width / n.width,
                0,
                0,
                i.height / n.height,
                -n.x / n.width,
                -n.y / n.height,
              ),
              this.mapCoord.append(vx))
            let s = t.source,
              o = this.uClampFrame,
              a = this.clampMargin / s._resolution,
              u = this.clampOffset / s._resolution
            return (
              (o[0] = (t.frame.x + a + u) / s.width),
              (o[1] = (t.frame.y + a + u) / s.height),
              (o[2] = (t.frame.x + t.frame.width - a + u) / s.width),
              (o[3] = (t.frame.y + t.frame.height - a + u) / s.height),
              (this.uClampOffset[0] = this.clampOffset / s.pixelWidth),
              (this.uClampOffset[1] = this.clampOffset / s.pixelHeight),
              (this.isSimple =
                t.frame.width === s.width && t.frame.height === s.height && t.rotate === 0),
              !0
            )
          }
        }))
    })
  var k,
    dt = p(() => {
      Wt()
      yx()
      Lt()
      Ot()
      gt()
      bx()
      Pc()
      te()
      Fc()
      k = class extends lt {
        constructor({
          source: t,
          label: e,
          frame: i,
          orig: n,
          trim: s,
          defaultAnchor: o,
          defaultBorders: a,
          rotate: u,
          dynamic: l,
        } = {}) {
          if (
            (super(),
            (this.uid = J("texture")),
            (this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 }),
            (this.frame = new Q()),
            (this.noFrame = !1),
            (this.dynamic = !1),
            (this.isTexture = !0),
            (this.label = e),
            (this.source = t?.source ?? new ot()),
            (this.noFrame = !i),
            i)
          )
            this.frame.copyFrom(i)
          else {
            let { width: c, height: h } = this._source
            ;((this.frame.width = c), (this.frame.height = h))
          }
          ;((this.orig = n || this.frame),
            (this.trim = s),
            (this.rotate = u ?? 0),
            (this.defaultAnchor = o),
            (this.defaultBorders = a),
            (this.destroyed = !1),
            (this.dynamic = l || !1),
            this.updateUvs())
        }
        set source(t) {
          ;(this._source && this._source.off("resize", this.update, this),
            (this._source = t),
            t.on("resize", this.update, this),
            this.emit("update", this))
        }
        get source() {
          return this._source
        }
        get textureMatrix() {
          return (this._textureMatrix || (this._textureMatrix = new Bi(this)), this._textureMatrix)
        }
        get width() {
          return this.orig.width
        }
        get height() {
          return this.orig.height
        }
        updateUvs() {
          let { uvs: t, frame: e } = this,
            { width: i, height: n } = this._source,
            s = e.x / i,
            o = e.y / n,
            a = e.width / i,
            u = e.height / n,
            l = this.rotate
          if (l) {
            let c = a / 2,
              h = u / 2,
              f = s + c,
              d = o + h
            ;((l = yt.add(l, yt.NW)),
              (t.x0 = f + c * yt.uX(l)),
              (t.y0 = d + h * yt.uY(l)),
              (l = yt.add(l, 2)),
              (t.x1 = f + c * yt.uX(l)),
              (t.y1 = d + h * yt.uY(l)),
              (l = yt.add(l, 2)),
              (t.x2 = f + c * yt.uX(l)),
              (t.y2 = d + h * yt.uY(l)),
              (l = yt.add(l, 2)),
              (t.x3 = f + c * yt.uX(l)),
              (t.y3 = d + h * yt.uY(l)))
          } else
            ((t.x0 = s),
              (t.y0 = o),
              (t.x1 = s + a),
              (t.y1 = o),
              (t.x2 = s + a),
              (t.y2 = o + u),
              (t.x3 = s),
              (t.y3 = o + u))
        }
        destroy(t = !1) {
          ;(this._source && t && (this._source.destroy(), (this._source = null)),
            (this._textureMatrix = null),
            (this.destroyed = !0),
            this.emit("destroy", this),
            this.removeAllListeners())
        }
        update() {
          ;(this.noFrame &&
            ((this.frame.width = this._source.width), (this.frame.height = this._source.height)),
            this.updateUvs(),
            this.emit("update", this))
        }
        get baseTexture() {
          return (z(K, "Texture.baseTexture is now Texture.source"), this._source)
        }
      }
      k.EMPTY = new k({ label: "EMPTY", source: new ot({ label: "EMPTY" }) })
      k.EMPTY.destroy = Dc
      k.WHITE = new k({
        source: new ei({
          resource: new Uint8Array([255, 255, 255, 255]),
          width: 1,
          height: 1,
          alphaMode: "premultiply-alpha-on-upload",
          label: "WHITE",
        }),
        label: "WHITE",
      })
      k.WHITE.destroy = Dc
    })
  var JM,
    Rc,
    St,
    _r = p(() => {
      es()
      te()
      dt()
      qr()
      ;((JM = 0),
        (Rc = class {
          constructor(t) {
            ;((this._poolKeyHash = Object.create(null)),
              (this._texturePool = {}),
              (this.textureOptions = t || {}),
              (this.enableFullScreen = !1),
              (this.textureStyle = new Jt(this.textureOptions)))
          }
          createTexture(t, e, i) {
            let n = new ot({
              ...this.textureOptions,
              width: t,
              height: e,
              resolution: 1,
              antialias: i,
              autoGarbageCollect: !1,
            })
            return new k({ source: n, label: `texturePool_${JM++}` })
          }
          getOptimalTexture(t, e, i = 1, n) {
            let s = Math.ceil(t * i - 1e-6),
              o = Math.ceil(e * i - 1e-6)
            ;((s = er(s)), (o = er(o)))
            let a = (s << 17) + (o << 1) + (n ? 1 : 0)
            this._texturePool[a] || (this._texturePool[a] = [])
            let u = this._texturePool[a].pop()
            return (
              u || (u = this.createTexture(s, o, n)),
              (u.source._resolution = i),
              (u.source.width = s / i),
              (u.source.height = o / i),
              (u.source.pixelWidth = s),
              (u.source.pixelHeight = o),
              (u.frame.x = 0),
              (u.frame.y = 0),
              (u.frame.width = t),
              (u.frame.height = e),
              u.updateUvs(),
              (this._poolKeyHash[u.uid] = a),
              u
            )
          }
          getSameSizeTexture(t, e = !1) {
            let i = t.source
            return this.getOptimalTexture(t.width, t.height, i._resolution, e)
          }
          returnTexture(t, e = !1) {
            let i = this._poolKeyHash[t.uid]
            ;(e && (t.source.style = this.textureStyle), this._texturePool[i].push(t))
          }
          clear(t) {
            if (((t = t !== !1), t))
              for (let e in this._texturePool) {
                let i = this._texturePool[e]
                if (i) for (let n = 0; n < i.length; n++) i[n].destroy(!0)
              }
            this._texturePool = {}
          }
        }),
        (St = new Rc()))
    })
  var La,
    Sx = p(() => {
      nt()
      Ec()
      _r()
      La = class {
        constructor() {
          ;((this.renderPipeId = "renderGroup"),
            (this.root = null),
            (this.canBundle = !1),
            (this.renderGroupParent = null),
            (this.renderGroupChildren = []),
            (this.worldTransform = new I()),
            (this.worldColorAlpha = 4294967295),
            (this.worldColor = 16777215),
            (this.worldAlpha = 1),
            (this.childrenToUpdate = Object.create(null)),
            (this.updateTick = 0),
            (this.gcTick = 0),
            (this.childrenRenderablesToUpdate = { list: [], index: 0 }),
            (this.structureDidChange = !0),
            (this.instructionSet = new Ri()),
            (this._onRenderContainers = []),
            (this.textureNeedsUpdate = !0),
            (this.isCachedAsTexture = !1),
            (this._matrixDirty = 7))
        }
        init(t) {
          ;((this.root = t), t._onRender && this.addOnRender(t), (t.didChange = !0))
          let e = t.children
          for (let i = 0; i < e.length; i++) {
            let n = e[i]
            ;((n._updateFlags = 15), this.addChild(n))
          }
        }
        enableCacheAsTexture(t = {}) {
          ;((this.textureOptions = t),
            (this.isCachedAsTexture = !0),
            (this.textureNeedsUpdate = !0))
        }
        disableCacheAsTexture() {
          ;((this.isCachedAsTexture = !1),
            this.texture && (St.returnTexture(this.texture), (this.texture = null)))
        }
        updateCacheTexture() {
          this.textureNeedsUpdate = !0
        }
        reset() {
          this.renderGroupChildren.length = 0
          for (let t in this.childrenToUpdate) {
            let e = this.childrenToUpdate[t]
            ;(e.list.fill(null), (e.index = 0))
          }
          ;((this.childrenRenderablesToUpdate.index = 0),
            this.childrenRenderablesToUpdate.list.fill(null),
            (this.root = null),
            (this.updateTick = 0),
            (this.structureDidChange = !0),
            (this._onRenderContainers.length = 0),
            (this.renderGroupParent = null),
            this.disableCacheAsTexture())
        }
        get localTransform() {
          return this.root.localTransform
        }
        addRenderGroupChild(t) {
          ;(t.renderGroupParent && t.renderGroupParent._removeRenderGroupChild(t),
            (t.renderGroupParent = this),
            this.renderGroupChildren.push(t))
        }
        _removeRenderGroupChild(t) {
          let e = this.renderGroupChildren.indexOf(t)
          ;(e > -1 && this.renderGroupChildren.splice(e, 1), (t.renderGroupParent = null))
        }
        addChild(t) {
          if (
            ((this.structureDidChange = !0),
            (t.parentRenderGroup = this),
            (t.updateTick = -1),
            t.parent === this.root
              ? (t.relativeRenderGroupDepth = 1)
              : (t.relativeRenderGroupDepth = t.parent.relativeRenderGroupDepth + 1),
            (t.didChange = !0),
            this.onChildUpdate(t),
            t.renderGroup)
          ) {
            this.addRenderGroupChild(t.renderGroup)
            return
          }
          t._onRender && this.addOnRender(t)
          let e = t.children
          for (let i = 0; i < e.length; i++) this.addChild(e[i])
        }
        removeChild(t) {
          if (
            ((this.structureDidChange = !0),
            t._onRender && (t.renderGroup || this.removeOnRender(t)),
            (t.parentRenderGroup = null),
            t.renderGroup)
          ) {
            this._removeRenderGroupChild(t.renderGroup)
            return
          }
          let e = t.children
          for (let i = 0; i < e.length; i++) this.removeChild(e[i])
        }
        removeChildren(t) {
          for (let e = 0; e < t.length; e++) this.removeChild(t[e])
        }
        onChildUpdate(t) {
          let e = this.childrenToUpdate[t.relativeRenderGroupDepth]
          ;(e || (e = this.childrenToUpdate[t.relativeRenderGroupDepth] = { index: 0, list: [] }),
            (e.list[e.index++] = t))
        }
        updateRenderable(t) {
          t.globalDisplayStatus < 7 ||
            (this.instructionSet.renderPipes[t.renderPipeId].updateRenderable(t),
            (t.didViewUpdate = !1))
        }
        onChildViewUpdate(t) {
          this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = t
        }
        get isRenderable() {
          return this.root.localDisplayStatus === 7 && this.worldAlpha > 0
        }
        addOnRender(t) {
          this._onRenderContainers.push(t)
        }
        removeOnRender(t) {
          this._onRenderContainers.splice(this._onRenderContainers.indexOf(t), 1)
        }
        runOnRender(t) {
          for (let e = 0; e < this._onRenderContainers.length; e++)
            this._onRenderContainers[e]._onRender(t)
        }
        destroy() {
          ;(this.disableCacheAsTexture(),
            (this.renderGroupParent = null),
            (this.root = null),
            (this.childrenRenderablesToUpdate = null),
            (this.childrenToUpdate = null),
            (this.renderGroupChildren = null),
            (this._onRenderContainers = null),
            (this.instructionSet = null))
        }
        getChildren(t = []) {
          let e = this.root.children
          for (let i = 0; i < e.length; i++) this._getChildren(e[i], t)
          return t
        }
        _getChildren(t, e = []) {
          if ((e.push(t), t.renderGroup)) return e
          let i = t.children
          for (let n = 0; n < i.length; n++) this._getChildren(i[n], e)
          return e
        }
        invalidateMatrices() {
          this._matrixDirty = 7
        }
        get inverseWorldTransform() {
          return (this._matrixDirty & 1) === 0
            ? this._inverseWorldTransform
            : ((this._matrixDirty &= -2),
              this._inverseWorldTransform || (this._inverseWorldTransform = new I()),
              this._inverseWorldTransform.copyFrom(this.worldTransform).invert())
        }
        get textureOffsetInverseTransform() {
          return (this._matrixDirty & 2) === 0
            ? this._textureOffsetInverseTransform
            : ((this._matrixDirty &= -3),
              this._textureOffsetInverseTransform ||
                (this._textureOffsetInverseTransform = new I()),
              this._textureOffsetInverseTransform
                .copyFrom(this.inverseWorldTransform)
                .translate(-this._textureBounds.x, -this._textureBounds.y))
        }
        get inverseParentTextureTransform() {
          if ((this._matrixDirty & 4) === 0) return this._inverseParentTextureTransform
          this._matrixDirty &= -5
          let t = this._parentCacheAsTextureRenderGroup
          return t
            ? (this._inverseParentTextureTransform ||
                (this._inverseParentTextureTransform = new I()),
              this._inverseParentTextureTransform
                .copyFrom(this.worldTransform)
                .prepend(t.inverseWorldTransform)
                .translate(-t._textureBounds.x, -t._textureBounds.y))
            : this.worldTransform
        }
        get cacheToLocalTransform() {
          return this._parentCacheAsTextureRenderGroup
            ? this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform
            : null
        }
      }
    })
  function Tx(r, t, e = {}) {
    for (let i in t) !e[i] && t[i] !== void 0 && (r[i] = t[i])
  }
  var Cx = p(() => {
    "use strict"
  })
  var Bc,
    Na,
    Ic,
    Ha,
    Ii,
    rs,
    ri,
    pt,
    we = p(() => {
      Wt()
      Vt()
      Rg()
      A()
      nt()
      pc()
      Da()
      Ot()
      gt()
      ft()
      Je()
      Ng()
      zg()
      Vg()
      Yg()
      Kg()
      Qg()
      rx()
      ox()
      ux()
      cx()
      fx()
      Sx()
      Cx()
      ;((Bc = new Pt(null)),
        (Na = new Pt(null)),
        (Ic = new Pt(null, 1, 1)),
        (Ha = new Pt(null)),
        (Ii = 1),
        (rs = 2),
        (ri = 4),
        (pt = class r extends lt {
          constructor(t = {}) {
            ;(super(),
              (this.uid = J("renderable")),
              (this._updateFlags = 15),
              (this.renderGroup = null),
              (this.parentRenderGroup = null),
              (this.parentRenderGroupIndex = 0),
              (this.didChange = !1),
              (this.didViewUpdate = !1),
              (this.relativeRenderGroupDepth = 0),
              (this.children = []),
              (this.parent = null),
              (this.includeInBuild = !0),
              (this.measurable = !0),
              (this.isSimple = !0),
              (this.updateTick = -1),
              (this.localTransform = new I()),
              (this.relativeGroupTransform = new I()),
              (this.groupTransform = this.relativeGroupTransform),
              (this.destroyed = !1),
              (this._position = new Pt(this, 0, 0)),
              (this._scale = Ic),
              (this._pivot = Na),
              (this._origin = Ha),
              (this._skew = Bc),
              (this._cx = 1),
              (this._sx = 0),
              (this._cy = 0),
              (this._sy = 1),
              (this._rotation = 0),
              (this.localColor = 16777215),
              (this.localAlpha = 1),
              (this.groupAlpha = 1),
              (this.groupColor = 16777215),
              (this.groupColorAlpha = 4294967295),
              (this.localBlendMode = "inherit"),
              (this.groupBlendMode = "normal"),
              (this.localDisplayStatus = 7),
              (this.globalDisplayStatus = 7),
              (this._didContainerChangeTick = 0),
              (this._didViewChangeTick = 0),
              (this._didLocalTransformChangeId = -1),
              (this.effects = []),
              Tx(this, t, { children: !0, parent: !0, effects: !0 }),
              t.children?.forEach((e) => this.addChild(e)),
              t.parent?.addChild(this))
          }
          static mixin(t) {
            ;(z("8.8.0", "Container.mixin is deprecated, please use extensions.mixin instead."),
              L.mixin(r, t))
          }
          set _didChangeId(t) {
            ;((this._didViewChangeTick = (t >> 12) & 4095),
              (this._didContainerChangeTick = t & 4095))
          }
          get _didChangeId() {
            return (this._didContainerChangeTick & 4095) | ((this._didViewChangeTick & 4095) << 12)
          }
          addChild(...t) {
            if (
              (this.allowChildren ||
                z(K, "addChild: Only Containers will be allowed to add children in v8.0.0"),
              t.length > 1)
            ) {
              for (let n = 0; n < t.length; n++) this.addChild(t[n])
              return t[0]
            }
            let e = t[0],
              i = this.renderGroup || this.parentRenderGroup
            return e.parent === this
              ? (this.children.splice(this.children.indexOf(e), 1),
                this.children.push(e),
                i && (i.structureDidChange = !0),
                e)
              : (e.parent && e.parent.removeChild(e),
                this.children.push(e),
                this.sortableChildren && (this.sortDirty = !0),
                (e.parent = this),
                (e.didChange = !0),
                (e._updateFlags = 15),
                i && i.addChild(e),
                this.emit("childAdded", e, this, this.children.length - 1),
                e.emit("added", this),
                this._didViewChangeTick++,
                e._zIndex !== 0 && e.depthOfChildModified(),
                e)
          }
          removeChild(...t) {
            if (t.length > 1) {
              for (let n = 0; n < t.length; n++) this.removeChild(t[n])
              return t[0]
            }
            let e = t[0],
              i = this.children.indexOf(e)
            return (
              i > -1 &&
                (this._didViewChangeTick++,
                this.children.splice(i, 1),
                this.renderGroup
                  ? this.renderGroup.removeChild(e)
                  : this.parentRenderGroup && this.parentRenderGroup.removeChild(e),
                e.parentRenderLayer && e.parentRenderLayer.detach(e),
                (e.parent = null),
                this.emit("childRemoved", e, this, i),
                e.emit("removed", this)),
              e
            )
          }
          _onUpdate(t) {
            ;(t && t === this._skew && this._updateSkew(),
              this._didContainerChangeTick++,
              !this.didChange &&
                ((this.didChange = !0),
                this.parentRenderGroup && this.parentRenderGroup.onChildUpdate(this)))
          }
          set isRenderGroup(t) {
            !!this.renderGroup !== t && (t ? this.enableRenderGroup() : this.disableRenderGroup())
          }
          get isRenderGroup() {
            return !!this.renderGroup
          }
          enableRenderGroup() {
            if (this.renderGroup) return
            let t = this.parentRenderGroup
            ;(t?.removeChild(this),
              (this.renderGroup = xt.get(La, this)),
              (this.groupTransform = I.IDENTITY),
              t?.addChild(this),
              this._updateIsSimple())
          }
          disableRenderGroup() {
            if (!this.renderGroup) return
            let t = this.parentRenderGroup
            ;(t?.removeChild(this),
              xt.return(this.renderGroup),
              (this.renderGroup = null),
              (this.groupTransform = this.relativeGroupTransform),
              t?.addChild(this),
              this._updateIsSimple())
          }
          _updateIsSimple() {
            this.isSimple = !this.renderGroup && this.effects.length === 0
          }
          get worldTransform() {
            return (
              this._worldTransform || (this._worldTransform = new I()),
              this.renderGroup
                ? this._worldTransform.copyFrom(this.renderGroup.worldTransform)
                : this.parentRenderGroup &&
                  this._worldTransform.appendFrom(
                    this.relativeGroupTransform,
                    this.parentRenderGroup.worldTransform,
                  ),
              this._worldTransform
            )
          }
          get x() {
            return this._position.x
          }
          set x(t) {
            this._position.x = t
          }
          get y() {
            return this._position.y
          }
          set y(t) {
            this._position.y = t
          }
          get position() {
            return this._position
          }
          set position(t) {
            this._position.copyFrom(t)
          }
          get rotation() {
            return this._rotation
          }
          set rotation(t) {
            this._rotation !== t && ((this._rotation = t), this._onUpdate(this._skew))
          }
          get angle() {
            return this.rotation * Ig
          }
          set angle(t) {
            this.rotation = t * kg
          }
          get pivot() {
            return (this._pivot === Na && (this._pivot = new Pt(this, 0, 0)), this._pivot)
          }
          set pivot(t) {
            ;(this._pivot === Na &&
              ((this._pivot = new Pt(this, 0, 0)),
              this._origin !== Ha &&
                N(
                  "Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.",
                )),
              typeof t == "number" ? this._pivot.set(t) : this._pivot.copyFrom(t))
          }
          get skew() {
            return (this._skew === Bc && (this._skew = new Pt(this, 0, 0)), this._skew)
          }
          set skew(t) {
            ;(this._skew === Bc && (this._skew = new Pt(this, 0, 0)), this._skew.copyFrom(t))
          }
          get scale() {
            return (this._scale === Ic && (this._scale = new Pt(this, 1, 1)), this._scale)
          }
          set scale(t) {
            ;(this._scale === Ic && (this._scale = new Pt(this, 0, 0)),
              typeof t == "string" && (t = parseFloat(t)),
              typeof t == "number" ? this._scale.set(t) : this._scale.copyFrom(t))
          }
          get origin() {
            return (this._origin === Ha && (this._origin = new Pt(this, 0, 0)), this._origin)
          }
          set origin(t) {
            ;(this._origin === Ha &&
              ((this._origin = new Pt(this, 0, 0)),
              this._pivot !== Na &&
                N(
                  "Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.",
                )),
              typeof t == "number" ? this._origin.set(t) : this._origin.copyFrom(t))
          }
          get width() {
            return Math.abs(this.scale.x * this.getLocalBounds().width)
          }
          set width(t) {
            let e = this.getLocalBounds().width
            this._setWidth(t, e)
          }
          get height() {
            return Math.abs(this.scale.y * this.getLocalBounds().height)
          }
          set height(t) {
            let e = this.getLocalBounds().height
            this._setHeight(t, e)
          }
          getSize(t) {
            t || (t = {})
            let e = this.getLocalBounds()
            return (
              (t.width = Math.abs(this.scale.x * e.width)),
              (t.height = Math.abs(this.scale.y * e.height)),
              t
            )
          }
          setSize(t, e) {
            let i = this.getLocalBounds()
            ;(typeof t == "object" ? ((e = t.height ?? t.width), (t = t.width)) : (e ?? (e = t)),
              t !== void 0 && this._setWidth(t, i.width),
              e !== void 0 && this._setHeight(e, i.height))
          }
          _updateSkew() {
            let t = this._rotation,
              e = this._skew
            ;((this._cx = Math.cos(t + e._y)),
              (this._sx = Math.sin(t + e._y)),
              (this._cy = -Math.sin(t - e._x)),
              (this._sy = Math.cos(t - e._x)))
          }
          updateTransform(t) {
            return (
              this.position.set(
                typeof t.x == "number" ? t.x : this.position.x,
                typeof t.y == "number" ? t.y : this.position.y,
              ),
              this.scale.set(
                typeof t.scaleX == "number" ? t.scaleX || 1 : this.scale.x,
                typeof t.scaleY == "number" ? t.scaleY || 1 : this.scale.y,
              ),
              (this.rotation = typeof t.rotation == "number" ? t.rotation : this.rotation),
              this.skew.set(
                typeof t.skewX == "number" ? t.skewX : this.skew.x,
                typeof t.skewY == "number" ? t.skewY : this.skew.y,
              ),
              this.pivot.set(
                typeof t.pivotX == "number" ? t.pivotX : this.pivot.x,
                typeof t.pivotY == "number" ? t.pivotY : this.pivot.y,
              ),
              this.origin.set(
                typeof t.originX == "number" ? t.originX : this.origin.x,
                typeof t.originY == "number" ? t.originY : this.origin.y,
              ),
              this
            )
          }
          setFromMatrix(t) {
            t.decompose(this)
          }
          updateLocalTransform() {
            let t = this._didContainerChangeTick
            if (this._didLocalTransformChangeId === t) return
            this._didLocalTransformChangeId = t
            let e = this.localTransform,
              i = this._scale,
              n = this._pivot,
              s = this._origin,
              o = this._position,
              a = i._x,
              u = i._y,
              l = n._x,
              c = n._y,
              h = -s._x,
              f = -s._y
            ;((e.a = this._cx * a),
              (e.b = this._sx * a),
              (e.c = this._cy * u),
              (e.d = this._sy * u),
              (e.tx = o._x - (l * e.a + c * e.c) + (h * e.a + f * e.c) - h * a),
              (e.ty = o._y - (l * e.b + c * e.d) + (h * e.b + f * e.d) - f * u))
          }
          set alpha(t) {
            t !== this.localAlpha &&
              ((this.localAlpha = t), (this._updateFlags |= Ii), this._onUpdate())
          }
          get alpha() {
            return this.localAlpha
          }
          set tint(t) {
            let i = q.shared.setValue(t ?? 16777215).toBgrNumber()
            i !== this.localColor &&
              ((this.localColor = i), (this._updateFlags |= Ii), this._onUpdate())
          }
          get tint() {
            return ts(this.localColor)
          }
          set blendMode(t) {
            this.localBlendMode !== t &&
              (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0),
              (this._updateFlags |= rs),
              (this.localBlendMode = t),
              this._onUpdate())
          }
          get blendMode() {
            return this.localBlendMode
          }
          get visible() {
            return !!(this.localDisplayStatus & 2)
          }
          set visible(t) {
            let e = t ? 2 : 0
            ;(this.localDisplayStatus & 2) !== e &&
              (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0),
              (this._updateFlags |= ri),
              (this.localDisplayStatus ^= 2),
              this._onUpdate())
          }
          get culled() {
            return !(this.localDisplayStatus & 4)
          }
          set culled(t) {
            let e = t ? 0 : 4
            ;(this.localDisplayStatus & 4) !== e &&
              (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0),
              (this._updateFlags |= ri),
              (this.localDisplayStatus ^= 4),
              this._onUpdate())
          }
          get renderable() {
            return !!(this.localDisplayStatus & 1)
          }
          set renderable(t) {
            let e = t ? 1 : 0
            ;(this.localDisplayStatus & 1) !== e &&
              ((this._updateFlags |= ri),
              (this.localDisplayStatus ^= 1),
              this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0),
              this._onUpdate())
          }
          get isRenderable() {
            return this.localDisplayStatus === 7 && this.groupAlpha > 0
          }
          destroy(t = !1) {
            if (this.destroyed) return
            this.destroyed = !0
            let e
            if (
              (this.children.length && (e = this.removeChildren(0, this.children.length)),
              this.removeFromParent(),
              (this.parent = null),
              (this._maskEffect = null),
              (this._filterEffect = null),
              (this.effects = null),
              (this._position = null),
              (this._scale = null),
              (this._pivot = null),
              (this._origin = null),
              (this._skew = null),
              this.emit("destroyed", this),
              this.removeAllListeners(),
              (typeof t == "boolean" ? t : t?.children) && e)
            )
              for (let n = 0; n < e.length; ++n) e[n].destroy(t)
            ;(this.renderGroup?.destroy(), (this.renderGroup = null))
          }
        }))
      L.mixin(pt, Hg, Zg, hx, ax, sx, Xg, jg, lx, Fg, Lg, ex, Wg)
    })
  var yr,
    za = p(() => {
      Ee()
      yr = class r {
        constructor(t) {
          ;((this.bubbles = !0),
            (this.cancelBubble = !0),
            (this.cancelable = !1),
            (this.composed = !1),
            (this.defaultPrevented = !1),
            (this.eventPhase = r.prototype.NONE),
            (this.propagationStopped = !1),
            (this.propagationImmediatelyStopped = !1),
            (this.layer = new rt()),
            (this.page = new rt()),
            (this.NONE = 0),
            (this.CAPTURING_PHASE = 1),
            (this.AT_TARGET = 2),
            (this.BUBBLING_PHASE = 3),
            (this.manager = t))
        }
        get layerX() {
          return this.layer.x
        }
        get layerY() {
          return this.layer.y
        }
        get pageX() {
          return this.page.x
        }
        get pageY() {
          return this.page.y
        }
        get data() {
          return this
        }
        composedPath() {
          return (
            this.manager &&
              (!this.path || this.path[this.path.length - 1] !== this.target) &&
              (this.path = this.target ? this.manager.propagationPath(this.target) : []),
            this.path
          )
        }
        initEvent(t, e, i) {
          throw new Error(
            "initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.",
          )
        }
        initUIEvent(t, e, i, n, s) {
          throw new Error(
            "initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.",
          )
        }
        preventDefault() {
          ;(this.nativeEvent instanceof Event &&
            this.nativeEvent.cancelable &&
            this.nativeEvent.preventDefault(),
            (this.defaultPrevented = !0))
        }
        stopImmediatePropagation() {
          this.propagationImmediatelyStopped = !0
        }
        stopPropagation() {
          this.propagationStopped = !0
        }
      }
    })
  function tA(r) {
    return function (t) {
      return t.test(r)
    }
  }
  function is(r) {
    var t = { userAgent: "", platform: "", maxTouchPoints: 0 }
    !r && typeof navigator < "u"
      ? (t = {
          userAgent: navigator.userAgent,
          platform: navigator.platform,
          maxTouchPoints: navigator.maxTouchPoints || 0,
        })
      : typeof r == "string"
        ? (t.userAgent = r)
        : r &&
          r.userAgent &&
          (t = {
            userAgent: r.userAgent,
            platform: r.platform,
            maxTouchPoints: r.maxTouchPoints || 0,
          })
    var e = t.userAgent,
      i = e.split("[FBAN")
    ;(typeof i[1] < "u" && (e = i[0]), (i = e.split("Twitter")), typeof i[1] < "u" && (e = i[0]))
    var n = tA(e),
      s = {
        apple: {
          phone: n(kc) && !n(rr),
          ipod: n(Ex),
          tablet: !n(kc) && (n(wx) || kx(t)) && !n(rr),
          universal: n(Mx),
          device: (n(kc) || n(Ex) || n(wx) || n(Mx) || kx(t)) && !n(rr),
        },
        amazon: { phone: n(ki), tablet: !n(ki) && n(Wa), device: n(ki) || n(Wa) },
        android: {
          phone: (!n(rr) && n(ki)) || (!n(rr) && n(Gc)),
          tablet: !n(rr) && !n(ki) && !n(Gc) && (n(Wa) || n(Ax)),
          device: (!n(rr) && (n(ki) || n(Wa) || n(Gc) || n(Ax))) || n(/\bokhttp\b/i),
        },
        windows: { phone: n(rr), tablet: n(Dx), device: n(rr) || n(Dx) },
        other: {
          blackberry: n(Px),
          blackberry10: n(Fx),
          opera: n(Rx),
          firefox: n(Ix),
          chrome: n(Bx),
          device: n(Px) || n(Fx) || n(Rx) || n(Ix) || n(Bx),
        },
        any: !1,
        phone: !1,
        tablet: !1,
      }
    return (
      (s.any = s.apple.device || s.android.device || s.windows.device || s.other.device),
      (s.phone = s.apple.phone || s.android.phone || s.windows.phone),
      (s.tablet = s.apple.tablet || s.android.tablet || s.windows.tablet),
      s
    )
  }
  var kc,
    Ex,
    wx,
    Mx,
    Gc,
    Ax,
    ki,
    Wa,
    rr,
    Dx,
    Px,
    Fx,
    Rx,
    Bx,
    Ix,
    kx,
    Uc = p(() => {
      ;((kc = /iPhone/i),
        (Ex = /iPod/i),
        (wx = /iPad/i),
        (Mx = /\biOS-universal(?:.+)Mac\b/i),
        (Gc = /\bAndroid(?:.+)Mobile\b/i),
        (Ax = /Android/i),
        (ki = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i),
        (Wa = /Silk/i),
        (rr = /Windows Phone/i),
        (Dx = /\bWindows(?:.+)ARM\b/i),
        (Px = /BlackBerry/i),
        (Fx = /BB10/i),
        (Rx = /Opera Mini/i),
        (Bx = /\b(CriOS|Chrome)(?:.+)Mobile/i),
        (Ix = /Mobile(?:.+)Firefox\b/i),
        (kx = function (r) {
          return (
            typeof r < "u" &&
            r.platform === "MacIntel" &&
            typeof r.maxTouchPoints == "number" &&
            r.maxTouchPoints > 1 &&
            typeof MSStream > "u"
          )
        }))
    })
  var Gx = p(() => {
    Uc()
    Uc()
  })
  var eA,
    Ux,
    Ox = p(() => {
      Gx()
      ;((eA = is.default ?? is), (Ux = eA(globalThis.navigator)))
    })
  var rA,
    Va,
    iA,
    nA,
    Lx,
    Nx,
    sA,
    oA,
    aA,
    Oc,
    zx,
    Wx = p(() => {
      za()
      A()
      Ox()
      bc()
      ;((rA = 9),
        (Va = 100),
        (iA = 0),
        (nA = 0),
        (Lx = 2),
        (Nx = 1),
        (sA = -1e3),
        (oA = -1e3),
        (aA = 2),
        (Oc = class Hx {
          constructor(t, e = Ux) {
            ;((this._mobileInfo = e),
              (this.debug = !1),
              (this._activateOnTab = !0),
              (this._deactivateOnMouseMove = !0),
              (this._isActive = !1),
              (this._isMobileAccessibility = !1),
              (this._div = null),
              (this._pool = []),
              (this._renderId = 0),
              (this._children = []),
              (this._androidUpdateCount = 0),
              (this._androidUpdateFrequency = 500),
              (this._hookDiv = null),
              (e.tablet || e.phone) && this._createTouchHook(),
              (this._renderer = t))
          }
          get isActive() {
            return this._isActive
          }
          get isMobileAccessibility() {
            return this._isMobileAccessibility
          }
          get hookDiv() {
            return this._hookDiv
          }
          _createTouchHook() {
            let t = document.createElement("button")
            ;((t.style.width = `${Nx}px`),
              (t.style.height = `${Nx}px`),
              (t.style.position = "absolute"),
              (t.style.top = `${sA}px`),
              (t.style.left = `${oA}px`),
              (t.style.zIndex = aA.toString()),
              (t.style.backgroundColor = "#FF0000"),
              (t.title = "select to enable accessibility for this content"),
              t.addEventListener("focus", () => {
                ;((this._isMobileAccessibility = !0), this._activate(), this._destroyTouchHook())
              }),
              document.body.appendChild(t),
              (this._hookDiv = t))
          }
          _destroyTouchHook() {
            this._hookDiv && (document.body.removeChild(this._hookDiv), (this._hookDiv = null))
          }
          _activate() {
            if (this._isActive) return
            ;((this._isActive = !0),
              this._div ||
                ((this._div = document.createElement("div")),
                (this._div.style.width = `${Va}px`),
                (this._div.style.height = `${Va}px`),
                (this._div.style.position = "absolute"),
                (this._div.style.top = `${iA}px`),
                (this._div.style.left = `${nA}px`),
                (this._div.style.zIndex = Lx.toString()),
                (this._div.style.pointerEvents = "none")),
              this._activateOnTab &&
                ((this._onKeyDown = this._onKeyDown.bind(this)),
                globalThis.addEventListener("keydown", this._onKeyDown, !1)),
              this._deactivateOnMouseMove &&
                ((this._onMouseMove = this._onMouseMove.bind(this)),
                globalThis.document.addEventListener("mousemove", this._onMouseMove, !0)))
            let t = this._renderer.view.canvas
            if (t.parentNode) (t.parentNode.appendChild(this._div), this._initAccessibilitySetup())
            else {
              let e = new MutationObserver(() => {
                t.parentNode &&
                  (t.parentNode.appendChild(this._div),
                  e.disconnect(),
                  this._initAccessibilitySetup())
              })
              e.observe(document.body, { childList: !0, subtree: !0 })
            }
          }
          _initAccessibilitySetup() {
            ;(this._renderer.runners.postrender.add(this),
              this._renderer.lastObjectRendered &&
                this._updateAccessibleObjects(this._renderer.lastObjectRendered))
          }
          _deactivate() {
            if (!(!this._isActive || this._isMobileAccessibility)) {
              ;((this._isActive = !1),
                globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0),
                this._activateOnTab && globalThis.addEventListener("keydown", this._onKeyDown, !1),
                this._renderer.runners.postrender.remove(this))
              for (let t of this._children)
                (t._accessibleDiv &&
                  t._accessibleDiv.parentNode &&
                  (t._accessibleDiv.parentNode.removeChild(t._accessibleDiv),
                  (t._accessibleDiv = null)),
                  (t._accessibleActive = !1))
              ;(this._pool.forEach((t) => {
                t.parentNode && t.parentNode.removeChild(t)
              }),
                this._div && this._div.parentNode && this._div.parentNode.removeChild(this._div),
                (this._pool = []),
                (this._children = []))
            }
          }
          _updateAccessibleObjects(t) {
            if (!t.visible || !t.accessibleChildren) return
            t.accessible &&
              (t._accessibleActive || this._addChild(t), (t._renderId = this._renderId))
            let e = t.children
            if (e) for (let i = 0; i < e.length; i++) this._updateAccessibleObjects(e[i])
          }
          init(t) {
            let i = {
              accessibilityOptions: { ...Hx.defaultOptions, ...(t?.accessibilityOptions || {}) },
            }
            ;((this.debug = i.accessibilityOptions.debug),
              (this._activateOnTab = i.accessibilityOptions.activateOnTab),
              (this._deactivateOnMouseMove = i.accessibilityOptions.deactivateOnMouseMove),
              i.accessibilityOptions.enabledByDefault
                ? this._activate()
                : this._activateOnTab &&
                  ((this._onKeyDown = this._onKeyDown.bind(this)),
                  globalThis.addEventListener("keydown", this._onKeyDown, !1)),
              this._renderer.runners.postrender.remove(this))
          }
          postrender() {
            let t = performance.now()
            if (
              (this._mobileInfo.android.device && t < this._androidUpdateCount) ||
              ((this._androidUpdateCount = t + this._androidUpdateFrequency),
              !this._renderer.renderingToScreen || !this._renderer.view.canvas)
            )
              return
            let e = new Set()
            if (this._renderer.lastObjectRendered) {
              this._updateAccessibleObjects(this._renderer.lastObjectRendered)
              for (let i of this._children)
                i._renderId === this._renderId && e.add(this._children.indexOf(i))
            }
            for (let i = this._children.length - 1; i >= 0; i--) {
              let n = this._children[i]
              e.has(i) ||
                (n._accessibleDiv &&
                  n._accessibleDiv.parentNode &&
                  (n._accessibleDiv.parentNode.removeChild(n._accessibleDiv),
                  this._pool.push(n._accessibleDiv),
                  (n._accessibleDiv = null)),
                (n._accessibleActive = !1),
                Pa(this._children, i, 1))
            }
            if (this._renderer.renderingToScreen) {
              let { x: i, y: n, width: s, height: o } = this._renderer.screen,
                a = this._div
              ;((a.style.left = `${i}px`),
                (a.style.top = `${n}px`),
                (a.style.width = `${s}px`),
                (a.style.height = `${o}px`))
            }
            for (let i = 0; i < this._children.length; i++) {
              let n = this._children[i]
              if (!n._accessibleActive || !n._accessibleDiv) continue
              let s = n._accessibleDiv,
                o = n.hitArea || n.getBounds().rectangle
              if (n.hitArea) {
                let a = n.worldTransform,
                  u = this._renderer.resolution,
                  l = this._renderer.resolution
                ;((s.style.left = `${(a.tx + o.x * a.a) * u}px`),
                  (s.style.top = `${(a.ty + o.y * a.d) * l}px`),
                  (s.style.width = `${o.width * a.a * u}px`),
                  (s.style.height = `${o.height * a.d * l}px`))
              } else {
                this._capHitArea(o)
                let a = this._renderer.resolution,
                  u = this._renderer.resolution
                ;((s.style.left = `${o.x * a}px`),
                  (s.style.top = `${o.y * u}px`),
                  (s.style.width = `${o.width * a}px`),
                  (s.style.height = `${o.height * u}px`))
              }
            }
            this._renderId++
          }
          _updateDebugHTML(t) {
            t.innerHTML = `type: ${t.type}</br> title : ${t.title}</br> tabIndex: ${t.tabIndex}`
          }
          _capHitArea(t) {
            ;(t.x < 0 && ((t.width += t.x), (t.x = 0)), t.y < 0 && ((t.height += t.y), (t.y = 0)))
            let { width: e, height: i } = this._renderer
            ;(t.x + t.width > e && (t.width = e - t.x), t.y + t.height > i && (t.height = i - t.y))
          }
          _addChild(t) {
            let e = this._pool.pop()
            ;(e ||
              (t.accessibleType === "button"
                ? (e = document.createElement("button"))
                : ((e = document.createElement(t.accessibleType)),
                  (e.style.cssText = `
                        color: transparent;
                        pointer-events: none;
                        padding: 0;
                        margin: 0;
                        border: 0;
                        outline: 0;
                        background: transparent;
                        box-sizing: border-box;
                        user-select: none;
                        -webkit-user-select: none;
                        -moz-user-select: none;
                        -ms-user-select: none;
                    `),
                  t.accessibleText && (e.innerText = t.accessibleText)),
              (e.style.width = `${Va}px`),
              (e.style.height = `${Va}px`),
              (e.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent"),
              (e.style.position = "absolute"),
              (e.style.zIndex = Lx.toString()),
              (e.style.borderStyle = "none"),
              navigator.userAgent.toLowerCase().includes("chrome")
                ? e.setAttribute("aria-live", "off")
                : e.setAttribute("aria-live", "polite"),
              navigator.userAgent.match(/rv:.*Gecko\//)
                ? e.setAttribute("aria-relevant", "additions")
                : e.setAttribute("aria-relevant", "text"),
              e.addEventListener("click", this._onClick.bind(this)),
              e.addEventListener("focus", this._onFocus.bind(this)),
              e.addEventListener("focusout", this._onFocusOut.bind(this))),
              (e.style.pointerEvents = t.accessiblePointerEvents),
              (e.type = t.accessibleType),
              t.accessibleTitle && t.accessibleTitle !== null
                ? (e.title = t.accessibleTitle)
                : (!t.accessibleHint || t.accessibleHint === null) &&
                  (e.title = `container ${t.tabIndex}`),
              t.accessibleHint &&
                t.accessibleHint !== null &&
                e.setAttribute("aria-label", t.accessibleHint),
              this.debug && this._updateDebugHTML(e),
              (t._accessibleActive = !0),
              (t._accessibleDiv = e),
              (e.container = t),
              this._children.push(t),
              this._div.appendChild(t._accessibleDiv),
              t.interactive && (t._accessibleDiv.tabIndex = t.tabIndex))
          }
          _dispatchEvent(t, e) {
            let { container: i } = t.target,
              n = this._renderer.events.rootBoundary,
              s = Object.assign(new yr(n), { target: i })
            ;((n.rootTarget = this._renderer.lastObjectRendered),
              e.forEach((o) => n.dispatchEvent(s, o)))
          }
          _onClick(t) {
            this._dispatchEvent(t, ["click", "pointertap", "tap"])
          }
          _onFocus(t) {
            ;(t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "assertive"),
              this._dispatchEvent(t, ["mouseover"]))
          }
          _onFocusOut(t) {
            ;(t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "polite"),
              this._dispatchEvent(t, ["mouseout"]))
          }
          _onKeyDown(t) {
            t.keyCode !== rA || !this._activateOnTab || this._activate()
          }
          _onMouseMove(t) {
            ;(t.movementX === 0 && t.movementY === 0) || this._deactivate()
          }
          destroy() {
            ;(this._deactivate(),
              this._destroyTouchHook(),
              (this._div = null),
              (this._pool = null),
              (this._children = null),
              (this._renderer = null),
              this._activateOnTab && globalThis.removeEventListener("keydown", this._onKeyDown))
          }
          setAccessibilityEnabled(t) {
            t ? this._activate() : this._deactivate()
          }
        }))
      Oc.extension = { type: [b.WebGLSystem, b.WebGPUSystem], name: "accessibility" }
      Oc.defaultOptions = {
        enabledByDefault: !1,
        debug: !1,
        activateOnTab: !0,
        deactivateOnMouseMove: !0,
      }
      zx = Oc
    })
  var Vx,
    $x = p(() => {
      "use strict"
      Vx = {
        accessible: !1,
        accessibleTitle: null,
        accessibleHint: null,
        tabIndex: 0,
        accessibleType: "button",
        accessibleText: null,
        accessiblePointerEvents: "auto",
        accessibleChildren: !0,
        _accessibleActive: !1,
        _accessibleDiv: null,
        _renderId: -1,
      }
    })
  var Xx = p(() => {
    A()
    we()
    Wx()
    $x()
    L.add(zx)
    L.mixin(pt, Vx)
  })
  var ns,
    Yx = p(() => {
      A()
      ns = class {
        static init(t) {
          ;(Object.defineProperty(this, "resizeTo", {
            set(e) {
              ;(globalThis.removeEventListener("resize", this.queueResize),
                (this._resizeTo = e),
                e && (globalThis.addEventListener("resize", this.queueResize), this.resize()))
            },
            get() {
              return this._resizeTo
            },
          }),
            (this.queueResize = () => {
              this._resizeTo &&
                (this._cancelResize(),
                (this._resizeId = requestAnimationFrame(() => this.resize())))
            }),
            (this._cancelResize = () => {
              this._resizeId && (cancelAnimationFrame(this._resizeId), (this._resizeId = null))
            }),
            (this.resize = () => {
              if (!this._resizeTo) return
              this._cancelResize()
              let e, i
              if (this._resizeTo === globalThis.window)
                ((e = globalThis.innerWidth), (i = globalThis.innerHeight))
              else {
                let { clientWidth: n, clientHeight: s } = this._resizeTo
                ;((e = n), (i = s))
              }
              ;(this.renderer.resize(e, i), this.render())
            }),
            (this._resizeId = null),
            (this._resizeTo = null),
            (this.resizeTo = t.resizeTo || null))
        }
        static destroy() {
          ;(globalThis.removeEventListener("resize", this.queueResize),
            this._cancelResize(),
            (this._cancelResize = null),
            (this.queueResize = null),
            (this.resizeTo = null),
            (this.resize = null))
        }
      }
      ns.extension = b.Application
    })
  var br,
    $a = p(() => {
      "use strict"
      br = ((r) => (
        (r[(r.INTERACTION = 50)] = "INTERACTION"),
        (r[(r.HIGH = 25)] = "HIGH"),
        (r[(r.NORMAL = 0)] = "NORMAL"),
        (r[(r.LOW = -25)] = "LOW"),
        (r[(r.UTILITY = -50)] = "UTILITY"),
        r
      ))(br || {})
    })
  var Gi,
    jx = p(() => {
      "use strict"
      Gi = class {
        constructor(t, e = null, i = 0, n = !1) {
          ;((this.next = null),
            (this.previous = null),
            (this._destroyed = !1),
            (this._fn = t),
            (this._context = e),
            (this.priority = i),
            (this._once = n))
        }
        match(t, e = null) {
          return this._fn === t && this._context === e
        }
        emit(t) {
          this._fn && (this._context ? this._fn.call(this._context, t) : this._fn(t))
          let e = this.next
          return (this._once && this.destroy(!0), this._destroyed && (this.next = null), e)
        }
        connect(t) {
          ;((this.previous = t),
            t.next && (t.next.previous = this),
            (this.next = t.next),
            (t.next = this))
        }
        destroy(t = !1) {
          ;((this._destroyed = !0),
            (this._fn = null),
            (this._context = null),
            this.previous && (this.previous.next = this.next),
            this.next && (this.next.previous = this.previous))
          let e = this.next
          return ((this.next = t ? null : e), (this.previous = null), e)
        }
      }
    })
  var Kx,
    oe,
    ss = p(() => {
      $a()
      jx()
      Kx = class fe {
        constructor() {
          ;((this.autoStart = !1),
            (this.deltaTime = 1),
            (this.lastTime = -1),
            (this.speed = 1),
            (this.started = !1),
            (this._requestId = null),
            (this._maxElapsedMS = 100),
            (this._minElapsedMS = 0),
            (this._protected = !1),
            (this._lastFrame = -1),
            (this._head = new Gi(null, null, 1 / 0)),
            (this.deltaMS = 1 / fe.targetFPMS),
            (this.elapsedMS = 1 / fe.targetFPMS),
            (this._tick = (t) => {
              ;((this._requestId = null),
                this.started &&
                  (this.update(t),
                  this.started &&
                    this._requestId === null &&
                    this._head.next &&
                    (this._requestId = requestAnimationFrame(this._tick))))
            }))
        }
        _requestIfNeeded() {
          this._requestId === null &&
            this._head.next &&
            ((this.lastTime = performance.now()),
            (this._lastFrame = this.lastTime),
            (this._requestId = requestAnimationFrame(this._tick)))
        }
        _cancelIfNeeded() {
          this._requestId !== null &&
            (cancelAnimationFrame(this._requestId), (this._requestId = null))
        }
        _startIfPossible() {
          this.started ? this._requestIfNeeded() : this.autoStart && this.start()
        }
        add(t, e, i = br.NORMAL) {
          return this._addListener(new Gi(t, e, i))
        }
        addOnce(t, e, i = br.NORMAL) {
          return this._addListener(new Gi(t, e, i, !0))
        }
        _addListener(t) {
          let e = this._head.next,
            i = this._head
          if (!e) t.connect(i)
          else {
            for (; e; ) {
              if (t.priority > e.priority) {
                t.connect(i)
                break
              }
              ;((i = e), (e = e.next))
            }
            t.previous || t.connect(i)
          }
          return (this._startIfPossible(), this)
        }
        remove(t, e) {
          let i = this._head.next
          for (; i; ) i.match(t, e) ? (i = i.destroy()) : (i = i.next)
          return (this._head.next || this._cancelIfNeeded(), this)
        }
        get count() {
          if (!this._head) return 0
          let t = 0,
            e = this._head
          for (; (e = e.next); ) t++
          return t
        }
        start() {
          this.started || ((this.started = !0), this._requestIfNeeded())
        }
        stop() {
          this.started && ((this.started = !1), this._cancelIfNeeded())
        }
        destroy() {
          if (!this._protected) {
            this.stop()
            let t = this._head.next
            for (; t; ) t = t.destroy(!0)
            ;(this._head.destroy(), (this._head = null))
          }
        }
        update(t = performance.now()) {
          let e
          if (t > this.lastTime) {
            if (
              ((e = this.elapsedMS = t - this.lastTime),
              e > this._maxElapsedMS && (e = this._maxElapsedMS),
              (e *= this.speed),
              this._minElapsedMS)
            ) {
              let s = (t - this._lastFrame) | 0
              if (s < this._minElapsedMS) return
              this._lastFrame = t - (s % this._minElapsedMS)
            }
            ;((this.deltaMS = e), (this.deltaTime = this.deltaMS * fe.targetFPMS))
            let i = this._head,
              n = i.next
            for (; n; ) n = n.emit(this)
            i.next || this._cancelIfNeeded()
          } else this.deltaTime = this.deltaMS = this.elapsedMS = 0
          this.lastTime = t
        }
        get FPS() {
          return 1e3 / this.elapsedMS
        }
        get minFPS() {
          return 1e3 / this._maxElapsedMS
        }
        set minFPS(t) {
          let e = Math.min(this.maxFPS, t),
            i = Math.min(Math.max(0, e) / 1e3, fe.targetFPMS)
          this._maxElapsedMS = 1 / i
        }
        get maxFPS() {
          return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0
        }
        set maxFPS(t) {
          if (t === 0) this._minElapsedMS = 0
          else {
            let e = Math.max(this.minFPS, t)
            this._minElapsedMS = 1 / (e / 1e3)
          }
        }
        static get shared() {
          if (!fe._shared) {
            let t = (fe._shared = new fe())
            ;((t.autoStart = !0), (t._protected = !0))
          }
          return fe._shared
        }
        static get system() {
          if (!fe._system) {
            let t = (fe._system = new fe())
            ;((t.autoStart = !0), (t._protected = !0))
          }
          return fe._system
        }
      }
      Kx.targetFPMS = 0.06
      oe = Kx
    })
  var os,
    qx = p(() => {
      A()
      $a()
      ss()
      os = class {
        static init(t) {
          ;((t = Object.assign({ autoStart: !0, sharedTicker: !1 }, t)),
            Object.defineProperty(this, "ticker", {
              set(e) {
                ;(this._ticker && this._ticker.remove(this.render, this),
                  (this._ticker = e),
                  e && e.add(this.render, this, br.LOW))
              },
              get() {
                return this._ticker
              },
            }),
            (this.stop = () => {
              this._ticker.stop()
            }),
            (this.start = () => {
              this._ticker.start()
            }),
            (this._ticker = null),
            (this.ticker = t.sharedTicker ? oe.shared : new oe()),
            t.autoStart && this.start())
        }
        static destroy() {
          if (this._ticker) {
            let t = this._ticker
            ;((this.ticker = null), t.destroy())
          }
        }
      }
      os.extension = b.Application
    })
  var Lc = p(() => {
    A()
    Yx()
    qx()
    L.add(ns)
    L.add(os)
  })
  var Nc,
    Fe,
    Hc = p(() => {
      $a()
      ss()
      ;((Nc = class {
        constructor() {
          ;((this.interactionFrequency = 10),
            (this._deltaTime = 0),
            (this._didMove = !1),
            (this._tickerAdded = !1),
            (this._pauseUpdate = !0))
        }
        init(t) {
          ;(this.removeTickerListener(),
            (this.events = t),
            (this.interactionFrequency = 10),
            (this._deltaTime = 0),
            (this._didMove = !1),
            (this._tickerAdded = !1),
            (this._pauseUpdate = !0))
        }
        get pauseUpdate() {
          return this._pauseUpdate
        }
        set pauseUpdate(t) {
          this._pauseUpdate = t
        }
        addTickerListener() {
          this._tickerAdded ||
            !this.domElement ||
            (oe.system.add(this._tickerUpdate, this, br.INTERACTION), (this._tickerAdded = !0))
        }
        removeTickerListener() {
          this._tickerAdded &&
            (oe.system.remove(this._tickerUpdate, this), (this._tickerAdded = !1))
        }
        pointerMoved() {
          this._didMove = !0
        }
        _update() {
          if (!this.domElement || this._pauseUpdate) return
          if (this._didMove) {
            this._didMove = !1
            return
          }
          let t = this.events._rootPointerEvent
          ;(this.events.supportsTouchEvents && t.pointerType === "touch") ||
            globalThis.document.dispatchEvent(
              this.events.supportsPointerEvents
                ? new PointerEvent("pointermove", {
                    clientX: t.clientX,
                    clientY: t.clientY,
                    pointerType: t.pointerType,
                    pointerId: t.pointerId,
                  })
                : new MouseEvent("mousemove", { clientX: t.clientX, clientY: t.clientY }),
            )
        }
        _tickerUpdate(t) {
          ;((this._deltaTime += t.deltaTime),
            !(this._deltaTime < this.interactionFrequency) &&
              ((this._deltaTime = 0), this._update()))
        }
      }),
        (Fe = new Nc()))
    })
  var ir,
    Xa = p(() => {
      Ee()
      za()
      ir = class extends yr {
        constructor() {
          ;(super(...arguments),
            (this.client = new rt()),
            (this.movement = new rt()),
            (this.offset = new rt()),
            (this.global = new rt()),
            (this.screen = new rt()))
        }
        get clientX() {
          return this.client.x
        }
        get clientY() {
          return this.client.y
        }
        get x() {
          return this.clientX
        }
        get y() {
          return this.clientY
        }
        get movementX() {
          return this.movement.x
        }
        get movementY() {
          return this.movement.y
        }
        get offsetX() {
          return this.offset.x
        }
        get offsetY() {
          return this.offset.y
        }
        get globalX() {
          return this.global.x
        }
        get globalY() {
          return this.global.y
        }
        get screenX() {
          return this.screen.x
        }
        get screenY() {
          return this.screen.y
        }
        getLocalPosition(t, e, i) {
          return t.worldTransform.applyInverse(i || this.global, e)
        }
        getModifierState(t) {
          return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(t)
        }
        initMouseEvent(t, e, i, n, s, o, a, u, l, c, h, f, d, g, x) {
          throw new Error("Method not implemented.")
        }
      }
    })
  var ee,
    zc = p(() => {
      Xa()
      ee = class extends ir {
        constructor() {
          ;(super(...arguments), (this.width = 0), (this.height = 0), (this.isPrimary = !1))
        }
        getCoalescedEvents() {
          return this.type === "pointermove" ||
            this.type === "mousemove" ||
            this.type === "touchmove"
            ? [this]
            : []
        }
        getPredictedEvents() {
          throw new Error("getPredictedEvents is not supported!")
        }
      }
    })
  var Re,
    Wc = p(() => {
      Xa()
      Re = class extends ir {
        constructor() {
          ;(super(...arguments),
            (this.DOM_DELTA_PIXEL = 0),
            (this.DOM_DELTA_LINE = 1),
            (this.DOM_DELTA_PAGE = 2))
        }
      }
      Re.DOM_DELTA_PIXEL = 0
      Re.DOM_DELTA_LINE = 1
      Re.DOM_DELTA_PAGE = 2
    })
  var uA,
    lA,
    as,
    Ya,
    Zx = p(() => {
      Wt()
      Ee()
      ft()
      Hc()
      Xa()
      zc()
      Wc()
      ;((uA = 2048),
        (lA = new rt()),
        (as = new rt()),
        (Ya = class {
          constructor(t) {
            ;((this.dispatch = new lt()),
              (this.moveOnAll = !1),
              (this.enableGlobalMoveEvents = !0),
              (this.mappingState = { trackingData: {} }),
              (this.eventPool = new Map()),
              (this._allInteractiveElements = []),
              (this._hitElements = []),
              (this._isPointerMoveEvent = !1),
              (this.rootTarget = t),
              (this.hitPruneFn = this.hitPruneFn.bind(this)),
              (this.hitTestFn = this.hitTestFn.bind(this)),
              (this.mapPointerDown = this.mapPointerDown.bind(this)),
              (this.mapPointerMove = this.mapPointerMove.bind(this)),
              (this.mapPointerOut = this.mapPointerOut.bind(this)),
              (this.mapPointerOver = this.mapPointerOver.bind(this)),
              (this.mapPointerUp = this.mapPointerUp.bind(this)),
              (this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this)),
              (this.mapWheel = this.mapWheel.bind(this)),
              (this.mappingTable = {}),
              this.addEventMapping("pointerdown", this.mapPointerDown),
              this.addEventMapping("pointermove", this.mapPointerMove),
              this.addEventMapping("pointerout", this.mapPointerOut),
              this.addEventMapping("pointerleave", this.mapPointerOut),
              this.addEventMapping("pointerover", this.mapPointerOver),
              this.addEventMapping("pointerup", this.mapPointerUp),
              this.addEventMapping("pointerupoutside", this.mapPointerUpOutside),
              this.addEventMapping("wheel", this.mapWheel))
          }
          addEventMapping(t, e) {
            ;(this.mappingTable[t] || (this.mappingTable[t] = []),
              this.mappingTable[t].push({ fn: e, priority: 0 }),
              this.mappingTable[t].sort((i, n) => i.priority - n.priority))
          }
          dispatchEvent(t, e) {
            ;((t.propagationStopped = !1),
              (t.propagationImmediatelyStopped = !1),
              this.propagate(t, e),
              this.dispatch.emit(e || t.type, t))
          }
          mapEvent(t) {
            if (!this.rootTarget) return
            let e = this.mappingTable[t.type]
            if (e) for (let i = 0, n = e.length; i < n; i++) e[i].fn(t)
            else N(`[EventBoundary]: Event mapping not defined for ${t.type}`)
          }
          hitTest(t, e) {
            Fe.pauseUpdate = !0
            let n =
                this._isPointerMoveEvent && this.enableGlobalMoveEvents
                  ? "hitTestMoveRecursive"
                  : "hitTestRecursive",
              s = this[n](
                this.rootTarget,
                this.rootTarget.eventMode,
                lA.set(t, e),
                this.hitTestFn,
                this.hitPruneFn,
              )
            return s && s[0]
          }
          propagate(t, e) {
            if (!t.target) return
            let i = t.composedPath()
            t.eventPhase = t.CAPTURING_PHASE
            for (let n = 0, s = i.length - 1; n < s; n++)
              if (
                ((t.currentTarget = i[n]),
                this.notifyTarget(t, e),
                t.propagationStopped || t.propagationImmediatelyStopped)
              )
                return
            if (
              ((t.eventPhase = t.AT_TARGET),
              (t.currentTarget = t.target),
              this.notifyTarget(t, e),
              !(t.propagationStopped || t.propagationImmediatelyStopped))
            ) {
              t.eventPhase = t.BUBBLING_PHASE
              for (let n = i.length - 2; n >= 0; n--)
                if (
                  ((t.currentTarget = i[n]),
                  this.notifyTarget(t, e),
                  t.propagationStopped || t.propagationImmediatelyStopped)
                )
                  return
            }
          }
          all(t, e, i = this._allInteractiveElements) {
            if (i.length === 0) return
            t.eventPhase = t.BUBBLING_PHASE
            let n = Array.isArray(e) ? e : [e]
            for (let s = i.length - 1; s >= 0; s--)
              n.forEach((o) => {
                ;((t.currentTarget = i[s]), this.notifyTarget(t, o))
              })
          }
          propagationPath(t) {
            let e = [t]
            for (let i = 0; i < uA && t !== this.rootTarget && t.parent; i++) {
              if (!t.parent) throw new Error("Cannot find propagation path to disconnected target")
              ;(e.push(t.parent), (t = t.parent))
            }
            return (e.reverse(), e)
          }
          hitTestMoveRecursive(t, e, i, n, s, o = !1) {
            let a = !1
            if (this._interactivePrune(t)) return null
            if (
              ((t.eventMode === "dynamic" || e === "dynamic") && (Fe.pauseUpdate = !1),
              t.interactiveChildren && t.children)
            ) {
              let c = t.children
              for (let h = c.length - 1; h >= 0; h--) {
                let f = c[h],
                  d = this.hitTestMoveRecursive(
                    f,
                    this._isInteractive(e) ? e : f.eventMode,
                    i,
                    n,
                    s,
                    o || s(t, i),
                  )
                if (d) {
                  if (d.length > 0 && !d[d.length - 1].parent) continue
                  let g = t.isInteractive()
                  ;((d.length > 0 || g) && (g && this._allInteractiveElements.push(t), d.push(t)),
                    this._hitElements.length === 0 && (this._hitElements = d),
                    (a = !0))
                }
              }
            }
            let u = this._isInteractive(e),
              l = t.isInteractive()
            return (
              l && l && this._allInteractiveElements.push(t),
              o || this._hitElements.length > 0
                ? null
                : a
                  ? this._hitElements
                  : u && !s(t, i) && n(t, i)
                    ? l
                      ? [t]
                      : []
                    : null
            )
          }
          hitTestRecursive(t, e, i, n, s) {
            if (this._interactivePrune(t) || s(t, i)) return null
            if (
              ((t.eventMode === "dynamic" || e === "dynamic") && (Fe.pauseUpdate = !1),
              t.interactiveChildren && t.children)
            ) {
              let u = t.children,
                l = i
              for (let c = u.length - 1; c >= 0; c--) {
                let h = u[c],
                  f = this.hitTestRecursive(h, this._isInteractive(e) ? e : h.eventMode, l, n, s)
                if (f) {
                  if (f.length > 0 && !f[f.length - 1].parent) continue
                  let d = t.isInteractive()
                  return ((f.length > 0 || d) && f.push(t), f)
                }
              }
            }
            let o = this._isInteractive(e),
              a = t.isInteractive()
            return o && n(t, i) ? (a ? [t] : []) : null
          }
          _isInteractive(t) {
            return t === "static" || t === "dynamic"
          }
          _interactivePrune(t) {
            return (
              !t ||
              !t.visible ||
              !t.renderable ||
              !t.measurable ||
              t.eventMode === "none" ||
              (t.eventMode === "passive" && !t.interactiveChildren)
            )
          }
          hitPruneFn(t, e) {
            if (
              t.hitArea &&
              (t.worldTransform.applyInverse(e, as), !t.hitArea.contains(as.x, as.y))
            )
              return !0
            if (t.effects && t.effects.length)
              for (let i = 0; i < t.effects.length; i++) {
                let n = t.effects[i]
                if (n.containsPoint && !n.containsPoint(e, this.hitTestFn)) return !0
              }
            return !1
          }
          hitTestFn(t, e) {
            return t.hitArea
              ? !0
              : t?.containsPoint
                ? (t.worldTransform.applyInverse(e, as), t.containsPoint(as))
                : !1
          }
          notifyTarget(t, e) {
            if (!t.currentTarget.isInteractive()) return
            e ?? (e = t.type)
            let i = `on${e}`
            t.currentTarget[i]?.(t)
            let n =
              t.eventPhase === t.CAPTURING_PHASE || t.eventPhase === t.AT_TARGET ? `${e}capture` : e
            ;(this._notifyListeners(t, n),
              t.eventPhase === t.AT_TARGET && this._notifyListeners(t, e))
          }
          mapPointerDown(t) {
            if (!(t instanceof ee)) {
              N("EventBoundary cannot map a non-pointer event as a pointer event")
              return
            }
            let e = this.createPointerEvent(t)
            if ((this.dispatchEvent(e, "pointerdown"), e.pointerType === "touch"))
              this.dispatchEvent(e, "touchstart")
            else if (e.pointerType === "mouse" || e.pointerType === "pen") {
              let n = e.button === 2
              this.dispatchEvent(e, n ? "rightdown" : "mousedown")
            }
            let i = this.trackingData(t.pointerId)
            ;((i.pressTargetsByButton[t.button] = e.composedPath()), this.freeEvent(e))
          }
          mapPointerMove(t) {
            if (!(t instanceof ee)) {
              N("EventBoundary cannot map a non-pointer event as a pointer event")
              return
            }
            ;((this._allInteractiveElements.length = 0),
              (this._hitElements.length = 0),
              (this._isPointerMoveEvent = !0))
            let e = this.createPointerEvent(t)
            this._isPointerMoveEvent = !1
            let i = e.pointerType === "mouse" || e.pointerType === "pen",
              n = this.trackingData(t.pointerId),
              s = this.findMountedTarget(n.overTargets)
            if (n.overTargets?.length > 0 && s !== e.target) {
              let u = t.type === "mousemove" ? "mouseout" : "pointerout",
                l = this.createPointerEvent(t, u, s)
              if (
                (this.dispatchEvent(l, "pointerout"),
                i && this.dispatchEvent(l, "mouseout"),
                !e.composedPath().includes(s))
              ) {
                let c = this.createPointerEvent(t, "pointerleave", s)
                for (c.eventPhase = c.AT_TARGET; c.target && !e.composedPath().includes(c.target); )
                  ((c.currentTarget = c.target),
                    this.notifyTarget(c),
                    i && this.notifyTarget(c, "mouseleave"),
                    (c.target = c.target.parent))
                this.freeEvent(c)
              }
              this.freeEvent(l)
            }
            if (s !== e.target) {
              let u = t.type === "mousemove" ? "mouseover" : "pointerover",
                l = this.clonePointerEvent(e, u)
              ;(this.dispatchEvent(l, "pointerover"), i && this.dispatchEvent(l, "mouseover"))
              let c = s?.parent
              for (; c && c !== this.rootTarget.parent && c !== e.target; ) c = c.parent
              if (!c || c === this.rootTarget.parent) {
                let f = this.clonePointerEvent(e, "pointerenter")
                for (
                  f.eventPhase = f.AT_TARGET;
                  f.target && f.target !== s && f.target !== this.rootTarget.parent;

                )
                  ((f.currentTarget = f.target),
                    this.notifyTarget(f),
                    i && this.notifyTarget(f, "mouseenter"),
                    (f.target = f.target.parent))
                this.freeEvent(f)
              }
              this.freeEvent(l)
            }
            let o = [],
              a = this.enableGlobalMoveEvents ?? !0
            ;(this.moveOnAll ? o.push("pointermove") : this.dispatchEvent(e, "pointermove"),
              a && o.push("globalpointermove"),
              e.pointerType === "touch" &&
                (this.moveOnAll ? o.splice(1, 0, "touchmove") : this.dispatchEvent(e, "touchmove"),
                a && o.push("globaltouchmove")),
              i &&
                (this.moveOnAll ? o.splice(1, 0, "mousemove") : this.dispatchEvent(e, "mousemove"),
                a && o.push("globalmousemove"),
                (this.cursor = e.target?.cursor)),
              o.length > 0 && this.all(e, o),
              (this._allInteractiveElements.length = 0),
              (this._hitElements.length = 0),
              (n.overTargets = e.composedPath()),
              this.freeEvent(e))
          }
          mapPointerOver(t) {
            if (!(t instanceof ee)) {
              N("EventBoundary cannot map a non-pointer event as a pointer event")
              return
            }
            let e = this.trackingData(t.pointerId),
              i = this.createPointerEvent(t),
              n = i.pointerType === "mouse" || i.pointerType === "pen"
            ;(this.dispatchEvent(i, "pointerover"),
              n && this.dispatchEvent(i, "mouseover"),
              i.pointerType === "mouse" && (this.cursor = i.target?.cursor))
            let s = this.clonePointerEvent(i, "pointerenter")
            for (s.eventPhase = s.AT_TARGET; s.target && s.target !== this.rootTarget.parent; )
              ((s.currentTarget = s.target),
                this.notifyTarget(s),
                n && this.notifyTarget(s, "mouseenter"),
                (s.target = s.target.parent))
            ;((e.overTargets = i.composedPath()), this.freeEvent(i), this.freeEvent(s))
          }
          mapPointerOut(t) {
            if (!(t instanceof ee)) {
              N("EventBoundary cannot map a non-pointer event as a pointer event")
              return
            }
            let e = this.trackingData(t.pointerId)
            if (e.overTargets) {
              let i = t.pointerType === "mouse" || t.pointerType === "pen",
                n = this.findMountedTarget(e.overTargets),
                s = this.createPointerEvent(t, "pointerout", n)
              ;(this.dispatchEvent(s), i && this.dispatchEvent(s, "mouseout"))
              let o = this.createPointerEvent(t, "pointerleave", n)
              for (o.eventPhase = o.AT_TARGET; o.target && o.target !== this.rootTarget.parent; )
                ((o.currentTarget = o.target),
                  this.notifyTarget(o),
                  i && this.notifyTarget(o, "mouseleave"),
                  (o.target = o.target.parent))
              ;((e.overTargets = null), this.freeEvent(s), this.freeEvent(o))
            }
            this.cursor = null
          }
          mapPointerUp(t) {
            if (!(t instanceof ee)) {
              N("EventBoundary cannot map a non-pointer event as a pointer event")
              return
            }
            let e = performance.now(),
              i = this.createPointerEvent(t)
            if ((this.dispatchEvent(i, "pointerup"), i.pointerType === "touch"))
              this.dispatchEvent(i, "touchend")
            else if (i.pointerType === "mouse" || i.pointerType === "pen") {
              let a = i.button === 2
              this.dispatchEvent(i, a ? "rightup" : "mouseup")
            }
            let n = this.trackingData(t.pointerId),
              s = this.findMountedTarget(n.pressTargetsByButton[t.button]),
              o = s
            if (s && !i.composedPath().includes(s)) {
              let a = s
              for (; a && !i.composedPath().includes(a); ) {
                if (
                  ((i.currentTarget = a),
                  this.notifyTarget(i, "pointerupoutside"),
                  i.pointerType === "touch")
                )
                  this.notifyTarget(i, "touchendoutside")
                else if (i.pointerType === "mouse" || i.pointerType === "pen") {
                  let u = i.button === 2
                  this.notifyTarget(i, u ? "rightupoutside" : "mouseupoutside")
                }
                a = a.parent
              }
              ;(delete n.pressTargetsByButton[t.button], (o = a))
            }
            if (o) {
              let a = this.clonePointerEvent(i, "click")
              ;((a.target = o),
                (a.path = null),
                n.clicksByButton[t.button] ||
                  (n.clicksByButton[t.button] = { clickCount: 0, target: a.target, timeStamp: e }))
              let u = n.clicksByButton[t.button]
              if (
                (u.target === a.target && e - u.timeStamp < 200
                  ? ++u.clickCount
                  : (u.clickCount = 1),
                (u.target = a.target),
                (u.timeStamp = e),
                (a.detail = u.clickCount),
                a.pointerType === "mouse")
              ) {
                let l = a.button === 2
                this.dispatchEvent(a, l ? "rightclick" : "click")
              } else a.pointerType === "touch" && this.dispatchEvent(a, "tap")
              ;(this.dispatchEvent(a, "pointertap"), this.freeEvent(a))
            }
            this.freeEvent(i)
          }
          mapPointerUpOutside(t) {
            if (!(t instanceof ee)) {
              N("EventBoundary cannot map a non-pointer event as a pointer event")
              return
            }
            let e = this.trackingData(t.pointerId),
              i = this.findMountedTarget(e.pressTargetsByButton[t.button]),
              n = this.createPointerEvent(t)
            if (i) {
              let s = i
              for (; s; )
                ((n.currentTarget = s),
                  this.notifyTarget(n, "pointerupoutside"),
                  n.pointerType === "touch"
                    ? this.notifyTarget(n, "touchendoutside")
                    : (n.pointerType === "mouse" || n.pointerType === "pen") &&
                      this.notifyTarget(n, n.button === 2 ? "rightupoutside" : "mouseupoutside"),
                  (s = s.parent))
              delete e.pressTargetsByButton[t.button]
            }
            this.freeEvent(n)
          }
          mapWheel(t) {
            if (!(t instanceof Re)) {
              N("EventBoundary cannot map a non-wheel event as a wheel event")
              return
            }
            let e = this.createWheelEvent(t)
            ;(this.dispatchEvent(e), this.freeEvent(e))
          }
          findMountedTarget(t) {
            if (!t) return null
            let e = t[0]
            for (let i = 1; i < t.length && t[i].parent === e; i++) e = t[i]
            return e
          }
          createPointerEvent(t, e, i) {
            let n = this.allocateEvent(ee)
            return (
              this.copyPointerData(t, n),
              this.copyMouseData(t, n),
              this.copyData(t, n),
              (n.nativeEvent = t.nativeEvent),
              (n.originalEvent = t),
              (n.target = i ?? this.hitTest(n.global.x, n.global.y) ?? this._hitElements[0]),
              typeof e == "string" && (n.type = e),
              n
            )
          }
          createWheelEvent(t) {
            let e = this.allocateEvent(Re)
            return (
              this.copyWheelData(t, e),
              this.copyMouseData(t, e),
              this.copyData(t, e),
              (e.nativeEvent = t.nativeEvent),
              (e.originalEvent = t),
              (e.target = this.hitTest(e.global.x, e.global.y)),
              e
            )
          }
          clonePointerEvent(t, e) {
            let i = this.allocateEvent(ee)
            return (
              (i.nativeEvent = t.nativeEvent),
              (i.originalEvent = t.originalEvent),
              this.copyPointerData(t, i),
              this.copyMouseData(t, i),
              this.copyData(t, i),
              (i.target = t.target),
              (i.path = t.composedPath().slice()),
              (i.type = e ?? i.type),
              i
            )
          }
          copyWheelData(t, e) {
            ;((e.deltaMode = t.deltaMode),
              (e.deltaX = t.deltaX),
              (e.deltaY = t.deltaY),
              (e.deltaZ = t.deltaZ))
          }
          copyPointerData(t, e) {
            t instanceof ee &&
              e instanceof ee &&
              ((e.pointerId = t.pointerId),
              (e.width = t.width),
              (e.height = t.height),
              (e.isPrimary = t.isPrimary),
              (e.pointerType = t.pointerType),
              (e.pressure = t.pressure),
              (e.tangentialPressure = t.tangentialPressure),
              (e.tiltX = t.tiltX),
              (e.tiltY = t.tiltY),
              (e.twist = t.twist))
          }
          copyMouseData(t, e) {
            t instanceof ir &&
              e instanceof ir &&
              ((e.altKey = t.altKey),
              (e.button = t.button),
              (e.buttons = t.buttons),
              e.client.copyFrom(t.client),
              (e.ctrlKey = t.ctrlKey),
              (e.metaKey = t.metaKey),
              e.movement.copyFrom(t.movement),
              e.screen.copyFrom(t.screen),
              (e.shiftKey = t.shiftKey),
              e.global.copyFrom(t.global))
          }
          copyData(t, e) {
            ;((e.isTrusted = t.isTrusted),
              (e.srcElement = t.srcElement),
              (e.timeStamp = performance.now()),
              (e.type = t.type),
              (e.detail = t.detail),
              (e.view = t.view),
              (e.which = t.which),
              e.layer.copyFrom(t.layer),
              e.page.copyFrom(t.page))
          }
          trackingData(t) {
            return (
              this.mappingState.trackingData[t] ||
                (this.mappingState.trackingData[t] = {
                  pressTargetsByButton: {},
                  clicksByButton: {},
                  overTarget: null,
                }),
              this.mappingState.trackingData[t]
            )
          }
          allocateEvent(t) {
            this.eventPool.has(t) || this.eventPool.set(t, [])
            let e = this.eventPool.get(t).pop() || new t(this)
            return (
              (e.eventPhase = e.NONE),
              (e.currentTarget = null),
              (e.defaultPrevented = !1),
              (e.path = null),
              (e.target = null),
              e
            )
          }
          freeEvent(t) {
            if (t.manager !== this)
              throw new Error("It is illegal to free an event not managed by this EventBoundary!")
            let e = t.constructor
            ;(this.eventPool.has(e) || this.eventPool.set(e, []), this.eventPool.get(e).push(t))
          }
          _notifyListeners(t, e) {
            let i = t.currentTarget._events[e]
            if (i)
              if ("fn" in i)
                (i.once && t.currentTarget.removeListener(e, i.fn, void 0, !0),
                  i.fn.call(i.context, t))
              else
                for (let n = 0, s = i.length; n < s && !t.propagationImmediatelyStopped; n++)
                  (i[n].once && t.currentTarget.removeListener(e, i[n].fn, void 0, !0),
                    i[n].fn.call(i[n].context, t))
          }
        }))
    })
  var cA,
    hA,
    $c,
    ja,
    Xc = p(() => {
      A()
      Zx()
      Hc()
      zc()
      Wc()
      ;((cA = 1),
        (hA = {
          touchstart: "pointerdown",
          touchend: "pointerup",
          touchendoutside: "pointerupoutside",
          touchmove: "pointermove",
          touchcancel: "pointercancel",
        }),
        ($c = class Vc {
          constructor(t) {
            ;((this.supportsTouchEvents = "ontouchstart" in globalThis),
              (this.supportsPointerEvents = !!globalThis.PointerEvent),
              (this.domElement = null),
              (this.resolution = 1),
              (this.renderer = t),
              (this.rootBoundary = new Ya(null)),
              Fe.init(this),
              (this.autoPreventDefault = !0),
              (this._eventsAdded = !1),
              (this._rootPointerEvent = new ee(null)),
              (this._rootWheelEvent = new Re(null)),
              (this.cursorStyles = { default: "inherit", pointer: "pointer" }),
              (this.features = new Proxy(
                { ...Vc.defaultEventFeatures },
                {
                  set: (e, i, n) => (
                    i === "globalMove" && (this.rootBoundary.enableGlobalMoveEvents = n),
                    (e[i] = n),
                    !0
                  ),
                },
              )),
              (this._onPointerDown = this._onPointerDown.bind(this)),
              (this._onPointerMove = this._onPointerMove.bind(this)),
              (this._onPointerUp = this._onPointerUp.bind(this)),
              (this._onPointerOverOut = this._onPointerOverOut.bind(this)),
              (this.onWheel = this.onWheel.bind(this)))
          }
          static get defaultEventMode() {
            return this._defaultEventMode
          }
          init(t) {
            let { canvas: e, resolution: i } = this.renderer
            ;(this.setTargetElement(e),
              (this.resolution = i),
              (Vc._defaultEventMode = t.eventMode ?? "passive"),
              Object.assign(this.features, t.eventFeatures ?? {}),
              (this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove))
          }
          resolutionChange(t) {
            this.resolution = t
          }
          destroy() {
            ;(this.setTargetElement(null), (this.renderer = null), (this._currentCursor = null))
          }
          setCursor(t) {
            t || (t = "default")
            let e = !0
            if (
              (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (e = !1),
              this._currentCursor === t)
            )
              return
            this._currentCursor = t
            let i = this.cursorStyles[t]
            if (i)
              switch (typeof i) {
                case "string":
                  e && (this.domElement.style.cursor = i)
                  break
                case "function":
                  i(t)
                  break
                case "object":
                  e && Object.assign(this.domElement.style, i)
                  break
              }
            else
              e &&
                typeof t == "string" &&
                !Object.prototype.hasOwnProperty.call(this.cursorStyles, t) &&
                (this.domElement.style.cursor = t)
          }
          get pointer() {
            return this._rootPointerEvent
          }
          _onPointerDown(t) {
            if (!this.features.click) return
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered
            let e = this._normalizeToPointerData(t)
            this.autoPreventDefault &&
              e[0].isNormalized &&
              (t.cancelable || !("cancelable" in t)) &&
              t.preventDefault()
            for (let i = 0, n = e.length; i < n; i++) {
              let s = e[i],
                o = this._bootstrapEvent(this._rootPointerEvent, s)
              this.rootBoundary.mapEvent(o)
            }
            this.setCursor(this.rootBoundary.cursor)
          }
          _onPointerMove(t) {
            if (!this.features.move) return
            ;((this.rootBoundary.rootTarget = this.renderer.lastObjectRendered), Fe.pointerMoved())
            let e = this._normalizeToPointerData(t)
            for (let i = 0, n = e.length; i < n; i++) {
              let s = this._bootstrapEvent(this._rootPointerEvent, e[i])
              this.rootBoundary.mapEvent(s)
            }
            this.setCursor(this.rootBoundary.cursor)
          }
          _onPointerUp(t) {
            if (!this.features.click) return
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered
            let e = t.target
            t.composedPath && t.composedPath().length > 0 && (e = t.composedPath()[0])
            let i = e !== this.domElement ? "outside" : "",
              n = this._normalizeToPointerData(t)
            for (let s = 0, o = n.length; s < o; s++) {
              let a = this._bootstrapEvent(this._rootPointerEvent, n[s])
              ;((a.type += i), this.rootBoundary.mapEvent(a))
            }
            this.setCursor(this.rootBoundary.cursor)
          }
          _onPointerOverOut(t) {
            if (!this.features.click) return
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered
            let e = this._normalizeToPointerData(t)
            for (let i = 0, n = e.length; i < n; i++) {
              let s = this._bootstrapEvent(this._rootPointerEvent, e[i])
              this.rootBoundary.mapEvent(s)
            }
            this.setCursor(this.rootBoundary.cursor)
          }
          onWheel(t) {
            if (!this.features.wheel) return
            let e = this.normalizeWheelEvent(t)
            ;((this.rootBoundary.rootTarget = this.renderer.lastObjectRendered),
              this.rootBoundary.mapEvent(e))
          }
          setTargetElement(t) {
            ;(this._removeEvents(), (this.domElement = t), (Fe.domElement = t), this._addEvents())
          }
          _addEvents() {
            if (this._eventsAdded || !this.domElement) return
            Fe.addTickerListener()
            let t = this.domElement.style
            ;(t &&
              (globalThis.navigator.msPointerEnabled
                ? ((t.msContentZooming = "none"), (t.msTouchAction = "none"))
                : this.supportsPointerEvents && (t.touchAction = "none")),
              this.supportsPointerEvents
                ? (globalThis.document.addEventListener("pointermove", this._onPointerMove, !0),
                  this.domElement.addEventListener("pointerdown", this._onPointerDown, !0),
                  this.domElement.addEventListener("pointerleave", this._onPointerOverOut, !0),
                  this.domElement.addEventListener("pointerover", this._onPointerOverOut, !0),
                  globalThis.addEventListener("pointerup", this._onPointerUp, !0))
                : (globalThis.document.addEventListener("mousemove", this._onPointerMove, !0),
                  this.domElement.addEventListener("mousedown", this._onPointerDown, !0),
                  this.domElement.addEventListener("mouseout", this._onPointerOverOut, !0),
                  this.domElement.addEventListener("mouseover", this._onPointerOverOut, !0),
                  globalThis.addEventListener("mouseup", this._onPointerUp, !0),
                  this.supportsTouchEvents &&
                    (this.domElement.addEventListener("touchstart", this._onPointerDown, !0),
                    this.domElement.addEventListener("touchend", this._onPointerUp, !0),
                    this.domElement.addEventListener("touchmove", this._onPointerMove, !0))),
              this.domElement.addEventListener("wheel", this.onWheel, { passive: !0, capture: !0 }),
              (this._eventsAdded = !0))
          }
          _removeEvents() {
            if (!this._eventsAdded || !this.domElement) return
            Fe.removeTickerListener()
            let t = this.domElement.style
            ;(t &&
              (globalThis.navigator.msPointerEnabled
                ? ((t.msContentZooming = ""), (t.msTouchAction = ""))
                : this.supportsPointerEvents && (t.touchAction = "")),
              this.supportsPointerEvents
                ? (globalThis.document.removeEventListener("pointermove", this._onPointerMove, !0),
                  this.domElement.removeEventListener("pointerdown", this._onPointerDown, !0),
                  this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, !0),
                  this.domElement.removeEventListener("pointerover", this._onPointerOverOut, !0),
                  globalThis.removeEventListener("pointerup", this._onPointerUp, !0))
                : (globalThis.document.removeEventListener("mousemove", this._onPointerMove, !0),
                  this.domElement.removeEventListener("mousedown", this._onPointerDown, !0),
                  this.domElement.removeEventListener("mouseout", this._onPointerOverOut, !0),
                  this.domElement.removeEventListener("mouseover", this._onPointerOverOut, !0),
                  globalThis.removeEventListener("mouseup", this._onPointerUp, !0),
                  this.supportsTouchEvents &&
                    (this.domElement.removeEventListener("touchstart", this._onPointerDown, !0),
                    this.domElement.removeEventListener("touchend", this._onPointerUp, !0),
                    this.domElement.removeEventListener("touchmove", this._onPointerMove, !0))),
              this.domElement.removeEventListener("wheel", this.onWheel, !0),
              (this.domElement = null),
              (this._eventsAdded = !1))
          }
          mapPositionToPoint(t, e, i) {
            let n = this.domElement.isConnected
                ? this.domElement.getBoundingClientRect()
                : {
                    x: 0,
                    y: 0,
                    width: this.domElement.width,
                    height: this.domElement.height,
                    left: 0,
                    top: 0,
                  },
              s = 1 / this.resolution
            ;((t.x = (e - n.left) * (this.domElement.width / n.width) * s),
              (t.y = (i - n.top) * (this.domElement.height / n.height) * s))
          }
          _normalizeToPointerData(t) {
            let e = []
            if (this.supportsTouchEvents && t instanceof TouchEvent)
              for (let i = 0, n = t.changedTouches.length; i < n; i++) {
                let s = t.changedTouches[i]
                ;(typeof s.button > "u" && (s.button = 0),
                  typeof s.buttons > "u" && (s.buttons = 1),
                  typeof s.isPrimary > "u" &&
                    (s.isPrimary = t.touches.length === 1 && t.type === "touchstart"),
                  typeof s.width > "u" && (s.width = s.radiusX || 1),
                  typeof s.height > "u" && (s.height = s.radiusY || 1),
                  typeof s.tiltX > "u" && (s.tiltX = 0),
                  typeof s.tiltY > "u" && (s.tiltY = 0),
                  typeof s.pointerType > "u" && (s.pointerType = "touch"),
                  typeof s.pointerId > "u" && (s.pointerId = s.identifier || 0),
                  typeof s.pressure > "u" && (s.pressure = s.force || 0.5),
                  typeof s.twist > "u" && (s.twist = 0),
                  typeof s.tangentialPressure > "u" && (s.tangentialPressure = 0),
                  typeof s.layerX > "u" && (s.layerX = s.offsetX = s.clientX),
                  typeof s.layerY > "u" && (s.layerY = s.offsetY = s.clientY),
                  (s.isNormalized = !0),
                  (s.type = t.type),
                  e.push(s))
              }
            else if (
              !globalThis.MouseEvent ||
              (t instanceof MouseEvent &&
                (!this.supportsPointerEvents || !(t instanceof globalThis.PointerEvent)))
            ) {
              let i = t
              ;(typeof i.isPrimary > "u" && (i.isPrimary = !0),
                typeof i.width > "u" && (i.width = 1),
                typeof i.height > "u" && (i.height = 1),
                typeof i.tiltX > "u" && (i.tiltX = 0),
                typeof i.tiltY > "u" && (i.tiltY = 0),
                typeof i.pointerType > "u" && (i.pointerType = "mouse"),
                typeof i.pointerId > "u" && (i.pointerId = cA),
                typeof i.pressure > "u" && (i.pressure = 0.5),
                typeof i.twist > "u" && (i.twist = 0),
                typeof i.tangentialPressure > "u" && (i.tangentialPressure = 0),
                (i.isNormalized = !0),
                e.push(i))
            } else e.push(t)
            return e
          }
          normalizeWheelEvent(t) {
            let e = this._rootWheelEvent
            return (
              this._transferMouseData(e, t),
              (e.deltaX = t.deltaX),
              (e.deltaY = t.deltaY),
              (e.deltaZ = t.deltaZ),
              (e.deltaMode = t.deltaMode),
              this.mapPositionToPoint(e.screen, t.clientX, t.clientY),
              e.global.copyFrom(e.screen),
              e.offset.copyFrom(e.screen),
              (e.nativeEvent = t),
              (e.type = t.type),
              e
            )
          }
          _bootstrapEvent(t, e) {
            return (
              (t.originalEvent = null),
              (t.nativeEvent = e),
              (t.pointerId = e.pointerId),
              (t.width = e.width),
              (t.height = e.height),
              (t.isPrimary = e.isPrimary),
              (t.pointerType = e.pointerType),
              (t.pressure = e.pressure),
              (t.tangentialPressure = e.tangentialPressure),
              (t.tiltX = e.tiltX),
              (t.tiltY = e.tiltY),
              (t.twist = e.twist),
              this._transferMouseData(t, e),
              this.mapPositionToPoint(t.screen, e.clientX, e.clientY),
              t.global.copyFrom(t.screen),
              t.offset.copyFrom(t.screen),
              (t.isTrusted = e.isTrusted),
              t.type === "pointerleave" && (t.type = "pointerout"),
              t.type.startsWith("mouse") && (t.type = t.type.replace("mouse", "pointer")),
              t.type.startsWith("touch") && (t.type = hA[t.type] || t.type),
              t
            )
          }
          _transferMouseData(t, e) {
            ;((t.isTrusted = e.isTrusted),
              (t.srcElement = e.srcElement),
              (t.timeStamp = performance.now()),
              (t.type = e.type),
              (t.altKey = e.altKey),
              (t.button = e.button),
              (t.buttons = e.buttons),
              (t.client.x = e.clientX),
              (t.client.y = e.clientY),
              (t.ctrlKey = e.ctrlKey),
              (t.metaKey = e.metaKey),
              (t.movement.x = e.movementX),
              (t.movement.y = e.movementY),
              (t.page.x = e.pageX),
              (t.page.y = e.pageY),
              (t.relatedTarget = null),
              (t.shiftKey = e.shiftKey))
          }
        }))
      $c.extension = {
        name: "events",
        type: [b.WebGLSystem, b.CanvasSystem, b.WebGPUSystem],
        priority: -1,
      }
      $c.defaultEventFeatures = { move: !0, globalMove: !0, click: !0, wheel: !0 }
      ja = $c
    })
  var Qx,
    Jx = p(() => {
      Xc()
      za()
      Qx = {
        onclick: null,
        onmousedown: null,
        onmouseenter: null,
        onmouseleave: null,
        onmousemove: null,
        onglobalmousemove: null,
        onmouseout: null,
        onmouseover: null,
        onmouseup: null,
        onmouseupoutside: null,
        onpointercancel: null,
        onpointerdown: null,
        onpointerenter: null,
        onpointerleave: null,
        onpointermove: null,
        onglobalpointermove: null,
        onpointerout: null,
        onpointerover: null,
        onpointertap: null,
        onpointerup: null,
        onpointerupoutside: null,
        onrightclick: null,
        onrightdown: null,
        onrightup: null,
        onrightupoutside: null,
        ontap: null,
        ontouchcancel: null,
        ontouchend: null,
        ontouchendoutside: null,
        ontouchmove: null,
        onglobaltouchmove: null,
        ontouchstart: null,
        onwheel: null,
        get interactive() {
          return this.eventMode === "dynamic" || this.eventMode === "static"
        },
        set interactive(r) {
          this.eventMode = r ? "static" : "passive"
        },
        _internalEventMode: void 0,
        get eventMode() {
          return this._internalEventMode ?? ja.defaultEventMode
        },
        set eventMode(r) {
          this._internalEventMode = r
        },
        isInteractive() {
          return this.eventMode === "static" || this.eventMode === "dynamic"
        },
        interactiveChildren: !0,
        hitArea: null,
        addEventListener(r, t, e) {
          let i = (typeof e == "boolean" && e) || (typeof e == "object" && e.capture),
            n = typeof e == "object" ? e.signal : void 0,
            s = typeof e == "object" ? e.once === !0 : !1,
            o = typeof t == "function" ? void 0 : t
          r = i ? `${r}capture` : r
          let a = typeof t == "function" ? t : t.handleEvent,
            u = this
          ;(n &&
            n.addEventListener("abort", () => {
              u.off(r, a, o)
            }),
            s ? u.once(r, a, o) : u.on(r, a, o))
        },
        removeEventListener(r, t, e) {
          let i = (typeof e == "boolean" && e) || (typeof e == "object" && e.capture),
            n = typeof t == "function" ? void 0 : t
          ;((r = i ? `${r}capture` : r),
            (t = typeof t == "function" ? t : t.handleEvent),
            this.off(r, t, n))
        },
        dispatchEvent(r) {
          if (!(r instanceof yr))
            throw new Error("Container cannot propagate events outside of the Federated Events API")
          return (
            (r.defaultPrevented = !1),
            (r.path = null),
            (r.target = this),
            r.manager.dispatchEvent(r),
            !r.defaultPrevented
          )
        },
      }
    })
  var t_ = p(() => {
    A()
    we()
    Xc()
    Jx()
    L.add(ja)
    L.mixin(pt, Qx)
  })
  var us,
    e_ = p(() => {
      A()
      us = class {
        constructor(t) {
          ;((this._attachedDomElements = []),
            (this._renderer = t),
            this._renderer.runners.postrender.add(this),
            (this._domElement = document.createElement("div")),
            (this._domElement.style.position = "absolute"),
            (this._domElement.style.top = "0"),
            (this._domElement.style.left = "0"),
            (this._domElement.style.pointerEvents = "none"),
            (this._domElement.style.zIndex = "1000"))
        }
        addRenderable(t, e) {
          this._attachedDomElements.includes(t) || this._attachedDomElements.push(t)
        }
        updateRenderable(t) {}
        validateRenderable(t) {
          return !0
        }
        postrender() {
          let t = this._attachedDomElements
          if (t.length === 0) {
            this._domElement.remove()
            return
          }
          let e = this._renderer.view.canvas
          this._domElement.parentNode !== e.parentNode &&
            e.parentNode?.appendChild(this._domElement)
          let i = (parseFloat(e.style.width) / e.width) * this._renderer.resolution,
            n = (parseFloat(e.style.height) / e.height) * this._renderer.resolution
          this._domElement.style.transform = `translate(${e.offsetLeft}px, ${e.offsetTop}px) scale(${i}, ${n})`
          for (let s = 0; s < t.length; s++) {
            let o = t[s],
              a = o.element
            if (!o.parent || o.globalDisplayStatus < 7) (a?.remove(), t.splice(s, 1), s--)
            else {
              this._domElement.contains(a) ||
                ((a.style.position = "absolute"),
                (a.style.pointerEvents = "auto"),
                this._domElement.appendChild(a))
              let u = o.worldTransform,
                l = o._anchor,
                c = o.width * l.x,
                h = o.height * l.y
              ;((a.style.transformOrigin = `${c}px ${h}px`),
                (a.style.transform = `matrix(${u.a}, ${u.b}, ${u.c}, ${u.d}, ${u.tx - c}, ${u.ty - h})`),
                (a.style.opacity = o.groupAlpha.toString()))
            }
          }
        }
        destroy() {
          this._renderer.runners.postrender.remove(this)
          for (let t = 0; t < this._attachedDomElements.length; t++)
            this._attachedDomElements[t].element?.remove()
          ;((this._attachedDomElements.length = 0),
            this._domElement.remove(),
            (this._renderer = null))
        }
      }
      us.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "dom" }
    })
  var vr,
    Ka = p(() => {
      se()
      we()
      vr = class extends pt {
        constructor(t) {
          ;(super(t),
            (this.canBundle = !0),
            (this.allowChildren = !1),
            (this._roundPixels = 0),
            (this._lastUsed = -1),
            (this._gpuData = Object.create(null)),
            (this._bounds = new ct(0, 1, 0, 0)),
            (this._boundsDirty = !0))
        }
        get bounds() {
          return this._boundsDirty
            ? (this.updateBounds(), (this._boundsDirty = !1), this._bounds)
            : this._bounds
        }
        get roundPixels() {
          return !!this._roundPixels
        }
        set roundPixels(t) {
          this._roundPixels = t ? 1 : 0
        }
        containsPoint(t) {
          let e = this.bounds,
            { x: i, y: n } = t
          return i >= e.minX && i <= e.maxX && n >= e.minY && n <= e.maxY
        }
        onViewUpdate() {
          if ((this._didViewChangeTick++, (this._boundsDirty = !0), this.didViewUpdate)) return
          this.didViewUpdate = !0
          let t = this.renderGroup || this.parentRenderGroup
          t && t.onChildViewUpdate(this)
        }
        destroy(t) {
          ;(super.destroy(t), (this._bounds = null))
          for (let e in this._gpuData) this._gpuData[e].destroy?.()
          this._gpuData = null
        }
        collectRenderablesSimple(t, e, i) {
          let { renderPipes: n } = e
          ;(n.blendMode.setBlendMode(this, this.groupBlendMode, t),
            n[this.renderPipeId].addRenderable(this, t),
            (this.didViewUpdate = !1))
          let o = this.children,
            a = o.length
          for (let u = 0; u < a; u++) o[u].collectRenderables(t, e, i)
        }
      }
    })
  var r_ = p(() => {
    A()
    e_()
    L.add(us)
  })
  var Yc,
    i_ = p(() => {
      "use strict"
      Yc = ((r) => (
        (r[(r.Low = 0)] = "Low"),
        (r[(r.Normal = 1)] = "Normal"),
        (r[(r.High = 2)] = "High"),
        r
      ))(Yc || {})
    })
  var n_,
    s_ = p(() => {
      "use strict"
      n_ = {
        createCanvas: (r, t) => {
          let e = document.createElement("canvas")
          return ((e.width = r), (e.height = t), e)
        },
        getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
        getWebGLRenderingContext: () => WebGLRenderingContext,
        getNavigator: () => navigator,
        getBaseUrl: () => document.baseURI ?? window.location.href,
        getFontFaceSet: () => document.fonts,
        fetch: (r, t) => fetch(r, t),
        parseXML: (r) => new DOMParser().parseFromString(r, "text/xml"),
      }
    })
  var o_,
    Z,
    At = p(() => {
      s_()
      ;((o_ = n_),
        (Z = {
          get() {
            return o_
          },
          set(r) {
            o_ = r
          },
        }))
    })
  function Me(r) {
    if (typeof r != "string")
      throw new TypeError(`Path must be a string. Received ${JSON.stringify(r)}`)
  }
  function ls(r) {
    return r.split("?")[0].split("#")[0]
  }
  function fA(r) {
    return r.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
  }
  function dA(r, t, e) {
    return r.replace(new RegExp(fA(t), "g"), e)
  }
  function pA(r, t) {
    let e = "",
      i = 0,
      n = -1,
      s = 0,
      o = -1
    for (let a = 0; a <= r.length; ++a) {
      if (a < r.length) o = r.charCodeAt(a)
      else {
        if (o === 47) break
        o = 47
      }
      if (o === 47) {
        if (!(n === a - 1 || s === 1))
          if (n !== a - 1 && s === 2) {
            if (
              e.length < 2 ||
              i !== 2 ||
              e.charCodeAt(e.length - 1) !== 46 ||
              e.charCodeAt(e.length - 2) !== 46
            ) {
              if (e.length > 2) {
                let u = e.lastIndexOf("/")
                if (u !== e.length - 1) {
                  ;(u === -1
                    ? ((e = ""), (i = 0))
                    : ((e = e.slice(0, u)), (i = e.length - 1 - e.lastIndexOf("/"))),
                    (n = a),
                    (s = 0))
                  continue
                }
              } else if (e.length === 2 || e.length === 1) {
                ;((e = ""), (i = 0), (n = a), (s = 0))
                continue
              }
            }
            t && (e.length > 0 ? (e += "/..") : (e = ".."), (i = 2))
          } else
            (e.length > 0 ? (e += `/${r.slice(n + 1, a)}`) : (e = r.slice(n + 1, a)),
              (i = a - n - 1))
        ;((n = a), (s = 0))
      } else o === 46 && s !== -1 ? ++s : (s = -1)
    }
    return e
  }
  var ii,
    jc = p(() => {
      At()
      ii = {
        toPosix(r) {
          return dA(r, "\\", "/")
        },
        isUrl(r) {
          return /^https?:/.test(this.toPosix(r))
        },
        isDataUrl(r) {
          return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(
            r,
          )
        },
        isBlobUrl(r) {
          return r.startsWith("blob:")
        },
        hasProtocol(r) {
          return /^[^/:]+:/.test(this.toPosix(r))
        },
        getProtocol(r) {
          ;(Me(r), (r = this.toPosix(r)))
          let t = /^file:\/\/\//.exec(r)
          if (t) return t[0]
          let e = /^[^/:]+:\/{0,2}/.exec(r)
          return e ? e[0] : ""
        },
        toAbsolute(r, t, e) {
          if ((Me(r), this.isDataUrl(r) || this.isBlobUrl(r))) return r
          let i = ls(this.toPosix(t ?? Z.get().getBaseUrl())),
            n = ls(this.toPosix(e ?? this.rootname(i)))
          return (
            (r = this.toPosix(r)),
            r.startsWith("/") ? ii.join(n, r.slice(1)) : this.isAbsolute(r) ? r : this.join(i, r)
          )
        },
        normalize(r) {
          if ((Me(r), r.length === 0)) return "."
          if (this.isDataUrl(r) || this.isBlobUrl(r)) return r
          r = this.toPosix(r)
          let t = "",
            e = r.startsWith("/")
          this.hasProtocol(r) && ((t = this.rootname(r)), (r = r.slice(t.length)))
          let i = r.endsWith("/")
          return ((r = pA(r, !1)), r.length > 0 && i && (r += "/"), e ? `/${r}` : t + r)
        },
        isAbsolute(r) {
          return (Me(r), (r = this.toPosix(r)), this.hasProtocol(r) ? !0 : r.startsWith("/"))
        },
        join(...r) {
          if (r.length === 0) return "."
          let t
          for (let e = 0; e < r.length; ++e) {
            let i = r[e]
            if ((Me(i), i.length > 0))
              if (t === void 0) t = i
              else {
                let n = r[e - 1] ?? ""
                this.joinExtensions.includes(this.extname(n).toLowerCase())
                  ? (t += `/../${i}`)
                  : (t += `/${i}`)
              }
          }
          return t === void 0 ? "." : this.normalize(t)
        },
        dirname(r) {
          if ((Me(r), r.length === 0)) return "."
          r = this.toPosix(r)
          let t = r.charCodeAt(0),
            e = t === 47,
            i = -1,
            n = !0,
            s = this.getProtocol(r),
            o = r
          r = r.slice(s.length)
          for (let a = r.length - 1; a >= 1; --a)
            if (((t = r.charCodeAt(a)), t === 47)) {
              if (!n) {
                i = a
                break
              }
            } else n = !1
          return i === -1
            ? e
              ? "/"
              : this.isUrl(o)
                ? s + r
                : s
            : e && i === 1
              ? "//"
              : s + r.slice(0, i)
        },
        rootname(r) {
          ;(Me(r), (r = this.toPosix(r)))
          let t = ""
          if ((r.startsWith("/") ? (t = "/") : (t = this.getProtocol(r)), this.isUrl(r))) {
            let e = r.indexOf("/", t.length)
            ;(e !== -1 ? (t = r.slice(0, e)) : (t = r), t.endsWith("/") || (t += "/"))
          }
          return t
        },
        basename(r, t) {
          ;(Me(r), t && Me(t), (r = ls(this.toPosix(r))))
          let e = 0,
            i = -1,
            n = !0,
            s
          if (t !== void 0 && t.length > 0 && t.length <= r.length) {
            if (t.length === r.length && t === r) return ""
            let o = t.length - 1,
              a = -1
            for (s = r.length - 1; s >= 0; --s) {
              let u = r.charCodeAt(s)
              if (u === 47) {
                if (!n) {
                  e = s + 1
                  break
                }
              } else
                (a === -1 && ((n = !1), (a = s + 1)),
                  o >= 0 && (u === t.charCodeAt(o) ? --o === -1 && (i = s) : ((o = -1), (i = a))))
            }
            return (e === i ? (i = a) : i === -1 && (i = r.length), r.slice(e, i))
          }
          for (s = r.length - 1; s >= 0; --s)
            if (r.charCodeAt(s) === 47) {
              if (!n) {
                e = s + 1
                break
              }
            } else i === -1 && ((n = !1), (i = s + 1))
          return i === -1 ? "" : r.slice(e, i)
        },
        extname(r) {
          ;(Me(r), (r = ls(this.toPosix(r))))
          let t = -1,
            e = 0,
            i = -1,
            n = !0,
            s = 0
          for (let o = r.length - 1; o >= 0; --o) {
            let a = r.charCodeAt(o)
            if (a === 47) {
              if (!n) {
                e = o + 1
                break
              }
              continue
            }
            ;(i === -1 && ((n = !1), (i = o + 1)),
              a === 46 ? (t === -1 ? (t = o) : s !== 1 && (s = 1)) : t !== -1 && (s = -1))
          }
          return t === -1 || i === -1 || s === 0 || (s === 1 && t === i - 1 && t === e + 1)
            ? ""
            : r.slice(t, i)
        },
        parse(r) {
          Me(r)
          let t = { root: "", dir: "", base: "", ext: "", name: "" }
          if (r.length === 0) return t
          r = ls(this.toPosix(r))
          let e = r.charCodeAt(0),
            i = this.isAbsolute(r),
            n,
            s = ""
          ;((t.root = this.rootname(r)), i || this.hasProtocol(r) ? (n = 1) : (n = 0))
          let o = -1,
            a = 0,
            u = -1,
            l = !0,
            c = r.length - 1,
            h = 0
          for (; c >= n; --c) {
            if (((e = r.charCodeAt(c)), e === 47)) {
              if (!l) {
                a = c + 1
                break
              }
              continue
            }
            ;(u === -1 && ((l = !1), (u = c + 1)),
              e === 46 ? (o === -1 ? (o = c) : h !== 1 && (h = 1)) : o !== -1 && (h = -1))
          }
          return (
            o === -1 || u === -1 || h === 0 || (h === 1 && o === u - 1 && o === a + 1)
              ? u !== -1 &&
                (a === 0 && i
                  ? (t.base = t.name = r.slice(1, u))
                  : (t.base = t.name = r.slice(a, u)))
              : (a === 0 && i
                  ? ((t.name = r.slice(1, o)), (t.base = r.slice(1, u)))
                  : ((t.name = r.slice(a, o)), (t.base = r.slice(a, u))),
                (t.ext = r.slice(o, u))),
            (t.dir = this.dirname(r)),
            s && (t.dir = s + t.dir),
            t
          )
        },
        sep: "/",
        delimiter: ":",
        joinExtensions: [".html"],
      }
    })
  var Sr,
    Kc = p(() => {
      "use strict"
      Sr = (r, t, e = !1) => (
        Array.isArray(r) || (r = [r]),
        t ? r.map((i) => (typeof i == "string" || e ? t(i) : i)) : r
      )
    })
  function a_(r, t, e, i, n) {
    let s = t[e]
    for (let o = 0; o < s.length; o++) {
      let a = s[o]
      e < t.length - 1 ? a_(r.replace(i[e], a), t, e + 1, i, n) : n.push(r.replace(i[e], a))
    }
  }
  function u_(r) {
    let t = /\{(.*?)\}/g,
      e = r.match(t),
      i = []
    if (e) {
      let n = []
      ;(e.forEach((s) => {
        let o = s.substring(1, s.length - 1).split(",")
        n.push(o)
      }),
        a_(r, n, 0, e, i))
    } else i.push(r)
    return i
  }
  var l_ = p(() => {
    "use strict"
  })
  var qc,
    c_ = p(() => {
      "use strict"
      qc = (r) => !Array.isArray(r)
    })
  function mA(r) {
    return r.split(".").pop().split("?").shift().split("#").shift()
  }
  var cs,
    h_ = p(() => {
      ft()
      jc()
      Kc()
      l_()
      c_()
      cs = class {
        constructor() {
          ;((this._defaultBundleIdentifierOptions = {
            connector: "-",
            createBundleAssetId: (t, e) => `${t}${this._bundleIdConnector}${e}`,
            extractAssetIdFromBundle: (t, e) => e.replace(`${t}${this._bundleIdConnector}`, ""),
          }),
            (this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector),
            (this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId),
            (this._extractAssetIdFromBundle =
              this._defaultBundleIdentifierOptions.extractAssetIdFromBundle),
            (this._assetMap = {}),
            (this._preferredOrder = []),
            (this._parsers = []),
            (this._resolverHash = {}),
            (this._bundles = {}))
        }
        setBundleIdentifier(t) {
          if (
            ((this._bundleIdConnector = t.connector ?? this._bundleIdConnector),
            (this._createBundleAssetId = t.createBundleAssetId ?? this._createBundleAssetId),
            (this._extractAssetIdFromBundle =
              t.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle),
            this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !==
              "bar")
          )
            throw new Error("[Resolver] GenerateBundleAssetId are not working correctly")
        }
        prefer(...t) {
          ;(t.forEach((e) => {
            ;(this._preferredOrder.push(e), e.priority || (e.priority = Object.keys(e.params)))
          }),
            (this._resolverHash = {}))
        }
        set basePath(t) {
          this._basePath = t
        }
        get basePath() {
          return this._basePath
        }
        set rootPath(t) {
          this._rootPath = t
        }
        get rootPath() {
          return this._rootPath
        }
        get parsers() {
          return this._parsers
        }
        reset() {
          ;(this.setBundleIdentifier(this._defaultBundleIdentifierOptions),
            (this._assetMap = {}),
            (this._preferredOrder = []),
            (this._resolverHash = {}),
            (this._rootPath = null),
            (this._basePath = null),
            (this._manifest = null),
            (this._bundles = {}),
            (this._defaultSearchParams = null))
        }
        setDefaultSearchParams(t) {
          if (typeof t == "string") this._defaultSearchParams = t
          else {
            let e = t
            this._defaultSearchParams = Object.keys(e)
              .map((i) => `${encodeURIComponent(i)}=${encodeURIComponent(e[i])}`)
              .join("&")
          }
        }
        getAlias(t) {
          let { alias: e, src: i } = t
          return Sr(
            e || i,
            (s) =>
              typeof s == "string"
                ? s
                : Array.isArray(s)
                  ? s.map((o) => o?.src ?? o)
                  : s?.src
                    ? s.src
                    : s,
            !0,
          )
        }
        addManifest(t) {
          ;(this._manifest && N("[Resolver] Manifest already exists, this will be overwritten"),
            (this._manifest = t),
            t.bundles.forEach((e) => {
              this.addBundle(e.name, e.assets)
            }))
        }
        addBundle(t, e) {
          let i = [],
            n = e
          ;(Array.isArray(e) ||
            (n = Object.entries(e).map(([s, o]) =>
              typeof o == "string" || Array.isArray(o) ? { alias: s, src: o } : { alias: s, ...o },
            )),
            n.forEach((s) => {
              let o = s.src,
                a = s.alias,
                u
              if (typeof a == "string") {
                let l = this._createBundleAssetId(t, a)
                ;(i.push(l), (u = [a, l]))
              } else {
                let l = a.map((c) => this._createBundleAssetId(t, c))
                ;(i.push(...l), (u = [...a, ...l]))
              }
              this.add({ ...s, alias: u, src: o })
            }),
            (this._bundles[t] = i))
        }
        add(t) {
          let e = []
          Array.isArray(t) ? e.push(...t) : e.push(t)
          let i
          ;((i = (s) => {
            this.hasKey(s) && N(`[Resolver] already has key: ${s} overwriting`)
          }),
            Sr(e).forEach((s) => {
              let { src: o } = s,
                { data: a, format: u, loadParser: l } = s,
                c = Sr(o).map((d) => (typeof d == "string" ? u_(d) : Array.isArray(d) ? d : [d])),
                h = this.getAlias(s)
              Array.isArray(h) ? h.forEach(i) : i(h)
              let f = []
              ;(c.forEach((d) => {
                d.forEach((g) => {
                  let x = {}
                  if (typeof g != "object") {
                    x.src = g
                    for (let m = 0; m < this._parsers.length; m++) {
                      let _ = this._parsers[m]
                      if (_.test(g)) {
                        x = _.parse(g)
                        break
                      }
                    }
                  } else
                    ((a = g.data ?? a),
                      (u = g.format ?? u),
                      (l = g.loadParser ?? l),
                      (x = { ...x, ...g }))
                  if (!h) throw new Error(`[Resolver] alias is undefined for this asset: ${x.src}`)
                  ;((x = this._buildResolvedAsset(x, {
                    aliases: h,
                    data: a,
                    format: u,
                    loadParser: l,
                  })),
                    f.push(x))
                })
              }),
                h.forEach((d) => {
                  this._assetMap[d] = f
                }))
            }))
        }
        resolveBundle(t) {
          let e = qc(t)
          t = Sr(t)
          let i = {}
          return (
            t.forEach((n) => {
              let s = this._bundles[n]
              if (s) {
                let o = this.resolve(s),
                  a = {}
                for (let u in o) {
                  let l = o[u]
                  a[this._extractAssetIdFromBundle(n, u)] = l
                }
                i[n] = a
              }
            }),
            e ? i[t[0]] : i
          )
        }
        resolveUrl(t) {
          let e = this.resolve(t)
          if (typeof t != "string") {
            let i = {}
            for (let n in e) i[n] = e[n].src
            return i
          }
          return e.src
        }
        resolve(t) {
          let e = qc(t)
          t = Sr(t)
          let i = {}
          return (
            t.forEach((n) => {
              if (!this._resolverHash[n])
                if (this._assetMap[n]) {
                  let s = this._assetMap[n],
                    o = this._getPreferredOrder(s)
                  ;(o?.priority.forEach((a) => {
                    o.params[a].forEach((u) => {
                      let l = s.filter((c) => (c[a] ? c[a] === u : !1))
                      l.length && (s = l)
                    })
                  }),
                    (this._resolverHash[n] = s[0]))
                } else this._resolverHash[n] = this._buildResolvedAsset({ alias: [n], src: n }, {})
              i[n] = this._resolverHash[n]
            }),
            e ? i[t[0]] : i
          )
        }
        hasKey(t) {
          return !!this._assetMap[t]
        }
        hasBundle(t) {
          return !!this._bundles[t]
        }
        _getPreferredOrder(t) {
          for (let e = 0; e < t.length; e++) {
            let i = t[e],
              n = this._preferredOrder.find((s) => s.params.format.includes(i.format))
            if (n) return n
          }
          return this._preferredOrder[0]
        }
        _appendDefaultSearchParams(t) {
          if (!this._defaultSearchParams) return t
          let e = /\?/.test(t) ? "&" : "?"
          return `${t}${e}${this._defaultSearchParams}`
        }
        _buildResolvedAsset(t, e) {
          let { aliases: i, data: n, loadParser: s, format: o } = e
          return (
            (this._basePath || this._rootPath) &&
              (t.src = ii.toAbsolute(t.src, this._basePath, this._rootPath)),
            (t.alias = i ?? t.alias ?? [t.src]),
            (t.src = this._appendDefaultSearchParams(t.src)),
            (t.data = { ...(n || {}), ...t.data }),
            (t.loadParser = s ?? t.loadParser),
            (t.format = o ?? t.format ?? mA(t.src)),
            t
          )
        }
      }
      cs.RETINA_PREFIX = /@([0-9\.]+)x/
    })
  var Zc,
    f_ = p(() => {
      "use strict"
      Zc = (r, t) => {
        let e = t.split("?")[1]
        return (e && (r += `?${e}`), r)
      }
    })
  var d_,
    Qc,
    p_ = p(() => {
      Lt()
      te()
      dt()
      d_ = class hs {
        constructor(t, e) {
          this.linkedSheets = []
          let i = t
          t?.source instanceof ot && (i = { texture: t, data: e })
          let { texture: n, data: s, cachePrefix: o = "" } = i
          ;((this.cachePrefix = o),
            (this._texture = n instanceof k ? n : null),
            (this.textureSource = n.source),
            (this.textures = {}),
            (this.animations = {}),
            (this.data = s))
          let a = parseFloat(s.meta.scale)
          ;(a
            ? ((this.resolution = a), (n.source.resolution = this.resolution))
            : (this.resolution = n.source._resolution),
            (this._frames = this.data.frames),
            (this._frameKeys = Object.keys(this._frames)),
            (this._batchIndex = 0),
            (this._callback = null))
        }
        parse() {
          return new Promise((t) => {
            ;((this._callback = t),
              (this._batchIndex = 0),
              this._frameKeys.length <= hs.BATCH_SIZE
                ? (this._processFrames(0), this._processAnimations(), this._parseComplete())
                : this._nextBatch())
          })
        }
        _processFrames(t) {
          let e = t,
            i = hs.BATCH_SIZE
          for (; e - t < i && e < this._frameKeys.length; ) {
            let n = this._frameKeys[e],
              s = this._frames[n],
              o = s.frame
            if (o) {
              let a = null,
                u = null,
                l = s.trimmed !== !1 && s.sourceSize ? s.sourceSize : s.frame,
                c = new Q(
                  0,
                  0,
                  Math.floor(l.w) / this.resolution,
                  Math.floor(l.h) / this.resolution,
                )
              ;(s.rotated
                ? (a = new Q(
                    Math.floor(o.x) / this.resolution,
                    Math.floor(o.y) / this.resolution,
                    Math.floor(o.h) / this.resolution,
                    Math.floor(o.w) / this.resolution,
                  ))
                : (a = new Q(
                    Math.floor(o.x) / this.resolution,
                    Math.floor(o.y) / this.resolution,
                    Math.floor(o.w) / this.resolution,
                    Math.floor(o.h) / this.resolution,
                  )),
                s.trimmed !== !1 &&
                  s.spriteSourceSize &&
                  (u = new Q(
                    Math.floor(s.spriteSourceSize.x) / this.resolution,
                    Math.floor(s.spriteSourceSize.y) / this.resolution,
                    Math.floor(o.w) / this.resolution,
                    Math.floor(o.h) / this.resolution,
                  )),
                (this.textures[n] = new k({
                  source: this.textureSource,
                  frame: a,
                  orig: c,
                  trim: u,
                  rotate: s.rotated ? 2 : 0,
                  defaultAnchor: s.anchor,
                  defaultBorders: s.borders,
                  label: n.toString(),
                })))
            }
            e++
          }
        }
        _processAnimations() {
          let t = this.data.animations || {}
          for (let e in t) {
            this.animations[e] = []
            for (let i = 0; i < t[e].length; i++) {
              let n = t[e][i]
              this.animations[e].push(this.textures[n])
            }
          }
        }
        _parseComplete() {
          let t = this._callback
          ;((this._callback = null), (this._batchIndex = 0), t.call(this, this.textures))
        }
        _nextBatch() {
          ;(this._processFrames(this._batchIndex * hs.BATCH_SIZE),
            this._batchIndex++,
            setTimeout(() => {
              this._batchIndex * hs.BATCH_SIZE < this._frameKeys.length
                ? this._nextBatch()
                : (this._processAnimations(), this._parseComplete())
            }, 0))
        }
        destroy(t = !1) {
          for (let e in this.textures) this.textures[e].destroy()
          ;((this._frames = null),
            (this._frameKeys = null),
            (this.data = null),
            (this.textures = null),
            t && (this._texture?.destroy(), this.textureSource.destroy()),
            (this._texture = null),
            (this.textureSource = null),
            (this.linkedSheets = []))
        }
      }
      d_.BATCH_SIZE = 1e3
      Qc = d_
    })
  function m_(r, t, e) {
    let i = {}
    if (
      (r.forEach((n) => {
        i[n] = t
      }),
      Object.keys(t.textures).forEach((n) => {
        i[`${t.cachePrefix}${n}`] = t.textures[n]
      }),
      !e)
    ) {
      let n = ii.dirname(r[0])
      t.linkedSheets.forEach((s, o) => {
        let a = m_([`${n}/${t.data.meta.related_multi_packs[o]}`], s, !0)
        Object.assign(i, a)
      })
    }
    return i
  }
  var gA,
    g_,
    x_ = p(() => {
      i_()
      h_()
      f_()
      A()
      dt()
      jc()
      p_()
      gA = [
        "jpg",
        "png",
        "jpeg",
        "avif",
        "webp",
        "basis",
        "etc2",
        "bc7",
        "bc6h",
        "bc5",
        "bc4",
        "bc3",
        "bc2",
        "bc1",
        "eac",
        "astc",
      ]
      g_ = {
        extension: b.Asset,
        cache: { test: (r) => r instanceof Qc, getCacheableAssets: (r, t) => m_(r, t, !1) },
        resolver: {
          extension: { type: b.ResolveParser, name: "resolveSpritesheet" },
          test: (r) => {
            let e = r.split("?")[0].split("."),
              i = e.pop(),
              n = e.pop()
            return i === "json" && gA.includes(n)
          },
          parse: (r) => {
            let t = r.split(".")
            return {
              resolution: parseFloat(cs.RETINA_PREFIX.exec(r)?.[1] ?? "1"),
              format: t[t.length - 2],
              src: r,
            }
          },
        },
        loader: {
          name: "spritesheetLoader",
          extension: { type: b.LoadParser, priority: Yc.Normal, name: "spritesheetLoader" },
          async testParse(r, t) {
            return ii.extname(t.src).toLowerCase() === ".json" && !!r.frames
          },
          async parse(r, t, e) {
            let { texture: i, imageFilename: n, textureOptions: s, cachePrefix: o } = t?.data ?? {},
              a = ii.dirname(t.src)
            a && a.lastIndexOf("/") !== a.length - 1 && (a += "/")
            let u
            if (i instanceof k) u = i
            else {
              let h = Zc(a + (n ?? r.meta.image), t.src)
              u = (await e.load([{ src: h, data: s }]))[h]
            }
            let l = new Qc({ texture: u.source, data: r, cachePrefix: o })
            await l.parse()
            let c = r?.meta?.related_multi_packs
            if (Array.isArray(c)) {
              let h = []
              for (let d of c) {
                if (typeof d != "string") continue
                let g = a + d
                t.data?.ignoreMultiPack ||
                  ((g = Zc(g, t.src)),
                  h.push(e.load({ src: g, data: { textureOptions: s, ignoreMultiPack: !0 } })))
              }
              let f = await Promise.all(h)
              ;((l.linkedSheets = f),
                f.forEach((d) => {
                  d.linkedSheets = [l].concat(l.linkedSheets.filter((g) => g !== d))
                }))
            }
            return l
          },
          async unload(r, t, e) {
            ;(await e.unload(r.textureSource._sourceOrigin), r.destroy(!1))
          },
        },
      }
    })
  var qa = p(() => {
    A()
    x_()
    L.add(g_)
  })
  function Za(r, t, e) {
    let { width: i, height: n } = e.orig,
      s = e.trim
    if (s) {
      let o = s.width,
        a = s.height
      ;((r.minX = s.x - t._x * i),
        (r.maxX = r.minX + o),
        (r.minY = s.y - t._y * n),
        (r.maxY = r.minY + a))
    } else
      ((r.minX = -t._x * i), (r.maxX = r.minX + i), (r.minY = -t._y * n), (r.maxY = r.minY + n))
  }
  var Jc = p(() => {
    "use strict"
  })
  var ni,
    th = p(() => {
      Da()
      dt()
      Jc()
      gt()
      Ka()
      ni = class r extends vr {
        constructor(t = k.EMPTY) {
          t instanceof k && (t = { texture: t })
          let { texture: e = k.EMPTY, anchor: i, roundPixels: n, width: s, height: o, ...a } = t
          ;(super({ label: "Sprite", ...a }),
            (this.renderPipeId = "sprite"),
            (this.batched = !0),
            (this._visualBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }),
            (this._anchor = new Pt({
              _onUpdate: () => {
                this.onViewUpdate()
              },
            })),
            i ? (this.anchor = i) : e.defaultAnchor && (this.anchor = e.defaultAnchor),
            (this.texture = e),
            (this.allowChildren = !1),
            (this.roundPixels = n ?? !1),
            s !== void 0 && (this.width = s),
            o !== void 0 && (this.height = o))
        }
        static from(t, e = !1) {
          return t instanceof k ? new r(t) : new r(k.from(t, e))
        }
        set texture(t) {
          t || (t = k.EMPTY)
          let e = this._texture
          e !== t &&
            (e && e.dynamic && e.off("update", this.onViewUpdate, this),
            t.dynamic && t.on("update", this.onViewUpdate, this),
            (this._texture = t),
            this._width && this._setWidth(this._width, this._texture.orig.width),
            this._height && this._setHeight(this._height, this._texture.orig.height),
            this.onViewUpdate())
        }
        get texture() {
          return this._texture
        }
        get visualBounds() {
          return (Za(this._visualBounds, this._anchor, this._texture), this._visualBounds)
        }
        get sourceBounds() {
          return (
            z("8.6.1", "Sprite.sourceBounds is deprecated, use visualBounds instead."),
            this.visualBounds
          )
        }
        updateBounds() {
          let t = this._anchor,
            e = this._texture,
            i = this._bounds,
            { width: n, height: s } = e.orig
          ;((i.minX = -t._x * n),
            (i.maxX = i.minX + n),
            (i.minY = -t._y * s),
            (i.maxY = i.minY + s))
        }
        destroy(t = !1) {
          if ((super.destroy(t), typeof t == "boolean" ? t : t?.texture)) {
            let i = typeof t == "boolean" ? t : t?.textureSource
            this._texture.destroy(i)
          }
          ;((this._texture = null),
            (this._visualBounds = null),
            (this._bounds = null),
            (this._anchor = null),
            (this._gpuData = null))
        }
        get anchor() {
          return this._anchor
        }
        set anchor(t) {
          typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t)
        }
        get width() {
          return Math.abs(this.scale.x) * this._texture.orig.width
        }
        set width(t) {
          ;(this._setWidth(t, this._texture.orig.width), (this._width = t))
        }
        get height() {
          return Math.abs(this.scale.y) * this._texture.orig.height
        }
        set height(t) {
          ;(this._setHeight(t, this._texture.orig.height), (this._height = t))
        }
        getSize(t) {
          return (
            t || (t = {}),
            (t.width = Math.abs(this.scale.x) * this._texture.orig.width),
            (t.height = Math.abs(this.scale.y) * this._texture.orig.height),
            t
          )
        }
        setSize(t, e) {
          ;(typeof t == "object" ? ((e = t.height ?? t.width), (t = t.width)) : (e ?? (e = t)),
            t !== void 0 && this._setWidth(t, this._texture.orig.width),
            e !== void 0 && this._setHeight(e, this._texture.orig.height))
        }
      }
    })
  function Qa(r, t, e) {
    let i = xA
    ;((r.measurable = !0), Di(r, e, i), t.addBoundsMask(i), (r.measurable = !1))
  }
  var xA,
    eh = p(() => {
      se()
      Jn()
      xA = new ct()
    })
  function Ja(r, t, e) {
    let i = he.get()
    r.measurable = !0
    let n = Ft.get().identity(),
      s = __(r, e, n)
    ;(Fi(r, i, s), (r.measurable = !1), t.addBoundsMask(i), Ft.return(n), he.return(i))
  }
  function __(r, t, e) {
    return r
      ? (r !== t && (__(r.parent, t, e), r.updateLocalTransform(), e.append(r.localTransform)), e)
      : (N("Mask bounds, renderable is not inside the root container"), e)
  }
  var rh = p(() => {
    Ga()
    Kr()
    ft()
  })
  var fs,
    y_ = p(() => {
      A()
      th()
      eh()
      rh()
      fs = class {
        constructor(t) {
          ;((this.priority = 0),
            (this.inverse = !1),
            (this.pipe = "alphaMask"),
            t?.mask && this.init(t.mask))
        }
        init(t) {
          ;((this.mask = t),
            (this.renderMaskToTexture = !(t instanceof ni)),
            (this.mask.renderable = this.renderMaskToTexture),
            (this.mask.includeInBuild = !this.renderMaskToTexture),
            (this.mask.measurable = !1))
        }
        reset() {
          ;((this.mask.measurable = !0), (this.mask = null))
        }
        addBounds(t, e) {
          this.inverse || Qa(this.mask, t, e)
        }
        addLocalBounds(t, e) {
          Ja(this.mask, t, e)
        }
        containsPoint(t, e) {
          let i = this.mask
          return e(i, t)
        }
        destroy() {
          this.reset()
        }
        static test(t) {
          return t instanceof ni
        }
      }
      fs.extension = b.MaskEffect
    })
  var ds,
    b_ = p(() => {
      A()
      ds = class {
        constructor(t) {
          ;((this.priority = 0), (this.pipe = "colorMask"), t?.mask && this.init(t.mask))
        }
        init(t) {
          this.mask = t
        }
        destroy() {}
        static test(t) {
          return typeof t == "number"
        }
      }
      ds.extension = b.MaskEffect
    })
  var ps,
    v_ = p(() => {
      A()
      we()
      eh()
      rh()
      ps = class {
        constructor(t) {
          ;((this.priority = 0), (this.pipe = "stencilMask"), t?.mask && this.init(t.mask))
        }
        init(t) {
          ;((this.mask = t), (this.mask.includeInBuild = !1), (this.mask.measurable = !1))
        }
        reset() {
          ;((this.mask.measurable = !0), (this.mask.includeInBuild = !0), (this.mask = null))
        }
        addBounds(t, e) {
          Qa(this.mask, t, e)
        }
        addLocalBounds(t, e) {
          Ja(this.mask, t, e)
        }
        containsPoint(t, e) {
          let i = this.mask
          return e(i, t)
        }
        destroy() {
          this.reset()
        }
        static test(t) {
          return t instanceof pt
        }
      }
      ps.extension = b.MaskEffect
    })
  var Yt,
    Ui = p(() => {
      At()
      A()
      te()
      Yt = class extends ot {
        constructor(t) {
          ;(t.resource || (t.resource = Z.get().createCanvas()),
            t.width || ((t.width = t.resource.width), t.autoDensity || (t.width /= t.resolution)),
            t.height ||
              ((t.height = t.resource.height), t.autoDensity || (t.height /= t.resolution)),
            super(t),
            (this.uploadMethodId = "image"),
            (this.autoDensity = t.autoDensity),
            this.resizeCanvas(),
            (this.transparent = !!t.transparent))
        }
        resizeCanvas() {
          ;(this.autoDensity &&
            "style" in this.resource &&
            ((this.resource.style.width = `${this.width}px`),
            (this.resource.style.height = `${this.height}px`)),
            (this.resource.width !== this.pixelWidth ||
              this.resource.height !== this.pixelHeight) &&
              ((this.resource.width = this.pixelWidth), (this.resource.height = this.pixelHeight)))
        }
        resize(t = this.width, e = this.height, i = this._resolution) {
          let n = super.resize(t, e, i)
          return (n && this.resizeCanvas(), n)
        }
        static test(t) {
          return (
            (globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement) ||
            (globalThis.OffscreenCanvas && t instanceof OffscreenCanvas)
          )
        }
        get context2D() {
          return this._context2D || (this._context2D = this.resource.getContext("2d"))
        }
      }
      Yt.extension = b.TextureSource
    })
  var Be,
    tu = p(() => {
      A()
      te()
      Be = class extends ot {
        constructor(t) {
          ;(super(t), (this.uploadMethodId = "image"), (this.autoGarbageCollect = !0))
        }
        static test(t) {
          return (
            (globalThis.HTMLImageElement && t instanceof HTMLImageElement) ||
            (typeof ImageBitmap < "u" && t instanceof ImageBitmap) ||
            (globalThis.VideoFrame && t instanceof VideoFrame)
          )
        }
      }
      Be.extension = b.TextureSource
    })
  async function S_() {
    return (
      ih ??
        (ih = (async () => {
          let t = document.createElement("canvas").getContext("webgl")
          if (!t) return "premultiply-alpha-on-upload"
          let e = await new Promise((o) => {
            let a = document.createElement("video")
            ;((a.onloadeddata = () => o(a)),
              (a.onerror = () => o(null)),
              (a.autoplay = !1),
              (a.crossOrigin = "anonymous"),
              (a.preload = "auto"),
              (a.src =
                "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM="),
              a.load())
          })
          if (!e) return "premultiply-alpha-on-upload"
          let i = t.createTexture()
          t.bindTexture(t.TEXTURE_2D, i)
          let n = t.createFramebuffer()
          ;(t.bindFramebuffer(t.FRAMEBUFFER, n),
            t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, i, 0),
            t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
            t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE),
            t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, e))
          let s = new Uint8Array(4)
          return (
            t.readPixels(0, 0, 1, 1, t.RGBA, t.UNSIGNED_BYTE, s),
            t.deleteFramebuffer(n),
            t.deleteTexture(i),
            t.getExtension("WEBGL_lose_context")?.loseContext(),
            s[0] <= s[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload"
          )
        })()),
      ih
    )
  }
  var ih,
    T_ = p(() => {
      "use strict"
    })
  var eu,
    E_,
    w_ = p(() => {
      A()
      ss()
      T_()
      te()
      eu = class C_ extends ot {
        constructor(t) {
          ;(super(t),
            (this.isReady = !1),
            (this.uploadMethodId = "video"),
            (t = { ...C_.defaultOptions, ...t }),
            (this._autoUpdate = !0),
            (this._isConnectedToTicker = !1),
            (this._updateFPS = t.updateFPS || 0),
            (this._msToNextUpdate = 0),
            (this.autoPlay = t.autoPlay !== !1),
            (this.alphaMode = t.alphaMode ?? "premultiply-alpha-on-upload"),
            (this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this)),
            (this._videoFrameRequestCallbackHandle = null),
            (this._load = null),
            (this._resolve = null),
            (this._reject = null),
            (this._onCanPlay = this._onCanPlay.bind(this)),
            (this._onCanPlayThrough = this._onCanPlayThrough.bind(this)),
            (this._onError = this._onError.bind(this)),
            (this._onPlayStart = this._onPlayStart.bind(this)),
            (this._onPlayStop = this._onPlayStop.bind(this)),
            (this._onSeeked = this._onSeeked.bind(this)),
            t.autoLoad !== !1 && this.load())
        }
        updateFrame() {
          if (!this.destroyed) {
            if (this._updateFPS) {
              let t = oe.shared.elapsedMS * this.resource.playbackRate
              this._msToNextUpdate = Math.floor(this._msToNextUpdate - t)
            }
            ;((!this._updateFPS || this._msToNextUpdate <= 0) &&
              (this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0),
              this.isValid && this.update())
          }
        }
        _videoFrameRequestCallback() {
          ;(this.updateFrame(),
            this.destroyed
              ? (this._videoFrameRequestCallbackHandle = null)
              : (this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
                  this._videoFrameRequestCallback,
                )))
        }
        get isValid() {
          return !!this.resource.videoWidth && !!this.resource.videoHeight
        }
        async load() {
          if (this._load) return this._load
          let t = this.resource,
            e = this.options
          return (
            (t.readyState === t.HAVE_ENOUGH_DATA || t.readyState === t.HAVE_FUTURE_DATA) &&
              t.width &&
              t.height &&
              (t.complete = !0),
            t.addEventListener("play", this._onPlayStart),
            t.addEventListener("pause", this._onPlayStop),
            t.addEventListener("seeked", this._onSeeked),
            this._isSourceReady()
              ? this._mediaReady()
              : (e.preload || t.addEventListener("canplay", this._onCanPlay),
                t.addEventListener("canplaythrough", this._onCanPlayThrough),
                t.addEventListener("error", this._onError, !0)),
            (this.alphaMode = await S_()),
            (this._load = new Promise((i, n) => {
              this.isValid
                ? i(this)
                : ((this._resolve = i),
                  (this._reject = n),
                  e.preloadTimeoutMs !== void 0 &&
                    (this._preloadTimeout = setTimeout(() => {
                      this._onError(
                        new ErrorEvent(`Preload exceeded timeout of ${e.preloadTimeoutMs}ms`),
                      )
                    })),
                  t.load())
            })),
            this._load
          )
        }
        _onError(t) {
          ;(this.resource.removeEventListener("error", this._onError, !0),
            this.emit("error", t),
            this._reject && (this._reject(t), (this._reject = null), (this._resolve = null)))
        }
        _isSourcePlaying() {
          let t = this.resource
          return !t.paused && !t.ended
        }
        _isSourceReady() {
          return this.resource.readyState > 2
        }
        _onPlayStart() {
          ;(this.isValid || this._mediaReady(), this._configureAutoUpdate())
        }
        _onPlayStop() {
          this._configureAutoUpdate()
        }
        _onSeeked() {
          this._autoUpdate &&
            !this._isSourcePlaying() &&
            ((this._msToNextUpdate = 0), this.updateFrame(), (this._msToNextUpdate = 0))
        }
        _onCanPlay() {
          ;(this.resource.removeEventListener("canplay", this._onCanPlay), this._mediaReady())
        }
        _onCanPlayThrough() {
          ;(this.resource.removeEventListener("canplaythrough", this._onCanPlay),
            this._preloadTimeout &&
              (clearTimeout(this._preloadTimeout), (this._preloadTimeout = void 0)),
            this._mediaReady())
        }
        _mediaReady() {
          let t = this.resource
          ;(this.isValid && ((this.isReady = !0), this.resize(t.videoWidth, t.videoHeight)),
            (this._msToNextUpdate = 0),
            this.updateFrame(),
            (this._msToNextUpdate = 0),
            this._resolve && (this._resolve(this), (this._resolve = null), (this._reject = null)),
            this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && this.resource.play())
        }
        destroy() {
          this._configureAutoUpdate()
          let t = this.resource
          ;(t &&
            (t.removeEventListener("play", this._onPlayStart),
            t.removeEventListener("pause", this._onPlayStop),
            t.removeEventListener("seeked", this._onSeeked),
            t.removeEventListener("canplay", this._onCanPlay),
            t.removeEventListener("canplaythrough", this._onCanPlayThrough),
            t.removeEventListener("error", this._onError, !0),
            t.pause(),
            (t.src = ""),
            t.load()),
            super.destroy())
        }
        get autoUpdate() {
          return this._autoUpdate
        }
        set autoUpdate(t) {
          t !== this._autoUpdate && ((this._autoUpdate = t), this._configureAutoUpdate())
        }
        get updateFPS() {
          return this._updateFPS
        }
        set updateFPS(t) {
          t !== this._updateFPS && ((this._updateFPS = t), this._configureAutoUpdate())
        }
        _configureAutoUpdate() {
          this._autoUpdate && this._isSourcePlaying()
            ? !this._updateFPS && this.resource.requestVideoFrameCallback
              ? (this._isConnectedToTicker &&
                  (oe.shared.remove(this.updateFrame, this),
                  (this._isConnectedToTicker = !1),
                  (this._msToNextUpdate = 0)),
                this._videoFrameRequestCallbackHandle === null &&
                  (this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
                    this._videoFrameRequestCallback,
                  )))
              : (this._videoFrameRequestCallbackHandle !== null &&
                  (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle),
                  (this._videoFrameRequestCallbackHandle = null)),
                this._isConnectedToTicker ||
                  (oe.shared.add(this.updateFrame, this),
                  (this._isConnectedToTicker = !0),
                  (this._msToNextUpdate = 0)))
            : (this._videoFrameRequestCallbackHandle !== null &&
                (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle),
                (this._videoFrameRequestCallbackHandle = null)),
              this._isConnectedToTicker &&
                (oe.shared.remove(this.updateFrame, this),
                (this._isConnectedToTicker = !1),
                (this._msToNextUpdate = 0)))
        }
        static test(t) {
          return globalThis.HTMLVideoElement && t instanceof HTMLVideoElement
        }
      }
      eu.extension = b.TextureSource
      eu.defaultOptions = {
        ...ot.defaultOptions,
        autoLoad: !0,
        autoPlay: !0,
        updateFPS: 0,
        crossorigin: !0,
        loop: !1,
        muted: !0,
        playsinline: !0,
        preload: !1,
      }
      eu.MIME_TYPES = { ogv: "video/ogg", mov: "video/quicktime", m4v: "video/mp4" }
      E_ = eu
    })
  var nh,
    Rt,
    ms = p(() => {
      ft()
      Kc()
      ;((nh = class {
        constructor() {
          ;((this._parsers = []), (this._cache = new Map()), (this._cacheMap = new Map()))
        }
        reset() {
          ;(this._cacheMap.clear(), this._cache.clear())
        }
        has(t) {
          return this._cache.has(t)
        }
        get(t) {
          let e = this._cache.get(t)
          return (e || N(`[Assets] Asset id ${t} was not found in the Cache`), e)
        }
        set(t, e) {
          let i = Sr(t),
            n
          for (let u = 0; u < this.parsers.length; u++) {
            let l = this.parsers[u]
            if (l.test(e)) {
              n = l.getCacheableAssets(i, e)
              break
            }
          }
          let s = new Map(Object.entries(n || {}))
          n ||
            i.forEach((u) => {
              s.set(u, e)
            })
          let o = [...s.keys()],
            a = { cacheKeys: o, keys: i }
          ;(i.forEach((u) => {
            this._cacheMap.set(u, a)
          }),
            o.forEach((u) => {
              let l = n ? n[u] : e
              ;(this._cache.has(u) && this._cache.get(u) !== l && N("[Cache] already has key:", u),
                this._cache.set(u, s.get(u)))
            }))
        }
        remove(t) {
          if (!this._cacheMap.has(t)) {
            N(`[Assets] Asset id ${t} was not found in the Cache`)
            return
          }
          let e = this._cacheMap.get(t)
          ;(e.cacheKeys.forEach((n) => {
            this._cache.delete(n)
          }),
            e.keys.forEach((n) => {
              this._cacheMap.delete(n)
            }))
        }
        get parsers() {
          return this._parsers
        }
      }),
        (Rt = new nh()))
    })
  function M_(r = {}) {
    let t = r && r.resource,
      e = t ? r.resource : r,
      i = t ? r : { resource: r }
    for (let n = 0; n < sh.length; n++) {
      let s = sh[n]
      if (s.test(e)) return new s(i)
    }
    throw new Error(`Could not find a source type for resource: ${i.resource}`)
  }
  function A_(r = {}, t = !1) {
    let e = r && r.resource,
      i = e ? r.resource : r,
      n = e ? r : { resource: r }
    if (!t && Rt.has(i)) return Rt.get(i)
    let s = new k({ source: M_(n) })
    return (
      s.on("destroy", () => {
        Rt.has(i) && Rt.remove(i)
      }),
      t || Rt.set(i, s),
      s
    )
  }
  function D_(r, t = !1) {
    return typeof r == "string" ? Rt.get(r) : r instanceof ot ? new k({ source: r }) : A_(r, t)
  }
  var sh,
    oh = p(() => {
      ms()
      A()
      te()
      dt()
      sh = []
      L.handleByList(b.TextureSource, sh)
      k.from = D_
      ot.from = M_
    })
  var ru = p(() => {
    A()
    y_()
    b_()
    v_()
    Pc()
    Ui()
    tu()
    w_()
    oh()
    L.add(fs, ds, ps, E_, Be, Yt, ei)
  })
  var Nt,
    Tr = p(() => {
      "use strict"
      Nt = class {
        constructor(t) {
          ;((this.resources = Object.create(null)), (this._dirty = !0))
          let e = 0
          for (let i in t) {
            let n = t[i]
            this.setResource(n, e++)
          }
          this._updateKey()
        }
        _updateKey() {
          if (!this._dirty) return
          this._dirty = !1
          let t = [],
            e = 0
          for (let i in this.resources) t[e++] = this.resources[i]._resourceId
          this._key = t.join("|")
        }
        setResource(t, e) {
          let i = this.resources[e]
          t !== i &&
            (i && t.off?.("change", this.onResourceChange, this),
            t.on?.("change", this.onResourceChange, this),
            (this.resources[e] = t),
            (this._dirty = !0))
        }
        getResource(t) {
          return this.resources[t]
        }
        _touch(t) {
          let e = this.resources
          for (let i in e) e[i]._touched = t
        }
        destroy() {
          let t = this.resources
          for (let e in t) t[e].off?.("change", this.onResourceChange, this)
          this.resources = null
        }
        onResourceChange(t) {
          if (((this._dirty = !0), t.destroyed)) {
            let e = this.resources
            for (let i in e) e[i] === t && (e[i] = null)
          } else this._updateKey()
        }
      }
    })
  function Oi(r, t, e) {
    let i = 2166136261
    for (let n = 0; n < t; n++) ((i ^= r[n].uid), (i = Math.imul(i, 16777619)), (i >>>= 0))
    return P_[i] || _A(r, t, i, e)
  }
  function _A(r, t, e, i) {
    let n = {},
      s = 0
    for (let a = 0; a < i; a++) {
      let u = a < t ? r[a] : k.EMPTY.source
      ;((n[s++] = u.source), (n[s++] = u.style))
    }
    let o = new Nt(n)
    return ((P_[e] = o), o)
  }
  var P_,
    iu = p(() => {
      Tr()
      dt()
      P_ = {}
    })
  var Ie,
    ah = p(() => {
      "use strict"
      Ie = class {
        constructor(t) {
          ;(typeof t == "number"
            ? (this.rawBinaryData = new ArrayBuffer(t))
            : t instanceof Uint8Array
              ? (this.rawBinaryData = t.buffer)
              : (this.rawBinaryData = t),
            (this.uint32View = new Uint32Array(this.rawBinaryData)),
            (this.float32View = new Float32Array(this.rawBinaryData)),
            (this.size = this.rawBinaryData.byteLength))
        }
        get int8View() {
          return (
            this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)),
            this._int8View
          )
        }
        get uint8View() {
          return (
            this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)),
            this._uint8View
          )
        }
        get int16View() {
          return (
            this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)),
            this._int16View
          )
        }
        get int32View() {
          return (
            this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)),
            this._int32View
          )
        }
        get float64View() {
          return (
            this._float64Array || (this._float64Array = new Float64Array(this.rawBinaryData)),
            this._float64Array
          )
        }
        get bigUint64View() {
          return (
            this._bigUint64Array || (this._bigUint64Array = new BigUint64Array(this.rawBinaryData)),
            this._bigUint64Array
          )
        }
        view(t) {
          return this[`${t}View`]
        }
        destroy() {
          ;((this.rawBinaryData = null),
            (this._int8View = null),
            (this._uint8View = null),
            (this._int16View = null),
            (this.uint16View = null),
            (this._int32View = null),
            (this.uint32View = null),
            (this.float32View = null))
        }
        static sizeOf(t) {
          switch (t) {
            case "int8":
            case "uint8":
              return 1
            case "int16":
            case "uint16":
              return 2
            case "int32":
            case "uint32":
            case "float32":
              return 4
            default:
              throw new Error(`${t} isn't a valid view type`)
          }
        }
      }
    })
  function gs(r, t) {
    let e = (r.byteLength / 8) | 0,
      i = new Float64Array(r, 0, e)
    new Float64Array(t, 0, e).set(i)
    let s = r.byteLength - e * 8
    if (s > 0) {
      let o = new Uint8Array(r, e * 8, s)
      new Uint8Array(t, e * 8, s).set(o)
    }
  }
  var uh = p(() => {
    "use strict"
  })
  var F_,
    mt,
    si = p(() => {
      "use strict"
      ;((F_ = { normal: "normal-npm", add: "add-npm", screen: "screen-npm" }),
        (mt = ((r) => (
          (r[(r.DISABLED = 0)] = "DISABLED"),
          (r[(r.RENDERING_MASK_ADD = 1)] = "RENDERING_MASK_ADD"),
          (r[(r.MASK_ACTIVE = 2)] = "MASK_ACTIVE"),
          (r[(r.INVERSE_MASK_ACTIVE = 3)] = "INVERSE_MASK_ACTIVE"),
          (r[(r.RENDERING_MASK_REMOVE = 4)] = "RENDERING_MASK_REMOVE"),
          (r[(r.NONE = 5)] = "NONE"),
          r
        ))(mt || {})))
    })
  function nr(r, t) {
    return (t.alphaMode === "no-premultiply-alpha" && F_[r]) || r
  }
  var xs = p(() => {
    si()
  })
  function su() {
    return (
      (!nu || nu?.isContextLost()) && (nu = Z.get().createCanvas().getContext("webgl", {})),
      nu
    )
  }
  var nu,
    lh = p(() => {
      At()
    })
  function bA(r) {
    let t = ""
    for (let e = 0; e < r; ++e)
      (e > 0 &&
        (t += `
else `),
        e < r - 1 && (t += `if(test == ${e}.0){}`))
    return t
  }
  function ou(r, t) {
    if (r === 0) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`")
    let e = t.createShader(t.FRAGMENT_SHADER)
    try {
      for (;;) {
        let i = yA.replace(/%forloop%/gi, bA(r))
        if ((t.shaderSource(e, i), t.compileShader(e), !t.getShaderParameter(e, t.COMPILE_STATUS)))
          r = (r / 2) | 0
        else break
      }
    } finally {
      t.deleteShader(e)
    }
    return r
  }
  var yA,
    ch = p(() => {
      "use strict"
      yA = [
        "precision mediump float;",
        "void main(void){",
        "float test = 0.1;",
        "%forloop%",
        "gl_FragColor = vec4(0.0);",
        "}",
      ].join(`
`)
    })
  function R_() {
    if (Li) return Li
    let r = su()
    return (
      (Li = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS)),
      (Li = ou(Li, r)),
      r.getExtension("WEBGL_lose_context")?.loseContext(),
      Li
    )
  }
  var Li,
    B_ = p(() => {
      lh()
      ch()
      Li = null
    })
  var au,
    I_ = p(() => {
      "use strict"
      au = class {
        constructor() {
          ;((this.ids = Object.create(null)), (this.textures = []), (this.count = 0))
        }
        clear() {
          for (let t = 0; t < this.count; t++) {
            let e = this.textures[t]
            ;((this.textures[t] = null), (this.ids[e.uid] = null))
          }
          this.count = 0
        }
      }
    })
  function k_() {
    return fh > 0 ? U_[--fh] : new hh()
  }
  function G_(r) {
    U_[fh++] = r
  }
  var hh,
    U_,
    fh,
    _s,
    O_,
    N_,
    H_ = p(() => {
      Ot()
      ah()
      gt()
      uh()
      xs()
      B_()
      I_()
      ;((hh = class {
        constructor() {
          ;((this.renderPipeId = "batch"),
            (this.action = "startBatch"),
            (this.start = 0),
            (this.size = 0),
            (this.textures = new au()),
            (this.blendMode = "normal"),
            (this.topology = "triangle-strip"),
            (this.canBundle = !0))
        }
        destroy() {
          ;((this.textures = null),
            (this.gpuBindGroup = null),
            (this.bindGroup = null),
            (this.batcher = null))
        }
      }),
        (U_ = []),
        (fh = 0))
      ;((_s = 0),
        (O_ = class L_ {
          constructor(t) {
            ;((this.uid = J("batcher")),
              (this.dirty = !0),
              (this.batchIndex = 0),
              (this.batches = []),
              (this._elements = []),
              (t = { ...L_.defaultOptions, ...t }),
              t.maxTextures ||
                (z(
                  "v8.8.0",
                  "maxTextures is a required option for Batcher now, please pass it in the options",
                ),
                (t.maxTextures = R_())))
            let { maxTextures: e, attributesInitialSize: i, indicesInitialSize: n } = t
            ;((this.attributeBuffer = new Ie(i * 4)),
              (this.indexBuffer = new Uint16Array(n)),
              (this.maxTextures = e))
          }
          begin() {
            ;((this.elementSize = 0),
              (this.elementStart = 0),
              (this.indexSize = 0),
              (this.attributeSize = 0))
            for (let t = 0; t < this.batchIndex; t++) G_(this.batches[t])
            ;((this.batchIndex = 0),
              (this._batchIndexStart = 0),
              (this._batchIndexSize = 0),
              (this.dirty = !0))
          }
          add(t) {
            ;((this._elements[this.elementSize++] = t),
              (t._indexStart = this.indexSize),
              (t._attributeStart = this.attributeSize),
              (t._batcher = this),
              (this.indexSize += t.indexSize),
              (this.attributeSize += t.attributeSize * this.vertexSize))
          }
          checkAndUpdateTexture(t, e) {
            let i = t._batch.textures.ids[e._source.uid]
            return !i && i !== 0 ? !1 : ((t._textureId = i), (t.texture = e), !0)
          }
          updateElement(t) {
            this.dirty = !0
            let e = this.attributeBuffer
            t.packAsQuad
              ? this.packQuadAttributes(
                  t,
                  e.float32View,
                  e.uint32View,
                  t._attributeStart,
                  t._textureId,
                )
              : this.packAttributes(t, e.float32View, e.uint32View, t._attributeStart, t._textureId)
          }
          break(t) {
            let e = this._elements
            if (!e[this.elementStart]) return
            let i = k_(),
              n = i.textures
            n.clear()
            let s = e[this.elementStart],
              o = nr(s.blendMode, s.texture._source),
              a = s.topology
            ;(this.attributeSize * 4 > this.attributeBuffer.size &&
              this._resizeAttributeBuffer(this.attributeSize * 4),
              this.indexSize > this.indexBuffer.length && this._resizeIndexBuffer(this.indexSize))
            let u = this.attributeBuffer.float32View,
              l = this.attributeBuffer.uint32View,
              c = this.indexBuffer,
              h = this._batchIndexSize,
              f = this._batchIndexStart,
              d = "startBatch",
              g = this.maxTextures
            for (let x = this.elementStart; x < this.elementSize; ++x) {
              let m = e[x]
              e[x] = null
              let v = m.texture._source,
                S = nr(m.blendMode, v),
                y = o !== S || a !== m.topology
              if (v._batchTick === _s && !y) {
                ;((m._textureId = v._textureBindLocation),
                  (h += m.indexSize),
                  m.packAsQuad
                    ? (this.packQuadAttributes(m, u, l, m._attributeStart, m._textureId),
                      this.packQuadIndex(c, m._indexStart, m._attributeStart / this.vertexSize))
                    : (this.packAttributes(m, u, l, m._attributeStart, m._textureId),
                      this.packIndex(m, c, m._indexStart, m._attributeStart / this.vertexSize)),
                  (m._batch = i))
                continue
              }
              ;((v._batchTick = _s),
                (n.count >= g || y) &&
                  (this._finishBatch(i, f, h - f, n, o, a, t, d),
                  (d = "renderBatch"),
                  (f = h),
                  (o = S),
                  (a = m.topology),
                  (i = k_()),
                  (n = i.textures),
                  n.clear(),
                  ++_s),
                (m._textureId = v._textureBindLocation = n.count),
                (n.ids[v.uid] = n.count),
                (n.textures[n.count++] = v),
                (m._batch = i),
                (h += m.indexSize),
                m.packAsQuad
                  ? (this.packQuadAttributes(m, u, l, m._attributeStart, m._textureId),
                    this.packQuadIndex(c, m._indexStart, m._attributeStart / this.vertexSize))
                  : (this.packAttributes(m, u, l, m._attributeStart, m._textureId),
                    this.packIndex(m, c, m._indexStart, m._attributeStart / this.vertexSize)))
            }
            ;(n.count > 0 && (this._finishBatch(i, f, h - f, n, o, a, t, d), (f = h), ++_s),
              (this.elementStart = this.elementSize),
              (this._batchIndexStart = f),
              (this._batchIndexSize = h))
          }
          _finishBatch(t, e, i, n, s, o, a, u) {
            ;((t.gpuBindGroup = null),
              (t.bindGroup = null),
              (t.action = u),
              (t.batcher = this),
              (t.textures = n),
              (t.blendMode = s),
              (t.topology = o),
              (t.start = e),
              (t.size = i),
              ++_s,
              (this.batches[this.batchIndex++] = t),
              a.add(t))
          }
          finish(t) {
            this.break(t)
          }
          ensureAttributeBuffer(t) {
            t * 4 <= this.attributeBuffer.size || this._resizeAttributeBuffer(t * 4)
          }
          ensureIndexBuffer(t) {
            t <= this.indexBuffer.length || this._resizeIndexBuffer(t)
          }
          _resizeAttributeBuffer(t) {
            let e = Math.max(t, this.attributeBuffer.size * 2),
              i = new Ie(e)
            ;(gs(this.attributeBuffer.rawBinaryData, i.rawBinaryData), (this.attributeBuffer = i))
          }
          _resizeIndexBuffer(t) {
            let e = this.indexBuffer,
              i = Math.max(t, e.length * 1.5)
            i += i % 2
            let n = i > 65535 ? new Uint32Array(i) : new Uint16Array(i)
            if (n.BYTES_PER_ELEMENT !== e.BYTES_PER_ELEMENT)
              for (let s = 0; s < e.length; s++) n[s] = e[s]
            else gs(e.buffer, n.buffer)
            this.indexBuffer = n
          }
          packQuadIndex(t, e, i) {
            ;((t[e] = i + 0),
              (t[e + 1] = i + 1),
              (t[e + 2] = i + 2),
              (t[e + 3] = i + 0),
              (t[e + 4] = i + 2),
              (t[e + 5] = i + 3))
          }
          packIndex(t, e, i, n) {
            let s = t.indices,
              o = t.indexSize,
              a = t.indexOffset,
              u = t.attributeOffset
            for (let l = 0; l < o; l++) e[i++] = n + s[l + a] - u
          }
          destroy() {
            for (let t = 0; t < this.batches.length; t++) G_(this.batches[t])
            this.batches = null
            for (let t = 0; t < this._elements.length; t++) this._elements[t]._batch = null
            ;((this._elements = null),
              (this.indexBuffer = null),
              this.attributeBuffer.destroy(),
              (this.attributeBuffer = null))
          }
        }))
      O_.defaultOptions = { maxTextures: null, attributesInitialSize: 4, indicesInitialSize: 6 }
      N_ = O_
    })
  var tt,
    sr = p(() => {
      "use strict"
      tt = ((r) => (
        (r[(r.MAP_READ = 1)] = "MAP_READ"),
        (r[(r.MAP_WRITE = 2)] = "MAP_WRITE"),
        (r[(r.COPY_SRC = 4)] = "COPY_SRC"),
        (r[(r.COPY_DST = 8)] = "COPY_DST"),
        (r[(r.INDEX = 16)] = "INDEX"),
        (r[(r.VERTEX = 32)] = "VERTEX"),
        (r[(r.UNIFORM = 64)] = "UNIFORM"),
        (r[(r.STORAGE = 128)] = "STORAGE"),
        (r[(r.INDIRECT = 256)] = "INDIRECT"),
        (r[(r.QUERY_RESOLVE = 512)] = "QUERY_RESOLVE"),
        (r[(r.STATIC = 1024)] = "STATIC"),
        r
      ))(tt || {})
    })
  var wt,
    Cr = p(() => {
      Wt()
      Ot()
      sr()
      wt = class extends lt {
        constructor(t) {
          let { data: e, size: i } = t,
            { usage: n, label: s, shrinkToFit: o } = t
          ;(super(),
            (this.uid = J("buffer")),
            (this._resourceType = "buffer"),
            (this._resourceId = J("resource")),
            (this._touched = 0),
            (this._updateID = 1),
            (this._dataInt32 = null),
            (this.shrinkToFit = !0),
            (this.destroyed = !1),
            e instanceof Array && (e = new Float32Array(e)),
            (this._data = e),
            i ?? (i = e?.byteLength))
          let a = !!e
          ;((this.descriptor = { size: i, usage: n, mappedAtCreation: a, label: s }),
            (this.shrinkToFit = o ?? !0))
        }
        get data() {
          return this._data
        }
        set data(t) {
          this.setDataWithSize(t, t.length, !0)
        }
        get dataInt32() {
          return (
            this._dataInt32 || (this._dataInt32 = new Int32Array(this.data.buffer)),
            this._dataInt32
          )
        }
        get static() {
          return !!(this.descriptor.usage & tt.STATIC)
        }
        set static(t) {
          t ? (this.descriptor.usage |= tt.STATIC) : (this.descriptor.usage &= ~tt.STATIC)
        }
        setDataWithSize(t, e, i) {
          if ((this._updateID++, (this._updateSize = e * t.BYTES_PER_ELEMENT), this._data === t)) {
            i && this.emit("update", this)
            return
          }
          let n = this._data
          if (((this._data = t), (this._dataInt32 = null), !n || n.length !== t.length)) {
            !this.shrinkToFit && n && t.byteLength < n.byteLength
              ? i && this.emit("update", this)
              : ((this.descriptor.size = t.byteLength),
                (this._resourceId = J("resource")),
                this.emit("change", this))
            return
          }
          i && this.emit("update", this)
        }
        update(t) {
          ;((this._updateSize = t ?? this._updateSize), this._updateID++, this.emit("update", this))
        }
        destroy() {
          ;((this.destroyed = !0),
            this.emit("destroy", this),
            this.emit("change", this),
            (this._data = null),
            (this.descriptor = null),
            this.removeAllListeners())
        }
      }
    })
  function dh(r, t) {
    if (!(r instanceof wt)) {
      let e = t ? tt.INDEX : tt.VERTEX
      ;(r instanceof Array &&
        (t
          ? ((r = new Uint32Array(r)), (e = tt.INDEX | tt.COPY_DST))
          : ((r = new Float32Array(r)), (e = tt.VERTEX | tt.COPY_DST))),
        (r = new wt({ data: r, label: t ? "index-mesh-buffer" : "vertex-mesh-buffer", usage: e })))
    }
    return r
  }
  var z_ = p(() => {
    Cr()
    sr()
  })
  function W_(r, t, e) {
    let i = r.getAttribute(t)
    if (!i) return ((e.minX = 0), (e.minY = 0), (e.maxX = 0), (e.maxY = 0), e)
    let n = i.buffer.data,
      s = 1 / 0,
      o = 1 / 0,
      a = -1 / 0,
      u = -1 / 0,
      l = n.BYTES_PER_ELEMENT,
      c = (i.offset || 0) / l,
      h = (i.stride || 8) / l
    for (let f = c; f < n.length; f += h) {
      let d = n[f],
        g = n[f + 1]
      ;(d > a && (a = d), g > u && (u = g), d < s && (s = d), g < o && (o = g))
    }
    return ((e.minX = s), (e.minY = o), (e.maxX = a), (e.maxY = u), e)
  }
  var V_ = p(() => {
    "use strict"
  })
  function vA(r) {
    return (
      (r instanceof wt || Array.isArray(r) || r.BYTES_PER_ELEMENT) && (r = { buffer: r }),
      (r.buffer = dh(r.buffer, !1)),
      r
    )
  }
  var _e,
    Ni = p(() => {
      Wt()
      se()
      Ot()
      Cr()
      z_()
      V_()
      _e = class extends lt {
        constructor(t = {}) {
          ;(super(),
            (this.uid = J("geometry")),
            (this._layoutKey = 0),
            (this.instanceCount = 1),
            (this._bounds = new ct()),
            (this._boundsDirty = !0))
          let { attributes: e, indexBuffer: i, topology: n } = t
          if (((this.buffers = []), (this.attributes = {}), e))
            for (let s in e) this.addAttribute(s, e[s])
          ;((this.instanceCount = t.instanceCount ?? 1),
            i && this.addIndex(i),
            (this.topology = n || "triangle-list"))
        }
        onBufferUpdate() {
          ;((this._boundsDirty = !0), this.emit("update", this))
        }
        getAttribute(t) {
          return this.attributes[t]
        }
        getIndex() {
          return this.indexBuffer
        }
        getBuffer(t) {
          return this.getAttribute(t).buffer
        }
        getSize() {
          for (let t in this.attributes) {
            let e = this.attributes[t]
            return e.buffer.data.length / (e.stride / 4 || e.size)
          }
          return 0
        }
        addAttribute(t, e) {
          let i = vA(e)
          ;(this.buffers.indexOf(i.buffer) === -1 &&
            (this.buffers.push(i.buffer),
            i.buffer.on("update", this.onBufferUpdate, this),
            i.buffer.on("change", this.onBufferUpdate, this)),
            (this.attributes[t] = i))
        }
        addIndex(t) {
          ;((this.indexBuffer = dh(t, !0)), this.buffers.push(this.indexBuffer))
        }
        get bounds() {
          return this._boundsDirty
            ? ((this._boundsDirty = !1), W_(this, "aPosition", this._bounds))
            : this._bounds
        }
        destroy(t = !1) {
          ;(this.emit("destroy", this),
            this.removeAllListeners(),
            t && this.buffers.forEach((e) => e.destroy()),
            (this.attributes = null),
            (this.buffers = null),
            (this.indexBuffer = null),
            (this._bounds = null))
        }
      }
    })
  var SA,
    TA,
    uu,
    $_ = p(() => {
      Cr()
      sr()
      Ni()
      ;((SA = new Float32Array(1)),
        (TA = new Uint32Array(1)),
        (uu = class extends _e {
          constructor() {
            let e = new wt({
                data: SA,
                label: "attribute-batch-buffer",
                usage: tt.VERTEX | tt.COPY_DST,
                shrinkToFit: !1,
              }),
              i = new wt({
                data: TA,
                label: "index-batch-buffer",
                usage: tt.INDEX | tt.COPY_DST,
                shrinkToFit: !1,
              }),
              n = 24
            super({
              attributes: {
                aPosition: { buffer: e, format: "float32x2", stride: n, offset: 0 },
                aUV: { buffer: e, format: "float32x2", stride: n, offset: 8 },
                aColor: { buffer: e, format: "unorm8x4", stride: n, offset: 16 },
                aTextureIdAndRound: { buffer: e, format: "uint16x2", stride: n, offset: 20 },
              },
              indexBuffer: i,
            })
          }
        }))
    })
  function or(r, t) {
    let e = X_[r]
    return (e === void 0 && (ph[t] === void 0 && (ph[t] = 1), (X_[r] = e = ph[t]++)), e)
  }
  var ph,
    X_,
    ys = p(() => {
      "use strict"
      ;((ph = Object.create(null)), (X_ = Object.create(null)))
    })
  function Y_() {
    if (!lu) {
      lu = "mediump"
      let r = su()
      r &&
        r.getShaderPrecisionFormat &&
        (lu = r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision
          ? "highp"
          : "mediump")
    }
    return lu
  }
  var lu,
    j_ = p(() => {
      lh()
    })
  function K_(r, t, e) {
    return t
      ? r
      : e
        ? ((r = r.replace("out vec4 finalColor;", "")),
          `

        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${r}
        `)
        : `

        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${r}
        `
  }
  var q_ = p(() => {
    "use strict"
  })
  function Z_(r, t, e) {
    let i = e ? t.maxSupportedFragmentPrecision : t.maxSupportedVertexPrecision
    if (r.substring(0, 9) !== "precision") {
      let n = e ? t.requestedFragmentPrecision : t.requestedVertexPrecision
      return (
        n === "highp" && i !== "highp" && (n = "mediump"),
        `precision ${n} float;
${r}`
      )
    } else if (i !== "highp" && r.substring(0, 15) === "precision highp")
      return r.replace("precision highp", "precision mediump")
    return r
  }
  var Q_ = p(() => {
    "use strict"
  })
  function J_(r, t) {
    return t
      ? `#version 300 es
${r}`
      : r
  }
  var ty = p(() => {
    "use strict"
  })
  function ey(r, { name: t = "pixi-program" }, e = !0) {
    ;((t = t.replace(/\s+/g, "-")), (t += e ? "-fragment" : "-vertex"))
    let i = e ? CA : EA
    return (
      i[t] ? (i[t]++, (t += `-${i[t]}`)) : (i[t] = 1),
      r.indexOf("#define SHADER_NAME") !== -1
        ? r
        : `${`#define SHADER_NAME ${t}`}
${r}`
    )
  }
  var CA,
    EA,
    ry = p(() => {
      "use strict"
      ;((CA = {}), (EA = {}))
    })
  function iy(r, t) {
    return t ? r.replace("#version 300 es", "") : r
  }
  var ny = p(() => {
    "use strict"
  })
  var mh,
    gh,
    sy,
    ye,
    oi = p(() => {
      ys()
      j_()
      q_()
      Q_()
      ty()
      ry()
      ny()
      ;((mh = {
        stripVersion: iy,
        ensurePrecision: Z_,
        addProgramDefines: K_,
        setProgramName: ey,
        insertVersion: J_,
      }),
        (gh = Object.create(null)),
        (sy = class xh {
          constructor(t) {
            t = { ...xh.defaultOptions, ...t }
            let e = t.fragment.indexOf("#version 300 es") !== -1,
              i = {
                stripVersion: e,
                ensurePrecision: {
                  requestedFragmentPrecision: t.preferredFragmentPrecision,
                  requestedVertexPrecision: t.preferredVertexPrecision,
                  maxSupportedVertexPrecision: "highp",
                  maxSupportedFragmentPrecision: Y_(),
                },
                setProgramName: { name: t.name },
                addProgramDefines: e,
                insertVersion: e,
              },
              n = t.fragment,
              s = t.vertex
            ;(Object.keys(mh).forEach((o) => {
              let a = i[o]
              ;((n = mh[o](n, a, !0)), (s = mh[o](s, a, !1)))
            }),
              (this.fragment = n),
              (this.vertex = s),
              (this.transformFeedbackVaryings = t.transformFeedbackVaryings),
              (this._key = or(`${this.vertex}:${this.fragment}`, "gl-program")))
          }
          destroy() {
            ;((this.fragment = null),
              (this.vertex = null),
              (this._attributeData = null),
              (this._uniformData = null),
              (this._uniformBlockData = null),
              (this.transformFeedbackVaryings = null))
          }
          static from(t) {
            let e = `${t.vertex}:${t.fragment}`
            return (gh[e] || (gh[e] = new xh(t)), gh[e])
          }
        }))
      sy.defaultOptions = {
        preferredVertexPrecision: "highp",
        preferredFragmentPrecision: "mediump",
      }
      ye = sy
    })
  function ae(r) {
    return oy[r] ?? oy.float32
  }
  var oy,
    ai = p(() => {
      "use strict"
      oy = {
        uint8x2: { size: 2, stride: 2, normalised: !1 },
        uint8x4: { size: 4, stride: 4, normalised: !1 },
        sint8x2: { size: 2, stride: 2, normalised: !1 },
        sint8x4: { size: 4, stride: 4, normalised: !1 },
        unorm8x2: { size: 2, stride: 2, normalised: !0 },
        unorm8x4: { size: 4, stride: 4, normalised: !0 },
        snorm8x2: { size: 2, stride: 2, normalised: !0 },
        snorm8x4: { size: 4, stride: 4, normalised: !0 },
        uint16x2: { size: 2, stride: 4, normalised: !1 },
        uint16x4: { size: 4, stride: 8, normalised: !1 },
        sint16x2: { size: 2, stride: 4, normalised: !1 },
        sint16x4: { size: 4, stride: 8, normalised: !1 },
        unorm16x2: { size: 2, stride: 4, normalised: !0 },
        unorm16x4: { size: 4, stride: 8, normalised: !0 },
        snorm16x2: { size: 2, stride: 4, normalised: !0 },
        snorm16x4: { size: 4, stride: 8, normalised: !0 },
        float16x2: { size: 2, stride: 4, normalised: !1 },
        float16x4: { size: 4, stride: 8, normalised: !1 },
        float32: { size: 1, stride: 4, normalised: !1 },
        float32x2: { size: 2, stride: 8, normalised: !1 },
        float32x3: { size: 3, stride: 12, normalised: !1 },
        float32x4: { size: 4, stride: 16, normalised: !1 },
        uint32: { size: 1, stride: 4, normalised: !1 },
        uint32x2: { size: 2, stride: 8, normalised: !1 },
        uint32x3: { size: 3, stride: 12, normalised: !1 },
        uint32x4: { size: 4, stride: 16, normalised: !1 },
        sint32: { size: 1, stride: 4, normalised: !1 },
        sint32x2: { size: 2, stride: 8, normalised: !1 },
        sint32x3: { size: 3, stride: 12, normalised: !1 },
        sint32x4: { size: 4, stride: 16, normalised: !1 },
      }
    })
  function ay({ source: r, entryPoint: t }) {
    let e = {},
      i = r.indexOf(`fn ${t}`)
    if (i !== -1) {
      let n = r.indexOf("->", i)
      if (n !== -1) {
        let s = r.substring(i, n),
          o = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g,
          a
        for (; (a = o.exec(s)) !== null; ) {
          let u = wA[a[3]] ?? "float32"
          e[a[2]] = {
            location: parseInt(a[1], 10),
            format: u,
            stride: ae(u).stride,
            offset: 0,
            instance: !1,
            start: 0,
          }
        }
      }
    }
    return e
  }
  var wA,
    uy = p(() => {
      ai()
      wA = {
        f32: "float32",
        "vec2<f32>": "float32x2",
        "vec3<f32>": "float32x3",
        "vec4<f32>": "float32x4",
        vec2f: "float32x2",
        vec3f: "float32x3",
        vec4f: "float32x4",
        i32: "sint32",
        "vec2<i32>": "sint32x2",
        "vec3<i32>": "sint32x3",
        "vec4<i32>": "sint32x4",
        u32: "uint32",
        "vec2<u32>": "uint32x2",
        "vec3<u32>": "uint32x3",
        "vec4<u32>": "uint32x4",
        bool: "uint32",
        "vec2<bool>": "uint32x2",
        "vec3<bool>": "uint32x3",
        "vec4<bool>": "uint32x4",
      }
    })
  function cu(r) {
    let t = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g,
      e = /@group\((\d+)\)/,
      i = /@binding\((\d+)\)/,
      n = /var(<[^>]+>)? (\w+)/,
      s = /:\s*(\w+)/,
      o = /struct\s+(\w+)\s*{([^}]+)}/g,
      a = /(\w+)\s*:\s*([\w\<\>]+)/g,
      u = /struct\s+(\w+)/,
      l = r
        .match(t)
        ?.map((h) => ({
          group: parseInt(h.match(e)[1], 10),
          binding: parseInt(h.match(i)[1], 10),
          name: h.match(n)[2],
          isUniform: h.match(n)[1] === "<uniform>",
          type: h.match(s)[1],
        }))
    if (!l) return { groups: [], structs: [] }
    let c =
      r
        .match(o)
        ?.map((h) => {
          let f = h.match(u)[1],
            d = h.match(a).reduce((g, x) => {
              let [m, _] = x.split(":")
              return ((g[m.trim()] = _.trim()), g)
            }, {})
          return d ? { name: f, members: d } : null
        })
        .filter(({ name: h }) => l.some((f) => f.type === h)) ?? []
    return { groups: l, structs: c }
  }
  var ly = p(() => {
    "use strict"
  })
  var Hi,
    cy = p(() => {
      "use strict"
      Hi = ((r) => (
        (r[(r.VERTEX = 1)] = "VERTEX"),
        (r[(r.FRAGMENT = 2)] = "FRAGMENT"),
        (r[(r.COMPUTE = 4)] = "COMPUTE"),
        r
      ))(Hi || {})
    })
  function hy({ groups: r }) {
    let t = []
    for (let e = 0; e < r.length; e++) {
      let i = r[e]
      ;(t[i.group] || (t[i.group] = []),
        i.isUniform
          ? t[i.group].push({
              binding: i.binding,
              visibility: Hi.VERTEX | Hi.FRAGMENT,
              buffer: { type: "uniform" },
            })
          : i.type === "sampler"
            ? t[i.group].push({
                binding: i.binding,
                visibility: Hi.FRAGMENT,
                sampler: { type: "filtering" },
              })
            : i.type === "texture_2d" &&
              t[i.group].push({
                binding: i.binding,
                visibility: Hi.FRAGMENT,
                texture: { sampleType: "float", viewDimension: "2d", multisampled: !1 },
              }))
    }
    return t
  }
  var fy = p(() => {
    cy()
  })
  function dy({ groups: r }) {
    let t = []
    for (let e = 0; e < r.length; e++) {
      let i = r[e]
      ;(t[i.group] || (t[i.group] = {}), (t[i.group][i.name] = i.binding))
    }
    return t
  }
  var py = p(() => {
    "use strict"
  })
  function my(r, t) {
    let e = new Set(),
      i = new Set(),
      n = [...r.structs, ...t.structs].filter((o) => (e.has(o.name) ? !1 : (e.add(o.name), !0))),
      s = [...r.groups, ...t.groups].filter((o) => {
        let a = `${o.name}-${o.binding}`
        return i.has(a) ? !1 : (i.add(a), !0)
      })
    return { structs: n, groups: s }
  }
  var gy = p(() => {
    "use strict"
  })
  var _h,
    be,
    zi = p(() => {
      ys()
      uy()
      ly()
      fy()
      py()
      gy()
      ;((_h = Object.create(null)),
        (be = class r {
          constructor(t) {
            ;((this._layoutKey = 0), (this._attributeLocationsKey = 0))
            let { fragment: e, vertex: i, layout: n, gpuLayout: s, name: o } = t
            if (((this.name = o), (this.fragment = e), (this.vertex = i), e.source === i.source)) {
              let a = cu(e.source)
              this.structsAndGroups = a
            } else {
              let a = cu(i.source),
                u = cu(e.source)
              this.structsAndGroups = my(a, u)
            }
            ;((this.layout = n ?? dy(this.structsAndGroups)),
              (this.gpuLayout = s ?? hy(this.structsAndGroups)),
              (this.autoAssignGlobalUniforms = this.layout[0]?.globalUniforms !== void 0),
              (this.autoAssignLocalUniforms = this.layout[1]?.localUniforms !== void 0),
              this._generateProgramKey())
          }
          _generateProgramKey() {
            let { vertex: t, fragment: e } = this,
              i = t.source + e.source + t.entryPoint + e.entryPoint
            this._layoutKey = or(i, "program")
          }
          get attributeData() {
            return (
              this._attributeData ?? (this._attributeData = ay(this.vertex)),
              this._attributeData
            )
          }
          destroy() {
            ;((this.gpuLayout = null),
              (this.layout = null),
              (this.structsAndGroups = null),
              (this.fragment = null),
              (this.vertex = null))
          }
          static from(t) {
            let e = `${t.vertex.source}:${t.fragment.source}:${t.fragment.entryPoint}:${t.vertex.entryPoint}`
            return (_h[e] || (_h[e] = new r(t)), _h[e])
          }
        }))
    })
  function yh(r, t, e) {
    if (r)
      for (let i in r) {
        let n = i.toLocaleLowerCase(),
          s = t[n]
        if (s) {
          let o = r[i]
          ;(i === "header" &&
            (o = o.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "")),
            e && s.push(`//----${e}----//`),
            s.push(o))
        } else N(`${i} placement hook does not exist in shader`)
      }
  }
  var xy = p(() => {
    ft()
  })
  function bh(r) {
    let t = {}
    return (
      (r.match(MA)?.map((i) => i.replace(/[{()}]/g, "")) ?? []).forEach((i) => {
        t[i] = []
      }),
      t
    )
  }
  var MA,
    _y = p(() => {
      "use strict"
      MA = /\{\{(.*?)\}\}/g
    })
  function yy(r, t) {
    let e,
      i = /@in\s+([^;]+);/g
    for (; (e = i.exec(r)) !== null; ) t.push(e[1])
  }
  function vh(r, t, e = !1) {
    let i = []
    ;(yy(t, i),
      r.forEach((a) => {
        a.header && yy(a.header, i)
      }))
    let n = i
    e && n.sort()
    let s = n.map((a, u) => `       @location(${u}) ${a},`).join(`
`),
      o = t.replace(/@in\s+[^;]+;\s*/g, "")
    return (
      (o = o.replace(
        "{{in}}",
        `
${s}
`,
      )),
      o
    )
  }
  var by = p(() => {
    "use strict"
  })
  function vy(r, t) {
    let e,
      i = /@out\s+([^;]+);/g
    for (; (e = i.exec(r)) !== null; ) t.push(e[1])
  }
  function AA(r) {
    let e = /\b(\w+)\s*:/g.exec(r)
    return e ? e[1] : ""
  }
  function DA(r) {
    let t = /@.*?\s+/g
    return r.replace(t, "")
  }
  function Sy(r, t) {
    let e = []
    ;(vy(t, e),
      r.forEach((u) => {
        u.header && vy(u.header, e)
      }))
    let i = 0,
      n = e.sort().map((u) => (u.indexOf("builtin") > -1 ? u : `@location(${i++}) ${u}`)).join(`,
`),
      s = e.sort().map((u) => `       var ${DA(u)};`).join(`
`),
      o = `return VSOutput(
            ${e.sort().map((u) => ` ${AA(u)}`).join(`,
`)});`,
      a = t.replace(/@out\s+[^;]+;\s*/g, "")
    return (
      (a = a.replace(
        "{{struct}}",
        `
${n}
`,
      )),
      (a = a.replace(
        "{{start}}",
        `
${s}
`,
      )),
      (a = a.replace(
        "{{return}}",
        `
${o}
`,
      )),
      a
    )
  }
  var Ty = p(() => {
    "use strict"
  })
  function Sh(r, t) {
    let e = r
    for (let i in t) {
      let n = t[i]
      n.join(`
`).length
        ? (e = e.replace(
            `{{${i}}}`,
            `//-----${i} START-----//
${n.join(`
`)}
//----${i} FINISH----//`,
          ))
        : (e = e.replace(`{{${i}}}`, ""))
    }
    return e
  }
  var Cy = p(() => {
    "use strict"
  })
  function Ey({ template: r, bits: t }) {
    let e = My(r, t)
    if (Er[e]) return Er[e]
    let { vertex: i, fragment: n } = FA(r, t)
    return ((Er[e] = Ay(i, n, t)), Er[e])
  }
  function wy({ template: r, bits: t }) {
    let e = My(r, t)
    return (Er[e] || (Er[e] = Ay(r.vertex, r.fragment, t)), Er[e])
  }
  function FA(r, t) {
    let e = t.map((o) => o.vertex).filter((o) => !!o),
      i = t.map((o) => o.fragment).filter((o) => !!o),
      n = vh(e, r.vertex, !0)
    n = Sy(e, n)
    let s = vh(i, r.fragment, !0)
    return { vertex: n, fragment: s }
  }
  function My(r, t) {
    return (
      t
        .map((e) => (Th.has(e) || Th.set(e, PA++), Th.get(e)))
        .sort((e, i) => e - i)
        .join("-") +
      r.vertex +
      r.fragment
    )
  }
  function Ay(r, t, e) {
    let i = bh(r),
      n = bh(t)
    return (
      e.forEach((s) => {
        ;(yh(s.vertex, i, s.name), yh(s.fragment, n, s.name))
      }),
      { vertex: Sh(r, i), fragment: Sh(t, n) }
    )
  }
  var Er,
    Th,
    PA,
    Dy = p(() => {
      xy()
      _y()
      by()
      Ty()
      Cy()
      ;((Er = Object.create(null)), (Th = new Map()), (PA = 0))
    })
  var Py,
    Fy,
    Ry,
    By,
    Iy = p(() => {
      "use strict"
      ;((Py = `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}

        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);

        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`),
        (Fy = `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;

    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {

        {{start}}

        var outColor:vec4<f32>;

        {{main}}

        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`),
        (Ry = `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;

        {{start}}

        vColor = vec4(1.);

        {{main}}

        vUV = uv;

        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`),
        (By = `

    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {

        {{start}}

        vec4 outColor;

        {{main}}

        finalColor = outColor * vColor;

        {{end}}
    }
`))
    })
  var ky,
    Gy,
    Uy = p(() => {
      "use strict"
      ;((ky = {
        name: "global-uniforms-bit",
        vertex: {
          header: `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `,
        },
      }),
        (Gy = {
          name: "global-uniforms-bit",
          vertex: {
            header: `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `,
          },
        }))
    })
  function ke({ bits: r, name: t }) {
    let e = Ey({ template: { fragment: Fy, vertex: Py }, bits: [ky, ...r] })
    return be.from({
      name: t,
      vertex: { source: e.vertex, entryPoint: "main" },
      fragment: { source: e.fragment, entryPoint: "main" },
    })
  }
  function Ge({ bits: r, name: t }) {
    return new ye({ name: t, ...wy({ template: { vertex: Ry, fragment: By }, bits: [Gy, ...r] }) })
  }
  var wr = p(() => {
    oi()
    zi()
    Dy()
    Iy()
    Uy()
  })
  var Wi,
    Vi,
    bs = p(() => {
      "use strict"
      ;((Wi = {
        name: "color-bit",
        vertex: {
          header: `
            @in aColor: vec4<f32>;
        `,
          main: `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `,
        },
      }),
        (Vi = {
          name: "color-bit",
          vertex: {
            header: `
            in vec4 aColor;
        `,
            main: `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `,
          },
        }))
    })
  function RA(r) {
    let t = []
    if (r === 1)
      (t.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"),
        t.push("@group(1) @binding(1) var textureSampler1: sampler;"))
    else {
      let e = 0
      for (let i = 0; i < r; i++)
        (t.push(`@group(1) @binding(${e++}) var textureSource${i + 1}: texture_2d<f32>;`),
          t.push(`@group(1) @binding(${e++}) var textureSampler${i + 1}: sampler;`))
    }
    return t.join(`
`)
  }
  function BA(r) {
    let t = []
    if (r === 1)
      t.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);")
    else {
      t.push("switch vTextureId {")
      for (let e = 0; e < r; e++)
        (e === r - 1 ? t.push("  default:{") : t.push(`  case ${e}:{`),
          t.push(
            `      outColor = textureSampleGrad(textureSource${e + 1}, textureSampler${e + 1}, vUV, uvDx, uvDy);`,
          ),
          t.push("      break;}"))
      t.push("}")
    }
    return t.join(`
`)
  }
  function $i(r) {
    return (
      Ch[r] ||
        (Ch[r] = {
          name: "texture-batch-bit",
          vertex: {
            header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
            main: `
                vTextureId = aTextureIdAndRound.y;
            `,
            end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `,
          },
          fragment: {
            header: `
                @in @interpolate(flat) vTextureId: u32;

                ${RA(r)}
            `,
            main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${BA(r)}
            `,
          },
        }),
      Ch[r]
    )
  }
  function IA(r) {
    let t = []
    for (let e = 0; e < r; e++)
      (e > 0 && t.push("else"),
        e < r - 1 && t.push(`if(vTextureId < ${e}.5)`),
        t.push("{"),
        t.push(`	outColor = texture(uTextures[${e}], vUV);`),
        t.push("}"))
    return t.join(`
`)
  }
  function Xi(r) {
    return (
      Eh[r] ||
        (Eh[r] = {
          name: "texture-batch-bit",
          vertex: {
            header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
            main: `
                vTextureId = aTextureIdAndRound.y;
            `,
            end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `,
          },
          fragment: {
            header: `
                in float vTextureId;

                uniform sampler2D uTextures[${r}];

            `,
            main: `

                ${IA(r)}
            `,
          },
        }),
      Eh[r]
    )
  }
  var Ch,
    Eh,
    vs = p(() => {
      "use strict"
      Ch = {}
      Eh = {}
    })
  var Ue,
    Oe,
    Mr = p(() => {
      "use strict"
      ;((Ue = {
        name: "round-pixels-bit",
        vertex: {
          header: `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `,
        },
      }),
        (Oe = {
          name: "round-pixels-bit",
          vertex: {
            header: `
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `,
          },
        }))
    })
  var wh,
    Oy,
    Ly = p(() => {
      "use strict"
      ;((wh = [
        "f32",
        "i32",
        "vec2<f32>",
        "vec3<f32>",
        "vec4<f32>",
        "mat2x2<f32>",
        "mat3x3<f32>",
        "mat4x4<f32>",
        "mat3x2<f32>",
        "mat4x2<f32>",
        "mat2x3<f32>",
        "mat4x3<f32>",
        "mat2x4<f32>",
        "mat3x4<f32>",
        "vec2<i32>",
        "vec3<i32>",
        "vec4<i32>",
      ]),
        (Oy = wh.reduce((r, t) => ((r[t] = !0), r), {})))
    })
  function Ny(r, t) {
    switch (r) {
      case "f32":
        return 0
      case "vec2<f32>":
        return new Float32Array(2 * t)
      case "vec3<f32>":
        return new Float32Array(3 * t)
      case "vec4<f32>":
        return new Float32Array(4 * t)
      case "mat2x2<f32>":
        return new Float32Array([1, 0, 0, 1])
      case "mat3x3<f32>":
        return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1])
      case "mat4x4<f32>":
        return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
    }
    return null
  }
  var Hy = p(() => {
    "use strict"
  })
  var zy,
    ht,
    re = p(() => {
      Ot()
      ys()
      Ly()
      Hy()
      zy = class Wy {
        constructor(t, e) {
          ;((this._touched = 0),
            (this.uid = J("uniform")),
            (this._resourceType = "uniformGroup"),
            (this._resourceId = J("resource")),
            (this.isUniformGroup = !0),
            (this._dirtyId = 0),
            (this.destroyed = !1),
            (e = { ...Wy.defaultOptions, ...e }),
            (this.uniformStructures = t))
          let i = {}
          for (let n in t) {
            let s = t[n]
            if (((s.name = n), (s.size = s.size ?? 1), !Oy[s.type]))
              throw new Error(
                `Uniform type ${s.type} is not supported. Supported uniform types are: ${wh.join(", ")}`,
              )
            ;(s.value ?? (s.value = Ny(s.type, s.size)), (i[n] = s.value))
          }
          ;((this.uniforms = i),
            (this._dirtyId = 1),
            (this.ubo = e.ubo),
            (this.isStatic = e.isStatic),
            (this._signature = or(
              Object.keys(i)
                .map((n) => `${n}-${t[n].type}`)
                .join("-"),
              "uniform-group",
            )))
        }
        update() {
          this._dirtyId++
        }
      }
      zy.defaultOptions = { ubo: !1, isStatic: !1 }
      ht = zy
    })
  function Yi(r) {
    let t = Vy[r]
    if (t) return t
    let e = new Int32Array(r)
    for (let i = 0; i < r; i++) e[i] = i
    return (
      (t = Vy[r] = new ht({ uTextures: { value: e, type: "i32", size: r } }, { isStatic: !0 })),
      t
    )
  }
  var Vy,
    hu = p(() => {
      re()
      Vy = {}
    })
  var Bt,
    Le = p(() => {
      "use strict"
      Bt = ((r) => (
        (r[(r.WEBGL = 1)] = "WEBGL"),
        (r[(r.WEBGPU = 2)] = "WEBGPU"),
        (r[(r.BOTH = 3)] = "BOTH"),
        r
      ))(Bt || {})
    })
  var Mt,
    Ae = p(() => {
      Wt()
      Ot()
      oi()
      Tr()
      zi()
      Le()
      re()
      Mt = class r extends lt {
        constructor(t) {
          ;(super(),
            (this.uid = J("shader")),
            (this._uniformBindMap = Object.create(null)),
            (this._ownedBindGroups = []))
          let {
            gpuProgram: e,
            glProgram: i,
            groups: n,
            resources: s,
            compatibleRenderers: o,
            groupMap: a,
          } = t
          ;((this.gpuProgram = e),
            (this.glProgram = i),
            o === void 0 && ((o = 0), e && (o |= Bt.WEBGPU), i && (o |= Bt.WEBGL)),
            (this.compatibleRenderers = o))
          let u = {}
          if ((!s && !n && (s = {}), s && n))
            throw new Error("[Shader] Cannot have both resources and groups")
          if (!e && n && !a)
            throw new Error(
              "[Shader] No group map or WebGPU shader provided - consider using resources instead.",
            )
          if (!e && n && a)
            for (let l in a)
              for (let c in a[l]) {
                let h = a[l][c]
                u[h] = { group: l, binding: c, name: h }
              }
          else if (e && n && !a) {
            let l = e.structsAndGroups.groups
            ;((a = {}),
              l.forEach((c) => {
                ;((a[c.group] = a[c.group] || {}),
                  (a[c.group][c.binding] = c.name),
                  (u[c.name] = c))
              }))
          } else if (s) {
            ;((n = {}),
              (a = {}),
              e &&
                e.structsAndGroups.groups.forEach((h) => {
                  ;((a[h.group] = a[h.group] || {}),
                    (a[h.group][h.binding] = h.name),
                    (u[h.name] = h))
                }))
            let l = 0
            for (let c in s)
              u[c] ||
                (n[99] || ((n[99] = new Nt()), this._ownedBindGroups.push(n[99])),
                (u[c] = { group: 99, binding: l, name: c }),
                (a[99] = a[99] || {}),
                (a[99][l] = c),
                l++)
            for (let c in s) {
              let h = c,
                f = s[c]
              !f.source && !f._resourceType && (f = new ht(f))
              let d = u[h]
              d &&
                (n[d.group] || ((n[d.group] = new Nt()), this._ownedBindGroups.push(n[d.group])),
                n[d.group].setResource(f, d.binding))
            }
          }
          ;((this.groups = n),
            (this._uniformBindMap = a),
            (this.resources = this._buildResourceAccessor(n, u)))
        }
        addResource(t, e, i) {
          var n, s
          ;((n = this._uniformBindMap)[e] || (n[e] = {}),
            (s = this._uniformBindMap[e])[i] || (s[i] = t),
            this.groups[e] ||
              ((this.groups[e] = new Nt()), this._ownedBindGroups.push(this.groups[e])))
        }
        _buildResourceAccessor(t, e) {
          let i = {}
          for (let n in e) {
            let s = e[n]
            Object.defineProperty(i, s.name, {
              get() {
                return t[s.group].getResource(s.binding)
              },
              set(o) {
                t[s.group].setResource(o, s.binding)
              },
            })
          }
          return i
        }
        destroy(t = !1) {
          ;(this.emit("destroy", this),
            t && (this.gpuProgram?.destroy(), this.glProgram?.destroy()),
            (this.gpuProgram = null),
            (this.glProgram = null),
            this.removeAllListeners(),
            (this._uniformBindMap = null),
            this._ownedBindGroups.forEach((e) => {
              e.destroy()
            }),
            (this._ownedBindGroups = null),
            (this.resources = null),
            (this.groups = null))
        }
        static from(t) {
          let { gpu: e, gl: i, ...n } = t,
            s,
            o
          return (
            e && (s = be.from(e)),
            i && (o = ye.from(i)),
            new r({ gpuProgram: s, glProgram: o, ...n })
          )
        }
      }
    })
  var fu,
    $y = p(() => {
      wr()
      bs()
      vs()
      Mr()
      hu()
      Ae()
      fu = class extends Mt {
        constructor(t) {
          let e = Ge({ name: "batch", bits: [Vi, Xi(t), Oe] }),
            i = ke({ name: "batch", bits: [Wi, $i(t), Ue] })
          super({ glProgram: e, gpuProgram: i, resources: { batchSamplers: Yi(t) } })
        }
      }
    })
  var Mh,
    Xy,
    Ss,
    Ah = p(() => {
      A()
      H_()
      $_()
      $y()
      ;((Mh = null),
        (Xy = class Yy extends N_ {
          constructor(t) {
            ;(super(t),
              (this.geometry = new uu()),
              (this.name = Yy.extension.name),
              (this.vertexSize = 6),
              Mh ?? (Mh = new fu(t.maxTextures)),
              (this.shader = Mh))
          }
          packAttributes(t, e, i, n, s) {
            let o = (s << 16) | (t.roundPixels & 65535),
              a = t.transform,
              u = a.a,
              l = a.b,
              c = a.c,
              h = a.d,
              f = a.tx,
              d = a.ty,
              { positions: g, uvs: x } = t,
              m = t.color,
              _ = t.attributeOffset,
              v = _ + t.attributeSize
            for (let S = _; S < v; S++) {
              let y = S * 2,
                M = g[y],
                T = g[y + 1]
              ;((e[n++] = u * M + c * T + f),
                (e[n++] = h * T + l * M + d),
                (e[n++] = x[y]),
                (e[n++] = x[y + 1]),
                (i[n++] = m),
                (i[n++] = o))
            }
          }
          packQuadAttributes(t, e, i, n, s) {
            let o = t.texture,
              a = t.transform,
              u = a.a,
              l = a.b,
              c = a.c,
              h = a.d,
              f = a.tx,
              d = a.ty,
              g = t.bounds,
              x = g.maxX,
              m = g.minX,
              _ = g.maxY,
              v = g.minY,
              S = o.uvs,
              y = t.color,
              M = (s << 16) | (t.roundPixels & 65535)
            ;((e[n + 0] = u * m + c * v + f),
              (e[n + 1] = h * v + l * m + d),
              (e[n + 2] = S.x0),
              (e[n + 3] = S.y0),
              (i[n + 4] = y),
              (i[n + 5] = M),
              (e[n + 6] = u * x + c * v + f),
              (e[n + 7] = h * v + l * x + d),
              (e[n + 8] = S.x1),
              (e[n + 9] = S.y1),
              (i[n + 10] = y),
              (i[n + 11] = M),
              (e[n + 12] = u * x + c * _ + f),
              (e[n + 13] = h * _ + l * x + d),
              (e[n + 14] = S.x2),
              (e[n + 15] = S.y2),
              (i[n + 16] = y),
              (i[n + 17] = M),
              (e[n + 18] = u * m + c * _ + f),
              (e[n + 19] = h * _ + l * m + d),
              (e[n + 20] = S.x3),
              (e[n + 21] = S.y3),
              (i[n + 22] = y),
              (i[n + 23] = M))
          }
        }))
      Xy.extension = { type: [b.Batcher], name: "default" }
      Ss = Xy
    })
  function jy(r, t, e, i, n, s, o, a = null) {
    let u = 0
    ;((e *= t), (n *= s))
    let l = a.a,
      c = a.b,
      h = a.c,
      f = a.d,
      d = a.tx,
      g = a.ty
    for (; u < o; ) {
      let x = r[e],
        m = r[e + 1]
      ;((i[n] = l * x + h * m + d), (i[n + 1] = c * x + f * m + g), (n += s), (e += t), u++)
    }
  }
  function Ky(r, t, e, i) {
    let n = 0
    for (t *= e; n < i; ) ((r[t] = 0), (r[t + 1] = 0), (t += e), n++)
  }
  var qy = p(() => {
    "use strict"
  })
  function Dh(r, t, e, i, n) {
    let s = t.a,
      o = t.b,
      a = t.c,
      u = t.d,
      l = t.tx,
      c = t.ty
    ;(e || (e = 0), i || (i = 2), n || (n = r.length / i - e))
    let h = e * i
    for (let f = 0; f < n; f++) {
      let d = r[h],
        g = r[h + 1]
      ;((r[h] = s * d + a * g + l), (r[h + 1] = o * d + u * g + c), (h += i))
    }
  }
  var Zy = p(() => {
    "use strict"
  })
  var kA,
    ui,
    Ph = p(() => {
      nt()
      Sc()
      ;((kA = new I()),
        (ui = class {
          constructor() {
            ;((this.packAsQuad = !1),
              (this.batcherName = "default"),
              (this.topology = "triangle-list"),
              (this.applyTransform = !0),
              (this.roundPixels = 0),
              (this._batcher = null),
              (this._batch = null))
          }
          get uvs() {
            return this.geometryData.uvs
          }
          get positions() {
            return this.geometryData.vertices
          }
          get indices() {
            return this.geometryData.indices
          }
          get blendMode() {
            return this.renderable && this.applyTransform
              ? this.renderable.groupBlendMode
              : "normal"
          }
          get color() {
            let t = this.baseColor,
              e = (t >> 16) | (t & 65280) | ((t & 255) << 16),
              i = this.renderable
            return i
              ? ka(e, i.groupColor) + ((this.alpha * i.groupAlpha * 255) << 24)
              : e + ((this.alpha * 255) << 24)
          }
          get transform() {
            return this.renderable?.groupTransform || kA
          }
          copyTo(t) {
            ;((t.indexOffset = this.indexOffset),
              (t.indexSize = this.indexSize),
              (t.attributeOffset = this.attributeOffset),
              (t.attributeSize = this.attributeSize),
              (t.baseColor = this.baseColor),
              (t.alpha = this.alpha),
              (t.texture = this.texture),
              (t.geometryData = this.geometryData),
              (t.topology = this.topology))
          }
          reset() {
            ;((this.applyTransform = !0),
              (this.renderable = null),
              (this.topology = "triangle-list"))
          }
        }))
    })
  var ji,
    Qy,
    Jy,
    t0 = p(() => {
      A()
      ;((ji = {
        extension: { type: b.ShapeBuilder, name: "circle" },
        build(r, t) {
          let e, i, n, s, o, a
          if (r.type === "circle") {
            let y = r
            if (((o = a = y.radius), o <= 0)) return !1
            ;((e = y.x), (i = y.y), (n = s = 0))
          } else if (r.type === "ellipse") {
            let y = r
            if (((o = y.halfWidth), (a = y.halfHeight), o <= 0 || a <= 0)) return !1
            ;((e = y.x), (i = y.y), (n = s = 0))
          } else {
            let y = r,
              M = y.width / 2,
              T = y.height / 2
            ;((e = y.x + M),
              (i = y.y + T),
              (o = a = Math.max(0, Math.min(y.radius, Math.min(M, T)))),
              (n = M - o),
              (s = T - a))
          }
          if (n < 0 || s < 0) return !1
          let u = Math.ceil(2.3 * Math.sqrt(o + a)),
            l = u * 8 + (n ? 4 : 0) + (s ? 4 : 0)
          if (l === 0) return !1
          if (u === 0)
            return (
              (t[0] = t[6] = e + n),
              (t[1] = t[3] = i + s),
              (t[2] = t[4] = e - n),
              (t[5] = t[7] = i - s),
              !0
            )
          let c = 0,
            h = u * 4 + (n ? 2 : 0) + 2,
            f = h,
            d = l,
            g = n + o,
            x = s,
            m = e + g,
            _ = e - g,
            v = i + x
          if (((t[c++] = m), (t[c++] = v), (t[--h] = v), (t[--h] = _), s)) {
            let y = i - x
            ;((t[f++] = _), (t[f++] = y), (t[--d] = y), (t[--d] = m))
          }
          for (let y = 1; y < u; y++) {
            let M = (Math.PI / 2) * (y / u),
              T = n + Math.cos(M) * o,
              E = s + Math.sin(M) * a,
              G = e + T,
              B = e - T,
              P = i + E,
              F = i - E
            ;((t[c++] = G),
              (t[c++] = P),
              (t[--h] = P),
              (t[--h] = B),
              (t[f++] = B),
              (t[f++] = F),
              (t[--d] = F),
              (t[--d] = G))
          }
          ;((g = n), (x = s + a), (m = e + g), (_ = e - g), (v = i + x))
          let S = i - x
          return (
            (t[c++] = m),
            (t[c++] = v),
            (t[--d] = S),
            (t[--d] = m),
            n && ((t[c++] = _), (t[c++] = v), (t[--d] = S), (t[--d] = _)),
            !0
          )
        },
        triangulate(r, t, e, i, n, s) {
          if (r.length === 0) return
          let o = 0,
            a = 0
          for (let c = 0; c < r.length; c += 2) ((o += r[c]), (a += r[c + 1]))
          ;((o /= r.length / 2), (a /= r.length / 2))
          let u = i
          ;((t[u * e] = o), (t[u * e + 1] = a))
          let l = u++
          for (let c = 0; c < r.length; c += 2)
            ((t[u * e] = r[c]),
              (t[u * e + 1] = r[c + 1]),
              c > 0 && ((n[s++] = u), (n[s++] = l), (n[s++] = u - 1)),
              u++)
          ;((n[s++] = l + 1), (n[s++] = l), (n[s++] = u - 1))
        },
      }),
        (Qy = { ...ji, extension: { ...ji.extension, name: "ellipse" } }),
        (Jy = { ...ji, extension: { ...ji.extension, name: "roundedRectangle" } }))
    })
  function e0(r) {
    let t = r.length
    if (t < 6) return 1
    let e = 0
    for (let i = 0, n = r[t - 2], s = r[t - 1]; i < t; i += 2) {
      let o = r[i],
        a = r[i + 1]
      ;((e += (o - n) * (a + s)), (n = o), (s = a))
    }
    return e < 0 ? -1 : 1
  }
  var r0 = p(() => {
    "use strict"
  })
  function i0(r, t, e, i, n, s, o, a) {
    let u = r - e * n,
      l = t - i * n,
      c = r + e * s,
      h = t + i * s,
      f,
      d
    o ? ((f = i), (d = -e)) : ((f = -i), (d = e))
    let g = u + f,
      x = l + d,
      m = c + f,
      _ = h + d
    return (a.push(g, x), a.push(m, _), 2)
  }
  function li(r, t, e, i, n, s, o, a) {
    let u = e - r,
      l = i - t,
      c = Math.atan2(u, l),
      h = Math.atan2(n - r, s - t)
    a && c < h ? (c += Math.PI * 2) : !a && c > h && (h += Math.PI * 2)
    let f = c,
      d = h - c,
      g = Math.abs(d),
      x = Math.sqrt(u * u + l * l),
      m = (((15 * g * Math.sqrt(x)) / Math.PI) >> 0) + 1,
      _ = d / m
    if (((f += _), a)) {
      ;(o.push(r, t), o.push(e, i))
      for (let v = 1, S = f; v < m; v++, S += _)
        (o.push(r, t), o.push(r + Math.sin(S) * x, t + Math.cos(S) * x))
      ;(o.push(r, t), o.push(n, s))
    } else {
      ;(o.push(e, i), o.push(r, t))
      for (let v = 1, S = f; v < m; v++, S += _)
        (o.push(r + Math.sin(S) * x, t + Math.cos(S) * x), o.push(r, t))
      ;(o.push(n, s), o.push(r, t))
    }
    return m * 2
  }
  function n0(r, t, e, i, n, s) {
    let o = 1e-4
    if (r.length === 0) return
    let a = t,
      u = a.alignment
    if (t.alignment !== 0.5) {
      let O = e0(r)
      ;(e && (O *= -1), (u = (u - 0.5) * O + 0.5))
    }
    let l = new rt(r[0], r[1]),
      c = new rt(r[r.length - 2], r[r.length - 1]),
      h = i,
      f = Math.abs(l.x - c.x) < o && Math.abs(l.y - c.y) < o
    if (h) {
      ;((r = r.slice()), f && (r.pop(), r.pop(), c.set(r[r.length - 2], r[r.length - 1])))
      let O = (l.x + c.x) * 0.5,
        X = (c.y + l.y) * 0.5
      ;(r.unshift(O, X), r.push(O, X))
    }
    let d = n,
      g = r.length / 2,
      x = r.length,
      m = d.length / 2,
      _ = a.width / 2,
      v = _ * _,
      S = a.miterLimit * a.miterLimit,
      y = r[0],
      M = r[1],
      T = r[2],
      E = r[3],
      G = 0,
      B = 0,
      P = -(M - E),
      F = y - T,
      W = 0,
      j = 0,
      C = Math.sqrt(P * P + F * F)
    ;((P /= C), (F /= C), (P *= _), (F *= _))
    let H = u,
      w = (1 - H) * 2,
      D = H * 2
    ;(h ||
      (a.cap === "round"
        ? (x +=
            li(
              y - P * (w - D) * 0.5,
              M - F * (w - D) * 0.5,
              y - P * w,
              M - F * w,
              y + P * D,
              M + F * D,
              d,
              !0,
            ) + 2)
        : a.cap === "square" && (x += i0(y, M, P, F, w, D, !0, d))),
      d.push(y - P * w, M - F * w),
      d.push(y + P * D, M + F * D))
    for (let O = 1; O < g - 1; ++O) {
      ;((y = r[(O - 1) * 2]),
        (M = r[(O - 1) * 2 + 1]),
        (T = r[O * 2]),
        (E = r[O * 2 + 1]),
        (G = r[(O + 1) * 2]),
        (B = r[(O + 1) * 2 + 1]),
        (P = -(M - E)),
        (F = y - T),
        (C = Math.sqrt(P * P + F * F)),
        (P /= C),
        (F /= C),
        (P *= _),
        (F *= _),
        (W = -(E - B)),
        (j = T - G),
        (C = Math.sqrt(W * W + j * j)),
        (W /= C),
        (j /= C),
        (W *= _),
        (j *= _))
      let X = T - y,
        it = M - E,
        ut = T - G,
        It = B - E,
        vt = X * ut + it * It,
        U = it * ut - It * X,
        R = U < 0
      if (Math.abs(U) < 0.001 * Math.abs(vt)) {
        ;(d.push(T - P * w, E - F * w),
          d.push(T + P * D, E + F * D),
          vt >= 0 &&
            (a.join === "round"
              ? (x += li(T, E, T - P * w, E - F * w, T - W * w, E - j * w, d, !1) + 4)
              : (x += 2),
            d.push(T - W * D, E - j * D),
            d.push(T + W * w, E + j * w)))
        continue
      }
      let V = (-P + y) * (-F + E) - (-P + T) * (-F + M),
        at = (-W + G) * (-j + E) - (-W + T) * (-j + B),
        Ct = (X * at - ut * V) / U,
        hr = (It * V - it * at) / U,
        Sn = (Ct - T) * (Ct - T) + (hr - E) * (hr - E),
        Xe = T + (Ct - T) * w,
        Ir = E + (hr - E) * w,
        kr = T - (Ct - T) * D,
        Gr = E - (hr - E) * D,
        jE = Math.min(X * X + it * it, ut * ut + It * It),
        $d = R ? w : D,
        KE = jE + $d * $d * v
      Sn <= KE
        ? a.join === "bevel" || Sn / v > S
          ? (R
              ? (d.push(Xe, Ir),
                d.push(T + P * D, E + F * D),
                d.push(Xe, Ir),
                d.push(T + W * D, E + j * D))
              : (d.push(T - P * w, E - F * w),
                d.push(kr, Gr),
                d.push(T - W * w, E - j * w),
                d.push(kr, Gr)),
            (x += 2))
          : a.join === "round"
            ? R
              ? (d.push(Xe, Ir),
                d.push(T + P * D, E + F * D),
                (x += li(T, E, T + P * D, E + F * D, T + W * D, E + j * D, d, !0) + 4),
                d.push(Xe, Ir),
                d.push(T + W * D, E + j * D))
              : (d.push(T - P * w, E - F * w),
                d.push(kr, Gr),
                (x += li(T, E, T - P * w, E - F * w, T - W * w, E - j * w, d, !1) + 4),
                d.push(T - W * w, E - j * w),
                d.push(kr, Gr))
            : (d.push(Xe, Ir), d.push(kr, Gr))
        : (d.push(T - P * w, E - F * w),
          d.push(T + P * D, E + F * D),
          a.join === "round"
            ? R
              ? (x += li(T, E, T + P * D, E + F * D, T + W * D, E + j * D, d, !0) + 2)
              : (x += li(T, E, T - P * w, E - F * w, T - W * w, E - j * w, d, !1) + 2)
            : a.join === "miter" &&
              Sn / v <= S &&
              (R ? (d.push(kr, Gr), d.push(kr, Gr)) : (d.push(Xe, Ir), d.push(Xe, Ir)), (x += 2)),
          d.push(T - W * w, E - j * w),
          d.push(T + W * D, E + j * D),
          (x += 2))
    }
    ;((y = r[(g - 2) * 2]),
      (M = r[(g - 2) * 2 + 1]),
      (T = r[(g - 1) * 2]),
      (E = r[(g - 1) * 2 + 1]),
      (P = -(M - E)),
      (F = y - T),
      (C = Math.sqrt(P * P + F * F)),
      (P /= C),
      (F /= C),
      (P *= _),
      (F *= _),
      d.push(T - P * w, E - F * w),
      d.push(T + P * D, E + F * D),
      h ||
        (a.cap === "round"
          ? (x +=
              li(
                T - P * (w - D) * 0.5,
                E - F * (w - D) * 0.5,
                T - P * w,
                E - F * w,
                T + P * D,
                E + F * D,
                d,
                !1,
              ) + 2)
          : a.cap === "square" && (x += i0(T, E, P, F, w, D, !1, d))))
    let Y = 1e-4 * 1e-4
    for (let O = m; O < x + m - 2; ++O)
      ((y = d[O * 2]),
        (M = d[O * 2 + 1]),
        (T = d[(O + 1) * 2]),
        (E = d[(O + 1) * 2 + 1]),
        (G = d[(O + 2) * 2]),
        (B = d[(O + 2) * 2 + 1]),
        !(Math.abs(y * (E - B) + T * (B - M) + G * (M - E)) < Y) && s.push(O, O + 1, O + 2))
  }
  var s0 = p(() => {
    Ee()
    r0()
  })
  function o0(r, t, e, i) {
    let n = 1e-4
    if (r.length === 0) return
    let s = r[0],
      o = r[1],
      a = r[r.length - 2],
      u = r[r.length - 1],
      l = t || (Math.abs(s - a) < n && Math.abs(o - u) < n),
      c = e,
      h = r.length / 2,
      f = c.length / 2
    for (let d = 0; d < h; d++) (c.push(r[d * 2]), c.push(r[d * 2 + 1]))
    for (let d = 0; d < h - 1; d++) i.push(f + d, f + d + 1)
    l && i.push(f + h - 1, f)
  }
  var a0 = p(() => {})
  function mu(r, t, e = 2) {
    let i = t && t.length,
      n = i ? t[0] * e : r.length,
      s = l0(r, 0, n, e, !0),
      o = []
    if (!s || s.next === s.prev) return o
    let a, u, l
    if ((i && (s = zA(r, t, s, e)), r.length > 80 * e)) {
      ;((a = r[0]), (u = r[1]))
      let c = a,
        h = u
      for (let f = e; f < n; f += e) {
        let d = r[f],
          g = r[f + 1]
        ;(d < a && (a = d), g < u && (u = g), d > c && (c = d), g > h && (h = g))
      }
      ;((l = Math.max(c - a, h - u)), (l = l !== 0 ? 32767 / l : 0))
    }
    return (Cs(s, o, e, a, u, l, 0), o)
  }
  function l0(r, t, e, i, n) {
    let s
    if (n === JA(r, t, e, i) > 0)
      for (let o = t; o < e; o += i) s = u0((o / i) | 0, r[o], r[o + 1], s)
    else for (let o = e - i; o >= t; o -= i) s = u0((o / i) | 0, r[o], r[o + 1], s)
    return (s && Ki(s, s.next) && (ws(s), (s = s.next)), s)
  }
  function ci(r, t) {
    if (!r) return r
    t || (t = r)
    let e = r,
      i
    do
      if (((i = !1), !e.steiner && (Ki(e, e.next) || Tt(e.prev, e, e.next) === 0))) {
        if ((ws(e), (e = t = e.prev), e === e.next)) break
        i = !0
      } else e = e.next
    while (i || e !== t)
    return t
  }
  function Cs(r, t, e, i, n, s, o) {
    if (!r) return
    !o && s && YA(r, i, n, s)
    let a = r
    for (; r.prev !== r.next; ) {
      let u = r.prev,
        l = r.next
      if (s ? LA(r, i, n, s) : OA(r)) {
        ;(t.push(u.i, r.i, l.i), ws(r), (r = l.next), (a = l.next))
        continue
      }
      if (((r = l), r === a)) {
        o
          ? o === 1
            ? ((r = NA(ci(r), t)), Cs(r, t, e, i, n, s, 2))
            : o === 2 && HA(r, t, e, i, n, s)
          : Cs(ci(r), t, e, i, n, s, 1)
        break
      }
    }
  }
  function OA(r) {
    let t = r.prev,
      e = r,
      i = r.next
    if (Tt(t, e, i) >= 0) return !1
    let n = t.x,
      s = e.x,
      o = i.x,
      a = t.y,
      u = e.y,
      l = i.y,
      c = Math.min(n, s, o),
      h = Math.min(a, u, l),
      f = Math.max(n, s, o),
      d = Math.max(a, u, l),
      g = i.next
    for (; g !== t; ) {
      if (
        g.x >= c &&
        g.x <= f &&
        g.y >= h &&
        g.y <= d &&
        Ts(n, a, s, u, o, l, g.x, g.y) &&
        Tt(g.prev, g, g.next) >= 0
      )
        return !1
      g = g.next
    }
    return !0
  }
  function LA(r, t, e, i) {
    let n = r.prev,
      s = r,
      o = r.next
    if (Tt(n, s, o) >= 0) return !1
    let a = n.x,
      u = s.x,
      l = o.x,
      c = n.y,
      h = s.y,
      f = o.y,
      d = Math.min(a, u, l),
      g = Math.min(c, h, f),
      x = Math.max(a, u, l),
      m = Math.max(c, h, f),
      _ = Fh(d, g, t, e, i),
      v = Fh(x, m, t, e, i),
      S = r.prevZ,
      y = r.nextZ
    for (; S && S.z >= _ && y && y.z <= v; ) {
      if (
        (S.x >= d &&
          S.x <= x &&
          S.y >= g &&
          S.y <= m &&
          S !== n &&
          S !== o &&
          Ts(a, c, u, h, l, f, S.x, S.y) &&
          Tt(S.prev, S, S.next) >= 0) ||
        ((S = S.prevZ),
        y.x >= d &&
          y.x <= x &&
          y.y >= g &&
          y.y <= m &&
          y !== n &&
          y !== o &&
          Ts(a, c, u, h, l, f, y.x, y.y) &&
          Tt(y.prev, y, y.next) >= 0)
      )
        return !1
      y = y.nextZ
    }
    for (; S && S.z >= _; ) {
      if (
        S.x >= d &&
        S.x <= x &&
        S.y >= g &&
        S.y <= m &&
        S !== n &&
        S !== o &&
        Ts(a, c, u, h, l, f, S.x, S.y) &&
        Tt(S.prev, S, S.next) >= 0
      )
        return !1
      S = S.prevZ
    }
    for (; y && y.z <= v; ) {
      if (
        y.x >= d &&
        y.x <= x &&
        y.y >= g &&
        y.y <= m &&
        y !== n &&
        y !== o &&
        Ts(a, c, u, h, l, f, y.x, y.y) &&
        Tt(y.prev, y, y.next) >= 0
      )
        return !1
      y = y.nextZ
    }
    return !0
  }
  function NA(r, t) {
    let e = r
    do {
      let i = e.prev,
        n = e.next.next
      ;(!Ki(i, n) &&
        h0(i, e, e.next, n) &&
        Es(i, n) &&
        Es(n, i) &&
        (t.push(i.i, e.i, n.i), ws(e), ws(e.next), (e = r = n)),
        (e = e.next))
    } while (e !== r)
    return ci(e)
  }
  function HA(r, t, e, i, n, s) {
    let o = r
    do {
      let a = o.next.next
      for (; a !== o.prev; ) {
        if (o.i !== a.i && qA(o, a)) {
          let u = f0(o, a)
          ;((o = ci(o, o.next)),
            (u = ci(u, u.next)),
            Cs(o, t, e, i, n, s, 0),
            Cs(u, t, e, i, n, s, 0))
          return
        }
        a = a.next
      }
      o = o.next
    } while (o !== r)
  }
  function zA(r, t, e, i) {
    let n = []
    for (let s = 0, o = t.length; s < o; s++) {
      let a = t[s] * i,
        u = s < o - 1 ? t[s + 1] * i : r.length,
        l = l0(r, a, u, i, !1)
      ;(l === l.next && (l.steiner = !0), n.push(KA(l)))
    }
    n.sort(WA)
    for (let s = 0; s < n.length; s++) e = VA(n[s], e)
    return e
  }
  function WA(r, t) {
    let e = r.x - t.x
    if (e === 0 && ((e = r.y - t.y), e === 0)) {
      let i = (r.next.y - r.y) / (r.next.x - r.x),
        n = (t.next.y - t.y) / (t.next.x - t.x)
      e = i - n
    }
    return e
  }
  function VA(r, t) {
    let e = $A(r, t)
    if (!e) return t
    let i = f0(e, r)
    return (ci(i, i.next), ci(e, e.next))
  }
  function $A(r, t) {
    let e = t,
      i = r.x,
      n = r.y,
      s = -1 / 0,
      o
    if (Ki(r, e)) return e
    do {
      if (Ki(r, e.next)) return e.next
      if (n <= e.y && n >= e.next.y && e.next.y !== e.y) {
        let h = e.x + ((n - e.y) * (e.next.x - e.x)) / (e.next.y - e.y)
        if (h <= i && h > s && ((s = h), (o = e.x < e.next.x ? e : e.next), h === i)) return o
      }
      e = e.next
    } while (e !== t)
    if (!o) return null
    let a = o,
      u = o.x,
      l = o.y,
      c = 1 / 0
    e = o
    do {
      if (
        i >= e.x &&
        e.x >= u &&
        i !== e.x &&
        c0(n < l ? i : s, n, u, l, n < l ? s : i, n, e.x, e.y)
      ) {
        let h = Math.abs(n - e.y) / (i - e.x)
        Es(e, r) &&
          (h < c || (h === c && (e.x > o.x || (e.x === o.x && XA(o, e))))) &&
          ((o = e), (c = h))
      }
      e = e.next
    } while (e !== a)
    return o
  }
  function XA(r, t) {
    return Tt(r.prev, r, t.prev) < 0 && Tt(t.next, r, r.next) < 0
  }
  function YA(r, t, e, i) {
    let n = r
    do
      (n.z === 0 && (n.z = Fh(n.x, n.y, t, e, i)),
        (n.prevZ = n.prev),
        (n.nextZ = n.next),
        (n = n.next))
    while (n !== r)
    ;((n.prevZ.nextZ = null), (n.prevZ = null), jA(n))
  }
  function jA(r) {
    let t,
      e = 1
    do {
      let i = r,
        n
      r = null
      let s = null
      for (t = 0; i; ) {
        t++
        let o = i,
          a = 0
        for (let l = 0; l < e && (a++, (o = o.nextZ), !!o); l++);
        let u = e
        for (; a > 0 || (u > 0 && o); )
          (a !== 0 && (u === 0 || !o || i.z <= o.z)
            ? ((n = i), (i = i.nextZ), a--)
            : ((n = o), (o = o.nextZ), u--),
            s ? (s.nextZ = n) : (r = n),
            (n.prevZ = s),
            (s = n))
        i = o
      }
      ;((s.nextZ = null), (e *= 2))
    } while (t > 1)
    return r
  }
  function Fh(r, t, e, i, n) {
    return (
      (r = ((r - e) * n) | 0),
      (t = ((t - i) * n) | 0),
      (r = (r | (r << 8)) & 16711935),
      (r = (r | (r << 4)) & 252645135),
      (r = (r | (r << 2)) & 858993459),
      (r = (r | (r << 1)) & 1431655765),
      (t = (t | (t << 8)) & 16711935),
      (t = (t | (t << 4)) & 252645135),
      (t = (t | (t << 2)) & 858993459),
      (t = (t | (t << 1)) & 1431655765),
      r | (t << 1)
    )
  }
  function KA(r) {
    let t = r,
      e = r
    do ((t.x < e.x || (t.x === e.x && t.y < e.y)) && (e = t), (t = t.next))
    while (t !== r)
    return e
  }
  function c0(r, t, e, i, n, s, o, a) {
    return (
      (n - o) * (t - a) >= (r - o) * (s - a) &&
      (r - o) * (i - a) >= (e - o) * (t - a) &&
      (e - o) * (s - a) >= (n - o) * (i - a)
    )
  }
  function Ts(r, t, e, i, n, s, o, a) {
    return !(r === o && t === a) && c0(r, t, e, i, n, s, o, a)
  }
  function qA(r, t) {
    return (
      r.next.i !== t.i &&
      r.prev.i !== t.i &&
      !ZA(r, t) &&
      ((Es(r, t) && Es(t, r) && QA(r, t) && (Tt(r.prev, r, t.prev) || Tt(r, t.prev, t))) ||
        (Ki(r, t) && Tt(r.prev, r, r.next) > 0 && Tt(t.prev, t, t.next) > 0))
    )
  }
  function Tt(r, t, e) {
    return (t.y - r.y) * (e.x - t.x) - (t.x - r.x) * (e.y - t.y)
  }
  function Ki(r, t) {
    return r.x === t.x && r.y === t.y
  }
  function h0(r, t, e, i) {
    let n = pu(Tt(r, t, e)),
      s = pu(Tt(r, t, i)),
      o = pu(Tt(e, i, r)),
      a = pu(Tt(e, i, t))
    return !!(
      (n !== s && o !== a) ||
      (n === 0 && du(r, e, t)) ||
      (s === 0 && du(r, i, t)) ||
      (o === 0 && du(e, r, i)) ||
      (a === 0 && du(e, t, i))
    )
  }
  function du(r, t, e) {
    return (
      t.x <= Math.max(r.x, e.x) &&
      t.x >= Math.min(r.x, e.x) &&
      t.y <= Math.max(r.y, e.y) &&
      t.y >= Math.min(r.y, e.y)
    )
  }
  function pu(r) {
    return r > 0 ? 1 : r < 0 ? -1 : 0
  }
  function ZA(r, t) {
    let e = r
    do {
      if (e.i !== r.i && e.next.i !== r.i && e.i !== t.i && e.next.i !== t.i && h0(e, e.next, r, t))
        return !0
      e = e.next
    } while (e !== r)
    return !1
  }
  function Es(r, t) {
    return Tt(r.prev, r, r.next) < 0
      ? Tt(r, t, r.next) >= 0 && Tt(r, r.prev, t) >= 0
      : Tt(r, t, r.prev) < 0 || Tt(r, r.next, t) < 0
  }
  function QA(r, t) {
    let e = r,
      i = !1,
      n = (r.x + t.x) / 2,
      s = (r.y + t.y) / 2
    do
      (e.y > s != e.next.y > s &&
        e.next.y !== e.y &&
        n < ((e.next.x - e.x) * (s - e.y)) / (e.next.y - e.y) + e.x &&
        (i = !i),
        (e = e.next))
    while (e !== r)
    return i
  }
  function f0(r, t) {
    let e = Rh(r.i, r.x, r.y),
      i = Rh(t.i, t.x, t.y),
      n = r.next,
      s = t.prev
    return (
      (r.next = t),
      (t.prev = r),
      (e.next = n),
      (n.prev = e),
      (i.next = e),
      (e.prev = i),
      (s.next = i),
      (i.prev = s),
      i
    )
  }
  function u0(r, t, e, i) {
    let n = Rh(r, t, e)
    return (
      i
        ? ((n.next = i.next), (n.prev = i), (i.next.prev = n), (i.next = n))
        : ((n.prev = n), (n.next = n)),
      n
    )
  }
  function ws(r) {
    ;((r.next.prev = r.prev),
      (r.prev.next = r.next),
      r.prevZ && (r.prevZ.nextZ = r.nextZ),
      r.nextZ && (r.nextZ.prevZ = r.prevZ))
  }
  function Rh(r, t, e) {
    return { i: r, x: t, y: e, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 }
  }
  function JA(r, t, e, i) {
    let n = 0
    for (let s = t, o = e - i; s < e; s += i)
      ((n += (r[o] - r[s]) * (r[s + 1] + r[o + 1])), (o = s))
    return n
  }
  var d0 = p(() => {})
  var p0,
    m0 = p(() => {
      d0()
      Wt()
      p0 = mu.default || mu
    })
  function gu(r, t, e, i, n, s, o) {
    let a = p0(r, t, 2)
    if (!a) return
    for (let l = 0; l < a.length; l += 3)
      ((s[o++] = a[l] + n), (s[o++] = a[l + 1] + n), (s[o++] = a[l + 2] + n))
    let u = n * i
    for (let l = 0; l < r.length; l += 2) ((e[u] = r[l]), (e[u + 1] = r[l + 1]), (u += i))
  }
  var Bh = p(() => {
    m0()
  })
  var tD,
    g0,
    x0 = p(() => {
      A()
      Bh()
      ;((tD = []),
        (g0 = {
          extension: { type: b.ShapeBuilder, name: "polygon" },
          build(r, t) {
            for (let e = 0; e < r.points.length; e++) t[e] = r.points[e]
            return !0
          },
          triangulate(r, t, e, i, n, s) {
            gu(r, tD, t, e, i, n, s)
          },
        }))
    })
  var _0,
    y0 = p(() => {
      A()
      _0 = {
        extension: { type: b.ShapeBuilder, name: "rectangle" },
        build(r, t) {
          let e = r,
            i = e.x,
            n = e.y,
            s = e.width,
            o = e.height
          return s > 0 && o > 0
            ? ((t[0] = i),
              (t[1] = n),
              (t[2] = i + s),
              (t[3] = n),
              (t[4] = i + s),
              (t[5] = n + o),
              (t[6] = i),
              (t[7] = n + o),
              !0)
            : !1
        },
        triangulate(r, t, e, i, n, s) {
          let o = 0
          ;((i *= e),
            (t[i + o] = r[0]),
            (t[i + o + 1] = r[1]),
            (o += e),
            (t[i + o] = r[2]),
            (t[i + o + 1] = r[3]),
            (o += e),
            (t[i + o] = r[6]),
            (t[i + o + 1] = r[7]),
            (o += e),
            (t[i + o] = r[4]),
            (t[i + o + 1] = r[5]),
            (o += e))
          let a = i / e
          ;((n[s++] = a),
            (n[s++] = a + 1),
            (n[s++] = a + 2),
            (n[s++] = a + 1),
            (n[s++] = a + 3),
            (n[s++] = a + 2))
        },
      }
    })
  var b0,
    v0 = p(() => {
      A()
      b0 = {
        extension: { type: b.ShapeBuilder, name: "triangle" },
        build(r, t) {
          return (
            (t[0] = r.x),
            (t[1] = r.y),
            (t[2] = r.x2),
            (t[3] = r.y2),
            (t[4] = r.x3),
            (t[5] = r.y3),
            !0
          )
        },
        triangulate(r, t, e, i, n, s) {
          let o = 0
          ;((i *= e),
            (t[i + o] = r[0]),
            (t[i + o + 1] = r[1]),
            (o += e),
            (t[i + o] = r[2]),
            (t[i + o + 1] = r[3]),
            (o += e),
            (t[i + o] = r[4]),
            (t[i + o + 1] = r[5]))
          let a = i / e
          ;((n[s++] = a), (n[s++] = a + 1), (n[s++] = a + 2))
        },
      }
    })
  function T0(r, t) {
    for (let e = 0; e < t.length; e++) {
      let i = t[e]
      r.addColorStop(i.offset, i.color)
    }
  }
  function C0(r, t) {
    let e = Z.get().createCanvas(r, t),
      i = e.getContext("2d")
    return { canvas: e, context: i }
  }
  function eD(r) {
    let t = r[0] ?? {}
    return (
      (typeof t == "number" || r[1]) &&
        (z("8.5.2", "use options object instead"),
        (t = {
          type: "linear",
          start: { x: r[0], y: r[1] },
          end: { x: r[2], y: r[3] },
          textureSpace: r[4],
          textureSize: r[5] ?? ue.defaultLinearOptions.textureSize,
        })),
      t
    )
  }
  var S0,
    kh,
    ue,
    qi = p(() => {
      Vt()
      At()
      nt()
      tu()
      dt()
      Ot()
      gt()
      Mc()
      ;((S0 = [
        { offset: 0, color: "white" },
        { offset: 1, color: "black" },
      ]),
        (kh = class Ih {
          constructor(...t) {
            ;((this.uid = J("fillGradient")), (this.type = "linear"), (this.colorStops = []))
            let e = eD(t)
            ;((e = {
              ...(e.type === "radial" ? Ih.defaultRadialOptions : Ih.defaultLinearOptions),
              ...Ua(e),
            }),
              (this._textureSize = e.textureSize),
              (this._wrapMode = e.wrapMode),
              e.type === "radial"
                ? ((this.center = e.center),
                  (this.outerCenter = e.outerCenter ?? this.center),
                  (this.innerRadius = e.innerRadius),
                  (this.outerRadius = e.outerRadius),
                  (this.scale = e.scale),
                  (this.rotation = e.rotation))
                : ((this.start = e.start), (this.end = e.end)),
              (this.textureSpace = e.textureSpace),
              (this.type = e.type),
              e.colorStops.forEach((n) => {
                this.addColorStop(n.offset, n.color)
              }))
          }
          addColorStop(t, e) {
            return (this.colorStops.push({ offset: t, color: q.shared.setValue(e).toHexa() }), this)
          }
          buildLinearGradient() {
            if (this.texture) return
            let { x: t, y: e } = this.start,
              { x: i, y: n } = this.end,
              s = i - t,
              o = n - e,
              a = s < 0 || o < 0
            if (this._wrapMode === "clamp-to-edge") {
              if (s < 0) {
                let m = t
                ;((t = i), (i = m), (s *= -1))
              }
              if (o < 0) {
                let m = e
                ;((e = n), (n = m), (o *= -1))
              }
            }
            let u = this.colorStops.length ? this.colorStops : S0,
              l = this._textureSize,
              { canvas: c, context: h } = C0(l, 1),
              f = a
                ? h.createLinearGradient(this._textureSize, 0, 0, 0)
                : h.createLinearGradient(0, 0, this._textureSize, 0)
            ;(T0(f, u),
              (h.fillStyle = f),
              h.fillRect(0, 0, l, 1),
              (this.texture = new k({
                source: new Be({ resource: c, addressMode: this._wrapMode }),
              })))
            let d = Math.sqrt(s * s + o * o),
              g = Math.atan2(o, s),
              x = new I()
            ;(x.scale(d / l, 1),
              x.rotate(g),
              x.translate(t, e),
              this.textureSpace === "local" && x.scale(l, l),
              (this.transform = x))
          }
          buildGradient() {
            this.type === "linear" ? this.buildLinearGradient() : this.buildRadialGradient()
          }
          buildRadialGradient() {
            if (this.texture) return
            let t = this.colorStops.length ? this.colorStops : S0,
              e = this._textureSize,
              { canvas: i, context: n } = C0(e, e),
              { x: s, y: o } = this.center,
              { x: a, y: u } = this.outerCenter,
              l = this.innerRadius,
              c = this.outerRadius,
              h = a - c,
              f = u - c,
              d = e / (c * 2),
              g = (s - h) * d,
              x = (o - f) * d,
              m = n.createRadialGradient(g, x, l * d, (a - h) * d, (u - f) * d, c * d)
            ;(T0(m, t),
              (n.fillStyle = t[t.length - 1].color),
              n.fillRect(0, 0, e, e),
              (n.fillStyle = m),
              n.translate(g, x),
              n.rotate(this.rotation),
              n.scale(1, this.scale),
              n.translate(-g, -x),
              n.fillRect(0, 0, e, e),
              (this.texture = new k({
                source: new Be({ resource: i, addressMode: this._wrapMode }),
              })))
            let _ = new I()
            ;(_.scale(1 / d, 1 / d),
              _.translate(h, f),
              this.textureSpace === "local" && _.scale(e, e),
              (this.transform = _))
          }
          get styleKey() {
            return this.uid
          }
          destroy() {
            ;(this.texture?.destroy(!0), (this.texture = null))
          }
        }))
      kh.defaultLinearOptions = {
        start: { x: 0, y: 0 },
        end: { x: 0, y: 1 },
        colorStops: [],
        textureSpace: "local",
        type: "linear",
        textureSize: 256,
        wrapMode: "clamp-to-edge",
      }
      kh.defaultRadialOptions = {
        center: { x: 0.5, y: 0.5 },
        innerRadius: 0,
        outerRadius: 0.5,
        colorStops: [],
        scale: 1,
        textureSpace: "local",
        type: "radial",
        textureSize: 256,
        wrapMode: "clamp-to-edge",
      }
      ue = kh
    })
  function E0(r, t, e, i) {
    let n = t.matrix ? r.copyFrom(t.matrix).invert() : r.identity()
    if (t.textureSpace === "local") {
      let o = e.getBounds(iD)
      t.width && o.pad(t.width)
      let { x: a, y: u } = o,
        l = 1 / o.width,
        c = 1 / o.height,
        h = -a * l,
        f = -u * c,
        d = n.a,
        g = n.b,
        x = n.c,
        m = n.d
      ;((n.a *= l),
        (n.b *= l),
        (n.c *= c),
        (n.d *= c),
        (n.tx = h * d + f * x + n.tx),
        (n.ty = h * g + f * m + n.ty))
    } else
      (n.translate(t.texture.frame.x, t.texture.frame.y),
        n.scale(1 / t.texture.source.width, 1 / t.texture.source.height))
    let s = t.texture.source.style
    return (
      !(t.fill instanceof ue) &&
        s.addressMode === "clamp-to-edge" &&
        ((s.addressMode = "repeat"), s.update()),
      i && n.append(rD.copyFrom(i).invert()),
      n
    )
  }
  var rD,
    iD,
    w0 = p(() => {
      nt()
      Lt()
      qi()
      ;((rD = new I()), (iD = new Q()))
    })
  function A0(r, t) {
    let { geometryData: e, batches: i } = t
    ;((i.length = 0), (e.indices.length = 0), (e.vertices.length = 0), (e.uvs.length = 0))
    for (let n = 0; n < r.instructions.length; n++) {
      let s = r.instructions[n]
      if (s.action === "texture") oD(s.data, i, e)
      else if (s.action === "fill" || s.action === "stroke") {
        let o = s.action === "stroke",
          a = s.data.path.shapePath,
          u = s.data.style,
          l = s.data.hole
        ;(o && l && M0(l.shapePath, u, !0, i, e),
          l &&
            (a.shapePrimitives[a.shapePrimitives.length - 1].holes = l.shapePath.shapePrimitives),
          M0(a, u, o, i, e))
      }
    }
  }
  function oD(r, t, e) {
    let i = [],
      n = xu.rectangle,
      s = nD
    ;((s.x = r.dx), (s.y = r.dy), (s.width = r.dw), (s.height = r.dh))
    let o = r.transform
    if (!n.build(s, i)) return
    let { vertices: a, uvs: u, indices: l } = e,
      c = l.length,
      h = a.length / 2
    ;(o && Dh(i, o), n.triangulate(i, a, 2, h, l, c))
    let f = r.image,
      d = f.uvs
    u.push(d.x0, d.y0, d.x1, d.y1, d.x3, d.y3, d.x2, d.y2)
    let g = xt.get(ui)
    ;((g.indexOffset = c),
      (g.indexSize = l.length - c),
      (g.attributeOffset = h),
      (g.attributeSize = a.length / 2 - h),
      (g.baseColor = r.style),
      (g.alpha = r.alpha),
      (g.texture = f),
      (g.geometryData = e),
      t.push(g))
  }
  function M0(r, t, e, i, n) {
    let { vertices: s, uvs: o, indices: a } = n
    r.shapePrimitives.forEach(({ shape: u, transform: l, holes: c }) => {
      let h = [],
        f = xu[u.type]
      if (!f.build(u, h)) return
      let d = a.length,
        g = s.length / 2,
        x = "triangle-list"
      if ((l && Dh(h, l), e)) {
        let S = u.closePath ?? !0,
          y = t
        y.pixelLine ? (o0(h, S, s, a), (x = "line-list")) : n0(h, y, !1, S, s, a)
      } else if (c) {
        let S = [],
          y = h.slice()
        ;(aD(c).forEach((T) => {
          ;(S.push(y.length / 2), y.push(...T))
        }),
          gu(y, S, s, 2, g, a, d))
      } else f.triangulate(h, s, 2, g, a, d)
      let m = o.length / 2,
        _ = t.texture
      if (_ !== k.WHITE) {
        let S = E0(sD, t, u, l)
        jy(s, 2, g, o, m, 2, s.length / 2 - g, S)
      } else Ky(o, m, 2, s.length / 2 - g)
      let v = xt.get(ui)
      ;((v.indexOffset = d),
        (v.indexSize = a.length - d),
        (v.attributeOffset = g),
        (v.attributeSize = s.length / 2 - g),
        (v.baseColor = t.color),
        (v.alpha = t.alpha),
        (v.texture = _),
        (v.geometryData = n),
        (v.topology = x),
        i.push(v))
    })
  }
  function aD(r) {
    let t = []
    for (let e = 0; e < r.length; e++) {
      let i = r[e].shape,
        n = []
      xu[i.type].build(i, n) && t.push(n)
    }
    return t
  }
  var xu,
    nD,
    sD,
    D0 = p(() => {
      A()
      nt()
      Lt()
      qy()
      Zy()
      dt()
      Je()
      Ph()
      t0()
      s0()
      a0()
      x0()
      y0()
      v0()
      w0()
      Bh()
      xu = {}
      L.handleByMap(b.ShapeBuilder, xu)
      L.add(_0, g0, b0, ji, Qy, Jy)
      ;((nD = new Q()), (sD = new I()))
    })
  var Gh,
    Uh,
    Lh,
    Zi,
    _u = p(() => {
      A()
      iu()
      Ah()
      Ec()
      gt()
      Je()
      D0()
      ;((Gh = class {
        constructor() {
          ;((this.batches = []), (this.geometryData = { vertices: [], uvs: [], indices: [] }))
        }
      }),
        (Uh = class {
          constructor() {
            this.instructions = new Ri()
          }
          init(t) {
            ;((this.batcher = new Ss({ maxTextures: t })), this.instructions.reset())
          }
          get geometry() {
            return (
              z(
                Ug,
                "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.",
              ),
              this.batcher.geometry
            )
          }
        }),
        (Lh = class Oh {
          constructor(t) {
            ;((this._gpuContextHash = {}),
              (this._graphicsDataContextHash = Object.create(null)),
              (this._renderer = t),
              t.renderableGC.addManagedHash(this, "_gpuContextHash"),
              t.renderableGC.addManagedHash(this, "_graphicsDataContextHash"))
          }
          init(t) {
            Oh.defaultOptions.bezierSmoothness =
              t?.bezierSmoothness ?? Oh.defaultOptions.bezierSmoothness
          }
          getContextRenderData(t) {
            return this._graphicsDataContextHash[t.uid] || this._initContextRenderData(t)
          }
          updateGpuContext(t) {
            let e = this._gpuContextHash[t.uid] || this._initContext(t)
            if (t.dirty) {
              ;(e ? this._cleanGraphicsContextData(t) : (e = this._initContext(t)), A0(t, e))
              let i = t.batchMode
              ;(t.customShader || i === "no-batch"
                ? (e.isBatchable = !1)
                : i === "auto"
                  ? (e.isBatchable = e.geometryData.vertices.length < 400)
                  : (e.isBatchable = !0),
                (t.dirty = !1))
            }
            return e
          }
          getGpuContext(t) {
            return this._gpuContextHash[t.uid] || this._initContext(t)
          }
          _initContextRenderData(t) {
            let e = xt.get(Uh, { maxTextures: this._renderer.limits.maxBatchableTextures }),
              { batches: i, geometryData: n } = this._gpuContextHash[t.uid],
              s = n.vertices.length,
              o = n.indices.length
            for (let c = 0; c < i.length; c++) i[c].applyTransform = !1
            let a = e.batcher
            ;(a.ensureAttributeBuffer(s), a.ensureIndexBuffer(o), a.begin())
            for (let c = 0; c < i.length; c++) {
              let h = i[c]
              a.add(h)
            }
            a.finish(e.instructions)
            let u = a.geometry
            ;(u.indexBuffer.setDataWithSize(a.indexBuffer, a.indexSize, !0),
              u.buffers[0].setDataWithSize(a.attributeBuffer.float32View, a.attributeSize, !0))
            let l = a.batches
            for (let c = 0; c < l.length; c++) {
              let h = l[c]
              h.bindGroup = Oi(
                h.textures.textures,
                h.textures.count,
                this._renderer.limits.maxBatchableTextures,
              )
            }
            return ((this._graphicsDataContextHash[t.uid] = e), e)
          }
          _initContext(t) {
            let e = new Gh()
            return (
              (e.context = t),
              (this._gpuContextHash[t.uid] = e),
              t.on("destroy", this.onGraphicsContextDestroy, this),
              this._gpuContextHash[t.uid]
            )
          }
          onGraphicsContextDestroy(t) {
            ;(this._cleanGraphicsContextData(t),
              t.off("destroy", this.onGraphicsContextDestroy, this),
              (this._gpuContextHash[t.uid] = null))
          }
          _cleanGraphicsContextData(t) {
            let e = this._gpuContextHash[t.uid]
            ;(e.isBatchable ||
              (this._graphicsDataContextHash[t.uid] &&
                (xt.return(this.getContextRenderData(t)),
                (this._graphicsDataContextHash[t.uid] = null))),
              e.batches &&
                e.batches.forEach((i) => {
                  xt.return(i)
                }))
          }
          destroy() {
            for (let t in this._gpuContextHash)
              this._gpuContextHash[t] &&
                this.onGraphicsContextDestroy(this._gpuContextHash[t].context)
          }
        }))
      Lh.extension = {
        type: [b.WebGLSystem, b.WebGPUSystem, b.CanvasSystem],
        name: "graphicsContext",
      }
      Lh.defaultOptions = { bezierSmoothness: 0.5 }
      Zi = Lh
    })
  var uD,
    Nh,
    Hh,
    zh,
    Wh,
    Vh,
    $h,
    Xh,
    Dt,
    De = p(() => {
      "use strict"
      ;((uD = {
        normal: 0,
        add: 1,
        multiply: 2,
        screen: 3,
        overlay: 4,
        erase: 5,
        "normal-npm": 6,
        "add-npm": 7,
        "screen-npm": 8,
        min: 9,
        max: 10,
      }),
        (Nh = 0),
        (Hh = 1),
        (zh = 2),
        (Wh = 3),
        (Vh = 4),
        ($h = 5),
        (Xh = class P0 {
          constructor() {
            ;((this.data = 0),
              (this.blendMode = "normal"),
              (this.polygonOffset = 0),
              (this.blend = !0),
              (this.depthMask = !0))
          }
          get blend() {
            return !!(this.data & (1 << Nh))
          }
          set blend(t) {
            !!(this.data & (1 << Nh)) !== t && (this.data ^= 1 << Nh)
          }
          get offsets() {
            return !!(this.data & (1 << Hh))
          }
          set offsets(t) {
            !!(this.data & (1 << Hh)) !== t && (this.data ^= 1 << Hh)
          }
          set cullMode(t) {
            if (t === "none") {
              this.culling = !1
              return
            }
            ;((this.culling = !0), (this.clockwiseFrontFace = t === "front"))
          }
          get cullMode() {
            return this.culling ? (this.clockwiseFrontFace ? "front" : "back") : "none"
          }
          get culling() {
            return !!(this.data & (1 << zh))
          }
          set culling(t) {
            !!(this.data & (1 << zh)) !== t && (this.data ^= 1 << zh)
          }
          get depthTest() {
            return !!(this.data & (1 << Wh))
          }
          set depthTest(t) {
            !!(this.data & (1 << Wh)) !== t && (this.data ^= 1 << Wh)
          }
          get depthMask() {
            return !!(this.data & (1 << $h))
          }
          set depthMask(t) {
            !!(this.data & (1 << $h)) !== t && (this.data ^= 1 << $h)
          }
          get clockwiseFrontFace() {
            return !!(this.data & (1 << Vh))
          }
          set clockwiseFrontFace(t) {
            !!(this.data & (1 << Vh)) !== t && (this.data ^= 1 << Vh)
          }
          get blendMode() {
            return this._blendMode
          }
          set blendMode(t) {
            ;((this.blend = t !== "none"), (this._blendMode = t), (this._blendModeId = uD[t] || 0))
          }
          get polygonOffset() {
            return this._polygonOffset
          }
          set polygonOffset(t) {
            ;((this.offsets = !!t), (this._polygonOffset = t))
          }
          toString() {
            return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`
          }
          static for2d() {
            let t = new P0()
            return ((t.depthTest = !1), (t.blend = !0), t)
          }
        }))
      Xh.default2d = Xh.for2d()
      Dt = Xh
    })
  function Ne(r, t, e) {
    let i = ((r >> 24) & 255) / 255
    ;((t[e++] = ((r & 255) / 255) * i),
      (t[e++] = (((r >> 8) & 255) / 255) * i),
      (t[e++] = (((r >> 16) & 255) / 255) * i),
      (t[e++] = i))
  }
  var Qi = p(() => {
    "use strict"
  })
  var Yh,
    Ms,
    F0 = p(() => {
      A()
      De()
      Je()
      Qi()
      Ph()
      ;((Yh = class {
        constructor() {
          ;((this.batches = []), (this.batched = !1))
        }
        destroy() {
          ;(this.batches.forEach((t) => {
            xt.return(t)
          }),
            (this.batches.length = 0))
        }
      }),
        (Ms = class {
          constructor(t, e) {
            ;((this.state = Dt.for2d()),
              (this.renderer = t),
              (this._adaptor = e),
              this.renderer.runners.contextChange.add(this))
          }
          contextChange() {
            this._adaptor.contextChange(this.renderer)
          }
          validateRenderable(t) {
            let e = t.context,
              i = !!t._gpuData,
              n = this.renderer.graphicsContext.updateGpuContext(e)
            return !!(n.isBatchable || i !== n.isBatchable)
          }
          addRenderable(t, e) {
            let i = this.renderer.graphicsContext.updateGpuContext(t.context)
            ;(t.didViewUpdate && this._rebuild(t),
              i.isBatchable
                ? this._addToBatcher(t, e)
                : (this.renderer.renderPipes.batch.break(e), e.add(t)))
          }
          updateRenderable(t) {
            let i = this._getGpuDataForRenderable(t).batches
            for (let n = 0; n < i.length; n++) {
              let s = i[n]
              s._batcher.updateElement(s)
            }
          }
          execute(t) {
            if (!t.isRenderable) return
            let e = this.renderer,
              i = t.context
            if (!e.graphicsContext.getGpuContext(i).batches.length) return
            let s = i.customShader || this._adaptor.shader
            this.state.blendMode = t.groupBlendMode
            let o = s.resources.localUniforms.uniforms
            ;((o.uTransformMatrix = t.groupTransform),
              (o.uRound = e._roundPixels | t._roundPixels),
              Ne(t.groupColorAlpha, o.uColor, 0),
              this._adaptor.execute(this, t))
          }
          _rebuild(t) {
            let e = this._getGpuDataForRenderable(t),
              i = this.renderer.graphicsContext.updateGpuContext(t.context)
            ;(e.destroy(), i.isBatchable && this._updateBatchesForRenderable(t, e))
          }
          _addToBatcher(t, e) {
            let i = this.renderer.renderPipes.batch,
              n = this._getGpuDataForRenderable(t).batches
            for (let s = 0; s < n.length; s++) {
              let o = n[s]
              i.addToBatch(o, e)
            }
          }
          _getGpuDataForRenderable(t) {
            return t._gpuData[this.renderer.uid] || this._initGpuDataForRenderable(t)
          }
          _initGpuDataForRenderable(t) {
            let e = new Yh()
            return ((t._gpuData[this.renderer.uid] = e), e)
          }
          _updateBatchesForRenderable(t, e) {
            let i = t.context,
              n = this.renderer.graphicsContext.getGpuContext(i),
              s = this.renderer._roundPixels | t._roundPixels
            e.batches = n.batches.map((o) => {
              let a = xt.get(ui)
              return (o.copyTo(a), (a.renderable = t), (a.roundPixels = s), a)
            })
          }
          destroy() {
            ;((this.renderer = null),
              this._adaptor.destroy(),
              (this._adaptor = null),
              (this.state = null))
          }
        }))
      Ms.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "graphics" }
    })
  var jh = p(() => {
    A()
    _u()
    F0()
    L.add(Ms)
    L.add(Zi)
  })
  var Ar,
    yu = p(() => {
      "use strict"
      Ar = class {
        constructor() {
          ;((this.batcherName = "default"),
            (this.packAsQuad = !1),
            (this.indexOffset = 0),
            (this.attributeOffset = 0),
            (this.roundPixels = 0),
            (this._batcher = null),
            (this._batch = null),
            (this._textureMatrixUpdateId = -1),
            (this._uvUpdateId = -1))
        }
        get blendMode() {
          return this.renderable.groupBlendMode
        }
        get topology() {
          return this._topology || this.geometry.topology
        }
        set topology(t) {
          this._topology = t
        }
        reset() {
          ;((this.renderable = null),
            (this.texture = null),
            (this._batcher = null),
            (this._batch = null),
            (this.geometry = null),
            (this._uvUpdateId = -1),
            (this._textureMatrixUpdateId = -1))
        }
        setTexture(t) {
          this.texture !== t && ((this.texture = t), (this._textureMatrixUpdateId = -1))
        }
        get uvs() {
          let e = this.geometry.getBuffer("aUV"),
            i = e.data,
            n = i,
            s = this.texture.textureMatrix
          return (
            s.isSimple ||
              ((n = this._transformedUvs),
              (this._textureMatrixUpdateId !== s._updateID || this._uvUpdateId !== e._updateID) &&
                ((!n || n.length < i.length) &&
                  (n = this._transformedUvs = new Float32Array(i.length)),
                (this._textureMatrixUpdateId = s._updateID),
                (this._uvUpdateId = e._updateID),
                s.multiplyUvs(i, n))),
            n
          )
        }
        get positions() {
          return this.geometry.positions
        }
        get indices() {
          return this.geometry.indices
        }
        get color() {
          return this.renderable.groupColorAlpha
        }
        get groupTransform() {
          return this.renderable.groupTransform
        }
        get attributeSize() {
          return this.geometry.positions.length / 2
        }
        get indexSize() {
          return this.geometry.indices.length
        }
      }
    })
  var bu,
    As,
    R0 = p(() => {
      A()
      nt()
      Tr()
      re()
      xs()
      Qi()
      yu()
      ;((bu = class {
        destroy() {}
      }),
        (As = class {
          constructor(t, e) {
            ;((this.localUniforms = new ht({
              uTransformMatrix: { value: new I(), type: "mat3x3<f32>" },
              uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
              uRound: { value: 0, type: "f32" },
            })),
              (this.localUniformsBindGroup = new Nt({ 0: this.localUniforms })),
              (this.renderer = t),
              (this._adaptor = e),
              this._adaptor.init())
          }
          validateRenderable(t) {
            let e = this._getMeshData(t),
              i = e.batched,
              n = t.batched
            if (((e.batched = n), i !== n)) return !0
            if (n) {
              let s = t._geometry
              if (s.indices.length !== e.indexSize || s.positions.length !== e.vertexSize)
                return ((e.indexSize = s.indices.length), (e.vertexSize = s.positions.length), !0)
              let o = this._getBatchableMesh(t)
              return (
                o.texture.uid !== t._texture.uid && (o._textureMatrixUpdateId = -1),
                !o._batcher.checkAndUpdateTexture(o, t._texture)
              )
            }
            return !1
          }
          addRenderable(t, e) {
            let i = this.renderer.renderPipes.batch,
              { batched: n } = this._getMeshData(t)
            if (n) {
              let s = this._getBatchableMesh(t)
              ;(s.setTexture(t._texture), (s.geometry = t._geometry), i.addToBatch(s, e))
            } else (i.break(e), e.add(t))
          }
          updateRenderable(t) {
            if (t.batched) {
              let e = this._getBatchableMesh(t)
              ;(e.setTexture(t._texture), (e.geometry = t._geometry), e._batcher.updateElement(e))
            }
          }
          execute(t) {
            if (!t.isRenderable) return
            t.state.blendMode = nr(t.groupBlendMode, t.texture._source)
            let e = this.localUniforms
            ;((e.uniforms.uTransformMatrix = t.groupTransform),
              (e.uniforms.uRound = this.renderer._roundPixels | t._roundPixels),
              e.update(),
              Ne(t.groupColorAlpha, e.uniforms.uColor, 0),
              this._adaptor.execute(this, t))
          }
          _getMeshData(t) {
            var e, i
            return (
              (e = t._gpuData)[(i = this.renderer.uid)] || (e[i] = new bu()),
              t._gpuData[this.renderer.uid].meshData || this._initMeshData(t)
            )
          }
          _initMeshData(t) {
            return (
              (t._gpuData[this.renderer.uid].meshData = {
                batched: t.batched,
                indexSize: t._geometry.indices?.length,
                vertexSize: t._geometry.positions?.length,
              }),
              t._gpuData[this.renderer.uid].meshData
            )
          }
          _getBatchableMesh(t) {
            var e, i
            return (
              (e = t._gpuData)[(i = this.renderer.uid)] || (e[i] = new bu()),
              t._gpuData[this.renderer.uid].batchableMesh || this._initBatchableMesh(t)
            )
          }
          _initBatchableMesh(t) {
            let e = new Ar()
            return (
              (e.renderable = t),
              e.setTexture(t._texture),
              (e.transform = t.groupTransform),
              (e.roundPixels = this.renderer._roundPixels | t._roundPixels),
              (t._gpuData[this.renderer.uid].batchableMesh = e),
              e
            )
          }
          destroy() {
            ;((this.localUniforms = null),
              (this.localUniformsBindGroup = null),
              this._adaptor.destroy(),
              (this._adaptor = null),
              (this.renderer = null))
          }
        }))
      As.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "mesh" }
    })
  var Kh = p(() => {
    A()
    R0()
    L.add(As)
  })
  var vu,
    B0 = p(() => {
      "use strict"
      vu = class {
        execute(t, e) {
          let i = t.state,
            n = t.renderer,
            s = e.shader || t.defaultShader
          ;((s.resources.uTexture = e.texture._source), (s.resources.uniforms = t.localUniforms))
          let o = n.gl,
            a = t.getBuffers(e)
          ;(n.shader.bind(s), n.state.set(i), n.geometry.bind(a.geometry, s.glProgram))
          let l =
            a.geometry.indexBuffer.data.BYTES_PER_ELEMENT === 2 ? o.UNSIGNED_SHORT : o.UNSIGNED_INT
          o.drawElements(o.TRIANGLES, e.particleChildren.length * 6, l, 0)
        }
      }
    })
  function qh(r, t = null) {
    let e = r * 6
    if ((e > 65535 ? t || (t = new Uint32Array(e)) : t || (t = new Uint16Array(e)), t.length !== e))
      throw new Error(`Out buffer length is incorrect, got ${t.length} and expected ${e}`)
    for (let i = 0, n = 0; i < e; i += 6, n += 4)
      ((t[i + 0] = n + 0),
        (t[i + 1] = n + 1),
        (t[i + 2] = n + 2),
        (t[i + 3] = n + 0),
        (t[i + 4] = n + 2),
        (t[i + 5] = n + 3))
    return t
  }
  var I0 = p(() => {
    "use strict"
  })
  function G0(r) {
    return { dynamicUpdate: k0(r, !0), staticUpdate: k0(r, !1) }
  }
  function k0(r, t) {
    let e = []
    e.push(`

        var index = 0;

        for (let i = 0; i < ps.length; ++i)
        {
            const p = ps[i];

            `)
    let i = 0
    for (let s in r) {
      let o = r[s]
      if (t !== o.dynamic) continue
      ;(e.push(`offset = index + ${i}`), e.push(o.code))
      let a = ae(o.format)
      i += a.stride / 4
    }
    ;(e.push(`
            index += stride * 4;
        }
    `),
      e.unshift(`
        var stride = ${i};
    `))
    let n = e.join(`
`)
    return new Function("ps", "f32v", "u32v", n)
  }
  var U0 = p(() => {
    ai()
  })
  function lD(r) {
    let t = []
    for (let e in r) {
      let i = r[e]
      t.push(e, i.code, i.dynamic ? "d" : "s")
    }
    return t.join("_")
  }
  var Su,
    O0 = p(() => {
      Cr()
      sr()
      Ni()
      ai()
      ah()
      I0()
      U0()
      Su = class {
        constructor(t) {
          ;((this._size = 0), (this._generateParticleUpdateCache = {}))
          let e = (this._size = t.size ?? 1e3),
            i = t.properties,
            n = 0,
            s = 0
          for (let c in i) {
            let h = i[c],
              f = ae(h.format)
            h.dynamic ? (s += f.stride) : (n += f.stride)
          }
          ;((this._dynamicStride = s / 4),
            (this._staticStride = n / 4),
            (this.staticAttributeBuffer = new Ie(e * 4 * n)),
            (this.dynamicAttributeBuffer = new Ie(e * 4 * s)),
            (this.indexBuffer = qh(e)))
          let o = new _e(),
            a = 0,
            u = 0
          ;((this._staticBuffer = new wt({
            data: new Float32Array(1),
            label: "static-particle-buffer",
            shrinkToFit: !1,
            usage: tt.VERTEX | tt.COPY_DST,
          })),
            (this._dynamicBuffer = new wt({
              data: new Float32Array(1),
              label: "dynamic-particle-buffer",
              shrinkToFit: !1,
              usage: tt.VERTEX | tt.COPY_DST,
            })))
          for (let c in i) {
            let h = i[c],
              f = ae(h.format)
            h.dynamic
              ? (o.addAttribute(h.attributeName, {
                  buffer: this._dynamicBuffer,
                  stride: this._dynamicStride * 4,
                  offset: a * 4,
                  format: h.format,
                }),
                (a += f.size))
              : (o.addAttribute(h.attributeName, {
                  buffer: this._staticBuffer,
                  stride: this._staticStride * 4,
                  offset: u * 4,
                  format: h.format,
                }),
                (u += f.size))
          }
          o.addIndex(this.indexBuffer)
          let l = this.getParticleUpdate(i)
          ;((this._dynamicUpload = l.dynamicUpdate),
            (this._staticUpload = l.staticUpdate),
            (this.geometry = o))
        }
        getParticleUpdate(t) {
          let e = lD(t)
          return this._generateParticleUpdateCache[e]
            ? this._generateParticleUpdateCache[e]
            : ((this._generateParticleUpdateCache[e] = this.generateParticleUpdate(t)),
              this._generateParticleUpdateCache[e])
        }
        generateParticleUpdate(t) {
          return G0(t)
        }
        update(t, e) {
          t.length > this._size &&
            ((e = !0),
            (this._size = Math.max(t.length, (this._size * 1.5) | 0)),
            (this.staticAttributeBuffer = new Ie(this._size * this._staticStride * 4 * 4)),
            (this.dynamicAttributeBuffer = new Ie(this._size * this._dynamicStride * 4 * 4)),
            (this.indexBuffer = qh(this._size)),
            this.geometry.indexBuffer.setDataWithSize(
              this.indexBuffer,
              this.indexBuffer.byteLength,
              !0,
            ))
          let i = this.dynamicAttributeBuffer
          if (
            (this._dynamicUpload(t, i.float32View, i.uint32View),
            this._dynamicBuffer.setDataWithSize(
              this.dynamicAttributeBuffer.float32View,
              t.length * this._dynamicStride * 4,
              !0,
            ),
            e)
          ) {
            let n = this.staticAttributeBuffer
            ;(this._staticUpload(t, n.float32View, n.uint32View),
              this._staticBuffer.setDataWithSize(
                n.float32View,
                t.length * this._staticStride * 4,
                !0,
              ))
          }
        }
        destroy() {
          ;(this._staticBuffer.destroy(), this._dynamicBuffer.destroy(), this.geometry.destroy())
        }
      }
    })
  var L0,
    N0 = p(() => {
      L0 = `varying vec2 vUV;
varying vec4 vColor;

uniform sampler2D uTexture;

void main(void){
    vec4 color = texture2D(uTexture, vUV) * vColor;
    gl_FragColor = color;
}`
    })
  var H0,
    z0 = p(() => {
      H0 = `attribute vec2 aVertex;
attribute vec2 aUV;
attribute vec4 aColor;

attribute vec2 aPosition;
attribute float aRotation;

uniform mat3 uTranslationMatrix;
uniform float uRound;
uniform vec2 uResolution;
uniform vec4 uColor;

varying vec2 vUV;
varying vec4 vColor;

vec2 roundPixels(vec2 position, vec2 targetSize)
{       
    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
}

void main(void){
    float cosRotation = cos(aRotation);
    float sinRotation = sin(aRotation);
    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;
    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;

    vec2 v = vec2(x, y);
    v = v + aPosition;

    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    if(uRound == 1.0)
    {
        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
    }

    vUV = aUV;
    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;
}
`
    })
  var Zh,
    W0 = p(() => {
      Zh = `
struct ParticleUniforms {
  uProjectionMatrix:mat3x3<f32>,
  uColor:vec4<f32>,
  uResolution:vec2<f32>,
  uRoundPixels:f32,
};

@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;

@group(1) @binding(0) var uTexture: texture_2d<f32>;
@group(1) @binding(1) var uSampler : sampler;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) color : vec4<f32>,
  };
@vertex
fn mainVertex(
  @location(0) aVertex: vec2<f32>,
  @location(1) aPosition: vec2<f32>,
  @location(2) aUV: vec2<f32>,
  @location(3) aColor: vec4<f32>,
  @location(4) aRotation: f32,
) -> VSOutput {
  
   let v = vec2(
       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),
       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)
   ) + aPosition;

   let position = vec4((uniforms.uProjectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;

  return VSOutput(
   position,
   aUV,
   vColor,
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) color: vec4<f32>,
  @builtin(position) position: vec4<f32>,
) -> @location(0) vec4<f32> {

    var sample = textureSample(uTexture, uSampler, uv) * color;
   
    return sample;
}`
    })
  var Tu,
    V0 = p(() => {
      Vt()
      nt()
      oi()
      zi()
      Ae()
      dt()
      qr()
      N0()
      z0()
      W0()
      Tu = class extends Mt {
        constructor() {
          let t = ye.from({ vertex: H0, fragment: L0 }),
            e = be.from({
              fragment: { source: Zh, entryPoint: "mainFragment" },
              vertex: { source: Zh, entryPoint: "mainVertex" },
            })
          super({
            glProgram: t,
            gpuProgram: e,
            resources: {
              uTexture: k.WHITE.source,
              uSampler: new Jt({}),
              uniforms: {
                uTranslationMatrix: { value: new I(), type: "mat3x3<f32>" },
                uColor: { value: new q(16777215), type: "vec4<f32>" },
                uRound: { value: 1, type: "f32" },
                uResolution: { value: [0, 0], type: "vec2<f32>" },
              },
            },
          })
        }
      }
    })
  var Ji,
    Qh = p(() => {
      nt()
      re()
      xs()
      De()
      Qi()
      O0()
      V0()
      Ji = class {
        constructor(t, e) {
          ;((this.state = Dt.for2d()),
            (this.localUniforms = new ht({
              uTranslationMatrix: { value: new I(), type: "mat3x3<f32>" },
              uColor: { value: new Float32Array(4), type: "vec4<f32>" },
              uRound: { value: 1, type: "f32" },
              uResolution: { value: [0, 0], type: "vec2<f32>" },
            })),
            (this.renderer = t),
            (this.adaptor = e),
            (this.defaultShader = new Tu()),
            (this.state = Dt.for2d()))
        }
        validateRenderable(t) {
          return !1
        }
        addRenderable(t, e) {
          ;(this.renderer.renderPipes.batch.break(e), e.add(t))
        }
        getBuffers(t) {
          return t._gpuData[this.renderer.uid] || this._initBuffer(t)
        }
        _initBuffer(t) {
          return (
            (t._gpuData[this.renderer.uid] = new Su({
              size: t.particleChildren.length,
              properties: t._properties,
            })),
            t._gpuData[this.renderer.uid]
          )
        }
        updateRenderable(t) {}
        execute(t) {
          let e = t.particleChildren
          if (e.length === 0) return
          let i = this.renderer,
            n = this.getBuffers(t)
          t.texture || (t.texture = e[0].texture)
          let s = this.state
          ;(n.update(e, t._childrenDirty),
            (t._childrenDirty = !1),
            (s.blendMode = nr(t.blendMode, t.texture._source)))
          let o = this.localUniforms.uniforms,
            a = o.uTranslationMatrix
          ;(t.worldTransform.copyTo(a),
            a.prepend(i.globalUniforms.globalUniformData.projectionMatrix),
            (o.uResolution = i.globalUniforms.globalUniformData.resolution),
            (o.uRound = i._roundPixels | t._roundPixels),
            Ne(t.groupColorAlpha, o.uColor, 0),
            this.adaptor.execute(this, t))
        }
        destroy() {
          this.defaultShader && (this.defaultShader.destroy(), (this.defaultShader = null))
        }
      }
    })
  var Ds,
    $0 = p(() => {
      A()
      B0()
      Qh()
      Ds = class extends Ji {
        constructor(t) {
          super(t, new vu())
        }
      }
      Ds.extension = { type: [b.WebGLPipes], name: "particle" }
    })
  var Cu,
    X0 = p(() => {
      "use strict"
      Cu = class {
        execute(t, e) {
          let i = t.renderer,
            n = e.shader || t.defaultShader
          ;((n.groups[0] = i.renderPipes.uniformBatch.getUniformBindGroup(t.localUniforms, !0)),
            (n.groups[1] = i.texture.getTextureBindGroup(e.texture)))
          let s = t.state,
            o = t.getBuffers(e)
          i.encoder.draw({
            geometry: o.geometry,
            shader: e.shader || t.defaultShader,
            state: s,
            size: e.particleChildren.length * 6,
          })
        }
      }
    })
  var Ps,
    Y0 = p(() => {
      A()
      X0()
      Qh()
      Ps = class extends Ji {
        constructor(t) {
          super(t, new Cu())
        }
      }
      Ps.extension = { type: [b.WebGPUPipes], name: "particle" }
    })
  var Jh = p(() => {
    A()
    $0()
    Y0()
    L.add(Ds)
    L.add(Ps)
  })
  function Fs(r, t) {
    let { texture: e, bounds: i } = r,
      n = t._style._getFinalPadding()
    Za(i, t._anchor, e)
    let s = t._anchor._x * n * 2,
      o = t._anchor._y * n * 2
    ;((i.minX -= n - s), (i.minY -= n - o), (i.maxX -= n - s), (i.maxY -= n - o))
  }
  var tf = p(() => {
    Jc()
  })
  var He,
    Rs = p(() => {
      "use strict"
      He = class {
        constructor() {
          ;((this.batcherName = "default"),
            (this.topology = "triangle-list"),
            (this.attributeSize = 4),
            (this.indexSize = 6),
            (this.packAsQuad = !0),
            (this.roundPixels = 0),
            (this._attributeStart = 0),
            (this._batcher = null),
            (this._batch = null))
        }
        get blendMode() {
          return this.renderable.groupBlendMode
        }
        get color() {
          return this.renderable.groupColorAlpha
        }
        reset() {
          ;((this.renderable = null),
            (this.texture = null),
            (this._batcher = null),
            (this._batch = null),
            (this.bounds = null))
        }
        destroy() {}
      }
    })
  var Eu,
    j0 = p(() => {
      Rs()
      Eu = class extends He {
        constructor(t) {
          ;(super(), (this._renderer = t), t.runners.resolutionChange.add(this))
        }
        resolutionChange() {
          let t = this.renderable
          t._autoResolution && t.onViewUpdate()
        }
        destroy() {
          ;(this._renderer.canvasText.returnTexture(this.texture), (this._renderer = null))
        }
      }
    })
  var Bs,
    K0 = p(() => {
      A()
      tf()
      j0()
      Bs = class {
        constructor(t) {
          this._renderer = t
        }
        validateRenderable(t) {
          return t._didTextUpdate
        }
        addRenderable(t, e) {
          let i = this._getGpuText(t)
          ;(t._didTextUpdate && (this._updateGpuText(t), (t._didTextUpdate = !1)),
            this._renderer.renderPipes.batch.addToBatch(i, e))
        }
        updateRenderable(t) {
          let e = this._getGpuText(t)
          e._batcher.updateElement(e)
        }
        _updateGpuText(t) {
          let e = this._getGpuText(t)
          ;(e.texture && this._renderer.canvasText.returnTexture(e.texture),
            (t._resolution = t._autoResolution ? this._renderer.resolution : t.resolution),
            (e.texture = e.texture = this._renderer.canvasText.getTexture(t)),
            Fs(e, t))
        }
        _getGpuText(t) {
          return t._gpuData[this._renderer.uid] || this.initGpuText(t)
        }
        initGpuText(t) {
          let e = new Eu(this._renderer)
          return (
            (e.renderable = t),
            (e.transform = t.groupTransform),
            (e.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }),
            (e.roundPixels = this._renderer._roundPixels | t._roundPixels),
            (t._gpuData[this._renderer.uid] = e),
            e
          )
        }
        destroy() {
          this._renderer = null
        }
      }
      Bs.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "text" }
    })
  var q0,
    ar,
    wu = p(() => {
      nt()
      Ot()
      ;((q0 = {
        repeat: { addressModeU: "repeat", addressModeV: "repeat" },
        "repeat-x": { addressModeU: "repeat", addressModeV: "clamp-to-edge" },
        "repeat-y": { addressModeU: "clamp-to-edge", addressModeV: "repeat" },
        "no-repeat": { addressModeU: "clamp-to-edge", addressModeV: "clamp-to-edge" },
      }),
        (ar = class {
          constructor(t, e) {
            ;((this.uid = J("fillPattern")),
              (this.transform = new I()),
              (this._styleKey = null),
              (this.texture = t),
              this.transform.scale(1 / t.frame.width, 1 / t.frame.height),
              e &&
                ((t.source.style.addressModeU = q0[e].addressModeU),
                (t.source.style.addressModeV = q0[e].addressModeV)))
          }
          setTransform(t) {
            let e = this.texture
            ;(this.transform.copyFrom(t),
              this.transform.invert(),
              this.transform.scale(1 / e.frame.width, 1 / e.frame.height),
              (this._styleKey = null))
          }
          get styleKey() {
            return this._styleKey
              ? this._styleKey
              : ((this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`),
                this._styleKey)
          }
        }))
    })
  var Q0 = El((sV, Z0) => {
    Z0.exports = hD
    var ef = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 },
      cD = /([astvzqmhlc])([^astvzqmhlc]*)/gi
    function hD(r) {
      var t = []
      return (
        r.replace(cD, function (e, i, n) {
          var s = i.toLowerCase()
          for (
            n = dD(n),
              s == "m" &&
                n.length > 2 &&
                (t.push([i].concat(n.splice(0, 2))), (s = "l"), (i = i == "m" ? "l" : "L"));
            ;

          ) {
            if (n.length == ef[s]) return (n.unshift(i), t.push(n))
            if (n.length < ef[s]) throw new Error("malformed path data")
            t.push([i].concat(n.splice(0, ef[s])))
          }
        }),
        t
      )
    }
    var fD = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/gi
    function dD(r) {
      var t = r.match(fD)
      return t ? t.map(Number) : []
    }
  })
  function tb(r, t) {
    let e = (0, J0.default)(r),
      i = [],
      n = null,
      s = 0,
      o = 0
    for (let a = 0; a < e.length; a++) {
      let u = e[a],
        l = u[0],
        c = u
      switch (l) {
        case "M":
          ;((s = c[1]), (o = c[2]), t.moveTo(s, o))
          break
        case "m":
          ;((s += c[1]), (o += c[2]), t.moveTo(s, o))
          break
        case "H":
          ;((s = c[1]), t.lineTo(s, o))
          break
        case "h":
          ;((s += c[1]), t.lineTo(s, o))
          break
        case "V":
          ;((o = c[1]), t.lineTo(s, o))
          break
        case "v":
          ;((o += c[1]), t.lineTo(s, o))
          break
        case "L":
          ;((s = c[1]), (o = c[2]), t.lineTo(s, o))
          break
        case "l":
          ;((s += c[1]), (o += c[2]), t.lineTo(s, o))
          break
        case "C":
          ;((s = c[5]), (o = c[6]), t.bezierCurveTo(c[1], c[2], c[3], c[4], s, o))
          break
        case "c":
          ;(t.bezierCurveTo(s + c[1], o + c[2], s + c[3], o + c[4], s + c[5], o + c[6]),
            (s += c[5]),
            (o += c[6]))
          break
        case "S":
          ;((s = c[3]), (o = c[4]), t.bezierCurveToShort(c[1], c[2], s, o))
          break
        case "s":
          ;(t.bezierCurveToShort(s + c[1], o + c[2], s + c[3], o + c[4]), (s += c[3]), (o += c[4]))
          break
        case "Q":
          ;((s = c[3]), (o = c[4]), t.quadraticCurveTo(c[1], c[2], s, o))
          break
        case "q":
          ;(t.quadraticCurveTo(s + c[1], o + c[2], s + c[3], o + c[4]), (s += c[3]), (o += c[4]))
          break
        case "T":
          ;((s = c[1]), (o = c[2]), t.quadraticCurveToShort(s, o))
          break
        case "t":
          ;((s += c[1]), (o += c[2]), t.quadraticCurveToShort(s, o))
          break
        case "A":
          ;((s = c[6]), (o = c[7]), t.arcToSvg(c[1], c[2], c[3], c[4], c[5], s, o))
          break
        case "a":
          ;((s += c[6]), (o += c[7]), t.arcToSvg(c[1], c[2], c[3], c[4], c[5], s, o))
          break
        case "Z":
        case "z":
          ;(t.closePath(),
            i.length > 0 &&
              ((n = i.pop()), n ? ((s = n.startX), (o = n.startY)) : ((s = 0), (o = 0))),
            (n = null))
          break
        default:
          N(`Unknown SVG path command: ${l}`)
      }
      l !== "Z" && l !== "z" && n === null && ((n = { startX: s, startY: o }), i.push(n))
    }
    return t
  }
  var J0,
    eb = p(() => {
      J0 = wl(Q0(), 1)
      ft()
    })
  var hi,
    rf = p(() => {
      Lt()
      hi = class r {
        constructor(t = 0, e = 0, i = 0) {
          ;((this.type = "circle"), (this.x = t), (this.y = e), (this.radius = i))
        }
        clone() {
          return new r(this.x, this.y, this.radius)
        }
        contains(t, e) {
          if (this.radius <= 0) return !1
          let i = this.radius * this.radius,
            n = this.x - t,
            s = this.y - e
          return ((n *= n), (s *= s), n + s <= i)
        }
        strokeContains(t, e, i, n = 0.5) {
          if (this.radius === 0) return !1
          let s = this.x - t,
            o = this.y - e,
            a = this.radius,
            u = (1 - n) * i,
            l = Math.sqrt(s * s + o * o)
          return l <= a + u && l > a - (i - u)
        }
        getBounds(t) {
          return (
            t || (t = new Q()),
            (t.x = this.x - this.radius),
            (t.y = this.y - this.radius),
            (t.width = this.radius * 2),
            (t.height = this.radius * 2),
            t
          )
        }
        copyFrom(t) {
          return ((this.x = t.x), (this.y = t.y), (this.radius = t.radius), this)
        }
        copyTo(t) {
          return (t.copyFrom(this), t)
        }
        toString() {
          return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`
        }
      }
    })
  var Mu,
    rb = p(() => {
      Lt()
      Mu = class r {
        constructor(t = 0, e = 0, i = 0, n = 0) {
          ;((this.type = "ellipse"),
            (this.x = t),
            (this.y = e),
            (this.halfWidth = i),
            (this.halfHeight = n))
        }
        clone() {
          return new r(this.x, this.y, this.halfWidth, this.halfHeight)
        }
        contains(t, e) {
          if (this.halfWidth <= 0 || this.halfHeight <= 0) return !1
          let i = (t - this.x) / this.halfWidth,
            n = (e - this.y) / this.halfHeight
          return ((i *= i), (n *= n), i + n <= 1)
        }
        strokeContains(t, e, i, n = 0.5) {
          let { halfWidth: s, halfHeight: o } = this
          if (s <= 0 || o <= 0) return !1
          let a = i * (1 - n),
            u = i - a,
            l = s - u,
            c = o - u,
            h = s + a,
            f = o + a,
            d = t - this.x,
            g = e - this.y,
            x = (d * d) / (l * l) + (g * g) / (c * c),
            m = (d * d) / (h * h) + (g * g) / (f * f)
          return x > 1 && m <= 1
        }
        getBounds(t) {
          return (
            t || (t = new Q()),
            (t.x = this.x - this.halfWidth),
            (t.y = this.y - this.halfHeight),
            (t.width = this.halfWidth * 2),
            (t.height = this.halfHeight * 2),
            t
          )
        }
        copyFrom(t) {
          return (
            (this.x = t.x),
            (this.y = t.y),
            (this.halfWidth = t.halfWidth),
            (this.halfHeight = t.halfHeight),
            this
          )
        }
        copyTo(t) {
          return (t.copyFrom(this), t)
        }
        toString() {
          return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`
        }
      }
    })
  function ib(r, t, e, i, n, s) {
    let o = r - e,
      a = t - i,
      u = n - e,
      l = s - i,
      c = o * u + a * l,
      h = u * u + l * l,
      f = -1
    h !== 0 && (f = c / h)
    let d, g
    f < 0 ? ((d = e), (g = i)) : f > 1 ? ((d = n), (g = s)) : ((d = e + f * u), (g = i + f * l))
    let x = r - d,
      m = t - g
    return x * x + m * m
  }
  var nb = p(() => {
    "use strict"
  })
  var pD,
    mD,
    tn,
    sb = p(() => {
      gt()
      nb()
      Lt()
      tn = class r {
        constructor(...t) {
          this.type = "polygon"
          let e = Array.isArray(t[0]) ? t[0] : t
          if (typeof e[0] != "number") {
            let i = []
            for (let n = 0, s = e.length; n < s; n++) i.push(e[n].x, e[n].y)
            e = i
          }
          ;((this.points = e), (this.closePath = !0))
        }
        isClockwise() {
          let t = 0,
            e = this.points,
            i = e.length
          for (let n = 0; n < i; n += 2) {
            let s = e[n],
              o = e[n + 1],
              a = e[(n + 2) % i],
              u = e[(n + 3) % i]
            t += (a - s) * (u + o)
          }
          return t < 0
        }
        containsPolygon(t) {
          let e = this.getBounds(pD),
            i = t.getBounds(mD)
          if (!e.containsRect(i)) return !1
          let n = t.points
          for (let s = 0; s < n.length; s += 2) {
            let o = n[s],
              a = n[s + 1]
            if (!this.contains(o, a)) return !1
          }
          return !0
        }
        clone() {
          let t = this.points.slice(),
            e = new r(t)
          return ((e.closePath = this.closePath), e)
        }
        contains(t, e) {
          let i = !1,
            n = this.points.length / 2
          for (let s = 0, o = n - 1; s < n; o = s++) {
            let a = this.points[s * 2],
              u = this.points[s * 2 + 1],
              l = this.points[o * 2],
              c = this.points[o * 2 + 1]
            u > e != c > e && t < (l - a) * ((e - u) / (c - u)) + a && (i = !i)
          }
          return i
        }
        strokeContains(t, e, i, n = 0.5) {
          let s = i * i,
            o = s * (1 - n),
            a = s - o,
            { points: u } = this,
            l = u.length - (this.closePath ? 0 : 2)
          for (let c = 0; c < l; c += 2) {
            let h = u[c],
              f = u[c + 1],
              d = u[(c + 2) % u.length],
              g = u[(c + 3) % u.length],
              x = ib(t, e, h, f, d, g),
              m = Math.sign((d - h) * (e - f) - (g - f) * (t - h))
            if (x <= (m < 0 ? a : o)) return !0
          }
          return !1
        }
        getBounds(t) {
          t || (t = new Q())
          let e = this.points,
            i = 1 / 0,
            n = -1 / 0,
            s = 1 / 0,
            o = -1 / 0
          for (let a = 0, u = e.length; a < u; a += 2) {
            let l = e[a],
              c = e[a + 1]
            ;((i = l < i ? l : i), (n = l > n ? l : n), (s = c < s ? c : s), (o = c > o ? c : o))
          }
          return ((t.x = i), (t.width = n - i), (t.y = s), (t.height = o - s), t)
        }
        copyFrom(t) {
          return ((this.points = t.points.slice()), (this.closePath = t.closePath), this)
        }
        copyTo(t) {
          return (t.copyFrom(this), t)
        }
        toString() {
          return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((t, e) => `${t}, ${e}`, "")}]`
        }
        get lastX() {
          return this.points[this.points.length - 2]
        }
        get lastY() {
          return this.points[this.points.length - 1]
        }
        get x() {
          return (
            z("8.11.0", "Polygon.lastX is deprecated, please use Polygon.lastX instead."),
            this.points[this.points.length - 2]
          )
        }
        get y() {
          return (
            z("8.11.0", "Polygon.y is deprecated, please use Polygon.lastY instead."),
            this.points[this.points.length - 1]
          )
        }
        get startX() {
          return this.points[0]
        }
        get startY() {
          return this.points[1]
        }
      }
    })
  var Au,
    Du,
    ob = p(() => {
      Lt()
      ;((Au = (r, t, e, i, n, s, o) => {
        let a = r - e,
          u = t - i,
          l = Math.sqrt(a * a + u * u)
        return l >= n - s && l <= n + o
      }),
        (Du = class r {
          constructor(t = 0, e = 0, i = 0, n = 0, s = 20) {
            ;((this.type = "roundedRectangle"),
              (this.x = t),
              (this.y = e),
              (this.width = i),
              (this.height = n),
              (this.radius = s))
          }
          getBounds(t) {
            return (
              t || (t = new Q()),
              (t.x = this.x),
              (t.y = this.y),
              (t.width = this.width),
              (t.height = this.height),
              t
            )
          }
          clone() {
            return new r(this.x, this.y, this.width, this.height, this.radius)
          }
          copyFrom(t) {
            return (
              (this.x = t.x),
              (this.y = t.y),
              (this.width = t.width),
              (this.height = t.height),
              this
            )
          }
          copyTo(t) {
            return (t.copyFrom(this), t)
          }
          contains(t, e) {
            if (this.width <= 0 || this.height <= 0) return !1
            if (
              t >= this.x &&
              t <= this.x + this.width &&
              e >= this.y &&
              e <= this.y + this.height
            ) {
              let i = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2))
              if (
                (e >= this.y + i && e <= this.y + this.height - i) ||
                (t >= this.x + i && t <= this.x + this.width - i)
              )
                return !0
              let n = t - (this.x + i),
                s = e - (this.y + i),
                o = i * i
              if (
                n * n + s * s <= o ||
                ((n = t - (this.x + this.width - i)), n * n + s * s <= o) ||
                ((s = e - (this.y + this.height - i)), n * n + s * s <= o) ||
                ((n = t - (this.x + i)), n * n + s * s <= o)
              )
                return !0
            }
            return !1
          }
          strokeContains(t, e, i, n = 0.5) {
            let { x: s, y: o, width: a, height: u, radius: l } = this,
              c = i * (1 - n),
              h = i - c,
              f = s + l,
              d = o + l,
              g = a - l * 2,
              x = u - l * 2,
              m = s + a,
              _ = o + u
            return (((t >= s - c && t <= s + h) || (t >= m - h && t <= m + c)) &&
              e >= d &&
              e <= d + x) ||
              (((e >= o - c && e <= o + h) || (e >= _ - h && e <= _ + c)) && t >= f && t <= f + g)
              ? !0
              : (t < f && e < d && Au(t, e, f, d, l, h, c)) ||
                  (t > m - l && e < d && Au(t, e, m - l, d, l, h, c)) ||
                  (t > m - l && e > _ - l && Au(t, e, m - l, _ - l, l, h, c)) ||
                  (t < f && e > _ - l && Au(t, e, f, _ - l, l, h, c))
          }
          toString() {
            return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`
          }
        }))
    })
  function Fu(r, t, e, i, n, s, o, a, u, l) {
    let h = Math.min(0.99, Math.max(0, l ?? Zi.defaultOptions.bezierSmoothness)),
      f = (xD - h) / 1
    return ((f *= f), _D(t, e, i, n, s, o, a, u, r, f), r)
  }
  function _D(r, t, e, i, n, s, o, a, u, l) {
    ;(sf(r, t, e, i, n, s, o, a, u, l, 0), u.push(o, a))
  }
  function sf(r, t, e, i, n, s, o, a, u, l, c) {
    if (c > gD) return
    let h = Math.PI,
      f = (r + e) / 2,
      d = (t + i) / 2,
      g = (e + n) / 2,
      x = (i + s) / 2,
      m = (n + o) / 2,
      _ = (s + a) / 2,
      v = (f + g) / 2,
      S = (d + x) / 2,
      y = (g + m) / 2,
      M = (x + _) / 2,
      T = (v + y) / 2,
      E = (S + M) / 2
    if (c > 0) {
      let G = o - r,
        B = a - t,
        P = Math.abs((e - o) * B - (i - a) * G),
        F = Math.abs((n - o) * B - (s - a) * G),
        W,
        j
      if (P > Pu && F > Pu) {
        if ((P + F) * (P + F) <= l * (G * G + B * B)) {
          if (en < nf) {
            u.push(T, E)
            return
          }
          let C = Math.atan2(s - i, n - e)
          if (
            ((W = Math.abs(C - Math.atan2(i - t, e - r))),
            (j = Math.abs(Math.atan2(a - s, o - n) - C)),
            W >= h && (W = 2 * h - W),
            j >= h && (j = 2 * h - j),
            W + j < en)
          ) {
            u.push(T, E)
            return
          }
          if (fi !== 0) {
            if (W > fi) {
              u.push(e, i)
              return
            }
            if (j > fi) {
              u.push(n, s)
              return
            }
          }
        }
      } else if (P > Pu) {
        if (P * P <= l * (G * G + B * B)) {
          if (en < nf) {
            u.push(T, E)
            return
          }
          if (
            ((W = Math.abs(Math.atan2(s - i, n - e) - Math.atan2(i - t, e - r))),
            W >= h && (W = 2 * h - W),
            W < en)
          ) {
            ;(u.push(e, i), u.push(n, s))
            return
          }
          if (fi !== 0 && W > fi) {
            u.push(e, i)
            return
          }
        }
      } else if (F > Pu) {
        if (F * F <= l * (G * G + B * B)) {
          if (en < nf) {
            u.push(T, E)
            return
          }
          if (
            ((W = Math.abs(Math.atan2(a - s, o - n) - Math.atan2(s - i, n - e))),
            W >= h && (W = 2 * h - W),
            W < en)
          ) {
            ;(u.push(e, i), u.push(n, s))
            return
          }
          if (fi !== 0 && W > fi) {
            u.push(n, s)
            return
          }
        }
      } else if (((G = T - (r + o) / 2), (B = E - (t + a) / 2), G * G + B * B <= l)) {
        u.push(T, E)
        return
      }
    }
    ;(sf(r, t, f, d, v, S, T, E, u, l, c + 1), sf(T, E, y, M, m, _, o, a, u, l, c + 1))
  }
  var gD,
    Pu,
    xD,
    nf,
    en,
    fi,
    of = p(() => {
      _u()
      ;((gD = 8), (Pu = 11920929e-14), (xD = 1), (nf = 0.01), (en = 0), (fi = 0))
    })
  function ub(r, t, e, i, n, s, o, a) {
    let l = Math.min(0.99, Math.max(0, a ?? Zi.defaultOptions.bezierSmoothness)),
      c = (vD - l) / 1
    return ((c *= c), TD(t, e, i, n, s, o, r, c), r)
  }
  function TD(r, t, e, i, n, s, o, a) {
    ;(af(o, r, t, e, i, n, s, a, 0), o.push(n, s))
  }
  function af(r, t, e, i, n, s, o, a, u) {
    if (u > yD) return
    let l = Math.PI,
      c = (t + i) / 2,
      h = (e + n) / 2,
      f = (i + s) / 2,
      d = (n + o) / 2,
      g = (c + f) / 2,
      x = (h + d) / 2,
      m = s - t,
      _ = o - e,
      v = Math.abs((i - s) * _ - (n - o) * m)
    if (v > bD) {
      if (v * v <= a * (m * m + _ * _)) {
        if (ab < SD) {
          r.push(g, x)
          return
        }
        let S = Math.abs(Math.atan2(o - n, s - i) - Math.atan2(n - e, i - t))
        if ((S >= l && (S = 2 * l - S), S < ab)) {
          r.push(g, x)
          return
        }
      }
    } else if (((m = g - (t + s) / 2), (_ = x - (e + o) / 2), m * m + _ * _ <= a)) {
      r.push(g, x)
      return
    }
    ;(af(r, t, e, c, h, g, x, a, u + 1), af(r, g, x, f, d, s, o, a, u + 1))
  }
  var yD,
    bD,
    vD,
    SD,
    ab,
    lb = p(() => {
      _u()
      ;((yD = 8), (bD = 11920929e-14), (vD = 1), (SD = 0.01), (ab = 0))
    })
  function Ru(r, t, e, i, n, s, o, a) {
    let u = Math.abs(n - s)
    ;(((!o && n > s) || (o && s > n)) && (u = 2 * Math.PI - u),
      a || (a = Math.max(6, Math.floor(6 * Math.pow(i, 1 / 3) * (u / Math.PI)))),
      (a = Math.max(a, 3)))
    let l = u / a,
      c = n
    l *= o ? -1 : 1
    for (let h = 0; h < a + 1; h++) {
      let f = Math.cos(c),
        d = Math.sin(c),
        g = t + f * i,
        x = e + d * i
      ;(r.push(g, x), (c += l))
    }
  }
  var uf = p(() => {
    "use strict"
  })
  function cb(r, t, e, i, n, s) {
    let o = r[r.length - 2],
      u = r[r.length - 1] - e,
      l = o - t,
      c = n - e,
      h = i - t,
      f = Math.abs(u * h - l * c)
    if (f < 1e-8 || s === 0) {
      ;(r[r.length - 2] !== t || r[r.length - 1] !== e) && r.push(t, e)
      return
    }
    let d = u * u + l * l,
      g = c * c + h * h,
      x = u * c + l * h,
      m = (s * Math.sqrt(d)) / f,
      _ = (s * Math.sqrt(g)) / f,
      v = (m * x) / d,
      S = (_ * x) / g,
      y = m * h + _ * l,
      M = m * c + _ * u,
      T = l * (_ + v),
      E = u * (_ + v),
      G = h * (m + S),
      B = c * (m + S),
      P = Math.atan2(E - M, T - y),
      F = Math.atan2(B - M, G - y)
    Ru(r, y + t, M + e, s, P, F, l * c > h * u)
  }
  var hb = p(() => {
    uf()
  })
  function CD(r, t) {
    let e = t === -1.5707963267948966 ? -0.551915024494 : 1.3333333333333333 * Math.tan(t / 4),
      i = t === 1.5707963267948966 ? 0.551915024494 : e,
      n = Math.cos(r),
      s = Math.sin(r),
      o = Math.cos(r + t),
      a = Math.sin(r + t)
    return [
      { x: n - s * i, y: s + n * i },
      { x: o + a * i, y: a - o * i },
      { x: o, y: a },
    ]
  }
  function db(r, t, e, i, n, s, o, a = 0, u = 0, l = 0) {
    if (s === 0 || o === 0) return
    let c = Math.sin((a * Is) / 360),
      h = Math.cos((a * Is) / 360),
      f = (h * (t - i)) / 2 + (c * (e - n)) / 2,
      d = (-c * (t - i)) / 2 + (h * (e - n)) / 2
    if (f === 0 && d === 0) return
    ;((s = Math.abs(s)), (o = Math.abs(o)))
    let g = Math.pow(f, 2) / Math.pow(s, 2) + Math.pow(d, 2) / Math.pow(o, 2)
    ;(g > 1 && ((s *= Math.sqrt(g)), (o *= Math.sqrt(g))),
      ED(t, e, i, n, s, o, u, l, c, h, f, d, lf))
    let { ang1: x, ang2: m } = lf,
      { centerX: _, centerY: v } = lf,
      S = Math.abs(m) / (Is / 4)
    Math.abs(1 - S) < 1e-7 && (S = 1)
    let y = Math.max(Math.ceil(S), 1)
    m /= y
    let M = r[r.length - 2],
      T = r[r.length - 1],
      E = { x: 0, y: 0 }
    for (let G = 0; G < y; G++) {
      let B = CD(x, m),
        { x: P, y: F } = cf(B[0], s, o, h, c, _, v, E),
        { x: W, y: j } = cf(B[1], s, o, h, c, _, v, E),
        { x: C, y: H } = cf(B[2], s, o, h, c, _, v, E)
      ;(Fu(r, M, T, P, F, W, j, C, H), (M = C), (T = H), (x += m))
    }
  }
  var Is,
    lf,
    cf,
    fb,
    ED,
    pb = p(() => {
      of()
      ;((Is = Math.PI * 2),
        (lf = { centerX: 0, centerY: 0, ang1: 0, ang2: 0 }),
        (cf = ({ x: r, y: t }, e, i, n, s, o, a, u) => {
          ;((r *= e), (t *= i))
          let l = n * r - s * t,
            c = s * r + n * t
          return ((u.x = l + o), (u.y = c + a), u)
        }))
      ;((fb = (r, t, e, i) => {
        let n = r * i - t * e < 0 ? -1 : 1,
          s = r * e + t * i
        return (s > 1 && (s = 1), s < -1 && (s = -1), n * Math.acos(s))
      }),
        (ED = (r, t, e, i, n, s, o, a, u, l, c, h, f) => {
          let d = Math.pow(n, 2),
            g = Math.pow(s, 2),
            x = Math.pow(c, 2),
            m = Math.pow(h, 2),
            _ = d * g - d * m - g * x
          ;(_ < 0 && (_ = 0), (_ /= d * m + g * x), (_ = Math.sqrt(_) * (o === a ? -1 : 1)))
          let v = ((_ * n) / s) * h,
            S = ((_ * -s) / n) * c,
            y = l * v - u * S + (r + e) / 2,
            M = u * v + l * S + (t + i) / 2,
            T = (c - v) / n,
            E = (h - S) / s,
            G = (-c - v) / n,
            B = (-h - S) / s,
            P = fb(1, 0, T, E),
            F = fb(T, E, G, B)
          ;(a === 0 && F > 0 && (F -= Is),
            a === 1 && F < 0 && (F += Is),
            (f.centerX = y),
            (f.centerY = M),
            (f.ang1 = P),
            (f.ang2 = F))
        }))
    })
  function mb(r, t, e) {
    let i = (o, a) => {
        let u = a.x - o.x,
          l = a.y - o.y,
          c = Math.sqrt(u * u + l * l),
          h = u / c,
          f = l / c
        return { len: c, nx: h, ny: f }
      },
      n = (o, a) => {
        o === 0 ? r.moveTo(a.x, a.y) : r.lineTo(a.x, a.y)
      },
      s = t[t.length - 1]
    for (let o = 0; o < t.length; o++) {
      let a = t[o % t.length],
        u = a.radius ?? e
      if (u <= 0) {
        ;(n(o, a), (s = a))
        continue
      }
      let l = t[(o + 1) % t.length],
        c = i(a, s),
        h = i(a, l)
      if (c.len < 1e-4 || h.len < 1e-4) {
        ;(n(o, a), (s = a))
        continue
      }
      let f = Math.asin(c.nx * h.ny - c.ny * h.nx),
        d = 1,
        g = !1
      c.nx * h.nx - c.ny * -h.ny < 0
        ? f < 0
          ? (f = Math.PI + f)
          : ((f = Math.PI - f), (d = -1), (g = !0))
        : f > 0 && ((d = -1), (g = !0))
      let x = f / 2,
        m,
        _ = Math.abs((Math.cos(x) * u) / Math.sin(x))
      _ > Math.min(c.len / 2, h.len / 2)
        ? ((_ = Math.min(c.len / 2, h.len / 2)), (m = Math.abs((_ * Math.sin(x)) / Math.cos(x))))
        : (m = u)
      let v = a.x + h.nx * _ + -h.ny * m * d,
        S = a.y + h.ny * _ + h.nx * m * d,
        y = Math.atan2(c.ny, c.nx) + (Math.PI / 2) * d,
        M = Math.atan2(h.ny, h.nx) - (Math.PI / 2) * d
      ;(o === 0 && r.moveTo(v + Math.cos(y) * m, S + Math.sin(y) * m),
        r.arc(v, S, m, y, M, g),
        (s = a))
    }
  }
  function gb(r, t, e, i) {
    let n = (a, u) => Math.sqrt((a.x - u.x) ** 2 + (a.y - u.y) ** 2),
      s = (a, u, l) => ({ x: a.x + (u.x - a.x) * l, y: a.y + (u.y - a.y) * l }),
      o = t.length
    for (let a = 0; a < o; a++) {
      let u = t[(a + 1) % o],
        l = u.radius ?? e
      if (l <= 0) {
        a === 0 ? r.moveTo(u.x, u.y) : r.lineTo(u.x, u.y)
        continue
      }
      let c = t[a],
        h = t[(a + 2) % o],
        f = n(c, u),
        d
      if (f < 1e-4) d = u
      else {
        let m = Math.min(f / 2, l)
        d = s(u, c, m / f)
      }
      let g = n(h, u),
        x
      if (g < 1e-4) x = u
      else {
        let m = Math.min(g / 2, l)
        x = s(u, h, m / g)
      }
      ;(a === 0 ? r.moveTo(d.x, d.y) : r.lineTo(d.x, d.y),
        r.quadraticCurveTo(u.x, u.y, x.x, x.y, i))
    }
  }
  var xb = p(() => {
    "use strict"
  })
  var wD,
    Bu,
    _b = p(() => {
      rf()
      rb()
      sb()
      Lt()
      ob()
      se()
      of()
      lb()
      uf()
      hb()
      pb()
      xb()
      ;((wD = new Q()),
        (Bu = class {
          constructor(t) {
            ;((this.shapePrimitives = []),
              (this._currentPoly = null),
              (this._bounds = new ct()),
              (this._graphicsPath2D = t),
              (this.signed = t.checkForHoles))
          }
          moveTo(t, e) {
            return (this.startPoly(t, e), this)
          }
          lineTo(t, e) {
            this._ensurePoly()
            let i = this._currentPoly.points,
              n = i[i.length - 2],
              s = i[i.length - 1]
            return ((n !== t || s !== e) && i.push(t, e), this)
          }
          arc(t, e, i, n, s, o) {
            this._ensurePoly(!1)
            let a = this._currentPoly.points
            return (Ru(a, t, e, i, n, s, o), this)
          }
          arcTo(t, e, i, n, s) {
            this._ensurePoly()
            let o = this._currentPoly.points
            return (cb(o, t, e, i, n, s), this)
          }
          arcToSvg(t, e, i, n, s, o, a) {
            let u = this._currentPoly.points
            return (
              db(u, this._currentPoly.lastX, this._currentPoly.lastY, o, a, t, e, i, n, s),
              this
            )
          }
          bezierCurveTo(t, e, i, n, s, o, a) {
            this._ensurePoly()
            let u = this._currentPoly
            return (Fu(this._currentPoly.points, u.lastX, u.lastY, t, e, i, n, s, o, a), this)
          }
          quadraticCurveTo(t, e, i, n, s) {
            this._ensurePoly()
            let o = this._currentPoly
            return (ub(this._currentPoly.points, o.lastX, o.lastY, t, e, i, n, s), this)
          }
          closePath() {
            return (this.endPoly(!0), this)
          }
          addPath(t, e) {
            ;(this.endPoly(), e && !e.isIdentity() && ((t = t.clone(!0)), t.transform(e)))
            let i = this.shapePrimitives,
              n = i.length
            for (let s = 0; s < t.instructions.length; s++) {
              let o = t.instructions[s]
              this[o.action](...o.data)
            }
            if (t.checkForHoles && i.length - n > 1) {
              let s = null
              for (let o = n; o < i.length; o++) {
                let a = i[o]
                if (a.shape.type === "polygon") {
                  let u = a.shape,
                    l = s?.shape
                  l && l.containsPolygon(u)
                    ? (s.holes || (s.holes = []),
                      s.holes.push(a),
                      i.copyWithin(o, o + 1),
                      i.length--,
                      o--)
                    : (s = a)
                }
              }
            }
            return this
          }
          finish(t = !1) {
            this.endPoly(t)
          }
          rect(t, e, i, n, s) {
            return (this.drawShape(new Q(t, e, i, n), s), this)
          }
          circle(t, e, i, n) {
            return (this.drawShape(new hi(t, e, i), n), this)
          }
          poly(t, e, i) {
            let n = new tn(t)
            return ((n.closePath = e), this.drawShape(n, i), this)
          }
          regularPoly(t, e, i, n, s = 0, o) {
            n = Math.max(n | 0, 3)
            let a = (-1 * Math.PI) / 2 + s,
              u = (Math.PI * 2) / n,
              l = []
            for (let c = 0; c < n; c++) {
              let h = a - c * u
              l.push(t + i * Math.cos(h), e + i * Math.sin(h))
            }
            return (this.poly(l, !0, o), this)
          }
          roundPoly(t, e, i, n, s, o = 0, a) {
            if (((n = Math.max(n | 0, 3)), s <= 0)) return this.regularPoly(t, e, i, n, o)
            let u = i * Math.sin(Math.PI / n) - 0.001
            s = Math.min(s, u)
            let l = (-1 * Math.PI) / 2 + o,
              c = (Math.PI * 2) / n,
              h = ((n - 2) * Math.PI) / n / 2
            for (let f = 0; f < n; f++) {
              let d = f * c + l,
                g = t + i * Math.cos(d),
                x = e + i * Math.sin(d),
                m = d + Math.PI + h,
                _ = d - Math.PI - h,
                v = g + s * Math.cos(m),
                S = x + s * Math.sin(m),
                y = g + s * Math.cos(_),
                M = x + s * Math.sin(_)
              ;(f === 0 ? this.moveTo(v, S) : this.lineTo(v, S),
                this.quadraticCurveTo(g, x, y, M, a))
            }
            return this.closePath()
          }
          roundShape(t, e, i = !1, n) {
            return t.length < 3 ? this : (i ? gb(this, t, e, n) : mb(this, t, e), this.closePath())
          }
          filletRect(t, e, i, n, s) {
            if (s === 0) return this.rect(t, e, i, n)
            let o = Math.min(i, n) / 2,
              a = Math.min(o, Math.max(-o, s)),
              u = t + i,
              l = e + n,
              c = a < 0 ? -a : 0,
              h = Math.abs(a)
            return this.moveTo(t, e + h)
              .arcTo(t + c, e + c, t + h, e, h)
              .lineTo(u - h, e)
              .arcTo(u - c, e + c, u, e + h, h)
              .lineTo(u, l - h)
              .arcTo(u - c, l - c, t + i - h, l, h)
              .lineTo(t + h, l)
              .arcTo(t + c, l - c, t, l - h, h)
              .closePath()
          }
          chamferRect(t, e, i, n, s, o) {
            if (s <= 0) return this.rect(t, e, i, n)
            let a = Math.min(s, Math.min(i, n) / 2),
              u = t + i,
              l = e + n,
              c = [t + a, e, u - a, e, u, e + a, u, l - a, u - a, l, t + a, l, t, l - a, t, e + a]
            for (let h = c.length - 1; h >= 2; h -= 2)
              c[h] === c[h - 2] && c[h - 1] === c[h - 3] && c.splice(h - 1, 2)
            return this.poly(c, !0, o)
          }
          ellipse(t, e, i, n, s) {
            return (this.drawShape(new Mu(t, e, i, n), s), this)
          }
          roundRect(t, e, i, n, s, o) {
            return (this.drawShape(new Du(t, e, i, n, s), o), this)
          }
          drawShape(t, e) {
            return (this.endPoly(), this.shapePrimitives.push({ shape: t, transform: e }), this)
          }
          startPoly(t, e) {
            let i = this._currentPoly
            return (
              i && this.endPoly(),
              (i = new tn()),
              i.points.push(t, e),
              (this._currentPoly = i),
              this
            )
          }
          endPoly(t = !1) {
            let e = this._currentPoly
            return (
              e &&
                e.points.length > 2 &&
                ((e.closePath = t), this.shapePrimitives.push({ shape: e })),
              (this._currentPoly = null),
              this
            )
          }
          _ensurePoly(t = !0) {
            if (!this._currentPoly && ((this._currentPoly = new tn()), t)) {
              let e = this.shapePrimitives[this.shapePrimitives.length - 1]
              if (e) {
                let i = e.shape.x,
                  n = e.shape.y
                if (e.transform && !e.transform.isIdentity()) {
                  let s = e.transform,
                    o = i
                  ;((i = s.a * i + s.c * n + s.tx), (n = s.b * o + s.d * n + s.ty))
                }
                this._currentPoly.points.push(i, n)
              } else this._currentPoly.points.push(0, 0)
            }
          }
          buildPath() {
            let t = this._graphicsPath2D
            ;((this.shapePrimitives.length = 0), (this._currentPoly = null))
            for (let e = 0; e < t.instructions.length; e++) {
              let i = t.instructions[e]
              this[i.action](...i.data)
            }
            this.finish()
          }
          get bounds() {
            let t = this._bounds
            t.clear()
            let e = this.shapePrimitives
            for (let i = 0; i < e.length; i++) {
              let n = e[i],
                s = n.shape.getBounds(wD)
              n.transform ? t.addRect(s, n.transform) : t.addRect(s)
            }
            return t
          }
        }))
    })
  function ks(r, t) {
    return r ? r.prepend(t) : t.clone()
  }
  var Dr,
    hf = p(() => {
      Ee()
      Ot()
      ft()
      eb()
      _b()
      Dr = class r {
        constructor(t, e = !1) {
          ;((this.instructions = []),
            (this.uid = J("graphicsPath")),
            (this._dirty = !0),
            (this.checkForHoles = e),
            typeof t == "string" ? tb(t, this) : (this.instructions = t?.slice() ?? []))
        }
        get shapePath() {
          return (
            this._shapePath || (this._shapePath = new Bu(this)),
            this._dirty && ((this._dirty = !1), this._shapePath.buildPath()),
            this._shapePath
          )
        }
        addPath(t, e) {
          return (
            (t = t.clone()),
            this.instructions.push({ action: "addPath", data: [t, e] }),
            (this._dirty = !0),
            this
          )
        }
        arc(...t) {
          return (this.instructions.push({ action: "arc", data: t }), (this._dirty = !0), this)
        }
        arcTo(...t) {
          return (this.instructions.push({ action: "arcTo", data: t }), (this._dirty = !0), this)
        }
        arcToSvg(...t) {
          return (this.instructions.push({ action: "arcToSvg", data: t }), (this._dirty = !0), this)
        }
        bezierCurveTo(...t) {
          return (
            this.instructions.push({ action: "bezierCurveTo", data: t }),
            (this._dirty = !0),
            this
          )
        }
        bezierCurveToShort(t, e, i, n, s) {
          let o = this.instructions[this.instructions.length - 1],
            a = this.getLastPoint(rt.shared),
            u = 0,
            l = 0
          if (!o || o.action !== "bezierCurveTo") ((u = a.x), (l = a.y))
          else {
            ;((u = o.data[2]), (l = o.data[3]))
            let c = a.x,
              h = a.y
            ;((u = c + (c - u)), (l = h + (h - l)))
          }
          return (
            this.instructions.push({ action: "bezierCurveTo", data: [u, l, t, e, i, n, s] }),
            (this._dirty = !0),
            this
          )
        }
        closePath() {
          return (
            this.instructions.push({ action: "closePath", data: [] }),
            (this._dirty = !0),
            this
          )
        }
        ellipse(...t) {
          return (this.instructions.push({ action: "ellipse", data: t }), (this._dirty = !0), this)
        }
        lineTo(...t) {
          return (this.instructions.push({ action: "lineTo", data: t }), (this._dirty = !0), this)
        }
        moveTo(...t) {
          return (this.instructions.push({ action: "moveTo", data: t }), this)
        }
        quadraticCurveTo(...t) {
          return (
            this.instructions.push({ action: "quadraticCurveTo", data: t }),
            (this._dirty = !0),
            this
          )
        }
        quadraticCurveToShort(t, e, i) {
          let n = this.instructions[this.instructions.length - 1],
            s = this.getLastPoint(rt.shared),
            o = 0,
            a = 0
          if (!n || n.action !== "quadraticCurveTo") ((o = s.x), (a = s.y))
          else {
            ;((o = n.data[0]), (a = n.data[1]))
            let u = s.x,
              l = s.y
            ;((o = u + (u - o)), (a = l + (l - a)))
          }
          return (
            this.instructions.push({ action: "quadraticCurveTo", data: [o, a, t, e, i] }),
            (this._dirty = !0),
            this
          )
        }
        rect(t, e, i, n, s) {
          return (
            this.instructions.push({ action: "rect", data: [t, e, i, n, s] }),
            (this._dirty = !0),
            this
          )
        }
        circle(t, e, i, n) {
          return (
            this.instructions.push({ action: "circle", data: [t, e, i, n] }),
            (this._dirty = !0),
            this
          )
        }
        roundRect(...t) {
          return (
            this.instructions.push({ action: "roundRect", data: t }),
            (this._dirty = !0),
            this
          )
        }
        poly(...t) {
          return (this.instructions.push({ action: "poly", data: t }), (this._dirty = !0), this)
        }
        regularPoly(...t) {
          return (
            this.instructions.push({ action: "regularPoly", data: t }),
            (this._dirty = !0),
            this
          )
        }
        roundPoly(...t) {
          return (
            this.instructions.push({ action: "roundPoly", data: t }),
            (this._dirty = !0),
            this
          )
        }
        roundShape(...t) {
          return (
            this.instructions.push({ action: "roundShape", data: t }),
            (this._dirty = !0),
            this
          )
        }
        filletRect(...t) {
          return (
            this.instructions.push({ action: "filletRect", data: t }),
            (this._dirty = !0),
            this
          )
        }
        chamferRect(...t) {
          return (
            this.instructions.push({ action: "chamferRect", data: t }),
            (this._dirty = !0),
            this
          )
        }
        star(t, e, i, n, s, o, a) {
          s || (s = n / 2)
          let u = (-1 * Math.PI) / 2 + o,
            l = i * 2,
            c = (Math.PI * 2) / l,
            h = []
          for (let f = 0; f < l; f++) {
            let d = f % 2 ? s : n,
              g = f * c + u
            h.push(t + d * Math.cos(g), e + d * Math.sin(g))
          }
          return (this.poly(h, !0, a), this)
        }
        clone(t = !1) {
          let e = new r()
          if (((e.checkForHoles = this.checkForHoles), !t))
            e.instructions = this.instructions.slice()
          else
            for (let i = 0; i < this.instructions.length; i++) {
              let n = this.instructions[i]
              e.instructions.push({ action: n.action, data: n.data.slice() })
            }
          return e
        }
        clear() {
          return ((this.instructions.length = 0), (this._dirty = !0), this)
        }
        transform(t) {
          if (t.isIdentity()) return this
          let e = t.a,
            i = t.b,
            n = t.c,
            s = t.d,
            o = t.tx,
            a = t.ty,
            u = 0,
            l = 0,
            c = 0,
            h = 0,
            f = 0,
            d = 0,
            g = 0,
            x = 0
          for (let m = 0; m < this.instructions.length; m++) {
            let _ = this.instructions[m],
              v = _.data
            switch (_.action) {
              case "moveTo":
              case "lineTo":
                ;((u = v[0]), (l = v[1]), (v[0] = e * u + n * l + o), (v[1] = i * u + s * l + a))
                break
              case "bezierCurveTo":
                ;((c = v[0]),
                  (h = v[1]),
                  (f = v[2]),
                  (d = v[3]),
                  (u = v[4]),
                  (l = v[5]),
                  (v[0] = e * c + n * h + o),
                  (v[1] = i * c + s * h + a),
                  (v[2] = e * f + n * d + o),
                  (v[3] = i * f + s * d + a),
                  (v[4] = e * u + n * l + o),
                  (v[5] = i * u + s * l + a))
                break
              case "quadraticCurveTo":
                ;((c = v[0]),
                  (h = v[1]),
                  (u = v[2]),
                  (l = v[3]),
                  (v[0] = e * c + n * h + o),
                  (v[1] = i * c + s * h + a),
                  (v[2] = e * u + n * l + o),
                  (v[3] = i * u + s * l + a))
                break
              case "arcToSvg":
                ;((u = v[5]),
                  (l = v[6]),
                  (g = v[0]),
                  (x = v[1]),
                  (v[0] = e * g + n * x),
                  (v[1] = i * g + s * x),
                  (v[5] = e * u + n * l + o),
                  (v[6] = i * u + s * l + a))
                break
              case "circle":
                v[4] = ks(v[3], t)
                break
              case "rect":
                v[4] = ks(v[4], t)
                break
              case "ellipse":
                v[8] = ks(v[8], t)
                break
              case "roundRect":
                v[5] = ks(v[5], t)
                break
              case "addPath":
                v[0].transform(t)
                break
              case "poly":
                v[2] = ks(v[2], t)
                break
              default:
                N("unknown transform action", _.action)
                break
            }
          }
          return ((this._dirty = !0), this)
        }
        get bounds() {
          return this.shapePath.bounds
        }
        getLastPoint(t) {
          let e = this.instructions.length - 1,
            i = this.instructions[e]
          if (!i) return ((t.x = 0), (t.y = 0), t)
          for (; i.action === "closePath"; ) {
            if ((e--, e < 0)) return ((t.x = 0), (t.y = 0), t)
            i = this.instructions[e]
          }
          switch (i.action) {
            case "moveTo":
            case "lineTo":
              ;((t.x = i.data[0]), (t.y = i.data[1]))
              break
            case "quadraticCurveTo":
              ;((t.x = i.data[2]), (t.y = i.data[3]))
              break
            case "bezierCurveTo":
              ;((t.x = i.data[4]), (t.y = i.data[5]))
              break
            case "arc":
            case "arcToSvg":
              ;((t.x = i.data[5]), (t.y = i.data[6]))
              break
            case "addPath":
              i.data[0].getLastPoint(t)
              break
          }
          return t
        }
      }
    })
  function bt(r, t, e) {
    let i = r.getAttribute(t)
    return i ? Number(i) : e
  }
  var ff = p(() => {
    "use strict"
  })
  function yb(r, t) {
    let e = r.querySelectorAll("defs")
    for (let i = 0; i < e.length; i++) {
      let n = e[i]
      for (let s = 0; s < n.children.length; s++) {
        let o = n.children[s]
        switch (o.nodeName.toLowerCase()) {
          case "lineargradient":
            t.defs[o.id] = MD(o)
            break
          case "radialgradient":
            t.defs[o.id] = AD(o)
            break
          default:
            break
        }
      }
    }
  }
  function MD(r) {
    let t = bt(r, "x1", 0),
      e = bt(r, "y1", 0),
      i = bt(r, "x2", 1),
      n = bt(r, "y2", 0),
      s = r.getAttribute("gradientUnits") || "objectBoundingBox",
      o = new ue(t, e, i, n, s === "objectBoundingBox" ? "local" : "global")
    for (let a = 0; a < r.children.length; a++) {
      let u = r.children[a],
        l = bt(u, "offset", 0),
        c = q.shared.setValue(u.getAttribute("stop-color")).toNumber()
      o.addColorStop(l, c)
    }
    return o
  }
  function AD(r) {
    return (N("[SVG Parser] Radial gradients are not yet supported"), new ue(0, 0, 1, 0))
  }
  var bb = p(() => {
    Vt()
    ft()
    qi()
    ff()
  })
  function df(r) {
    let t = r.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i)
    return t ? t[1] : ""
  }
  var vb = p(() => {
    "use strict"
  })
  function pf(r, t) {
    let e = r.getAttribute("style"),
      i = {},
      n = {},
      s = { strokeStyle: i, fillStyle: n, useFill: !1, useStroke: !1 }
    for (let o in Sb) {
      let a = r.getAttribute(o)
      a && Tb(t, s, o, a.trim())
    }
    if (e) {
      let o = e.split(";")
      for (let a = 0; a < o.length; a++) {
        let u = o[a].trim(),
          [l, c] = u.split(":")
        Sb[l] && Tb(t, s, l, c.trim())
      }
    }
    return {
      strokeStyle: s.useStroke ? i : null,
      fillStyle: s.useFill ? n : null,
      useFill: s.useFill,
      useStroke: s.useStroke,
    }
  }
  function Tb(r, t, e, i) {
    switch (e) {
      case "stroke":
        if (i !== "none") {
          if (i.startsWith("url(")) {
            let n = df(i)
            t.strokeStyle.fill = r.defs[n]
          } else t.strokeStyle.color = q.shared.setValue(i).toNumber()
          t.useStroke = !0
        }
        break
      case "stroke-width":
        t.strokeStyle.width = Number(i)
        break
      case "fill":
        if (i !== "none") {
          if (i.startsWith("url(")) {
            let n = df(i)
            t.fillStyle.fill = r.defs[n]
          } else t.fillStyle.color = q.shared.setValue(i).toNumber()
          t.useFill = !0
        }
        break
      case "fill-opacity":
        t.fillStyle.alpha = Number(i)
        break
      case "stroke-opacity":
        t.strokeStyle.alpha = Number(i)
        break
      case "opacity":
        ;((t.fillStyle.alpha = Number(i)), (t.strokeStyle.alpha = Number(i)))
        break
    }
  }
  var Sb,
    Cb = p(() => {
      Vt()
      vb()
      Sb = {
        fill: { type: "paint", default: 0 },
        "fill-opacity": { type: "number", default: 1 },
        stroke: { type: "paint", default: 0 },
        "stroke-width": { type: "number", default: 1 },
        "stroke-opacity": { type: "number", default: 1 },
        "stroke-linecap": { type: "string", default: "butt" },
        "stroke-linejoin": { type: "string", default: "miter" },
        "stroke-miterlimit": { type: "number", default: 10 },
        "stroke-dasharray": { type: "string", default: "none" },
        "stroke-dashoffset": { type: "number", default: 0 },
        opacity: { type: "number", default: 1 },
      }
    })
  function Eb(r, t) {
    if (typeof r == "string") {
      let o = document.createElement("div")
      ;((o.innerHTML = r.trim()), (r = o.querySelector("svg")))
    }
    let e = { context: t, defs: {}, path: new Dr() }
    yb(r, e)
    let i = r.children,
      { fillStyle: n, strokeStyle: s } = pf(r, e)
    for (let o = 0; o < i.length; o++) {
      let a = i[o]
      a.nodeName.toLowerCase() !== "defs" && wb(a, e, n, s)
    }
    return t
  }
  function wb(r, t, e, i) {
    let n = r.children,
      { fillStyle: s, strokeStyle: o } = pf(r, t)
    ;(s && e ? (e = { ...e, ...s }) : s && (e = s), o && i ? (i = { ...i, ...o }) : o && (i = o))
    let a = !e && !i
    a && (e = { color: 0 })
    let u, l, c, h, f, d, g, x, m, _, v, S, y, M, T, E, G
    switch (r.nodeName.toLowerCase()) {
      case "path":
        ;((M = r.getAttribute("d")),
          r.getAttribute("fill-rule") === "evenodd" &&
            N("SVG Evenodd fill rule not supported, your svg may render incorrectly"),
          (T = new Dr(M, !0)),
          t.context.path(T),
          e && t.context.fill(e),
          i && t.context.stroke(i))
        break
      case "circle":
        ;((g = bt(r, "cx", 0)),
          (x = bt(r, "cy", 0)),
          (m = bt(r, "r", 0)),
          t.context.ellipse(g, x, m, m),
          e && t.context.fill(e),
          i && t.context.stroke(i))
        break
      case "rect":
        ;((u = bt(r, "x", 0)),
          (l = bt(r, "y", 0)),
          (E = bt(r, "width", 0)),
          (G = bt(r, "height", 0)),
          (_ = bt(r, "rx", 0)),
          (v = bt(r, "ry", 0)),
          _ || v ? t.context.roundRect(u, l, E, G, _ || v) : t.context.rect(u, l, E, G),
          e && t.context.fill(e),
          i && t.context.stroke(i))
        break
      case "ellipse":
        ;((g = bt(r, "cx", 0)),
          (x = bt(r, "cy", 0)),
          (_ = bt(r, "rx", 0)),
          (v = bt(r, "ry", 0)),
          t.context.beginPath(),
          t.context.ellipse(g, x, _, v),
          e && t.context.fill(e),
          i && t.context.stroke(i))
        break
      case "line":
        ;((c = bt(r, "x1", 0)),
          (h = bt(r, "y1", 0)),
          (f = bt(r, "x2", 0)),
          (d = bt(r, "y2", 0)),
          t.context.beginPath(),
          t.context.moveTo(c, h),
          t.context.lineTo(f, d),
          i && t.context.stroke(i))
        break
      case "polygon":
        ;((y = r.getAttribute("points")),
          (S = y.match(/\d+/g).map((B) => parseInt(B, 10))),
          t.context.poly(S, !0),
          e && t.context.fill(e),
          i && t.context.stroke(i))
        break
      case "polyline":
        ;((y = r.getAttribute("points")),
          (S = y.match(/\d+/g).map((B) => parseInt(B, 10))),
          t.context.poly(S, !1),
          i && t.context.stroke(i))
        break
      case "g":
      case "svg":
        break
      default: {
        N(`[SVG parser] <${r.nodeName}> elements unsupported`)
        break
      }
    }
    a && (e = null)
    for (let B = 0; B < n.length; B++) wb(n[B], t, e, i)
  }
  var Mb = p(() => {
    ft()
    hf()
    bb()
    ff()
    Cb()
  })
  function DD(r) {
    return q.isColorLike(r)
  }
  function Ab(r) {
    return r instanceof ar
  }
  function Db(r) {
    return r instanceof ue
  }
  function PD(r) {
    return r instanceof k
  }
  function FD(r, t, e) {
    let i = q.shared.setValue(t ?? 0)
    return (
      (r.color = i.toNumber()),
      (r.alpha = i.alpha === 1 ? e.alpha : i.alpha),
      (r.texture = k.WHITE),
      { ...e, ...r }
    )
  }
  function RD(r, t, e) {
    return ((r.texture = t), { ...e, ...r })
  }
  function Pb(r, t, e) {
    return (
      (r.fill = t),
      (r.color = 16777215),
      (r.texture = t.texture),
      (r.matrix = t.transform),
      { ...e, ...r }
    )
  }
  function Fb(r, t, e) {
    return (
      t.buildGradient(),
      (r.fill = t),
      (r.color = 16777215),
      (r.texture = t.texture),
      (r.matrix = t.transform),
      (r.textureSpace = t.textureSpace),
      { ...e, ...r }
    )
  }
  function BD(r, t) {
    let e = { ...t, ...r },
      i = q.shared.setValue(e.color)
    return ((e.alpha *= i.alpha), (e.color = i.toNumber()), e)
  }
  function ur(r, t) {
    if (r == null) return null
    let e = {},
      i = r
    return DD(r)
      ? FD(e, r, t)
      : PD(r)
        ? RD(e, r, t)
        : Ab(r)
          ? Pb(e, r, t)
          : Db(r)
            ? Fb(e, r, t)
            : i.fill && Ab(i.fill)
              ? Pb(i, i.fill, t)
              : i.fill && Db(i.fill)
                ? Fb(i, i.fill, t)
                : BD(i, t)
  }
  function rn(r, t) {
    let { width: e, alignment: i, miterLimit: n, cap: s, join: o, pixelLine: a, ...u } = t,
      l = ur(r, u)
    return l ? { width: e, alignment: i, miterLimit: n, cap: s, join: o, pixelLine: a, ...l } : null
  }
  var mf = p(() => {
    Vt()
    dt()
    qi()
    wu()
  })
  var ID,
    Rb,
    gf,
    de,
    xf = p(() => {
      Wt()
      Vt()
      nt()
      Ee()
      dt()
      Ot()
      gt()
      se()
      hf()
      Mb()
      mf()
      ;((ID = new rt()),
        (Rb = new I()),
        (gf = class ze extends lt {
          constructor() {
            ;(super(...arguments),
              (this.uid = J("graphicsContext")),
              (this.dirty = !0),
              (this.batchMode = "auto"),
              (this.instructions = []),
              (this._activePath = new Dr()),
              (this._transform = new I()),
              (this._fillStyle = { ...ze.defaultFillStyle }),
              (this._strokeStyle = { ...ze.defaultStrokeStyle }),
              (this._stateStack = []),
              (this._tick = 0),
              (this._bounds = new ct()),
              (this._boundsDirty = !0))
          }
          clone() {
            let t = new ze()
            return (
              (t.batchMode = this.batchMode),
              (t.instructions = this.instructions.slice()),
              (t._activePath = this._activePath.clone()),
              (t._transform = this._transform.clone()),
              (t._fillStyle = { ...this._fillStyle }),
              (t._strokeStyle = { ...this._strokeStyle }),
              (t._stateStack = this._stateStack.slice()),
              (t._bounds = this._bounds.clone()),
              (t._boundsDirty = !0),
              t
            )
          }
          get fillStyle() {
            return this._fillStyle
          }
          set fillStyle(t) {
            this._fillStyle = ur(t, ze.defaultFillStyle)
          }
          get strokeStyle() {
            return this._strokeStyle
          }
          set strokeStyle(t) {
            this._strokeStyle = rn(t, ze.defaultStrokeStyle)
          }
          setFillStyle(t) {
            return ((this._fillStyle = ur(t, ze.defaultFillStyle)), this)
          }
          setStrokeStyle(t) {
            return ((this._strokeStyle = ur(t, ze.defaultStrokeStyle)), this)
          }
          texture(t, e, i, n, s, o) {
            return (
              this.instructions.push({
                action: "texture",
                data: {
                  image: t,
                  dx: i || 0,
                  dy: n || 0,
                  dw: s || t.frame.width,
                  dh: o || t.frame.height,
                  transform: this._transform.clone(),
                  alpha: this._fillStyle.alpha,
                  style: e ? q.shared.setValue(e).toNumber() : 16777215,
                },
              }),
              this.onUpdate(),
              this
            )
          }
          beginPath() {
            return ((this._activePath = new Dr()), this)
          }
          fill(t, e) {
            let i,
              n = this.instructions[this.instructions.length - 1]
            return (
              this._tick === 0 && n && n.action === "stroke"
                ? (i = n.data.path)
                : (i = this._activePath.clone()),
              i
                ? (t != null &&
                    (e !== void 0 &&
                      typeof t == "number" &&
                      (z(
                        K,
                        "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead",
                      ),
                      (t = { color: t, alpha: e })),
                    (this._fillStyle = ur(t, ze.defaultFillStyle))),
                  this.instructions.push({
                    action: "fill",
                    data: { style: this.fillStyle, path: i },
                  }),
                  this.onUpdate(),
                  this._initNextPathLocation(),
                  (this._tick = 0),
                  this)
                : this
            )
          }
          _initNextPathLocation() {
            let { x: t, y: e } = this._activePath.getLastPoint(rt.shared)
            ;(this._activePath.clear(), this._activePath.moveTo(t, e))
          }
          stroke(t) {
            let e,
              i = this.instructions[this.instructions.length - 1]
            return (
              this._tick === 0 && i && i.action === "fill"
                ? (e = i.data.path)
                : (e = this._activePath.clone()),
              e
                ? (t != null && (this._strokeStyle = rn(t, ze.defaultStrokeStyle)),
                  this.instructions.push({
                    action: "stroke",
                    data: { style: this.strokeStyle, path: e },
                  }),
                  this.onUpdate(),
                  this._initNextPathLocation(),
                  (this._tick = 0),
                  this)
                : this
            )
          }
          cut() {
            for (let t = 0; t < 2; t++) {
              let e = this.instructions[this.instructions.length - 1 - t],
                i = this._activePath.clone()
              if (e && (e.action === "stroke" || e.action === "fill"))
                if (e.data.hole) e.data.hole.addPath(i)
                else {
                  e.data.hole = i
                  break
                }
            }
            return (this._initNextPathLocation(), this)
          }
          arc(t, e, i, n, s, o) {
            this._tick++
            let a = this._transform
            return (
              this._activePath.arc(a.a * t + a.c * e + a.tx, a.b * t + a.d * e + a.ty, i, n, s, o),
              this
            )
          }
          arcTo(t, e, i, n, s) {
            this._tick++
            let o = this._transform
            return (
              this._activePath.arcTo(
                o.a * t + o.c * e + o.tx,
                o.b * t + o.d * e + o.ty,
                o.a * i + o.c * n + o.tx,
                o.b * i + o.d * n + o.ty,
                s,
              ),
              this
            )
          }
          arcToSvg(t, e, i, n, s, o, a) {
            this._tick++
            let u = this._transform
            return (
              this._activePath.arcToSvg(
                t,
                e,
                i,
                n,
                s,
                u.a * o + u.c * a + u.tx,
                u.b * o + u.d * a + u.ty,
              ),
              this
            )
          }
          bezierCurveTo(t, e, i, n, s, o, a) {
            this._tick++
            let u = this._transform
            return (
              this._activePath.bezierCurveTo(
                u.a * t + u.c * e + u.tx,
                u.b * t + u.d * e + u.ty,
                u.a * i + u.c * n + u.tx,
                u.b * i + u.d * n + u.ty,
                u.a * s + u.c * o + u.tx,
                u.b * s + u.d * o + u.ty,
                a,
              ),
              this
            )
          }
          closePath() {
            return (this._tick++, this._activePath?.closePath(), this)
          }
          ellipse(t, e, i, n) {
            return (
              this._tick++,
              this._activePath.ellipse(t, e, i, n, this._transform.clone()),
              this
            )
          }
          circle(t, e, i) {
            return (this._tick++, this._activePath.circle(t, e, i, this._transform.clone()), this)
          }
          path(t) {
            return (this._tick++, this._activePath.addPath(t, this._transform.clone()), this)
          }
          lineTo(t, e) {
            this._tick++
            let i = this._transform
            return (
              this._activePath.lineTo(i.a * t + i.c * e + i.tx, i.b * t + i.d * e + i.ty),
              this
            )
          }
          moveTo(t, e) {
            this._tick++
            let i = this._transform,
              n = this._activePath.instructions,
              s = i.a * t + i.c * e + i.tx,
              o = i.b * t + i.d * e + i.ty
            return n.length === 1 && n[0].action === "moveTo"
              ? ((n[0].data[0] = s), (n[0].data[1] = o), this)
              : (this._activePath.moveTo(s, o), this)
          }
          quadraticCurveTo(t, e, i, n, s) {
            this._tick++
            let o = this._transform
            return (
              this._activePath.quadraticCurveTo(
                o.a * t + o.c * e + o.tx,
                o.b * t + o.d * e + o.ty,
                o.a * i + o.c * n + o.tx,
                o.b * i + o.d * n + o.ty,
                s,
              ),
              this
            )
          }
          rect(t, e, i, n) {
            return (this._tick++, this._activePath.rect(t, e, i, n, this._transform.clone()), this)
          }
          roundRect(t, e, i, n, s) {
            return (
              this._tick++,
              this._activePath.roundRect(t, e, i, n, s, this._transform.clone()),
              this
            )
          }
          poly(t, e) {
            return (this._tick++, this._activePath.poly(t, e, this._transform.clone()), this)
          }
          regularPoly(t, e, i, n, s = 0, o) {
            return (this._tick++, this._activePath.regularPoly(t, e, i, n, s, o), this)
          }
          roundPoly(t, e, i, n, s, o) {
            return (this._tick++, this._activePath.roundPoly(t, e, i, n, s, o), this)
          }
          roundShape(t, e, i, n) {
            return (this._tick++, this._activePath.roundShape(t, e, i, n), this)
          }
          filletRect(t, e, i, n, s) {
            return (this._tick++, this._activePath.filletRect(t, e, i, n, s), this)
          }
          chamferRect(t, e, i, n, s, o) {
            return (this._tick++, this._activePath.chamferRect(t, e, i, n, s, o), this)
          }
          star(t, e, i, n, s = 0, o = 0) {
            return (
              this._tick++,
              this._activePath.star(t, e, i, n, s, o, this._transform.clone()),
              this
            )
          }
          svg(t) {
            return (this._tick++, Eb(t, this), this)
          }
          restore() {
            let t = this._stateStack.pop()
            return (
              t &&
                ((this._transform = t.transform),
                (this._fillStyle = t.fillStyle),
                (this._strokeStyle = t.strokeStyle)),
              this
            )
          }
          save() {
            return (
              this._stateStack.push({
                transform: this._transform.clone(),
                fillStyle: { ...this._fillStyle },
                strokeStyle: { ...this._strokeStyle },
              }),
              this
            )
          }
          getTransform() {
            return this._transform
          }
          resetTransform() {
            return (this._transform.identity(), this)
          }
          rotate(t) {
            return (this._transform.rotate(t), this)
          }
          scale(t, e = t) {
            return (this._transform.scale(t, e), this)
          }
          setTransform(t, e, i, n, s, o) {
            return t instanceof I
              ? (this._transform.set(t.a, t.b, t.c, t.d, t.tx, t.ty), this)
              : (this._transform.set(t, e, i, n, s, o), this)
          }
          transform(t, e, i, n, s, o) {
            return t instanceof I
              ? (this._transform.append(t), this)
              : (Rb.set(t, e, i, n, s, o), this._transform.append(Rb), this)
          }
          translate(t, e = t) {
            return (this._transform.translate(t, e), this)
          }
          clear() {
            return (
              this._activePath.clear(),
              (this.instructions.length = 0),
              this.resetTransform(),
              this.onUpdate(),
              this
            )
          }
          onUpdate() {
            this.dirty ||
              (this.emit("update", this, 16), (this.dirty = !0), (this._boundsDirty = !0))
          }
          get bounds() {
            if (!this._boundsDirty) return this._bounds
            let t = this._bounds
            t.clear()
            for (let e = 0; e < this.instructions.length; e++) {
              let i = this.instructions[e],
                n = i.action
              if (n === "fill") {
                let s = i.data
                t.addBounds(s.path.bounds)
              } else if (n === "texture") {
                let s = i.data
                t.addFrame(s.dx, s.dy, s.dx + s.dw, s.dy + s.dh, s.transform)
              }
              if (n === "stroke") {
                let s = i.data,
                  o = s.style.alignment,
                  a = s.style.width * (1 - o),
                  u = s.path.bounds
                t.addFrame(u.minX - a, u.minY - a, u.maxX + a, u.maxY + a)
              }
            }
            return t
          }
          containsPoint(t) {
            if (!this.bounds.containsPoint(t.x, t.y)) return !1
            let e = this.instructions,
              i = !1
            for (let n = 0; n < e.length; n++) {
              let s = e[n],
                o = s.data,
                a = o.path
              if (!s.action || !a) continue
              let u = o.style,
                l = a.shapePath.shapePrimitives
              for (let c = 0; c < l.length; c++) {
                let h = l[c].shape
                if (!u || !h) continue
                let f = l[c].transform,
                  d = f ? f.applyInverse(t, ID) : t
                if (s.action === "fill") i = h.contains(d.x, d.y)
                else {
                  let x = u
                  i = h.strokeContains(d.x, d.y, x.width, x.alignment)
                }
                let g = o.hole
                if (g) {
                  let x = g.shapePath?.shapePrimitives
                  if (x)
                    for (let m = 0; m < x.length; m++) x[m].shape.contains(d.x, d.y) && (i = !1)
                }
                if (i) return !0
              }
            }
            return i
          }
          destroy(t = !1) {
            if (
              ((this._stateStack.length = 0),
              (this._transform = null),
              this.emit("destroy", this),
              this.removeAllListeners(),
              typeof t == "boolean" ? t : t?.texture)
            ) {
              let i = typeof t == "boolean" ? t : t?.textureSource
              ;(this._fillStyle.texture && this._fillStyle.texture.destroy(i),
                this._strokeStyle.texture && this._strokeStyle.texture.destroy(i))
            }
            ;((this._fillStyle = null),
              (this._strokeStyle = null),
              (this.instructions = null),
              (this._activePath = null),
              (this._bounds = null),
              (this._stateStack = null),
              (this.customShader = null),
              (this._transform = null))
          }
        }))
      gf.defaultFillStyle = {
        color: 16777215,
        alpha: 1,
        texture: k.WHITE,
        matrix: null,
        fill: null,
        textureSpace: "local",
      }
      gf.defaultStrokeStyle = {
        width: 1,
        color: 16777215,
        alpha: 1,
        alignment: 0.5,
        miterLimit: 10,
        cap: "butt",
        join: "miter",
        texture: k.WHITE,
        matrix: null,
        fill: null,
        textureSpace: "local",
        pixelLine: !1,
      }
      de = gf
    })
  function Ib(r) {
    let t = [],
      e = 0
    for (let i = 0; i < Bb.length; i++) {
      let n = `_${Bb[i]}`
      t[e++] = r[n]
    }
    return (
      (e = kb(r._fill, t, e)),
      (e = GD(r._stroke, t, e)),
      (e = UD(r.dropShadow, t, e)),
      (e = kD(r.filters, t, e)),
      t.join("-")
    )
  }
  function kD(r, t, e) {
    if (!r) return e
    for (let i of r) t[e++] = i.uid
    return e
  }
  function kb(r, t, e) {
    return (r && ((t[e++] = r.color), (t[e++] = r.alpha), (t[e++] = r.fill?.styleKey)), e)
  }
  function GD(r, t, e) {
    return (
      r &&
        ((e = kb(r, t, e)),
        (t[e++] = r.width),
        (t[e++] = r.alignment),
        (t[e++] = r.cap),
        (t[e++] = r.join),
        (t[e++] = r.miterLimit)),
      e
    )
  }
  function UD(r, t, e) {
    return (
      r &&
        ((t[e++] = r.alpha),
        (t[e++] = r.angle),
        (t[e++] = r.blur),
        (t[e++] = r.distance),
        (t[e++] = q.shared.setValue(r.color).toNumber())),
      e
    )
  }
  var Bb,
    Gb = p(() => {
      Vt()
      Bb = [
        "align",
        "breakWords",
        "cssOverrides",
        "fontVariant",
        "fontWeight",
        "leading",
        "letterSpacing",
        "lineHeight",
        "padding",
        "textBaseline",
        "trim",
        "whiteSpace",
        "wordWrap",
        "wordWrapWidth",
        "fontFamily",
        "fontStyle",
        "fontSize",
      ]
    })
  function OD(r) {
    let t = r
    if (typeof t.dropShadow == "boolean" && t.dropShadow) {
      let e = le.defaultDropShadow
      r.dropShadow = {
        alpha: t.dropShadowAlpha ?? e.alpha,
        angle: t.dropShadowAngle ?? e.angle,
        blur: t.dropShadowBlur ?? e.blur,
        color: t.dropShadowColor ?? e.color,
        distance: t.dropShadowDistance ?? e.distance,
      }
    }
    if (t.strokeThickness !== void 0) {
      z(K, "strokeThickness is now a part of stroke")
      let e = t.stroke,
        i = {}
      if (q.isColorLike(e)) i.color = e
      else if (e instanceof ue || e instanceof ar) i.fill = e
      else if (Object.hasOwnProperty.call(e, "color") || Object.hasOwnProperty.call(e, "fill"))
        i = e
      else throw new Error("Invalid stroke value.")
      r.stroke = { ...i, width: t.strokeThickness }
    }
    if (Array.isArray(t.fillGradientStops)) {
      z(K, "gradient fill is now a fill pattern: `new FillGradient(...)`")
      let e
      r.fontSize == null
        ? (r.fontSize = le.defaultTextStyle.fontSize)
        : typeof r.fontSize == "string"
          ? (e = parseInt(r.fontSize, 10))
          : (e = r.fontSize)
      let i = new ue({ start: { x: 0, y: 0 }, end: { x: 0, y: (e || 0) * 1.7 } }),
        n = t.fillGradientStops.map((s) => q.shared.setValue(s).toNumber())
      ;(n.forEach((s, o) => {
        let a = o / (n.length - 1)
        i.addColorStop(a, s)
      }),
        (r.fill = { fill: i }))
    }
  }
  var _f,
    le,
    sn = p(() => {
      Wt()
      Vt()
      gt()
      qi()
      wu()
      xf()
      mf()
      Gb()
      _f = class nn extends lt {
        constructor(t = {}) {
          ;(super(), OD(t))
          let e = { ...nn.defaultTextStyle, ...t }
          for (let i in e) {
            let n = i
            this[n] = e[i]
          }
          this.update()
        }
        get align() {
          return this._align
        }
        set align(t) {
          ;((this._align = t), this.update())
        }
        get breakWords() {
          return this._breakWords
        }
        set breakWords(t) {
          ;((this._breakWords = t), this.update())
        }
        get dropShadow() {
          return this._dropShadow
        }
        set dropShadow(t) {
          ;(t !== null && typeof t == "object"
            ? (this._dropShadow = this._createProxy({ ...nn.defaultDropShadow, ...t }))
            : (this._dropShadow = t ? this._createProxy({ ...nn.defaultDropShadow }) : null),
            this.update())
        }
        get fontFamily() {
          return this._fontFamily
        }
        set fontFamily(t) {
          ;((this._fontFamily = t), this.update())
        }
        get fontSize() {
          return this._fontSize
        }
        set fontSize(t) {
          ;(typeof t == "string" ? (this._fontSize = parseInt(t, 10)) : (this._fontSize = t),
            this.update())
        }
        get fontStyle() {
          return this._fontStyle
        }
        set fontStyle(t) {
          ;((this._fontStyle = t.toLowerCase()), this.update())
        }
        get fontVariant() {
          return this._fontVariant
        }
        set fontVariant(t) {
          ;((this._fontVariant = t), this.update())
        }
        get fontWeight() {
          return this._fontWeight
        }
        set fontWeight(t) {
          ;((this._fontWeight = t), this.update())
        }
        get leading() {
          return this._leading
        }
        set leading(t) {
          ;((this._leading = t), this.update())
        }
        get letterSpacing() {
          return this._letterSpacing
        }
        set letterSpacing(t) {
          ;((this._letterSpacing = t), this.update())
        }
        get lineHeight() {
          return this._lineHeight
        }
        set lineHeight(t) {
          ;((this._lineHeight = t), this.update())
        }
        get padding() {
          return this._padding
        }
        set padding(t) {
          ;((this._padding = t), this.update())
        }
        get filters() {
          return this._filters
        }
        set filters(t) {
          ;((this._filters = t), this.update())
        }
        get trim() {
          return this._trim
        }
        set trim(t) {
          ;((this._trim = t), this.update())
        }
        get textBaseline() {
          return this._textBaseline
        }
        set textBaseline(t) {
          ;((this._textBaseline = t), this.update())
        }
        get whiteSpace() {
          return this._whiteSpace
        }
        set whiteSpace(t) {
          ;((this._whiteSpace = t), this.update())
        }
        get wordWrap() {
          return this._wordWrap
        }
        set wordWrap(t) {
          ;((this._wordWrap = t), this.update())
        }
        get wordWrapWidth() {
          return this._wordWrapWidth
        }
        set wordWrapWidth(t) {
          ;((this._wordWrapWidth = t), this.update())
        }
        get fill() {
          return this._originalFill
        }
        set fill(t) {
          t !== this._originalFill &&
            ((this._originalFill = t),
            this._isFillStyle(t) &&
              (this._originalFill = this._createProxy({ ...de.defaultFillStyle, ...t }, () => {
                this._fill = ur({ ...this._originalFill }, de.defaultFillStyle)
              })),
            (this._fill = ur(t === 0 ? "black" : t, de.defaultFillStyle)),
            this.update())
        }
        get stroke() {
          return this._originalStroke
        }
        set stroke(t) {
          t !== this._originalStroke &&
            ((this._originalStroke = t),
            this._isFillStyle(t) &&
              (this._originalStroke = this._createProxy({ ...de.defaultStrokeStyle, ...t }, () => {
                this._stroke = rn({ ...this._originalStroke }, de.defaultStrokeStyle)
              })),
            (this._stroke = rn(t, de.defaultStrokeStyle)),
            this.update())
        }
        _generateKey() {
          return ((this._styleKey = Ib(this)), this._styleKey)
        }
        update() {
          ;((this._styleKey = null), this.emit("update", this))
        }
        reset() {
          let t = nn.defaultTextStyle
          for (let e in t) this[e] = t[e]
        }
        get styleKey() {
          return this._styleKey || this._generateKey()
        }
        clone() {
          return new nn({
            align: this.align,
            breakWords: this.breakWords,
            dropShadow: this._dropShadow ? { ...this._dropShadow } : null,
            fill: this._fill,
            fontFamily: this.fontFamily,
            fontSize: this.fontSize,
            fontStyle: this.fontStyle,
            fontVariant: this.fontVariant,
            fontWeight: this.fontWeight,
            leading: this.leading,
            letterSpacing: this.letterSpacing,
            lineHeight: this.lineHeight,
            padding: this.padding,
            stroke: this._stroke,
            textBaseline: this.textBaseline,
            whiteSpace: this.whiteSpace,
            wordWrap: this.wordWrap,
            wordWrapWidth: this.wordWrapWidth,
            filters: this._filters ? [...this._filters] : void 0,
          })
        }
        _getFinalPadding() {
          let t = 0
          if (this._filters)
            for (let e = 0; e < this._filters.length; e++) t += this._filters[e].padding
          return Math.max(this._padding, t)
        }
        destroy(t = !1) {
          if ((this.removeAllListeners(), typeof t == "boolean" ? t : t?.texture)) {
            let i = typeof t == "boolean" ? t : t?.textureSource
            ;(this._fill?.texture && this._fill.texture.destroy(i),
              this._originalFill?.texture && this._originalFill.texture.destroy(i),
              this._stroke?.texture && this._stroke.texture.destroy(i),
              this._originalStroke?.texture && this._originalStroke.texture.destroy(i))
          }
          ;((this._fill = null),
            (this._stroke = null),
            (this.dropShadow = null),
            (this._originalStroke = null),
            (this._originalFill = null))
        }
        _createProxy(t, e) {
          return new Proxy(t, { set: (i, n, s) => ((i[n] = s), e?.(n, s), this.update(), !0) })
        }
        _isFillStyle(t) {
          return (t ?? null) !== null && !(q.isColorLike(t) || t instanceof ue || t instanceof ar)
        }
      }
      _f.defaultDropShadow = { alpha: 1, angle: Math.PI / 6, blur: 0, color: "black", distance: 5 }
      _f.defaultTextStyle = {
        align: "left",
        breakWords: !1,
        dropShadow: null,
        fill: "black",
        fontFamily: "Arial",
        fontSize: 26,
        fontStyle: "normal",
        fontVariant: "normal",
        fontWeight: "normal",
        leading: 0,
        letterSpacing: 0,
        lineHeight: 0,
        padding: 0,
        stroke: null,
        textBaseline: "alphabetic",
        trim: !1,
        whiteSpace: "pre",
        wordWrap: !1,
        wordWrapWidth: 100,
      }
      le = _f
    })
  function Iu(r, t, e, i) {
    let n = LD
    ;((n.minX = 0), (n.minY = 0), (n.maxX = (r.width / i) | 0), (n.maxY = (r.height / i) | 0))
    let s = St.getOptimalTexture(n.width, n.height, i, !1)
    return (
      (s.source.uploadMethodId = "image"),
      (s.source.resource = r),
      (s.source.alphaMode = "premultiply-alpha-on-upload"),
      (s.frame.width = t / i),
      (s.frame.height = e / i),
      s.source.emit("update", s.source),
      s.updateUvs(),
      s
    )
  }
  var LD,
    yf = p(() => {
      _r()
      se()
      LD = new ct()
    })
  var bf,
    pe,
    on = p(() => {
      At()
      es()
      ;((bf = class {
        constructor(t) {
          ;((this._canvasPool = Object.create(null)),
            (this.canvasOptions = t || {}),
            (this.enableFullScreen = !1))
        }
        _createCanvasAndContext(t, e) {
          let i = Z.get().createCanvas()
          ;((i.width = t), (i.height = e))
          let n = i.getContext("2d")
          return { canvas: i, context: n }
        }
        getOptimalCanvasAndContext(t, e, i = 1) {
          ;((t = Math.ceil(t * i - 1e-6)), (e = Math.ceil(e * i - 1e-6)), (t = er(t)), (e = er(e)))
          let n = (t << 17) + (e << 1)
          this._canvasPool[n] || (this._canvasPool[n] = [])
          let s = this._canvasPool[n].pop()
          return (s || (s = this._createCanvasAndContext(t, e)), s)
        }
        returnCanvasAndContext(t) {
          let e = t.canvas,
            { width: i, height: n } = e,
            s = (i << 17) + (n << 1)
          ;(t.context.resetTransform(),
            t.context.clearRect(0, 0, i, n),
            this._canvasPool[s].push(t))
        }
        clear() {
          this._canvasPool = {}
        }
      }),
        (pe = new bf()))
    })
  function ND(r, t) {
    ;(di ||
      ((di = Z.get().createCanvas(256, 128)),
      (lr = di.getContext("2d", { willReadFrequently: !0 })),
      (lr.globalCompositeOperation = "copy"),
      (lr.globalAlpha = 1)),
      (di.width < r || di.height < t) && ((di.width = er(r)), (di.height = er(t))))
  }
  function Ub(r, t, e) {
    for (let i = 0, n = 4 * e * t; i < t; ++i, n += 4) if (r[n + 3] !== 0) return !1
    return !0
  }
  function Ob(r, t, e, i, n) {
    let s = 4 * t
    for (let o = i, a = i * s + 4 * e; o <= n; ++o, a += s) if (r[a + 3] !== 0) return !1
    return !0
  }
  function Lb(...r) {
    let t = r[0]
    t.canvas || (t = { canvas: r[0], resolution: r[1] })
    let { canvas: e } = t,
      i = Math.min(t.resolution ?? 1, 1),
      n = t.width ?? e.width,
      s = t.height ?? e.height,
      o = t.output
    if ((ND(n, s), !lr)) throw new TypeError("Failed to get canvas 2D context")
    lr.drawImage(e, 0, 0, n, s, 0, 0, n * i, s * i)
    let u = lr.getImageData(0, 0, n, s).data,
      l = 0,
      c = 0,
      h = n - 1,
      f = s - 1
    for (; c < s && Ub(u, n, c); ) ++c
    if (c === s) return Q.EMPTY
    for (; Ub(u, n, f); ) --f
    for (; Ob(u, n, l, c, f); ) ++l
    for (; Ob(u, n, h, c, f); ) --h
    return (
      ++h,
      ++f,
      (lr.globalCompositeOperation = "source-over"),
      lr.strokeRect(l, c, h - l, f - c),
      (lr.globalCompositeOperation = "copy"),
      o ?? (o = new Q()),
      o.set(l / i, c / i, (h - l) / i, (f - c) / i),
      o
    )
  }
  var di,
    lr,
    Nb = p(() => {
      At()
      es()
      Lt()
      ;((di = null), (lr = null))
    })
  function pi(r) {
    let t = typeof r.fontSize == "number" ? `${r.fontSize}px` : r.fontSize,
      e = r.fontFamily
    Array.isArray(r.fontFamily) || (e = r.fontFamily.split(","))
    for (let i = e.length - 1; i >= 0; i--) {
      let n = e[i].trim()
      ;(!/([\"\'])[^\'\"]+\1/.test(n) && !HD.includes(n) && (n = `"${n}"`), (e[i] = n))
    }
    return `${r.fontStyle} ${r.fontVariant} ${r.fontWeight} ${t} ${e.join(",")}`
  }
  var HD,
    ku = p(() => {
      "use strict"
      HD = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"]
    })
  var vf,
    We,
    jt,
    an = p(() => {
      At()
      ku()
      ;((vf = { willReadFrequently: !0 }),
        (We = class $ {
          static get experimentalLetterSpacingSupported() {
            let t = $._experimentalLetterSpacingSupported
            if (t === void 0) {
              let e = Z.get().getCanvasRenderingContext2D().prototype
              t = $._experimentalLetterSpacingSupported =
                "letterSpacing" in e || "textLetterSpacing" in e
            }
            return t
          }
          constructor(t, e, i, n, s, o, a, u, l) {
            ;((this.text = t),
              (this.style = e),
              (this.width = i),
              (this.height = n),
              (this.lines = s),
              (this.lineWidths = o),
              (this.lineHeight = a),
              (this.maxLineWidth = u),
              (this.fontProperties = l))
          }
          static measureText(t = " ", e, i = $._canvas, n = e.wordWrap) {
            let s = pi(e),
              o = $.measureFont(s)
            o.fontSize === 0 && ((o.fontSize = e.fontSize), (o.ascent = e.fontSize))
            let a = $.__context
            a.font = s
            let l = (n ? $._wordWrap(t, e, i) : t).split(/(?:\r\n|\r|\n)/),
              c = new Array(l.length),
              h = 0
            for (let _ = 0; _ < l.length; _++) {
              let v = $._measureText(l[_], e.letterSpacing, a)
              ;((c[_] = v), (h = Math.max(h, v)))
            }
            let f = e._stroke?.width || 0,
              d = h + f
            e.dropShadow && (d += e.dropShadow.distance)
            let g = e.lineHeight || o.fontSize,
              x = Math.max(g, o.fontSize + f) + (l.length - 1) * (g + e.leading)
            return (
              e.dropShadow && (x += e.dropShadow.distance),
              new $(t, e, d, x, l, c, g + e.leading, h, o)
            )
          }
          static _measureText(t, e, i) {
            let n = !1
            $.experimentalLetterSpacingSupported &&
              ($.experimentalLetterSpacing
                ? ((i.letterSpacing = `${e}px`), (i.textLetterSpacing = `${e}px`), (n = !0))
                : ((i.letterSpacing = "0px"), (i.textLetterSpacing = "0px")))
            let s = i.measureText(t),
              o = s.width,
              a = -s.actualBoundingBoxLeft,
              l = s.actualBoundingBoxRight - a
            if (o > 0)
              if (n) ((o -= e), (l -= e))
              else {
                let c = ($.graphemeSegmenter(t).length - 1) * e
                ;((o += c), (l += c))
              }
            return Math.max(o, l)
          }
          static _wordWrap(t, e, i = $._canvas) {
            let n = i.getContext("2d", vf),
              s = 0,
              o = "",
              a = "",
              u = Object.create(null),
              { letterSpacing: l, whiteSpace: c } = e,
              h = $._collapseSpaces(c),
              f = $._collapseNewlines(c),
              d = !h,
              g = e.wordWrapWidth + l,
              x = $._tokenize(t)
            for (let m = 0; m < x.length; m++) {
              let _ = x[m]
              if ($._isNewline(_)) {
                if (!f) {
                  ;((a += $._addLine(o)), (d = !h), (o = ""), (s = 0))
                  continue
                }
                _ = " "
              }
              if (h) {
                let S = $.isBreakingSpace(_),
                  y = $.isBreakingSpace(o[o.length - 1])
                if (S && y) continue
              }
              let v = $._getFromCache(_, l, u, n)
              if (v > g)
                if (
                  (o !== "" && ((a += $._addLine(o)), (o = ""), (s = 0)),
                  $.canBreakWords(_, e.breakWords))
                ) {
                  let S = $.wordWrapSplit(_)
                  for (let y = 0; y < S.length; y++) {
                    let M = S[y],
                      T = M,
                      E = 1
                    for (; S[y + E]; ) {
                      let B = S[y + E]
                      if (!$.canBreakChars(T, B, _, y, e.breakWords)) M += B
                      else break
                      ;((T = B), E++)
                    }
                    y += E - 1
                    let G = $._getFromCache(M, l, u, n)
                    ;(G + s > g && ((a += $._addLine(o)), (d = !1), (o = ""), (s = 0)),
                      (o += M),
                      (s += G))
                  }
                } else {
                  o.length > 0 && ((a += $._addLine(o)), (o = ""), (s = 0))
                  let S = m === x.length - 1
                  ;((a += $._addLine(_, !S)), (d = !1), (o = ""), (s = 0))
                }
              else
                (v + s > g && ((d = !1), (a += $._addLine(o)), (o = ""), (s = 0)),
                  (o.length > 0 || !$.isBreakingSpace(_) || d) && ((o += _), (s += v)))
            }
            return ((a += $._addLine(o, !1)), a)
          }
          static _addLine(t, e = !0) {
            return (
              (t = $._trimRight(t)),
              (t = e
                ? `${t}
`
                : t),
              t
            )
          }
          static _getFromCache(t, e, i, n) {
            let s = i[t]
            return (typeof s != "number" && ((s = $._measureText(t, e, n) + e), (i[t] = s)), s)
          }
          static _collapseSpaces(t) {
            return t === "normal" || t === "pre-line"
          }
          static _collapseNewlines(t) {
            return t === "normal"
          }
          static _trimRight(t) {
            if (typeof t != "string") return ""
            for (let e = t.length - 1; e >= 0; e--) {
              let i = t[e]
              if (!$.isBreakingSpace(i)) break
              t = t.slice(0, -1)
            }
            return t
          }
          static _isNewline(t) {
            return typeof t != "string" ? !1 : $._newlines.includes(t.charCodeAt(0))
          }
          static isBreakingSpace(t, e) {
            return typeof t != "string" ? !1 : $._breakingSpaces.includes(t.charCodeAt(0))
          }
          static _tokenize(t) {
            let e = [],
              i = ""
            if (typeof t != "string") return e
            for (let n = 0; n < t.length; n++) {
              let s = t[n],
                o = t[n + 1]
              if ($.isBreakingSpace(s, o) || $._isNewline(s)) {
                ;(i !== "" && (e.push(i), (i = "")),
                  s === "\r" &&
                  o ===
                    `
`
                    ? (e.push(`\r
`),
                      n++)
                    : e.push(s))
                continue
              }
              i += s
            }
            return (i !== "" && e.push(i), e)
          }
          static canBreakWords(t, e) {
            return e
          }
          static canBreakChars(t, e, i, n, s) {
            return !0
          }
          static wordWrapSplit(t) {
            return $.graphemeSegmenter(t)
          }
          static measureFont(t) {
            if ($._fonts[t]) return $._fonts[t]
            let e = $._context
            e.font = t
            let i = e.measureText($.METRICS_STRING + $.BASELINE_SYMBOL),
              n = {
                ascent: i.actualBoundingBoxAscent,
                descent: i.actualBoundingBoxDescent,
                fontSize: i.actualBoundingBoxAscent + i.actualBoundingBoxDescent,
              }
            return (($._fonts[t] = n), n)
          }
          static clearMetrics(t = "") {
            t ? delete $._fonts[t] : ($._fonts = {})
          }
          static get _canvas() {
            if (!$.__canvas) {
              let t
              try {
                let e = new OffscreenCanvas(0, 0)
                if (e.getContext("2d", vf)?.measureText) return (($.__canvas = e), e)
                t = Z.get().createCanvas()
              } catch {
                t = Z.get().createCanvas()
              }
              ;((t.width = t.height = 10), ($.__canvas = t))
            }
            return $.__canvas
          }
          static get _context() {
            return ($.__context || ($.__context = $._canvas.getContext("2d", vf)), $.__context)
          }
        }))
      We.METRICS_STRING = "|\xC9q\xC5"
      We.BASELINE_SYMBOL = "M"
      We.BASELINE_MULTIPLIER = 1.4
      We.HEIGHT_MULTIPLIER = 2
      We.graphemeSegmenter = (() => {
        if (typeof Intl?.Segmenter == "function") {
          let r = new Intl.Segmenter()
          return (t) => {
            let e = r.segment(t),
              i = [],
              n = 0
            for (let s of e) i[n++] = s.segment
            return i
          }
        }
        return (r) => [...r]
      })()
      We.experimentalLetterSpacing = !1
      We._fonts = {}
      We._newlines = [10, 13]
      We._breakingSpaces = [
        9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288,
      ]
      jt = We
    })
  function un(r, t, e, i = 0) {
    if (r.texture === k.WHITE && !r.fill)
      return q.shared
        .setValue(r.color)
        .setAlpha(r.alpha ?? 1)
        .toHexa()
    if (r.fill) {
      if (r.fill instanceof ar) {
        let n = r.fill,
          s = t.createPattern(n.texture.source.resource, "repeat"),
          o = n.transform.copyTo(I.shared)
        return (o.scale(n.texture.frame.width, n.texture.frame.height), s.setTransform(o), s)
      } else if (r.fill instanceof ue) {
        let n = r.fill,
          s = n.type === "linear",
          o = n.textureSpace === "local",
          a = 1,
          u = 1
        o && e && ((a = e.width + i), (u = e.height + i))
        let l,
          c = !1
        if (s) {
          let { start: h, end: f } = n
          ;((l = t.createLinearGradient(h.x * a, h.y * u, f.x * a, f.y * u)),
            (c = Math.abs(f.x - h.x) < Math.abs((f.y - h.y) * 0.1)))
        } else {
          let { center: h, innerRadius: f, outerCenter: d, outerRadius: g } = n
          l = t.createRadialGradient(h.x * a, h.y * u, f * a, d.x * a, d.y * u, g * a)
        }
        if (c && o && e) {
          let h = e.lineHeight / u
          for (let f = 0; f < e.lines.length; f++) {
            let d = (f * e.lineHeight + i / 2) / u
            n.colorStops.forEach((g) => {
              let x = d + g.offset * h
              l.addColorStop(Math.floor(x * Hb) / Hb, q.shared.setValue(g.color).toHex())
            })
          }
        } else
          n.colorStops.forEach((h) => {
            l.addColorStop(h.offset, q.shared.setValue(h.color).toHex())
          })
        return l
      }
    } else {
      let n = t.createPattern(r.texture.source.resource, "repeat"),
        s = r.matrix.copyTo(I.shared)
      return (s.scale(r.texture.frame.width, r.texture.frame.height), n.setTransform(s), n)
    }
    return (N("FillStyle not recognised", r), "red")
  }
  var Hb,
    Sf = p(() => {
      Vt()
      nt()
      dt()
      ft()
      qi()
      wu()
      Hb = 1e5
    })
  var zb,
    Tf,
    mi,
    Cf = p(() => {
      Vt()
      Lt()
      on()
      Nb()
      an()
      ku()
      Sf()
      ;((zb = new Q()),
        (Tf = class {
          getCanvasAndContext(t) {
            let { text: e, style: i, resolution: n = 1 } = t,
              s = i._getFinalPadding(),
              o = jt.measureText(e || " ", i),
              a = Math.ceil(Math.ceil(Math.max(1, o.width) + s * 2) * n),
              u = Math.ceil(Math.ceil(Math.max(1, o.height) + s * 2) * n),
              l = pe.getOptimalCanvasAndContext(a, u)
            this._renderTextToCanvas(e, i, s, n, l)
            let c = i.trim
              ? Lb({ canvas: l.canvas, width: a, height: u, resolution: 1, output: zb })
              : zb.set(0, 0, a, u)
            return { canvasAndContext: l, frame: c }
          }
          returnCanvasAndContext(t) {
            pe.returnCanvasAndContext(t)
          }
          _renderTextToCanvas(t, e, i, n, s) {
            let { canvas: o, context: a } = s,
              u = pi(e),
              l = jt.measureText(t || " ", e),
              c = l.lines,
              h = l.lineHeight,
              f = l.lineWidths,
              d = l.maxLineWidth,
              g = l.fontProperties,
              x = o.height
            if (
              (a.resetTransform(),
              a.scale(n, n),
              (a.textBaseline = e.textBaseline),
              e._stroke?.width)
            ) {
              let S = e._stroke
              ;((a.lineWidth = S.width),
                (a.miterLimit = S.miterLimit),
                (a.lineJoin = S.join),
                (a.lineCap = S.cap))
            }
            a.font = u
            let m,
              _,
              v = e.dropShadow ? 2 : 1
            for (let S = 0; S < v; ++S) {
              let y = e.dropShadow && S === 0,
                M = y ? Math.ceil(Math.max(1, x) + i * 2) : 0,
                T = M * n
              if (y) {
                ;((a.fillStyle = "black"), (a.strokeStyle = "black"))
                let B = e.dropShadow,
                  P = B.color,
                  F = B.alpha
                a.shadowColor = q.shared.setValue(P).setAlpha(F).toRgbaString()
                let W = B.blur * n,
                  j = B.distance * n
                ;((a.shadowBlur = W),
                  (a.shadowOffsetX = Math.cos(B.angle) * j),
                  (a.shadowOffsetY = Math.sin(B.angle) * j + T))
              } else {
                if (((a.fillStyle = e._fill ? un(e._fill, a, l) : null), e._stroke?.width)) {
                  let B = e._stroke.width * e._stroke.alignment
                  a.strokeStyle = un(e._stroke, a, l, B)
                }
                a.shadowColor = "black"
              }
              let E = (h - g.fontSize) / 2
              h - g.fontSize < 0 && (E = 0)
              let G = e._stroke?.width ?? 0
              for (let B = 0; B < c.length; B++)
                ((m = G / 2),
                  (_ = G / 2 + B * h + g.ascent + E),
                  e.align === "right"
                    ? (m += d - f[B])
                    : e.align === "center" && (m += (d - f[B]) / 2),
                  e._stroke?.width && this._drawLetterSpacing(c[B], e, s, m + i, _ + i - M, !0),
                  e._fill !== void 0 && this._drawLetterSpacing(c[B], e, s, m + i, _ + i - M))
            }
          }
          _drawLetterSpacing(t, e, i, n, s, o = !1) {
            let { context: a } = i,
              u = e.letterSpacing,
              l = !1
            if (
              (jt.experimentalLetterSpacingSupported &&
                (jt.experimentalLetterSpacing
                  ? ((a.letterSpacing = `${u}px`), (a.textLetterSpacing = `${u}px`), (l = !0))
                  : ((a.letterSpacing = "0px"), (a.textLetterSpacing = "0px"))),
              u === 0 || l)
            ) {
              o ? a.strokeText(t, n, s) : a.fillText(t, n, s)
              return
            }
            let c = n,
              h = jt.graphemeSegmenter(t),
              f = a.measureText(t).width,
              d = 0
            for (let g = 0; g < h.length; ++g) {
              let x = h[g]
              o ? a.strokeText(x, c, s) : a.fillText(x, c, s)
              let m = ""
              for (let _ = g + 1; _ < h.length; ++_) m += h[_]
              ;((d = a.measureText(m).width), (c += f - d + u), (f = d))
            }
          }
        }),
        (mi = new Tf()))
    })
  var Gs,
    Wb = p(() => {
      A()
      _r()
      qr()
      gt()
      sn()
      yf()
      Cf()
      Gs = class {
        constructor(t) {
          this._renderer = t
        }
        getTexture(t, e, i, n) {
          ;(typeof t == "string" &&
            (z(
              "8.0.0",
              "CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments",
            ),
            (t = { text: t, style: i, resolution: e })),
            t.style instanceof le || (t.style = new le(t.style)),
            t.textureStyle instanceof Jt || (t.textureStyle = new Jt(t.textureStyle)),
            typeof t.text != "string" && (t.text = t.text.toString()))
          let { text: s, style: o, textureStyle: a } = t,
            u = t.resolution ?? this._renderer.resolution,
            { frame: l, canvasAndContext: c } = mi.getCanvasAndContext({
              text: s,
              style: o,
              resolution: u,
            }),
            h = Iu(c.canvas, l.width, l.height, u)
          if (
            (a && (h.source.style = a),
            o.trim && (l.pad(o.padding), h.frame.copyFrom(l), h.updateUvs()),
            o.filters)
          ) {
            let f = this._applyFilters(h, o.filters)
            return (this.returnTexture(h), mi.returnCanvasAndContext(c), f)
          }
          return (this._renderer.texture.initSource(h._source), mi.returnCanvasAndContext(c), h)
        }
        returnTexture(t) {
          let e = t.source
          ;((e.resource = null),
            (e.uploadMethodId = "unknown"),
            (e.alphaMode = "no-premultiply-alpha"),
            St.returnTexture(t, !0))
        }
        renderTextToCanvas() {
          z(
            "8.10.0",
            "CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead",
          )
        }
        _applyFilters(t, e) {
          let i = this._renderer.renderTarget.renderTarget,
            n = this._renderer.filter.generateFilteredTexture({ texture: t, filters: e })
          return (this._renderer.renderTarget.bind(i, !1), n)
        }
        destroy() {
          this._renderer = null
        }
      }
      Gs.extension = { type: [b.WebGLSystem, b.WebGPUSystem, b.CanvasSystem], name: "canvasText" }
    })
  var Ef = p(() => {
    A()
    K0()
    Wb()
    L.add(Gs)
    L.add(Bs)
  })
  var Pr,
    wf = p(() => {
      gt()
      Ka()
      xf()
      Pr = class r extends vr {
        constructor(t) {
          t instanceof de && (t = { context: t })
          let { context: e, roundPixels: i, ...n } = t || {}
          ;(super({ label: "Graphics", ...n }),
            (this.renderPipeId = "graphics"),
            e ? (this._context = e) : (this._context = this._ownedContext = new de()),
            this._context.on("update", this.onViewUpdate, this),
            (this.didViewUpdate = !0),
            (this.allowChildren = !1),
            (this.roundPixels = i ?? !1))
        }
        set context(t) {
          t !== this._context &&
            (this._context.off("update", this.onViewUpdate, this),
            (this._context = t),
            this._context.on("update", this.onViewUpdate, this),
            this.onViewUpdate())
        }
        get context() {
          return this._context
        }
        get bounds() {
          return this._context.bounds
        }
        updateBounds() {}
        containsPoint(t) {
          return this._context.containsPoint(t)
        }
        destroy(t) {
          ;(this._ownedContext && !t
            ? this._ownedContext.destroy(t)
            : (t === !0 || t?.context === !0) && this._context.destroy(t),
            (this._ownedContext = null),
            (this._context = null),
            super.destroy(t))
        }
        _callContextMethod(t, e) {
          return (this.context[t](...e), this)
        }
        setFillStyle(...t) {
          return this._callContextMethod("setFillStyle", t)
        }
        setStrokeStyle(...t) {
          return this._callContextMethod("setStrokeStyle", t)
        }
        fill(...t) {
          return this._callContextMethod("fill", t)
        }
        stroke(...t) {
          return this._callContextMethod("stroke", t)
        }
        texture(...t) {
          return this._callContextMethod("texture", t)
        }
        beginPath() {
          return this._callContextMethod("beginPath", [])
        }
        cut() {
          return this._callContextMethod("cut", [])
        }
        arc(...t) {
          return this._callContextMethod("arc", t)
        }
        arcTo(...t) {
          return this._callContextMethod("arcTo", t)
        }
        arcToSvg(...t) {
          return this._callContextMethod("arcToSvg", t)
        }
        bezierCurveTo(...t) {
          return this._callContextMethod("bezierCurveTo", t)
        }
        closePath() {
          return this._callContextMethod("closePath", [])
        }
        ellipse(...t) {
          return this._callContextMethod("ellipse", t)
        }
        circle(...t) {
          return this._callContextMethod("circle", t)
        }
        path(...t) {
          return this._callContextMethod("path", t)
        }
        lineTo(...t) {
          return this._callContextMethod("lineTo", t)
        }
        moveTo(...t) {
          return this._callContextMethod("moveTo", t)
        }
        quadraticCurveTo(...t) {
          return this._callContextMethod("quadraticCurveTo", t)
        }
        rect(...t) {
          return this._callContextMethod("rect", t)
        }
        roundRect(...t) {
          return this._callContextMethod("roundRect", t)
        }
        poly(...t) {
          return this._callContextMethod("poly", t)
        }
        regularPoly(...t) {
          return this._callContextMethod("regularPoly", t)
        }
        roundPoly(...t) {
          return this._callContextMethod("roundPoly", t)
        }
        roundShape(...t) {
          return this._callContextMethod("roundShape", t)
        }
        filletRect(...t) {
          return this._callContextMethod("filletRect", t)
        }
        chamferRect(...t) {
          return this._callContextMethod("chamferRect", t)
        }
        star(...t) {
          return this._callContextMethod("star", t)
        }
        svg(...t) {
          return this._callContextMethod("svg", t)
        }
        restore(...t) {
          return this._callContextMethod("restore", t)
        }
        save() {
          return this._callContextMethod("save", [])
        }
        getTransform() {
          return this.context.getTransform()
        }
        resetTransform() {
          return this._callContextMethod("resetTransform", [])
        }
        rotateTransform(...t) {
          return this._callContextMethod("rotate", t)
        }
        scaleTransform(...t) {
          return this._callContextMethod("scale", t)
        }
        setTransform(...t) {
          return this._callContextMethod("setTransform", t)
        }
        transform(...t) {
          return this._callContextMethod("transform", t)
        }
        translateTransform(...t) {
          return this._callContextMethod("translate", t)
        }
        clear() {
          return this._callContextMethod("clear", [])
        }
        get fillStyle() {
          return this._context.fillStyle
        }
        set fillStyle(t) {
          this._context.fillStyle = t
        }
        get strokeStyle() {
          return this._context.strokeStyle
        }
        set strokeStyle(t) {
          this._context.strokeStyle = t
        }
        clone(t = !1) {
          return t
            ? new r(this._context.clone())
            : ((this._ownedContext = null), new r(this._context))
        }
        lineStyle(t, e, i) {
          z(
            K,
            "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.",
          )
          let n = {}
          return (
            t && (n.width = t),
            e && (n.color = e),
            i && (n.alpha = i),
            (this.context.strokeStyle = n),
            this
          )
        }
        beginFill(t, e) {
          z(
            K,
            "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.",
          )
          let i = {}
          return (
            t !== void 0 && (i.color = t),
            e !== void 0 && (i.alpha = e),
            (this.context.fillStyle = i),
            this
          )
        }
        endFill() {
          ;(z(
            K,
            "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.",
          ),
            this.context.fill())
          let t = this.context.strokeStyle
          return (
            (t.width !== de.defaultStrokeStyle.width ||
              t.color !== de.defaultStrokeStyle.color ||
              t.alpha !== de.defaultStrokeStyle.alpha) &&
              this.context.stroke(),
            this
          )
        }
        drawCircle(...t) {
          return (
            z(K, "Graphics#drawCircle has been renamed to Graphics#circle"),
            this._callContextMethod("circle", t)
          )
        }
        drawEllipse(...t) {
          return (
            z(K, "Graphics#drawEllipse has been renamed to Graphics#ellipse"),
            this._callContextMethod("ellipse", t)
          )
        }
        drawPolygon(...t) {
          return (
            z(K, "Graphics#drawPolygon has been renamed to Graphics#poly"),
            this._callContextMethod("poly", t)
          )
        }
        drawRect(...t) {
          return (
            z(K, "Graphics#drawRect has been renamed to Graphics#rect"),
            this._callContextMethod("rect", t)
          )
        }
        drawRoundedRect(...t) {
          return (
            z(K, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect"),
            this._callContextMethod("roundRect", t)
          )
        }
        drawStar(...t) {
          return (
            z(K, "Graphics#drawStar has been renamed to Graphics#star"),
            this._callContextMethod("star", t)
          )
        }
      }
    })
  var Vb,
    $b,
    Xb = p(() => {
      "use strict"
      ;((Vb = {
        name: "local-uniform-msdf-bit",
        vertex: {
          header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
          main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
          end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `,
        },
        fragment: {
          header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `,
          main: `
            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));
        `,
        },
      }),
        ($b = {
          name: "local-uniform-msdf-bit",
          vertex: {
            header: `
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
            main: `
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `,
            end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `,
          },
          fragment: {
            header: `
            uniform float uDistance;
         `,
            main: `
            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));
        `,
          },
        }))
    })
  var Yb,
    jb,
    Kb = p(() => {
      "use strict"
      ;((Yb = {
        name: "msdf-bit",
        fragment: {
          header: `
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {

                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));

                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));
                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);
                var coverage: f32 = pow(shapeColor.a * alpha, gamma);

                return coverage;

            }
        `,
        },
      }),
        (jb = {
          name: "msdf-bit",
          fragment: {
            header: `
            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {

                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));

                // SDF
                median = min(median, msdfColor.a);

                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);

                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));
                float gamma = mix(1.0, 1.0 / 2.2, luma);
                float coverage = pow(shapeColor.a * alpha, gamma);

                return coverage;
            }
        `,
          },
        }))
    })
  var Mf,
    Af,
    Gu,
    qb = p(() => {
      nt()
      wr()
      bs()
      vs()
      Mr()
      hu()
      Ae()
      re()
      Xb()
      Kb()
      Gu = class extends Mt {
        constructor(t) {
          let e = new ht({
            uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
            uTransformMatrix: { value: new I(), type: "mat3x3<f32>" },
            uDistance: { value: 4, type: "f32" },
            uRound: { value: 0, type: "f32" },
          })
          ;(Mf ?? (Mf = ke({ name: "sdf-shader", bits: [Wi, $i(t), Vb, Yb, Ue] })),
            Af ?? (Af = Ge({ name: "sdf-shader", bits: [Vi, Xi(t), $b, jb, Oe] })),
            super({
              glProgram: Af,
              gpuProgram: Mf,
              resources: { localUniforms: e, batchSamplers: Yi(t) },
            }))
        }
      }
    })
  var Uu,
    Zb = p(() => {
      Wt()
      gt()
      Uu = class extends lt {
        constructor() {
          ;(super(...arguments),
            (this.chars = Object.create(null)),
            (this.lineHeight = 0),
            (this.fontFamily = ""),
            (this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 }),
            (this.baseLineOffset = 0),
            (this.distanceField = { type: "none", range: 0 }),
            (this.pages = []),
            (this.applyFillAsTint = !0),
            (this.baseMeasurementFontSize = 100),
            (this.baseRenderedFontSize = 100))
        }
        get font() {
          return (
            z(K, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."),
            this.fontFamily
          )
        }
        get pageTextures() {
          return (
            z(K, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),
            this.pages
          )
        }
        get size() {
          return (
            z(
              K,
              "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.",
            ),
            this.fontMetrics.fontSize
          )
        }
        get distanceFieldRange() {
          return (
            z(
              K,
              "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.",
            ),
            this.distanceField.range
          )
        }
        get distanceFieldType() {
          return (
            z(
              K,
              "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.",
            ),
            this.distanceField.type
          )
        }
        destroy(t = !1) {
          ;(this.emit("destroy", this), this.removeAllListeners())
          for (let e in this.chars) this.chars[e].texture?.destroy()
          ;((this.chars = null),
            t && (this.pages.forEach((e) => e.texture.destroy(!0)), (this.pages = null)))
        }
      }
    })
  var Qb,
    Df,
    tv = p(() => {
      Vt()
      Lt()
      on()
      tu()
      dt()
      qr()
      gt()
      an()
      ku()
      Sf()
      sn()
      Zb()
      Qb = class Jb extends Uu {
        constructor(t) {
          ;(super(),
            (this.resolution = 1),
            (this.pages = []),
            (this._padding = 0),
            (this._measureCache = Object.create(null)),
            (this._currentChars = []),
            (this._currentX = 0),
            (this._currentY = 0),
            (this._currentMaxCharHeight = 0),
            (this._currentPageIndex = -1),
            (this._skipKerning = !1))
          let e = { ...Jb.defaultOptions, ...t }
          ;((this._textureSize = e.textureSize), (this._mipmap = e.mipmap))
          let i = e.style.clone()
          ;(e.overrideFill &&
            ((i._fill.color = 16777215),
            (i._fill.alpha = 1),
            (i._fill.texture = k.WHITE),
            (i._fill.fill = null)),
            (this.applyFillAsTint = e.overrideFill))
          let n = i.fontSize
          i.fontSize = this.baseMeasurementFontSize
          let s = pi(i)
          ;(e.overrideSize
            ? i._stroke && (i._stroke.width *= this.baseRenderedFontSize / n)
            : (i.fontSize = this.baseRenderedFontSize = n),
            (this._style = i),
            (this._skipKerning = e.skipKerning ?? !1),
            (this.resolution = e.resolution ?? 1),
            (this._padding = e.padding ?? 4),
            e.textureStyle &&
              (this._textureStyle =
                e.textureStyle instanceof Jt ? e.textureStyle : new Jt(e.textureStyle)),
            (this.fontMetrics = jt.measureFont(s)),
            (this.lineHeight = i.lineHeight || this.fontMetrics.fontSize || i.fontSize))
        }
        ensureCharacters(t) {
          let e = jt
            .graphemeSegmenter(t)
            .filter((m) => !this._currentChars.includes(m))
            .filter((m, _, v) => v.indexOf(m) === _)
          if (!e.length) return
          this._currentChars = [...this._currentChars, ...e]
          let i
          this._currentPageIndex === -1
            ? (i = this._nextPage())
            : (i = this.pages[this._currentPageIndex])
          let { canvas: n, context: s } = i.canvasAndContext,
            o = i.texture.source,
            a = this._style,
            u = this._currentX,
            l = this._currentY,
            c = this._currentMaxCharHeight,
            h = this.baseRenderedFontSize / this.baseMeasurementFontSize,
            f = this._padding * h,
            d = !1,
            g = n.width / this.resolution,
            x = n.height / this.resolution
          for (let m = 0; m < e.length; m++) {
            let _ = e[m],
              v = jt.measureText(_, a, n, !1)
            v.lineHeight = v.height
            let S = v.width * h,
              y = Math.ceil((a.fontStyle === "italic" ? 2 : 1) * S),
              M = v.height * h,
              T = y + f * 2,
              E = M + f * 2
            if (
              ((d = !1),
              _ !==
                `
` &&
                _ !== "\r" &&
                _ !== "	" &&
                _ !== " " &&
                ((d = !0), (c = Math.ceil(Math.max(E, c)))),
              u + T > g && ((l += c), (c = E), (u = 0), l + c > x))
            ) {
              o.update()
              let B = this._nextPage()
              ;((n = B.canvasAndContext.canvas),
                (s = B.canvasAndContext.context),
                (o = B.texture.source),
                (u = 0),
                (l = 0),
                (c = 0))
            }
            let G = S / h - (a.dropShadow?.distance ?? 0) - (a._stroke?.width ?? 0)
            if (
              ((this.chars[_] = {
                id: _.codePointAt(0),
                xOffset: -this._padding,
                yOffset: -this._padding,
                xAdvance: G,
                kerning: {},
              }),
              d)
            ) {
              this._drawGlyph(s, v, u + f, l + f, h, a)
              let B = o.width * h,
                P = o.height * h,
                F = new Q(
                  (u / B) * o.width,
                  (l / P) * o.height,
                  (T / B) * o.width,
                  (E / P) * o.height,
                )
              ;((this.chars[_].texture = new k({ source: o, frame: F })), (u += Math.ceil(T)))
            }
          }
          ;(o.update(),
            (this._currentX = u),
            (this._currentY = l),
            (this._currentMaxCharHeight = c),
            this._skipKerning && this._applyKerning(e, s))
        }
        get pageTextures() {
          return (
            z(K, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),
            this.pages
          )
        }
        _applyKerning(t, e) {
          let i = this._measureCache
          for (let n = 0; n < t.length; n++) {
            let s = t[n]
            for (let o = 0; o < this._currentChars.length; o++) {
              let a = this._currentChars[o],
                u = i[s]
              u || (u = i[s] = e.measureText(s).width)
              let l = i[a]
              l || (l = i[a] = e.measureText(a).width)
              let c = e.measureText(s + a).width,
                h = c - (u + l)
              ;(h && (this.chars[s].kerning[a] = h),
                (c = e.measureText(s + a).width),
                (h = c - (u + l)),
                h && (this.chars[a].kerning[s] = h))
            }
          }
        }
        _nextPage() {
          this._currentPageIndex++
          let t = this.resolution,
            e = pe.getOptimalCanvasAndContext(this._textureSize, this._textureSize, t)
          this._setupContext(e.context, this._style, t)
          let i = t * (this.baseRenderedFontSize / this.baseMeasurementFontSize),
            n = new k({
              source: new Be({
                resource: e.canvas,
                resolution: i,
                alphaMode: "premultiply-alpha-on-upload",
                autoGenerateMipmaps: this._mipmap,
              }),
            })
          this._textureStyle && (n.source.style = this._textureStyle)
          let s = { canvasAndContext: e, texture: n }
          return ((this.pages[this._currentPageIndex] = s), s)
        }
        _setupContext(t, e, i) {
          ;((e.fontSize = this.baseRenderedFontSize),
            t.scale(i, i),
            (t.font = pi(e)),
            (e.fontSize = this.baseMeasurementFontSize),
            (t.textBaseline = e.textBaseline))
          let n = e._stroke,
            s = n?.width ?? 0
          if (
            (n &&
              ((t.lineWidth = s),
              (t.lineJoin = n.join),
              (t.miterLimit = n.miterLimit),
              (t.strokeStyle = un(n, t))),
            e._fill && (t.fillStyle = un(e._fill, t)),
            e.dropShadow)
          ) {
            let o = e.dropShadow,
              a = q.shared.setValue(o.color).toArray(),
              u = o.blur * i,
              l = o.distance * i
            ;((t.shadowColor = `rgba(${a[0] * 255},${a[1] * 255},${a[2] * 255},${o.alpha})`),
              (t.shadowBlur = u),
              (t.shadowOffsetX = Math.cos(o.angle) * l),
              (t.shadowOffsetY = Math.sin(o.angle) * l))
          } else
            ((t.shadowColor = "black"),
              (t.shadowBlur = 0),
              (t.shadowOffsetX = 0),
              (t.shadowOffsetY = 0))
        }
        _drawGlyph(t, e, i, n, s, o) {
          let a = e.text,
            u = e.fontProperties,
            c = (o._stroke?.width ?? 0) * s,
            h = i + c / 2,
            f = n - c / 2,
            d = u.descent * s,
            g = e.lineHeight * s,
            x = !1
          o.stroke && c && ((x = !0), t.strokeText(a, h, f + g - d))
          let { shadowBlur: m, shadowOffsetX: _, shadowOffsetY: v } = t
          ;(o._fill &&
            (x && ((t.shadowBlur = 0), (t.shadowOffsetX = 0), (t.shadowOffsetY = 0)),
            t.fillText(a, h, f + g - d)),
            x && ((t.shadowBlur = m), (t.shadowOffsetX = _), (t.shadowOffsetY = v)))
        }
        destroy() {
          super.destroy()
          for (let t = 0; t < this.pages.length; t++) {
            let { canvasAndContext: e, texture: i } = this.pages[t]
            ;(pe.returnCanvasAndContext(e), i.destroy(!0))
          }
          this.pages = null
        }
      }
      Qb.defaultOptions = { textureSize: 512, style: new le(), mipmap: !0 }
      Df = Qb
    })
  function Ou(r, t, e, i) {
    let n = {
      width: 0,
      height: 0,
      offsetY: 0,
      scale: t.fontSize / e.baseMeasurementFontSize,
      lines: [{ width: 0, charPositions: [], spaceWidth: 0, spacesIndex: [], chars: [] }],
    }
    n.offsetY = e.baseLineOffset
    let s = n.lines[0],
      o = null,
      a = !0,
      u = { spaceWord: !1, width: 0, start: 0, index: 0, positions: [], chars: [] },
      l = (m) => {
        let _ = s.width
        for (let v = 0; v < u.index; v++) {
          let S = m.positions[v]
          ;(s.chars.push(m.chars[v]), s.charPositions.push(S + _))
        }
        ;((s.width += m.width), (a = !1), (u.width = 0), (u.index = 0), (u.chars.length = 0))
      },
      c = () => {
        let m = s.chars.length - 1
        if (i) {
          let _ = s.chars[m]
          for (; _ === " "; ) ((s.width -= e.chars[_].xAdvance), (_ = s.chars[--m]))
        }
        ;((n.width = Math.max(n.width, s.width)),
          (s = { width: 0, charPositions: [], chars: [], spaceWidth: 0, spacesIndex: [] }),
          (a = !0),
          n.lines.push(s),
          (n.height += e.lineHeight))
      },
      h = e.baseMeasurementFontSize / t.fontSize,
      f = t.letterSpacing * h,
      d = t.wordWrapWidth * h,
      g = t.wordWrap && t.breakWords,
      x = (m) => m - f > d
    for (let m = 0; m < r.length + 1; m++) {
      let _,
        v = m === r.length
      v || (_ = r[m])
      let S = e.chars[_] || e.chars[" "]
      if (
        /(?:\s)/.test(_) ||
        _ === "\r" ||
        _ ===
          `
` ||
        v
      ) {
        if (
          (!a && t.wordWrap && x(s.width + u.width)
            ? (c(), l(u), v || s.charPositions.push(0))
            : ((u.start = s.width), l(u), v || s.charPositions.push(0)),
          _ === "\r" ||
            _ ===
              `
`)
        )
          s.width !== 0 && c()
        else if (!v) {
          let E = S.xAdvance + (S.kerning[o] || 0) + f
          ;((s.width += E),
            (s.spaceWidth = E),
            s.spacesIndex.push(s.charPositions.length),
            s.chars.push(_))
        }
      } else {
        let T = S.kerning[o] || 0,
          E = S.xAdvance + T + f
        ;(g && x(s.width + u.width + E) && (l(u), c()),
          (u.positions[u.index++] = u.width + T),
          u.chars.push(_),
          (u.width += E))
      }
      o = _
    }
    return (
      c(),
      t.align === "center" ? zD(n) : t.align === "right" ? WD(n) : t.align === "justify" && VD(n),
      n
    )
  }
  function zD(r) {
    for (let t = 0; t < r.lines.length; t++) {
      let e = r.lines[t],
        i = r.width / 2 - e.width / 2
      for (let n = 0; n < e.charPositions.length; n++) e.charPositions[n] += i
    }
  }
  function WD(r) {
    for (let t = 0; t < r.lines.length; t++) {
      let e = r.lines[t],
        i = r.width - e.width
      for (let n = 0; n < e.charPositions.length; n++) e.charPositions[n] += i
    }
  }
  function VD(r) {
    let t = r.width
    for (let e = 0; e < r.lines.length; e++) {
      let i = r.lines[e],
        n = 0,
        s = i.spacesIndex[n++],
        o = 0,
        a = i.spacesIndex.length,
        l = (t - i.width) / a
      for (let c = 0; c < i.charPositions.length; c++)
        (c === s && ((s = i.spacesIndex[n++]), (o += l)), (i.charPositions[c] += o))
    }
  }
  var Pf = p(() => {
    "use strict"
  })
  function ev(r) {
    if (r === "") return []
    typeof r == "string" && (r = [r])
    let t = []
    for (let e = 0, i = r.length; e < i; e++) {
      let n = r[e]
      if (Array.isArray(n)) {
        if (n.length !== 2)
          throw new Error(
            `[BitmapFont]: Invalid character range length, expecting 2 got ${n.length}.`,
          )
        if (n[0].length === 0 || n[1].length === 0)
          throw new Error("[BitmapFont]: Invalid character delimiter.")
        let s = n[0].charCodeAt(0),
          o = n[1].charCodeAt(0)
        if (o < s) throw new Error("[BitmapFont]: Invalid character range.")
        for (let a = s, u = o; a <= u; a++) t.push(String.fromCharCode(a))
      } else t.push(...Array.from(n))
    }
    if (t.length === 0) throw new Error("[BitmapFont]: Empty set when resolving characters.")
    return t
  }
  var rv = p(() => {
    "use strict"
  })
  var Lu,
    Ff,
    iv,
    nv = p(() => {
      ms()
      gt()
      ft()
      an()
      sn()
      tv()
      Pf()
      rv()
      ;((Lu = 0),
        (Ff = class {
          constructor() {
            ;((this.ALPHA = [["a", "z"], ["A", "Z"], " "]),
              (this.NUMERIC = [["0", "9"]]),
              (this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "]),
              (this.ASCII = [[" ", "~"]]),
              (this.defaultOptions = {
                chars: this.ALPHANUMERIC,
                resolution: 1,
                padding: 4,
                skipKerning: !1,
                textureStyle: null,
              }))
          }
          getFont(t, e) {
            let i = `${e.fontFamily}-bitmap`,
              n = !0
            if (e._fill.fill && !e._stroke) ((i += e._fill.fill.styleKey), (n = !1))
            else if (e._stroke || e.dropShadow) {
              let o = e.styleKey
              ;((o = o.substring(0, o.lastIndexOf("-"))), (i = `${o}-bitmap`), (n = !1))
            }
            if (!Rt.has(i)) {
              let o = new Df({
                style: e,
                overrideFill: n,
                overrideSize: !0,
                ...this.defaultOptions,
              })
              ;(Lu++,
                Lu > 50 &&
                  N(
                    "BitmapText",
                    `You have dynamically created ${Lu} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``,
                  ),
                o.once("destroy", () => {
                  ;(Lu--, Rt.remove(i))
                }),
                Rt.set(i, o))
            }
            let s = Rt.get(i)
            return (s.ensureCharacters?.(t), s)
          }
          getLayout(t, e, i = !0) {
            let n = this.getFont(t, e),
              s = jt.graphemeSegmenter(t)
            return Ou(s, e, n, i)
          }
          measureText(t, e, i = !0) {
            return this.getLayout(t, e, i)
          }
          install(...t) {
            let e = t[0]
            typeof e == "string" &&
              ((e = {
                name: e,
                style: t[1],
                chars: t[2]?.chars,
                resolution: t[2]?.resolution,
                padding: t[2]?.padding,
                skipKerning: t[2]?.skipKerning,
              }),
              z(
                K,
                "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})",
              ))
            let i = e?.name
            if (!i) throw new Error("[BitmapFontManager] Property `name` is required.")
            e = { ...this.defaultOptions, ...e }
            let n = e.style,
              s = n instanceof le ? n : new le(n),
              o = s._fill.fill !== null && s._fill.fill !== void 0,
              a = new Df({
                style: s,
                overrideFill: o,
                skipKerning: e.skipKerning,
                padding: e.padding,
                resolution: e.resolution,
                overrideSize: !1,
                textureStyle: e.textureStyle,
              }),
              u = ev(e.chars)
            return (
              a.ensureCharacters(u.join("")),
              Rt.set(`${i}-bitmap`, a),
              a.once("destroy", () => Rt.remove(`${i}-bitmap`)),
              a
            )
          }
          uninstall(t) {
            let e = `${t}-bitmap`,
              i = Rt.get(e)
            i && i.destroy()
          }
        }),
        (iv = new Ff()))
    })
  function sv(r, t) {
    ;((t.groupTransform = r.groupTransform),
      (t.groupColorAlpha = r.groupColorAlpha),
      (t.groupColor = r.groupColor),
      (t.groupBlendMode = r.groupBlendMode),
      (t.globalDisplayStatus = r.globalDisplayStatus),
      (t.groupTransform = r.groupTransform),
      (t.localDisplayStatus = r.localDisplayStatus),
      (t.groupAlpha = r.groupAlpha),
      (t._roundPixels = r._roundPixels))
  }
  var Rf,
    Us,
    ov = p(() => {
      ms()
      A()
      wf()
      an()
      qb()
      nv()
      Pf()
      ;((Rf = class extends Pr {
        destroy() {
          ;(this.context.customShader && this.context.customShader.destroy(), super.destroy())
        }
      }),
        (Us = class {
          constructor(t) {
            ;((this._renderer = t),
              this._renderer.renderableGC.addManagedHash(this, "_gpuBitmapText"))
          }
          validateRenderable(t) {
            let e = this._getGpuBitmapText(t)
            return (
              t._didTextUpdate && ((t._didTextUpdate = !1), this._updateContext(t, e)),
              this._renderer.renderPipes.graphics.validateRenderable(e)
            )
          }
          addRenderable(t, e) {
            let i = this._getGpuBitmapText(t)
            ;(sv(t, i),
              t._didTextUpdate && ((t._didTextUpdate = !1), this._updateContext(t, i)),
              this._renderer.renderPipes.graphics.addRenderable(i, e),
              i.context.customShader && this._updateDistanceField(t))
          }
          updateRenderable(t) {
            let e = this._getGpuBitmapText(t)
            ;(sv(t, e),
              this._renderer.renderPipes.graphics.updateRenderable(e),
              e.context.customShader && this._updateDistanceField(t))
          }
          _updateContext(t, e) {
            let { context: i } = e,
              n = iv.getFont(t.text, t._style)
            ;(i.clear(),
              n.distanceField.type !== "none" &&
                (i.customShader ||
                  (i.customShader = new Gu(this._renderer.limits.maxBatchableTextures))))
            let s = jt.graphemeSegmenter(t.text),
              o = t._style,
              a = n.baseLineOffset,
              u = Ou(s, o, n, !0),
              l = o.padding,
              c = u.scale,
              h = u.width,
              f = u.height + u.offsetY
            ;(o._stroke && ((h += o._stroke.width / c), (f += o._stroke.width / c)),
              i.translate(-t._anchor._x * h - l, -t._anchor._y * f - l).scale(c, c))
            let d = n.applyFillAsTint ? o._fill.color : 16777215
            for (let g = 0; g < u.lines.length; g++) {
              let x = u.lines[g]
              for (let m = 0; m < x.charPositions.length; m++) {
                let _ = x.chars[m],
                  v = n.chars[_]
                v?.texture &&
                  i.texture(
                    v.texture,
                    d || "black",
                    Math.round(x.charPositions[m] + v.xOffset),
                    Math.round(a + v.yOffset),
                  )
              }
              a += n.lineHeight
            }
          }
          _getGpuBitmapText(t) {
            return t._gpuData[this._renderer.uid] || this.initGpuText(t)
          }
          initGpuText(t) {
            let e = new Rf()
            return ((t._gpuData[this._renderer.uid] = e), this._updateContext(t, e), e)
          }
          _updateDistanceField(t) {
            let e = this._getGpuBitmapText(t).context,
              i = t._style.fontFamily,
              n = Rt.get(`${i}-bitmap`),
              { a: s, b: o, c: a, d: u } = t.groupTransform,
              l = Math.sqrt(s * s + o * o),
              c = Math.sqrt(a * a + u * u),
              h = (Math.abs(l) + Math.abs(c)) / 2,
              f = n.baseRenderedFontSize / t._style.fontSize,
              d = h * n.distanceField.range * (1 / f)
            e.customShader.resources.localUniforms.uniforms.uDistance = d
          }
          destroy() {
            this._renderer = null
          }
        }))
      Us.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "bitmapText" }
    })
  var Bf = p(() => {
    A()
    ov()
    L.add(Us)
  })
  var Nu,
    av = p(() => {
      Rs()
      Nu = class extends He {
        constructor(t) {
          ;(super(),
            (this.generatingTexture = !1),
            (this._renderer = t),
            t.runners.resolutionChange.add(this))
        }
        resolutionChange() {
          let t = this.renderable
          t._autoResolution && t.onViewUpdate()
        }
        destroy() {
          ;(this._renderer.htmlText.returnTexturePromise(this.texturePromise),
            (this.texturePromise = null),
            (this._renderer = null))
        }
      }
    })
  var Os,
    uv = p(() => {
      A()
      dt()
      tf()
      av()
      Os = class {
        constructor(t) {
          this._renderer = t
        }
        validateRenderable(t) {
          return t._didTextUpdate
        }
        addRenderable(t, e) {
          let i = this._getGpuText(t)
          ;(t._didTextUpdate &&
            (this._updateGpuText(t).catch((n) => {
              console.error(n)
            }),
            (t._didTextUpdate = !1),
            Fs(i, t)),
            this._renderer.renderPipes.batch.addToBatch(i, e))
        }
        updateRenderable(t) {
          let e = this._getGpuText(t)
          e._batcher.updateElement(e)
        }
        async _updateGpuText(t) {
          t._didTextUpdate = !1
          let e = this._getGpuText(t)
          if (e.generatingTexture) return
          ;(e.texturePromise &&
            (this._renderer.htmlText.returnTexturePromise(e.texturePromise),
            (e.texturePromise = null)),
            (e.generatingTexture = !0),
            (t._resolution = t._autoResolution ? this._renderer.resolution : t.resolution))
          let i = this._renderer.htmlText.getTexturePromise(t)
          ;((e.texturePromise = i), (e.texture = await i))
          let n = t.renderGroup || t.parentRenderGroup
          ;(n && (n.structureDidChange = !0), (e.generatingTexture = !1), Fs(e, t))
        }
        _getGpuText(t) {
          return t._gpuData[this._renderer.uid] || this.initGpuText(t)
        }
        initGpuText(t) {
          let e = new Nu(this._renderer)
          return (
            (e.renderable = t),
            (e.transform = t.groupTransform),
            (e.texture = k.EMPTY),
            (e.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }),
            (e.roundPixels = this._renderer._roundPixels | t._roundPixels),
            (t._resolution = t._autoResolution ? this._renderer.resolution : t.resolution),
            (t._gpuData[this._renderer.uid] = e),
            e
          )
        }
        destroy() {
          this._renderer = null
        }
      }
      Os.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "htmlText" }
    })
  function lv() {
    let { userAgent: r } = Z.get().getNavigator()
    return /^((?!chrome|android).)*safari/i.test(r)
  }
  var cv = p(() => {
    At()
  })
  var hv,
    fv,
    ln,
    If = p(() => {
      "use strict"
      ;((hv = "http://www.w3.org/2000/svg"),
        (fv = "http://www.w3.org/1999/xhtml"),
        (ln = class {
          constructor() {
            ;((this.svgRoot = document.createElementNS(hv, "svg")),
              (this.foreignObject = document.createElementNS(hv, "foreignObject")),
              (this.domElement = document.createElementNS(fv, "div")),
              (this.styleElement = document.createElementNS(fv, "style")),
              (this.image = new Image()))
            let { foreignObject: t, svgRoot: e, styleElement: i, domElement: n } = this
            ;(t.setAttribute("width", "10000"),
              t.setAttribute("height", "10000"),
              (t.style.overflow = "hidden"),
              e.appendChild(t),
              t.appendChild(i),
              t.appendChild(n))
          }
        }))
    })
  function mv(r) {
    let t = r._stroke,
      e = r._fill,
      n = [
        `div { ${[`color: ${q.shared.setValue(e.color).toHex()}`, `font-size: ${r.fontSize}px`, `font-family: ${r.fontFamily}`, `font-weight: ${r.fontWeight}`, `font-style: ${r.fontStyle}`, `font-variant: ${r.fontVariant}`, `letter-spacing: ${r.letterSpacing}px`, `text-align: ${r.align}`, `padding: ${r.padding}px`, `white-space: ${r.whiteSpace === "pre" && r.wordWrap ? "pre-wrap" : r.whiteSpace}`, ...(r.lineHeight ? [`line-height: ${r.lineHeight}px`] : []), ...(r.wordWrap ? [`word-wrap: ${r.breakWords ? "break-all" : "break-word"}`, `max-width: ${r.wordWrapWidth}px`] : []), ...(t ? [xv(t)] : []), ...(r.dropShadow ? [gv(r.dropShadow)] : []), ...r.cssOverrides].join(";")} }`,
      ]
    return ($D(r.tagStyles, n), n.join(" "))
  }
  function gv(r) {
    let t = q.shared.setValue(r.color).setAlpha(r.alpha).toHexa(),
      e = Math.round(Math.cos(r.angle) * r.distance),
      i = Math.round(Math.sin(r.angle) * r.distance),
      n = `${e}px ${i}px`
    return r.blur > 0 ? `text-shadow: ${n} ${r.blur}px ${t}` : `text-shadow: ${n} ${t}`
  }
  function xv(r) {
    return [
      `-webkit-text-stroke-width: ${r.width}px`,
      `-webkit-text-stroke-color: ${q.shared.setValue(r.color).toHex()}`,
      `text-stroke-width: ${r.width}px`,
      `text-stroke-color: ${q.shared.setValue(r.color).toHex()}`,
      "paint-order: stroke",
    ].join(";")
  }
  function $D(r, t) {
    for (let e in r) {
      let i = r[e],
        n = []
      for (let s in i)
        pv[s] ? n.push(pv[s](i[s])) : dv[s] && n.push(dv[s].replace("{{VALUE}}", i[s]))
      t.push(`${e} { ${n.join(";")} }`)
    }
  }
  var dv,
    pv,
    _v = p(() => {
      Vt()
      ;((dv = {
        fontSize: "font-size: {{VALUE}}px",
        fontFamily: "font-family: {{VALUE}}",
        fontWeight: "font-weight: {{VALUE}}",
        fontStyle: "font-style: {{VALUE}}",
        fontVariant: "font-variant: {{VALUE}}",
        letterSpacing: "letter-spacing: {{VALUE}}px",
        align: "text-align: {{VALUE}}",
        padding: "padding: {{VALUE}}px",
        whiteSpace: "white-space: {{VALUE}}",
        lineHeight: "line-height: {{VALUE}}px",
        wordWrapWidth: "max-width: {{VALUE}}px",
      }),
        (pv = {
          fill: (r) => `color: ${q.shared.setValue(r).toHex()}`,
          breakWords: (r) => `word-wrap: ${r ? "break-all" : "break-word"}`,
          stroke: xv,
          dropShadow: gv,
        }))
    })
  var Hu,
    yv = p(() => {
      ft()
      sn()
      _v()
      Hu = class r extends le {
        constructor(t = {}) {
          ;(super(t),
            (this._cssOverrides = []),
            (this.cssOverrides = t.cssOverrides ?? []),
            (this.tagStyles = t.tagStyles ?? {}))
        }
        set cssOverrides(t) {
          ;((this._cssOverrides = t instanceof Array ? t : [t]), this.update())
        }
        get cssOverrides() {
          return this._cssOverrides
        }
        update() {
          ;((this._cssStyle = null), super.update())
        }
        clone() {
          return new r({
            align: this.align,
            breakWords: this.breakWords,
            dropShadow: this.dropShadow ? { ...this.dropShadow } : null,
            fill: this._fill,
            fontFamily: this.fontFamily,
            fontSize: this.fontSize,
            fontStyle: this.fontStyle,
            fontVariant: this.fontVariant,
            fontWeight: this.fontWeight,
            letterSpacing: this.letterSpacing,
            lineHeight: this.lineHeight,
            padding: this.padding,
            stroke: this._stroke,
            whiteSpace: this.whiteSpace,
            wordWrap: this.wordWrap,
            wordWrapWidth: this.wordWrapWidth,
            cssOverrides: this.cssOverrides,
            tagStyles: { ...this.tagStyles },
          })
        }
        get cssStyle() {
          return (this._cssStyle || (this._cssStyle = mv(this)), this._cssStyle)
        }
        addOverride(...t) {
          let e = t.filter((i) => !this.cssOverrides.includes(i))
          e.length > 0 && (this.cssOverrides.push(...e), this.update())
        }
        removeOverride(...t) {
          let e = t.filter((i) => this.cssOverrides.includes(i))
          e.length > 0 &&
            ((this.cssOverrides = this.cssOverrides.filter((i) => !e.includes(i))), this.update())
        }
        set fill(t) {
          ;(typeof t != "string" &&
            typeof t != "number" &&
            N("[HTMLTextStyle] only color fill is not supported by HTMLText"),
            (super.fill = t))
        }
        set stroke(t) {
          ;(t &&
            typeof t != "string" &&
            typeof t != "number" &&
            N("[HTMLTextStyle] only color stroke is not supported by HTMLText"),
            (super.stroke = t))
        }
      }
    })
  function bv(r, t) {
    let e = t.fontFamily,
      i = [],
      n = {},
      s = /font-family:([^;"\s]+)/g,
      o = r.match(s)
    function a(u) {
      n[u] || (i.push(u), (n[u] = !0))
    }
    if (Array.isArray(e)) for (let u = 0; u < e.length; u++) a(e[u])
    else a(e)
    o &&
      o.forEach((u) => {
        let l = u.split(":")[1].trim()
        a(l)
      })
    for (let u in t.tagStyles) {
      let l = t.tagStyles[u].fontFamily
      a(l)
    }
    return i
  }
  var vv = p(() => {
    "use strict"
  })
  async function Sv(r) {
    let e = await (await Z.get().fetch(r)).blob(),
      i = new FileReader()
    return await new Promise((s, o) => {
      ;((i.onloadend = () => s(i.result)), (i.onerror = o), i.readAsDataURL(e))
    })
  }
  var Tv = p(() => {
    At()
  })
  async function kf(r, t) {
    let e = await Sv(t)
    return `@font-face {
        font-family: "${r.fontFamily}";
        src: url('${e}');
        font-weight: ${r.fontWeight};
        font-style: ${r.fontStyle};
    }`
  }
  var Cv = p(() => {
    Tv()
  })
  async function Ev(r, t, e) {
    let i = r
      .filter((n) => Rt.has(`${n}-and-url`))
      .map((n, s) => {
        if (!zu.has(n)) {
          let { url: o } = Rt.get(`${n}-and-url`)
          s === 0
            ? zu.set(n, kf({ fontWeight: t.fontWeight, fontStyle: t.fontStyle, fontFamily: n }, o))
            : zu.set(n, kf({ fontWeight: e.fontWeight, fontStyle: e.fontStyle, fontFamily: n }, o))
        }
        return zu.get(n)
      })
    return (await Promise.all(i)).join(`
`)
  }
  var zu,
    wv = p(() => {
      ms()
      Cv()
      zu = new Map()
    })
  function Mv(r, t, e, i, n) {
    let { domElement: s, styleElement: o, svgRoot: a } = n
    ;((s.innerHTML = `<style>${t.cssStyle}</style><div style='padding:0;'>${r}</div>`),
      s.setAttribute(
        "style",
        `transform: scale(${e});transform-origin: top left; display: inline-block`,
      ),
      (o.textContent = i))
    let { width: u, height: l } = n.image
    return (
      a.setAttribute("width", u.toString()),
      a.setAttribute("height", l.toString()),
      new XMLSerializer().serializeToString(a)
    )
  }
  var Av = p(() => {
    "use strict"
  })
  function Dv(r, t) {
    let e = pe.getOptimalCanvasAndContext(r.width, r.height, t),
      { context: i } = e
    return (i.clearRect(0, 0, r.width, r.height), i.drawImage(r, 0, 0), e)
  }
  var Pv = p(() => {
    on()
  })
  function Fv(r, t, e) {
    return new Promise(async (i) => {
      ;(e && (await new Promise((n) => setTimeout(n, 100))),
        (r.onload = () => {
          i()
        }),
        (r.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(t)}`),
        (r.crossOrigin = "anonymous"))
    })
  }
  var Rv = p(() => {
    "use strict"
  })
  function Iv(r, t, e, i) {
    i || (i = Bv || (Bv = new ln()))
    let { domElement: n, styleElement: s, svgRoot: o } = i
    ;((n.innerHTML = `<style>${t.cssStyle};</style><div style='padding:0'>${r}</div>`),
      n.setAttribute("style", "transform-origin: top left; display: inline-block"),
      e && (s.textContent = e),
      document.body.appendChild(o))
    let a = n.getBoundingClientRect()
    o.remove()
    let u = t.padding * 2
    return { width: a.width - u, height: a.height - u }
  }
  var Bv,
    kv = p(() => {
      If()
    })
  var Ls,
    Gv = p(() => {
      A()
      on()
      _r()
      Le()
      cv()
      ft()
      Je()
      yf()
      If()
      yv()
      vv()
      wv()
      Av()
      Pv()
      Rv()
      kv()
      Ls = class {
        constructor(t) {
          ;((this._renderer = t), (this._createCanvas = t.type === Bt.WEBGPU))
        }
        getTexture(t) {
          return this.getTexturePromise(t)
        }
        getTexturePromise(t) {
          return this._buildTexturePromise(t)
        }
        async _buildTexturePromise(t) {
          let { text: e, style: i, resolution: n, textureStyle: s } = t,
            o = xt.get(ln),
            a = bv(e, i),
            u = await Ev(a, i, Hu.defaultTextStyle),
            l = Iv(e, i, u, o),
            c = Math.ceil(Math.ceil(Math.max(1, l.width) + i.padding * 2) * n),
            h = Math.ceil(Math.ceil(Math.max(1, l.height) + i.padding * 2) * n),
            f = o.image,
            d = 2
          ;((f.width = (c | 0) + d), (f.height = (h | 0) + d))
          let g = Mv(e, i, n, u, o)
          await Fv(f, g, lv() && a.length > 0)
          let x = f,
            m
          this._createCanvas && (m = Dv(f, n))
          let _ = Iu(m ? m.canvas : x, f.width - d, f.height - d, n)
          return (
            s && (_.source.style = s),
            this._createCanvas &&
              (this._renderer.texture.initSource(_.source), pe.returnCanvasAndContext(m)),
            xt.return(o),
            _
          )
        }
        returnTexturePromise(t) {
          t.then((e) => {
            this._cleanUp(e)
          }).catch(() => {
            N("HTMLTextSystem: Failed to clean texture")
          })
        }
        _cleanUp(t) {
          ;(St.returnTexture(t, !0),
            (t.source.resource = null),
            (t.source.uploadMethodId = "unknown"))
        }
        destroy() {
          this._renderer = null
        }
      }
      Ls.extension = { type: [b.WebGLSystem, b.WebGPUSystem, b.CanvasSystem], name: "htmlText" }
    })
  var Gf = p(() => {
    A()
    uv()
    Gv()
    L.add(Ls)
    L.add(Os)
  })
  var Uv,
    cn,
    Wu = p(() => {
      Cr()
      sr()
      Ni()
      gt()
      Uv = class Ov extends _e {
        constructor(...t) {
          let e = t[0] ?? {}
          ;(e instanceof Float32Array &&
            (z(K, "use new MeshGeometry({ positions, uvs, indices }) instead"),
            (e = { positions: e, uvs: t[1], indices: t[2] })),
            (e = { ...Ov.defaultOptions, ...e }))
          let i = e.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            n = e.uvs
          n ||
            (e.positions
              ? (n = new Float32Array(i.length))
              : (n = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])))
          let s = e.indices || new Uint32Array([0, 1, 2, 0, 2, 3]),
            o = e.shrinkBuffersToFit,
            a = new wt({
              data: i,
              label: "attribute-mesh-positions",
              shrinkToFit: o,
              usage: tt.VERTEX | tt.COPY_DST,
            }),
            u = new wt({
              data: n,
              label: "attribute-mesh-uvs",
              shrinkToFit: o,
              usage: tt.VERTEX | tt.COPY_DST,
            }),
            l = new wt({
              data: s,
              label: "index-mesh-buffer",
              shrinkToFit: o,
              usage: tt.INDEX | tt.COPY_DST,
            })
          ;(super({
            attributes: {
              aPosition: { buffer: a, format: "float32x2", stride: 8, offset: 0 },
              aUV: { buffer: u, format: "float32x2", stride: 8, offset: 0 },
            },
            indexBuffer: l,
            topology: e.topology,
          }),
            (this.batchMode = "auto"))
        }
        get positions() {
          return this.attributes.aPosition.buffer.data
        }
        set positions(t) {
          this.attributes.aPosition.buffer.data = t
        }
        get uvs() {
          return this.attributes.aUV.buffer.data
        }
        set uvs(t) {
          this.attributes.aUV.buffer.data = t
        }
        get indices() {
          return this.indexBuffer.data
        }
        set indices(t) {
          this.indexBuffer.data = t
        }
      }
      Uv.defaultOptions = { topology: "triangle-list", shrinkBuffersToFit: !1 }
      cn = Uv
    })
  var gi,
    Lv,
    hn,
    fn = p(() => {
      "use strict"
      ;((gi = {
        name: "local-uniform-bit",
        vertex: {
          header: `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
          main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
          end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `,
        },
      }),
        (Lv = {
          ...gi,
          vertex: { ...gi.vertex, header: gi.vertex.header.replace("group(1)", "group(2)") },
        }),
        (hn = {
          name: "local-uniform-bit",
          vertex: {
            header: `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
            main: `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `,
            end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `,
          },
        }))
    })
  var Nv,
    Hv,
    zv = p(() => {
      "use strict"
      ;((Nv = {
        name: "tiling-bit",
        vertex: {
          header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,
          main: `
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `,
        },
        fragment: {
          header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,
          main: `

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            }

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `,
        },
      }),
        (Hv = {
          name: "tiling-bit",
          vertex: {
            header: `
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;

        `,
            main: `
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `,
          },
          fragment: {
            header: `
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `,
            main: `

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0

        `,
          },
        }))
    })
  var Uf,
    Of,
    Vu,
    Wv = p(() => {
      nt()
      wr()
      fn()
      Mr()
      Ae()
      re()
      dt()
      zv()
      Vu = class extends Mt {
        constructor() {
          ;(Uf ?? (Uf = ke({ name: "tiling-sprite-shader", bits: [gi, Nv, Ue] })),
            Of ?? (Of = Ge({ name: "tiling-sprite-shader", bits: [hn, Hv, Oe] })))
          let t = new ht({
            uMapCoord: { value: new I(), type: "mat3x3<f32>" },
            uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: "vec4<f32>" },
            uClampOffset: { value: new Float32Array([0, 0]), type: "vec2<f32>" },
            uTextureTransform: { value: new I(), type: "mat3x3<f32>" },
            uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: "vec4<f32>" },
          })
          super({
            glProgram: Of,
            gpuProgram: Uf,
            resources: {
              localUniforms: new ht({
                uTransformMatrix: { value: new I(), type: "mat3x3<f32>" },
                uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
                uRound: { value: 0, type: "f32" },
              }),
              tilingUniforms: t,
              uTexture: k.EMPTY.source,
              uSampler: k.EMPTY.source.style,
            },
          })
        }
        updateUniforms(t, e, i, n, s, o) {
          let a = this.resources.tilingUniforms,
            u = o.width,
            l = o.height,
            c = o.textureMatrix,
            h = a.uniforms.uTextureTransform
          ;(h.set((i.a * u) / t, (i.b * u) / e, (i.c * l) / t, (i.d * l) / e, i.tx / t, i.ty / e),
            h.invert(),
            (a.uniforms.uMapCoord = c.mapCoord),
            (a.uniforms.uClampFrame = c.uClampFrame),
            (a.uniforms.uClampOffset = c.uClampOffset),
            (a.uniforms.uTextureTransform = h),
            (a.uniforms.uSizeAnchor[0] = t),
            (a.uniforms.uSizeAnchor[1] = e),
            (a.uniforms.uSizeAnchor[2] = n),
            (a.uniforms.uSizeAnchor[3] = s),
            o && ((this.resources.uTexture = o.source), (this.resources.uSampler = o.source.style)))
        }
      }
    })
  var $u,
    Vv = p(() => {
      Wu()
      $u = class extends cn {
        constructor() {
          super({
            positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            indices: new Uint32Array([0, 1, 2, 0, 2, 3]),
          })
        }
      }
    })
  function $v(r, t) {
    let e = r.anchor.x,
      i = r.anchor.y
    ;((t[0] = -e * r.width),
      (t[1] = -i * r.height),
      (t[2] = (1 - e) * r.width),
      (t[3] = -i * r.height),
      (t[4] = (1 - e) * r.width),
      (t[5] = (1 - i) * r.height),
      (t[6] = -e * r.width),
      (t[7] = (1 - i) * r.height))
  }
  var Xv = p(() => {
    "use strict"
  })
  function Yv(r, t, e, i) {
    let n = 0,
      s = r.length / (t || 2),
      o = i.a,
      a = i.b,
      u = i.c,
      l = i.d,
      c = i.tx,
      h = i.ty
    for (e *= t; n < s; ) {
      let f = r[e],
        d = r[e + 1]
      ;((r[e] = o * f + u * d + c), (r[e + 1] = a * f + l * d + h), (e += t), n++)
    }
  }
  var jv = p(() => {
    "use strict"
  })
  function Kv(r, t) {
    let e = r.texture,
      i = e.frame.width,
      n = e.frame.height,
      s = 0,
      o = 0
    ;(r.applyAnchorToTexture && ((s = r.anchor.x), (o = r.anchor.y)),
      (t[0] = t[6] = -s),
      (t[2] = t[4] = 1 - s),
      (t[1] = t[3] = -o),
      (t[5] = t[7] = 1 - o))
    let a = I.shared
    ;(a.copyFrom(r._tileTransform.matrix),
      (a.tx /= r.width),
      (a.ty /= r.height),
      a.invert(),
      a.scale(r.width / i, r.height / n),
      Yv(t, 2, 0, a))
  }
  var qv = p(() => {
    nt()
    jv()
  })
  var Xu,
    Lf,
    Ns,
    Zv = p(() => {
      A()
      xs()
      De()
      Le()
      Qi()
      yu()
      Wu()
      Wv()
      Vv()
      Xv()
      qv()
      ;((Xu = new $u()),
        (Lf = class {
          constructor() {
            ;((this.canBatch = !0),
              (this.geometry = new cn({
                indices: Xu.indices.slice(),
                positions: Xu.positions.slice(),
                uvs: Xu.uvs.slice(),
              })))
          }
          destroy() {
            ;(this.geometry.destroy(), this.shader?.destroy())
          }
        }),
        (Ns = class {
          constructor(t) {
            ;((this._state = Dt.default2d), (this._renderer = t))
          }
          validateRenderable(t) {
            let e = this._getTilingSpriteData(t),
              i = e.canBatch
            this._updateCanBatch(t)
            let n = e.canBatch
            if (n && n === i) {
              let { batchableMesh: s } = e
              return !s._batcher.checkAndUpdateTexture(s, t.texture)
            }
            return i !== n
          }
          addRenderable(t, e) {
            let i = this._renderer.renderPipes.batch
            this._updateCanBatch(t)
            let n = this._getTilingSpriteData(t),
              { geometry: s, canBatch: o } = n
            if (o) {
              n.batchableMesh || (n.batchableMesh = new Ar())
              let a = n.batchableMesh
              ;(t.didViewUpdate &&
                (this._updateBatchableMesh(t),
                (a.geometry = s),
                (a.renderable = t),
                (a.transform = t.groupTransform),
                a.setTexture(t._texture)),
                (a.roundPixels = this._renderer._roundPixels | t._roundPixels),
                i.addToBatch(a, e))
            } else
              (i.break(e), n.shader || (n.shader = new Vu()), this.updateRenderable(t), e.add(t))
          }
          execute(t) {
            let { shader: e } = this._getTilingSpriteData(t)
            e.groups[0] = this._renderer.globalUniforms.bindGroup
            let i = e.resources.localUniforms.uniforms
            ;((i.uTransformMatrix = t.groupTransform),
              (i.uRound = this._renderer._roundPixels | t._roundPixels),
              Ne(t.groupColorAlpha, i.uColor, 0),
              (this._state.blendMode = nr(t.groupBlendMode, t.texture._source)),
              this._renderer.encoder.draw({ geometry: Xu, shader: e, state: this._state }))
          }
          updateRenderable(t) {
            let e = this._getTilingSpriteData(t),
              { canBatch: i } = e
            if (i) {
              let { batchableMesh: n } = e
              ;(t.didViewUpdate && this._updateBatchableMesh(t), n._batcher.updateElement(n))
            } else if (t.didViewUpdate) {
              let { shader: n } = e
              n.updateUniforms(
                t.width,
                t.height,
                t._tileTransform.matrix,
                t.anchor.x,
                t.anchor.y,
                t.texture,
              )
            }
          }
          _getTilingSpriteData(t) {
            return t._gpuData[this._renderer.uid] || this._initTilingSpriteData(t)
          }
          _initTilingSpriteData(t) {
            let e = new Lf()
            return ((e.renderable = t), (t._gpuData[this._renderer.uid] = e), e)
          }
          _updateBatchableMesh(t) {
            let e = this._getTilingSpriteData(t),
              { geometry: i } = e,
              n = t.texture.source.style
            ;(n.addressMode !== "repeat" && ((n.addressMode = "repeat"), n.update()),
              Kv(t, i.uvs),
              $v(t, i.positions))
          }
          destroy() {
            this._renderer = null
          }
          _updateCanBatch(t) {
            let e = this._getTilingSpriteData(t),
              i = t.texture,
              n = !0
            return (
              this._renderer.type === Bt.WEBGL &&
                (n = this._renderer.context.supports.nonPowOf2wrapping),
              (e.canBatch = i.textureMatrix.isSimple && (n || i.source.isPowerOfTwo)),
              e.canBatch
            )
          }
        }))
      Ns.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "tilingSprite" }
    })
  var Nf = p(() => {
    A()
    Zv()
    L.add(Ns)
  })
  var Qv,
    tS,
    eS = p(() => {
      gt()
      Wu()
      Qv = class Jv extends cn {
        constructor(...t) {
          super({})
          let e = t[0] ?? {}
          ;(typeof e == "number" &&
            (z(
              K,
              "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead",
            ),
            (e = { width: e, height: t[1], verticesX: t[2], verticesY: t[3] })),
            this.build(e))
        }
        build(t) {
          ;((t = { ...Jv.defaultOptions, ...t }),
            (this.verticesX = this.verticesX ?? t.verticesX),
            (this.verticesY = this.verticesY ?? t.verticesY),
            (this.width = this.width ?? t.width),
            (this.height = this.height ?? t.height))
          let e = this.verticesX * this.verticesY,
            i = [],
            n = [],
            s = [],
            o = this.verticesX - 1,
            a = this.verticesY - 1,
            u = this.width / o,
            l = this.height / a
          for (let h = 0; h < e; h++) {
            let f = h % this.verticesX,
              d = (h / this.verticesX) | 0
            ;(i.push(f * u, d * l), n.push(f / o, d / a))
          }
          let c = o * a
          for (let h = 0; h < c; h++) {
            let f = h % o,
              d = (h / o) | 0,
              g = d * this.verticesX + f,
              x = d * this.verticesX + f + 1,
              m = (d + 1) * this.verticesX + f,
              _ = (d + 1) * this.verticesX + f + 1
            s.push(g, x, m, x, _, m)
          }
          ;((this.buffers[0].data = new Float32Array(i)),
            (this.buffers[1].data = new Float32Array(n)),
            (this.indexBuffer.data = new Uint32Array(s)),
            this.buffers[0].update(),
            this.buffers[1].update(),
            this.indexBuffer.update())
        }
      }
      Qv.defaultOptions = { width: 100, height: 100, verticesX: 10, verticesY: 10 }
      tS = Qv
    })
  var rS,
    nS,
    sS = p(() => {
      eS()
      rS = class iS extends tS {
        constructor(t = {}) {
          ;((t = { ...iS.defaultOptions, ...t }),
            super({ width: t.width, height: t.height, verticesX: 4, verticesY: 4 }),
            this.update(t))
        }
        update(t) {
          ;((this.width = t.width ?? this.width),
            (this.height = t.height ?? this.height),
            (this._originalWidth = t.originalWidth ?? this._originalWidth),
            (this._originalHeight = t.originalHeight ?? this._originalHeight),
            (this._leftWidth = t.leftWidth ?? this._leftWidth),
            (this._rightWidth = t.rightWidth ?? this._rightWidth),
            (this._topHeight = t.topHeight ?? this._topHeight),
            (this._bottomHeight = t.bottomHeight ?? this._bottomHeight),
            (this._anchorX = t.anchor?.x),
            (this._anchorY = t.anchor?.y),
            this.updateUvs(),
            this.updatePositions())
        }
        updatePositions() {
          let t = this.positions,
            {
              width: e,
              height: i,
              _leftWidth: n,
              _rightWidth: s,
              _topHeight: o,
              _bottomHeight: a,
              _anchorX: u,
              _anchorY: l,
            } = this,
            c = n + s,
            h = e > c ? 1 : e / c,
            f = o + a,
            d = i > f ? 1 : i / f,
            g = Math.min(h, d),
            x = u * e,
            m = l * i
          ;((t[0] = t[8] = t[16] = t[24] = -x),
            (t[2] = t[10] = t[18] = t[26] = n * g - x),
            (t[4] = t[12] = t[20] = t[28] = e - s * g - x),
            (t[6] = t[14] = t[22] = t[30] = e - x),
            (t[1] = t[3] = t[5] = t[7] = -m),
            (t[9] = t[11] = t[13] = t[15] = o * g - m),
            (t[17] = t[19] = t[21] = t[23] = i - a * g - m),
            (t[25] = t[27] = t[29] = t[31] = i - m),
            this.getBuffer("aPosition").update())
        }
        updateUvs() {
          let t = this.uvs
          ;((t[0] = t[8] = t[16] = t[24] = 0),
            (t[1] = t[3] = t[5] = t[7] = 0),
            (t[6] = t[14] = t[22] = t[30] = 1),
            (t[25] = t[27] = t[29] = t[31] = 1))
          let e = 1 / this._originalWidth,
            i = 1 / this._originalHeight
          ;((t[2] = t[10] = t[18] = t[26] = e * this._leftWidth),
            (t[9] = t[11] = t[13] = t[15] = i * this._topHeight),
            (t[4] = t[12] = t[20] = t[28] = 1 - e * this._rightWidth),
            (t[17] = t[19] = t[21] = t[23] = 1 - i * this._bottomHeight),
            this.getBuffer("aUV").update())
        }
      }
      rS.defaultOptions = {
        width: 100,
        height: 100,
        leftWidth: 10,
        topHeight: 10,
        rightWidth: 10,
        bottomHeight: 10,
        originalWidth: 100,
        originalHeight: 100,
      }
      nS = rS
    })
  var Hf,
    Hs,
    oS = p(() => {
      A()
      yu()
      sS()
      ;((Hf = class extends Ar {
        constructor() {
          ;(super(), (this.geometry = new nS()))
        }
        destroy() {
          this.geometry.destroy()
        }
      }),
        (Hs = class {
          constructor(t) {
            this._renderer = t
          }
          addRenderable(t, e) {
            let i = this._getGpuSprite(t)
            ;(t.didViewUpdate && this._updateBatchableSprite(t, i),
              this._renderer.renderPipes.batch.addToBatch(i, e))
          }
          updateRenderable(t) {
            let e = this._getGpuSprite(t)
            ;(t.didViewUpdate && this._updateBatchableSprite(t, e), e._batcher.updateElement(e))
          }
          validateRenderable(t) {
            let e = this._getGpuSprite(t)
            return !e._batcher.checkAndUpdateTexture(e, t._texture)
          }
          _updateBatchableSprite(t, e) {
            ;(e.geometry.update(t), e.setTexture(t._texture))
          }
          _getGpuSprite(t) {
            return t._gpuData[this._renderer.uid] || this._initGPUSprite(t)
          }
          _initGPUSprite(t) {
            let e = (t._gpuData[this._renderer.uid] = new Hf()),
              i = e
            return (
              (i.renderable = t),
              (i.transform = t.groupTransform),
              (i.texture = t._texture),
              (i.roundPixels = this._renderer._roundPixels | t._roundPixels),
              t.didViewUpdate || this._updateBatchableSprite(t, i),
              e
            )
          }
          destroy() {
            this._renderer = null
          }
        }))
      Hs.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "nineSliceSprite" }
    })
  var zf = p(() => {
    A()
    oS()
    L.add(Hs)
  })
  var zs,
    aS = p(() => {
      A()
      zs = class {
        constructor(t) {
          this._renderer = t
        }
        push(t, e, i) {
          ;(this._renderer.renderPipes.batch.break(i),
            i.add({
              renderPipeId: "filter",
              canBundle: !1,
              action: "pushFilter",
              container: e,
              filterEffect: t,
            }))
        }
        pop(t, e, i) {
          ;(this._renderer.renderPipes.batch.break(i),
            i.add({ renderPipeId: "filter", action: "popFilter", canBundle: !1 }))
        }
        execute(t) {
          t.action === "pushFilter"
            ? this._renderer.filter.push(t)
            : t.action === "popFilter" && this._renderer.filter.pop()
        }
        destroy() {
          this._renderer = null
        }
      }
      zs.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "filter" }
    })
  function uS(r, t) {
    t.clear()
    let e = t.matrix
    for (let i = 0; i < r.length; i++) {
      let n = r[i]
      n.globalDisplayStatus < 7 || ((t.matrix = n.worldTransform), t.addBounds(n.bounds))
    }
    return ((t.matrix = e), t)
  }
  var lS = p(() => {
    "use strict"
  })
  var XD,
    Wf,
    Ws,
    cS = p(() => {
      A()
      nt()
      Tr()
      Ni()
      re()
      dt()
      _r()
      Le()
      se()
      lS()
      ft()
      ;((XD = new _e({
        attributes: {
          aPosition: {
            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            format: "float32x2",
            stride: 8,
            offset: 0,
          },
        },
        indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]),
      })),
        (Wf = class {
          constructor() {
            ;((this.skip = !1),
              (this.inputTexture = null),
              (this.backTexture = null),
              (this.filters = null),
              (this.bounds = new ct()),
              (this.container = null),
              (this.blendRequired = !1),
              (this.outputRenderSurface = null),
              (this.globalFrame = { x: 0, y: 0, width: 0, height: 0 }))
          }
        }),
        (Ws = class {
          constructor(t) {
            ;((this._filterStackIndex = 0),
              (this._filterStack = []),
              (this._filterGlobalUniforms = new ht({
                uInputSize: { value: new Float32Array(4), type: "vec4<f32>" },
                uInputPixel: { value: new Float32Array(4), type: "vec4<f32>" },
                uInputClamp: { value: new Float32Array(4), type: "vec4<f32>" },
                uOutputFrame: { value: new Float32Array(4), type: "vec4<f32>" },
                uGlobalFrame: { value: new Float32Array(4), type: "vec4<f32>" },
                uOutputTexture: { value: new Float32Array(4), type: "vec4<f32>" },
              })),
              (this._globalFilterBindGroup = new Nt({})),
              (this.renderer = t))
          }
          get activeBackTexture() {
            return this._activeFilterData?.backTexture
          }
          push(t) {
            let e = this.renderer,
              i = t.filterEffect.filters,
              n = this._pushFilterData()
            ;((n.skip = !1),
              (n.filters = i),
              (n.container = t.container),
              (n.outputRenderSurface = e.renderTarget.renderSurface))
            let s = e.renderTarget.renderTarget.colorTexture.source,
              o = s.resolution,
              a = s.antialias
            if (i.length === 0) {
              n.skip = !0
              return
            }
            let u = n.bounds
            if (
              (this._calculateFilterArea(t, u),
              this._calculateFilterBounds(n, e.renderTarget.rootViewPort, a, o, 1),
              n.skip)
            )
              return
            let l = this._getPreviousFilterData(),
              c = this._findFilterResolution(o),
              h = 0,
              f = 0
            ;(l && ((h = l.bounds.minX), (f = l.bounds.minY)),
              this._calculateGlobalFrame(n, h, f, c, s.width, s.height),
              this._setupFilterTextures(n, u, e, l))
          }
          generateFilteredTexture({ texture: t, filters: e }) {
            let i = this._pushFilterData()
            ;((this._activeFilterData = i), (i.skip = !1), (i.filters = e))
            let n = t.source,
              s = n.resolution,
              o = n.antialias
            if (e.length === 0) return ((i.skip = !0), t)
            let a = i.bounds
            if ((a.addRect(t.frame), this._calculateFilterBounds(i, a.rectangle, o, s, 0), i.skip))
              return t
            let u = s
            ;(this._calculateGlobalFrame(i, 0, 0, u, n.width, n.height),
              (i.outputRenderSurface = St.getOptimalTexture(
                a.width,
                a.height,
                i.resolution,
                i.antialias,
              )),
              (i.backTexture = k.EMPTY),
              (i.inputTexture = t),
              this.renderer.renderTarget.finishRenderPass(),
              this._applyFiltersToTexture(i, !0))
            let f = i.outputRenderSurface
            return ((f.source.alphaMode = "premultiplied-alpha"), f)
          }
          pop() {
            let t = this.renderer,
              e = this._popFilterData()
            e.skip ||
              (t.globalUniforms.pop(),
              t.renderTarget.finishRenderPass(),
              (this._activeFilterData = e),
              this._applyFiltersToTexture(e, !1),
              e.blendRequired && St.returnTexture(e.backTexture),
              St.returnTexture(e.inputTexture))
          }
          getBackTexture(t, e, i) {
            let n = t.colorTexture.source._resolution,
              s = St.getOptimalTexture(e.width, e.height, n, !1),
              o = e.minX,
              a = e.minY
            ;(i && ((o -= i.minX), (a -= i.minY)), (o = Math.floor(o * n)), (a = Math.floor(a * n)))
            let u = Math.ceil(e.width * n),
              l = Math.ceil(e.height * n)
            return (
              this.renderer.renderTarget.copyToTexture(
                t,
                s,
                { x: o, y: a },
                { width: u, height: l },
                { x: 0, y: 0 },
              ),
              s
            )
          }
          applyFilter(t, e, i, n) {
            let s = this.renderer,
              o = this._activeFilterData,
              u = o.outputRenderSurface === i,
              l = s.renderTarget.rootRenderTarget.colorTexture.source._resolution,
              c = this._findFilterResolution(l),
              h = 0,
              f = 0
            if (u) {
              let d = this._findPreviousFilterOffset()
              ;((h = d.x), (f = d.y))
            }
            ;(this._updateFilterUniforms(e, i, o, h, f, c, u, n),
              this._setupBindGroupsAndRender(t, e, s))
          }
          calculateSpriteMatrix(t, e) {
            let i = this._activeFilterData,
              n = t.set(
                i.inputTexture._source.width,
                0,
                0,
                i.inputTexture._source.height,
                i.bounds.minX,
                i.bounds.minY,
              ),
              s = e.worldTransform.copyTo(I.shared),
              o = e.renderGroup || e.parentRenderGroup
            return (
              o && o.cacheToLocalTransform && s.prepend(o.cacheToLocalTransform),
              s.invert(),
              n.prepend(s),
              n.scale(1 / e.texture.frame.width, 1 / e.texture.frame.height),
              n.translate(e.anchor.x, e.anchor.y),
              n
            )
          }
          destroy() {}
          _setupBindGroupsAndRender(t, e, i) {
            if (i.renderPipes.uniformBatch) {
              let n = i.renderPipes.uniformBatch.getUboResource(this._filterGlobalUniforms)
              this._globalFilterBindGroup.setResource(n, 0)
            } else this._globalFilterBindGroup.setResource(this._filterGlobalUniforms, 0)
            ;(this._globalFilterBindGroup.setResource(e.source, 1),
              this._globalFilterBindGroup.setResource(e.source.style, 2),
              (t.groups[0] = this._globalFilterBindGroup),
              i.encoder.draw({
                geometry: XD,
                shader: t,
                state: t._state,
                topology: "triangle-list",
              }),
              i.type === Bt.WEBGL && i.renderTarget.finishRenderPass())
          }
          _setupFilterTextures(t, e, i, n) {
            if (((t.backTexture = k.EMPTY), t.blendRequired)) {
              i.renderTarget.finishRenderPass()
              let s = i.renderTarget.getRenderTarget(t.outputRenderSurface)
              t.backTexture = this.getBackTexture(s, e, n?.bounds)
            }
            ;((t.inputTexture = St.getOptimalTexture(e.width, e.height, t.resolution, t.antialias)),
              i.renderTarget.bind(t.inputTexture, !0),
              i.globalUniforms.push({ offset: e }))
          }
          _calculateGlobalFrame(t, e, i, n, s, o) {
            let a = t.globalFrame
            ;((a.x = e * n), (a.y = i * n), (a.width = s * n), (a.height = o * n))
          }
          _updateFilterUniforms(t, e, i, n, s, o, a, u) {
            let l = this._filterGlobalUniforms.uniforms,
              c = l.uOutputFrame,
              h = l.uInputSize,
              f = l.uInputPixel,
              d = l.uInputClamp,
              g = l.uGlobalFrame,
              x = l.uOutputTexture
            ;(a
              ? ((c[0] = i.bounds.minX - n), (c[1] = i.bounds.minY - s))
              : ((c[0] = 0), (c[1] = 0)),
              (c[2] = t.frame.width),
              (c[3] = t.frame.height),
              (h[0] = t.source.width),
              (h[1] = t.source.height),
              (h[2] = 1 / h[0]),
              (h[3] = 1 / h[1]),
              (f[0] = t.source.pixelWidth),
              (f[1] = t.source.pixelHeight),
              (f[2] = 1 / f[0]),
              (f[3] = 1 / f[1]),
              (d[0] = 0.5 * f[2]),
              (d[1] = 0.5 * f[3]),
              (d[2] = t.frame.width * h[2] - 0.5 * f[2]),
              (d[3] = t.frame.height * h[3] - 0.5 * f[3]))
            let m = this.renderer.renderTarget.rootRenderTarget.colorTexture
            ;((g[0] = n * o),
              (g[1] = s * o),
              (g[2] = m.source.width * o),
              (g[3] = m.source.height * o),
              e instanceof k && (e.source.resource = null))
            let _ = this.renderer.renderTarget.getRenderTarget(e)
            ;(this.renderer.renderTarget.bind(e, !!u),
              e instanceof k
                ? ((x[0] = e.frame.width), (x[1] = e.frame.height))
                : ((x[0] = _.width), (x[1] = _.height)),
              (x[2] = _.isRoot ? -1 : 1),
              this._filterGlobalUniforms.update())
          }
          _findFilterResolution(t) {
            let e = this._filterStackIndex - 1
            for (; e > 0 && this._filterStack[e].skip; ) --e
            return e > 0 && this._filterStack[e].inputTexture
              ? this._filterStack[e].inputTexture.source._resolution
              : t
          }
          _findPreviousFilterOffset() {
            let t = 0,
              e = 0,
              i = this._filterStackIndex
            for (; i > 0; ) {
              i--
              let n = this._filterStack[i]
              if (!n.skip) {
                ;((t = n.bounds.minX), (e = n.bounds.minY))
                break
              }
            }
            return { x: t, y: e }
          }
          _calculateFilterArea(t, e) {
            if (
              (t.renderables
                ? uS(t.renderables, e)
                : t.filterEffect.filterArea
                  ? (e.clear(),
                    e.addRect(t.filterEffect.filterArea),
                    e.applyMatrix(t.container.worldTransform))
                  : t.container.getFastGlobalBounds(!0, e),
              t.container)
            ) {
              let n = (t.container.renderGroup || t.container.parentRenderGroup)
                .cacheToLocalTransform
              n && e.applyMatrix(n)
            }
          }
          _applyFiltersToTexture(t, e) {
            let i = t.inputTexture,
              n = t.bounds,
              s = t.filters
            if (
              (this._globalFilterBindGroup.setResource(i.source.style, 2),
              this._globalFilterBindGroup.setResource(t.backTexture.source, 3),
              s.length === 1)
            )
              s[0].apply(this, i, t.outputRenderSurface, e)
            else {
              let o = t.inputTexture,
                a = St.getOptimalTexture(n.width, n.height, o.source._resolution, !1),
                u = a,
                l = 0
              for (l = 0; l < s.length - 1; ++l) {
                s[l].apply(this, o, u, !0)
                let h = o
                ;((o = u), (u = h))
              }
              ;(s[l].apply(this, o, t.outputRenderSurface, e), St.returnTexture(a))
            }
          }
          _calculateFilterBounds(t, e, i, n, s) {
            let o = this.renderer,
              a = t.bounds,
              u = t.filters,
              l = 1 / 0,
              c = 0,
              h = !0,
              f = !1,
              d = !1,
              g = !0
            for (let x = 0; x < u.length; x++) {
              let m = u[x]
              if (
                ((l = Math.min(l, m.resolution === "inherit" ? n : m.resolution)),
                (c += m.padding),
                m.antialias === "off" ? (h = !1) : m.antialias === "inherit" && h && (h = i),
                m.clipToViewport || (g = !1),
                !!!(m.compatibleRenderers & o.type))
              ) {
                d = !1
                break
              }
              if (m.blendRequired && !(o.backBuffer?.useBackBuffer ?? !0)) {
                ;(N(
                  "Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.",
                ),
                  (d = !1))
                break
              }
              ;((d = m.enabled || d), f || (f = m.blendRequired))
            }
            if (!d) {
              t.skip = !0
              return
            }
            if (
              (g && a.fitBounds(0, e.width / n, 0, e.height / n),
              a
                .scale(l)
                .ceil()
                .scale(1 / l)
                .pad((c | 0) * s),
              !a.isPositive)
            ) {
              t.skip = !0
              return
            }
            ;((t.antialias = h), (t.resolution = l), (t.blendRequired = f))
          }
          _popFilterData() {
            return (this._filterStackIndex--, this._filterStack[this._filterStackIndex])
          }
          _getPreviousFilterData() {
            let t,
              e = this._filterStackIndex - 1
            for (; e > 1 && (e--, (t = this._filterStack[e]), !!t.skip); );
            return t
          }
          _pushFilterData() {
            let t = this._filterStack[this._filterStackIndex]
            return (
              t || (t = this._filterStack[this._filterStackIndex] = new Wf()),
              this._filterStackIndex++,
              t
            )
          }
        }))
      Ws.extension = { type: [b.WebGLSystem, b.WebGPUSystem], name: "filter" }
    })
  var Vf = p(() => {
    A()
    aS()
    cS()
    L.add(Ws)
    L.add(zs)
  })
  var YD = {}
  var hS = p(() => {
    Xx()
    Lc()
    t_()
    r_()
    qa()
    ru()
    jh()
    Kh()
    Jh()
    Ef()
    Bf()
    Gf()
    Nf()
    zf()
    Vf()
  })
  var jD = {}
  var dS = p(() => {
    Lc()
    qa()
    ru()
    jh()
    Kh()
    Jh()
    Ef()
    Bf()
    Gf()
    Nf()
    zf()
    Vf()
  })
  var mS,
    gS,
    xS = p(() => {
      oi()
      zi()
      Ae()
      De()
      mS = class $f extends Mt {
        constructor(t) {
          ;((t = { ...$f.defaultOptions, ...t }),
            super(t),
            (this.enabled = !0),
            (this._state = Dt.for2d()),
            (this.blendMode = t.blendMode),
            (this.padding = t.padding),
            typeof t.antialias == "boolean"
              ? (this.antialias = t.antialias ? "on" : "off")
              : (this.antialias = t.antialias),
            (this.resolution = t.resolution),
            (this.blendRequired = t.blendRequired),
            (this.clipToViewport = t.clipToViewport),
            this.addResource("uTexture", 0, 1))
        }
        apply(t, e, i, n) {
          t.applyFilter(this, e, i, n)
        }
        get blendMode() {
          return this._state.blendMode
        }
        set blendMode(t) {
          this._state.blendMode = t
        }
        static from(t) {
          let { gpu: e, gl: i, ...n } = t,
            s,
            o
          return (
            e && (s = be.from(e)),
            i && (o = ye.from(i)),
            new $f({ gpuProgram: s, glProgram: o, ...n })
          )
        }
      }
      mS.defaultOptions = {
        blendMode: "normal",
        resolution: 1,
        padding: 0,
        antialias: "off",
        blendRequired: !1,
        clipToViewport: !0,
      }
      gS = mS
    })
  async function _S(r) {
    if (!r)
      for (let t = 0; t < Xf.length; t++) {
        let e = Xf[t]
        if (e.value.test()) {
          await e.value.load()
          return
        }
      }
  }
  var Xf,
    yS = p(() => {
      A()
      Xf = []
      L.handleByNamedList(b.Environment, Xf)
    })
  function Yu() {
    if (typeof Vs == "boolean") return Vs
    try {
      Vs =
        new Function("param1", "param2", "param3", "return param1[param2] === param3;")(
          { a: "b" },
          "a",
          "b",
        ) === !0
    } catch {
      Vs = !1
    }
    return Vs
  }
  var Vs,
    Yf = p(() => {
      "use strict"
    })
  var Ht,
    dn = p(() => {
      "use strict"
      Ht = ((r) => (
        (r[(r.NONE = 0)] = "NONE"),
        (r[(r.COLOR = 16384)] = "COLOR"),
        (r[(r.STENCIL = 1024)] = "STENCIL"),
        (r[(r.DEPTH = 256)] = "DEPTH"),
        (r[(r.COLOR_DEPTH = 16640)] = "COLOR_DEPTH"),
        (r[(r.COLOR_STENCIL = 17408)] = "COLOR_STENCIL"),
        (r[(r.DEPTH_STENCIL = 1280)] = "DEPTH_STENCIL"),
        (r[(r.ALL = 17664)] = "ALL"),
        r
      ))(Ht || {})
    })
  var pn,
    jf = p(() => {
      "use strict"
      pn = class {
        constructor(t) {
          ;((this.items = []), (this._name = t))
        }
        emit(t, e, i, n, s, o, a, u) {
          let { name: l, items: c } = this
          for (let h = 0, f = c.length; h < f; h++) c[h][l](t, e, i, n, s, o, a, u)
          return this
        }
        add(t) {
          return (t[this._name] && (this.remove(t), this.items.push(t)), this)
        }
        remove(t) {
          let e = this.items.indexOf(t)
          return (e !== -1 && this.items.splice(e, 1), this)
        }
        contains(t) {
          return this.items.indexOf(t) !== -1
        }
        removeAll() {
          return ((this.items.length = 0), this)
        }
        destroy() {
          ;(this.removeAll(), (this.items = null), (this._name = null))
        }
        get empty() {
          return this.items.length === 0
        }
        get name() {
          return this._name
        }
      }
    })
  var KD,
    bS,
    Fr,
    $s = p(() => {
      Vt()
      yS()
      we()
      Yf()
      Ot()
      gt()
      dn()
      jf()
      Wt()
      ;((KD = [
        "init",
        "destroy",
        "contextChange",
        "resolutionChange",
        "resetState",
        "renderEnd",
        "renderStart",
        "render",
        "update",
        "postrender",
        "prerender",
      ]),
        (bS = class vS extends lt {
          constructor(t) {
            ;(super(),
              (this.uid = J("renderer")),
              (this.runners = Object.create(null)),
              (this.renderPipes = Object.create(null)),
              (this._initOptions = {}),
              (this._systemsHash = Object.create(null)),
              (this.type = t.type),
              (this.name = t.name),
              (this.config = t))
            let e = [...KD, ...(this.config.runners ?? [])]
            ;(this._addRunners(...e), this._unsafeEvalCheck())
          }
          async init(t = {}) {
            let e = t.skipExtensionImports === !0 ? !0 : t.manageImports === !1
            ;(await _S(e),
              this._addSystems(this.config.systems),
              this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors))
            for (let i in this._systemsHash)
              t = { ...this._systemsHash[i].constructor.defaultOptions, ...t }
            ;((t = { ...vS.defaultOptions, ...t }), (this._roundPixels = t.roundPixels ? 1 : 0))
            for (let i = 0; i < this.runners.init.items.length; i++)
              await this.runners.init.items[i].init(t)
            this._initOptions = t
          }
          render(t, e) {
            let i = t
            if (
              (i instanceof pt &&
                ((i = { container: i }),
                e &&
                  (z(
                    K,
                    "passing a second argument is deprecated, please use render options instead",
                  ),
                  (i.target = e.renderTexture))),
              i.target || (i.target = this.view.renderTarget),
              i.target === this.view.renderTarget &&
                ((this._lastObjectRendered = i.container),
                i.clearColor ?? (i.clearColor = this.background.colorRgba),
                i.clear ?? (i.clear = this.background.clearBeforeRender)),
              i.clearColor)
            ) {
              let n = Array.isArray(i.clearColor) && i.clearColor.length === 4
              i.clearColor = n ? i.clearColor : q.shared.setValue(i.clearColor).toArray()
            }
            ;(i.transform ||
              (i.container.updateLocalTransform(), (i.transform = i.container.localTransform)),
              i.container.enableRenderGroup(),
              this.runners.prerender.emit(i),
              this.runners.renderStart.emit(i),
              this.runners.render.emit(i),
              this.runners.renderEnd.emit(i),
              this.runners.postrender.emit(i))
          }
          resize(t, e, i) {
            let n = this.view.resolution
            ;(this.view.resize(t, e, i),
              this.emit(
                "resize",
                this.view.screen.width,
                this.view.screen.height,
                this.view.resolution,
              ),
              i !== void 0 && i !== n && this.runners.resolutionChange.emit(i))
          }
          clear(t = {}) {
            let e = this
            ;(t.target || (t.target = e.renderTarget.renderTarget),
              t.clearColor || (t.clearColor = this.background.colorRgba),
              t.clear ?? (t.clear = Ht.ALL))
            let { clear: i, clearColor: n, target: s } = t
            ;(q.shared.setValue(n ?? this.background.colorRgba),
              e.renderTarget.clear(s, i, q.shared.toArray()))
          }
          get resolution() {
            return this.view.resolution
          }
          set resolution(t) {
            ;((this.view.resolution = t), this.runners.resolutionChange.emit(t))
          }
          get width() {
            return this.view.texture.frame.width
          }
          get height() {
            return this.view.texture.frame.height
          }
          get canvas() {
            return this.view.canvas
          }
          get lastObjectRendered() {
            return this._lastObjectRendered
          }
          get renderingToScreen() {
            return this.renderTarget.renderingToScreen
          }
          get screen() {
            return this.view.screen
          }
          _addRunners(...t) {
            t.forEach((e) => {
              this.runners[e] = new pn(e)
            })
          }
          _addSystems(t) {
            let e
            for (e in t) {
              let i = t[e]
              this._addSystem(i.value, i.name)
            }
          }
          _addSystem(t, e) {
            let i = new t(this)
            if (this[e]) throw new Error(`Whoops! The name "${e}" is already in use`)
            ;((this[e] = i), (this._systemsHash[e] = i))
            for (let n in this.runners) this.runners[n].add(i)
            return this
          }
          _addPipes(t, e) {
            let i = e.reduce((n, s) => ((n[s.name] = s.value), n), {})
            t.forEach((n) => {
              let s = n.value,
                o = n.name,
                a = i[o]
              this.renderPipes[o] = new s(this, a ? new a() : null)
            })
          }
          destroy(t = !1) {
            ;(this.runners.destroy.items.reverse(),
              this.runners.destroy.emit(t),
              Object.values(this.runners).forEach((e) => {
                e.destroy()
              }),
              (this._systemsHash = null),
              (this.renderPipes = null))
          }
          generateTexture(t) {
            return this.textureGenerator.generateTexture(t)
          }
          get roundPixels() {
            return !!this._roundPixels
          }
          _unsafeEvalCheck() {
            if (!Yu())
              throw new Error(
                "Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.",
              )
          }
          resetState() {
            this.runners.resetState.emit()
          }
        }))
      bS.defaultOptions = { resolution: 1, failIfMajorPerformanceCaveat: !1, roundPixels: !1 }
      Fr = bS
    })
  var Xs,
    CS = p(() => {
      A()
      nt()
      iu()
      wr()
      bs()
      vs()
      fn()
      Mr()
      Ae()
      re()
      Xs = class {
        constructor() {
          this._maxTextures = 0
        }
        contextChange(t) {
          let e = new ht({
            uTransformMatrix: { value: new I(), type: "mat3x3<f32>" },
            uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
            uRound: { value: 0, type: "f32" },
          })
          this._maxTextures = t.limits.maxBatchableTextures
          let i = ke({ name: "graphics", bits: [Wi, $i(this._maxTextures), Lv, Ue] })
          this.shader = new Mt({ gpuProgram: i, resources: { localUniforms: e } })
        }
        execute(t, e) {
          let i = e.context,
            n = i.customShader || this.shader,
            s = t.renderer,
            o = s.graphicsContext,
            { batcher: a, instructions: u } = o.getContextRenderData(i),
            l = s.encoder
          l.setGeometry(a.geometry, n.gpuProgram)
          let c = s.globalUniforms.bindGroup
          l.setBindGroup(0, c, n.gpuProgram)
          let h = s.renderPipes.uniformBatch.getUniformBindGroup(n.resources.localUniforms, !0)
          l.setBindGroup(2, h, n.gpuProgram)
          let f = u.instructions,
            d = null
          for (let g = 0; g < u.instructionSize; g++) {
            let x = f[g]
            if (
              (x.topology !== d &&
                ((d = x.topology),
                l.setPipelineFromGeometryProgramAndState(
                  a.geometry,
                  n.gpuProgram,
                  t.state,
                  x.topology,
                )),
              (n.groups[1] = x.bindGroup),
              !x.gpuBindGroup)
            ) {
              let m = x.textures
              ;((x.bindGroup = Oi(m.textures, m.count, this._maxTextures)),
                (x.gpuBindGroup = s.bindGroup.getBindGroup(x.bindGroup, n.gpuProgram, 1)))
            }
            ;(l.setBindGroup(1, x.bindGroup, n.gpuProgram),
              l.renderPassEncoder.drawIndexed(x.size, 1, x.start))
          }
        }
        destroy() {
          ;(this.shader.destroy(!0), (this.shader = null))
        }
      }
      Xs.extension = { type: [b.WebGPUPipesAdaptor], name: "graphics" }
    })
  var ES,
    wS,
    Kf = p(() => {
      "use strict"
      ;((ES = {
        name: "texture-bit",
        vertex: {
          header: `

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `,
          main: `
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `,
        },
        fragment: {
          header: `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;


        `,
          main: `
            outColor = textureSample(uTexture, uSampler, vUV);
        `,
        },
      }),
        (wS = {
          name: "texture-bit",
          vertex: {
            header: `
            uniform mat3 uTextureMatrix;
        `,
            main: `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `,
          },
          fragment: {
            header: `
        uniform sampler2D uTexture;


        `,
            main: `
            outColor = texture(uTexture, vUV);
        `,
          },
        }))
    })
  var Ys,
    MS = p(() => {
      A()
      nt()
      wr()
      fn()
      Mr()
      Kf()
      Ae()
      dt()
      ft()
      Ys = class {
        init() {
          let t = ke({ name: "mesh", bits: [gi, ES, Ue] })
          this._shader = new Mt({
            gpuProgram: t,
            resources: {
              uTexture: k.EMPTY._source,
              uSampler: k.EMPTY._source.style,
              textureUniforms: { uTextureMatrix: { type: "mat3x3<f32>", value: new I() } },
            },
          })
        }
        execute(t, e) {
          let i = t.renderer,
            n = e._shader
          if (!n) ((n = this._shader), (n.groups[2] = i.texture.getTextureBindGroup(e.texture)))
          else if (!n.gpuProgram) {
            N("Mesh shader has no gpuProgram", e.shader)
            return
          }
          let s = n.gpuProgram
          if (
            (s.autoAssignGlobalUniforms && (n.groups[0] = i.globalUniforms.bindGroup),
            s.autoAssignLocalUniforms)
          ) {
            let o = t.localUniforms
            n.groups[1] = i.renderPipes.uniformBatch.getUniformBindGroup(o, !0)
          }
          i.encoder.draw({ geometry: e._geometry, shader: n, state: e.state })
        }
        destroy() {
          ;(this._shader.destroy(!0), (this._shader = null))
        }
      }
      Ys.extension = { type: [b.WebGPUPipesAdaptor], name: "mesh" }
    })
  var qu,
    js,
    AS = p(() => {
      A()
      De()
      iu()
      ;((qu = Dt.for2d()),
        (js = class {
          start(t, e, i) {
            let n = t.renderer,
              s = n.encoder,
              o = i.gpuProgram
            ;((this._shader = i),
              (this._geometry = e),
              s.setGeometry(e, o),
              (qu.blendMode = "normal"),
              n.pipeline.getPipeline(e, o, qu))
            let a = n.globalUniforms.bindGroup
            ;(s.resetBindGroup(1), s.setBindGroup(0, a, o))
          }
          execute(t, e) {
            let i = this._shader.gpuProgram,
              n = t.renderer,
              s = n.encoder
            if (!e.bindGroup) {
              let u = e.textures
              e.bindGroup = Oi(u.textures, u.count, n.limits.maxBatchableTextures)
            }
            qu.blendMode = e.blendMode
            let o = n.bindGroup.getBindGroup(e.bindGroup, i, 1),
              a = n.pipeline.getPipeline(this._geometry, i, qu, e.topology)
            ;(e.bindGroup._touch(n.textureGC.count),
              s.setPipeline(a),
              s.renderPassEncoder.setBindGroup(1, o),
              s.renderPassEncoder.drawIndexed(e.size, 1, e.start))
          }
        }))
      js.extension = { type: [b.WebGPUPipesAdaptor], name: "batch" }
    })
  var Ks,
    DS = p(() => {
      A()
      Ks = class {
        constructor(t) {
          this._renderer = t
        }
        updateRenderable() {}
        destroyRenderable() {}
        validateRenderable() {
          return !1
        }
        addRenderable(t, e) {
          ;(this._renderer.renderPipes.batch.break(e), e.add(t))
        }
        execute(t) {
          t.isRenderable && t.render(this._renderer)
        }
        destroy() {
          this._renderer = null
        }
      }
      Ks.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "customRender" }
    })
  function qs(r, t) {
    let e = r.instructionSet,
      i = e.instructions
    for (let n = 0; n < e.instructionSize; n++) {
      let s = i[n]
      t[s.renderPipeId].execute(s)
    }
  }
  var qf = p(() => {
    "use strict"
  })
  var qD,
    Zs,
    PS = p(() => {
      A()
      nt()
      Je()
      Rs()
      qf()
      ;((qD = new I()),
        (Zs = class {
          constructor(t) {
            this._renderer = t
          }
          addRenderGroup(t, e) {
            t.isCachedAsTexture
              ? this._addRenderableCacheAsTexture(t, e)
              : this._addRenderableDirect(t, e)
          }
          execute(t) {
            t.isRenderable &&
              (t.isCachedAsTexture ? this._executeCacheAsTexture(t) : this._executeDirect(t))
          }
          destroy() {
            this._renderer = null
          }
          _addRenderableDirect(t, e) {
            ;(this._renderer.renderPipes.batch.break(e),
              t._batchableRenderGroup &&
                (xt.return(t._batchableRenderGroup), (t._batchableRenderGroup = null)),
              e.add(t))
          }
          _addRenderableCacheAsTexture(t, e) {
            let i = t._batchableRenderGroup ?? (t._batchableRenderGroup = xt.get(He))
            ;((i.renderable = t.root),
              (i.transform = t.root.relativeGroupTransform),
              (i.texture = t.texture),
              (i.bounds = t._textureBounds),
              e.add(t),
              this._renderer.renderPipes.batch.addToBatch(i, e))
          }
          _executeCacheAsTexture(t) {
            if (t.textureNeedsUpdate) {
              t.textureNeedsUpdate = !1
              let e = qD.identity().translate(-t._textureBounds.x, -t._textureBounds.y)
              ;(this._renderer.renderTarget.push(t.texture, !0, null, t.texture.frame),
                this._renderer.globalUniforms.push({
                  worldTransformMatrix: e,
                  worldColor: 4294967295,
                }),
                qs(t, this._renderer.renderPipes),
                this._renderer.renderTarget.finishRenderPass(),
                this._renderer.renderTarget.pop(),
                this._renderer.globalUniforms.pop())
            }
            ;(t._batchableRenderGroup._batcher.updateElement(t._batchableRenderGroup),
              t._batchableRenderGroup._batcher.geometry.buffers[0].update())
          }
          _executeDirect(t) {
            ;(this._renderer.globalUniforms.push({
              worldTransformMatrix: t.inverseParentTextureTransform,
              worldColor: t.worldColorAlpha,
            }),
              qs(t, this._renderer.renderPipes),
              this._renderer.globalUniforms.pop())
          }
        }))
      Zs.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "renderGroup" }
    })
  function Qs(r, t) {
    t || (t = 0)
    for (let e = t; e < r.length && r[e]; e++) r[e] = null
  }
  var Zf = p(() => {
    "use strict"
  })
  function Qf(r, t = !1) {
    QD(r)
    let e = r.childrenToUpdate,
      i = r.updateTick++
    for (let n in e) {
      let s = Number(n),
        o = e[n],
        a = o.list,
        u = o.index
      for (let l = 0; l < u; l++) {
        let c = a[l]
        c.parentRenderGroup === r && c.relativeRenderGroupDepth === s && BS(c, i, 0)
      }
      ;(Qs(a, u), (o.index = 0))
    }
    if (t) for (let n = 0; n < r.renderGroupChildren.length; n++) Qf(r.renderGroupChildren[n], t)
  }
  function QD(r) {
    let t = r.root,
      e
    if (r.renderGroupParent) {
      let i = r.renderGroupParent
      ;(r.worldTransform.appendFrom(t.relativeGroupTransform, i.worldTransform),
        (r.worldColor = Pi(t.groupColor, i.worldColor)),
        (e = t.groupAlpha * i.worldAlpha))
    } else
      (r.worldTransform.copyFrom(t.localTransform),
        (r.worldColor = t.localColor),
        (e = t.localAlpha))
    ;((e = e < 0 ? 0 : e > 1 ? 1 : e),
      (r.worldAlpha = e),
      (r.worldColorAlpha = r.worldColor + (((e * 255) | 0) << 24)))
  }
  function BS(r, t, e) {
    if (t === r.updateTick) return
    ;((r.updateTick = t), (r.didChange = !1))
    let i = r.localTransform
    r.updateLocalTransform()
    let n = r.parent
    if (
      (n && !n.renderGroup
        ? ((e |= r._updateFlags),
          r.relativeGroupTransform.appendFrom(i, n.relativeGroupTransform),
          e & FS && RS(r, n, e))
        : ((e = r._updateFlags), r.relativeGroupTransform.copyFrom(i), e & FS && RS(r, ZD, e)),
      !r.renderGroup)
    ) {
      let s = r.children,
        o = s.length
      for (let l = 0; l < o; l++) BS(s[l], t, e)
      let a = r.parentRenderGroup,
        u = r
      u.renderPipeId && !a.structureDidChange && a.updateRenderable(u)
    }
  }
  function RS(r, t, e) {
    if (e & Ii) {
      r.groupColor = Pi(r.localColor, t.groupColor)
      let i = r.localAlpha * t.groupAlpha
      ;((i = i < 0 ? 0 : i > 1 ? 1 : i),
        (r.groupAlpha = i),
        (r.groupColorAlpha = r.groupColor + (((i * 255) | 0) << 24)))
    }
    ;(e & rs &&
      (r.groupBlendMode = r.localBlendMode === "inherit" ? t.groupBlendMode : r.localBlendMode),
      e & ri && (r.globalDisplayStatus = r.localDisplayStatus & t.globalDisplayStatus),
      (r._updateFlags = 0))
  }
  var ZD,
    FS,
    IS = p(() => {
      we()
      Zf()
      Tc()
      ;((ZD = new pt()), (FS = ri | Ii | rs))
    })
  function kS(r, t) {
    let { list: e, index: i } = r.childrenRenderablesToUpdate,
      n = !1
    for (let s = 0; s < i; s++) {
      let o = e[s]
      if (((n = t[o.renderPipeId].validateRenderable(o)), n)) break
    }
    return ((r.structureDidChange = n), n)
  }
  var GS = p(() => {
    "use strict"
  })
  var JD,
    Js,
    US = p(() => {
      A()
      nt()
      _r()
      se()
      Zf()
      qf()
      IS()
      GS()
      ;((JD = new I()),
        (Js = class {
          constructor(t) {
            this._renderer = t
          }
          render({ container: t, transform: e }) {
            let i = t.parent,
              n = t.renderGroup.renderGroupParent
            ;((t.parent = null), (t.renderGroup.renderGroupParent = null))
            let s = this._renderer,
              o = JD
            e &&
              ((o = o.copyFrom(t.renderGroup.localTransform)),
              t.renderGroup.localTransform.copyFrom(e))
            let a = s.renderPipes
            ;(this._updateCachedRenderGroups(t.renderGroup, null),
              this._updateRenderGroups(t.renderGroup),
              s.globalUniforms.start({
                worldTransformMatrix: e
                  ? t.renderGroup.localTransform
                  : t.renderGroup.worldTransform,
                worldColor: t.renderGroup.worldColorAlpha,
              }),
              qs(t.renderGroup, a),
              a.uniformBatch && a.uniformBatch.renderEnd(),
              e && t.renderGroup.localTransform.copyFrom(o),
              (t.parent = i),
              (t.renderGroup.renderGroupParent = n))
          }
          destroy() {
            this._renderer = null
          }
          _updateCachedRenderGroups(t, e) {
            if (t.isCachedAsTexture) {
              if (!t.updateCacheTexture) return
              e = t
            }
            t._parentCacheAsTextureRenderGroup = e
            for (let i = t.renderGroupChildren.length - 1; i >= 0; i--)
              this._updateCachedRenderGroups(t.renderGroupChildren[i], e)
            if ((t.invalidateMatrices(), t.isCachedAsTexture)) {
              if (t.textureNeedsUpdate) {
                let i = t.root.getLocalBounds()
                i.ceil()
                let n = t.texture
                t.texture && St.returnTexture(t.texture)
                let s = this._renderer,
                  o = t.textureOptions.resolution || s.view.resolution,
                  a = t.textureOptions.antialias ?? s.view.antialias
                ;((t.texture = St.getOptimalTexture(i.width, i.height, o, a)),
                  t._textureBounds || (t._textureBounds = new ct()),
                  t._textureBounds.copyFrom(i),
                  n !== t.texture &&
                    t.renderGroupParent &&
                    (t.renderGroupParent.structureDidChange = !0))
              }
            } else t.texture && (St.returnTexture(t.texture), (t.texture = null))
          }
          _updateRenderGroups(t) {
            let e = this._renderer,
              i = e.renderPipes
            if (
              (t.runOnRender(e),
              (t.instructionSet.renderPipes = i),
              t.structureDidChange ? Qs(t.childrenRenderablesToUpdate.list, 0) : kS(t, i),
              Qf(t),
              t.structureDidChange
                ? ((t.structureDidChange = !1), this._buildInstructions(t, e))
                : this._updateRenderables(t),
              (t.childrenRenderablesToUpdate.index = 0),
              e.renderPipes.batch.upload(t.instructionSet),
              !(t.isCachedAsTexture && !t.textureNeedsUpdate))
            )
              for (let n = 0; n < t.renderGroupChildren.length; n++)
                this._updateRenderGroups(t.renderGroupChildren[n])
          }
          _updateRenderables(t) {
            let { list: e, index: i } = t.childrenRenderablesToUpdate
            for (let n = 0; n < i; n++) {
              let s = e[n]
              s.didViewUpdate && t.updateRenderable(s)
            }
            Qs(e, i)
          }
          _buildInstructions(t, e) {
            let i = t.root,
              n = t.instructionSet
            n.reset()
            let s = e.renderPipes ? e : e.batch.renderer,
              o = s.renderPipes
            ;(o.batch.buildStart(n),
              o.blendMode.buildStart(),
              o.colorMask.buildStart(),
              i.sortableChildren && i.sortChildren(),
              i.collectRenderablesWithEffects(n, s, null),
              o.batch.buildEnd(n),
              o.blendMode.buildEnd(n))
          }
        }))
      Js.extension = { type: [b.WebGLSystem, b.WebGPUSystem, b.CanvasSystem], name: "renderGroup" }
    })
  var to,
    OS = p(() => {
      A()
      Rs()
      to = class {
        constructor(t) {
          this._renderer = t
        }
        addRenderable(t, e) {
          let i = this._getGpuSprite(t)
          ;(t.didViewUpdate && this._updateBatchableSprite(t, i),
            this._renderer.renderPipes.batch.addToBatch(i, e))
        }
        updateRenderable(t) {
          let e = this._getGpuSprite(t)
          ;(t.didViewUpdate && this._updateBatchableSprite(t, e), e._batcher.updateElement(e))
        }
        validateRenderable(t) {
          let e = this._getGpuSprite(t)
          return !e._batcher.checkAndUpdateTexture(e, t._texture)
        }
        _updateBatchableSprite(t, e) {
          ;((e.bounds = t.visualBounds), (e.texture = t._texture))
        }
        _getGpuSprite(t) {
          return t._gpuData[this._renderer.uid] || this._initGPUSprite(t)
        }
        _initGPUSprite(t) {
          let e = new He()
          return (
            (e.renderable = t),
            (e.transform = t.groupTransform),
            (e.texture = t._texture),
            (e.bounds = t.visualBounds),
            (e.roundPixels = this._renderer._roundPixels | t._roundPixels),
            (t._gpuData[this._renderer.uid] = e),
            e
          )
        }
        destroy() {
          this._renderer = null
        }
      }
      to.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "sprite" }
    })
  var mn,
    Jf = p(() => {
      Wt()
      mn = "8.11.0"
    })
  var eo,
    ro,
    td = p(() => {
      A()
      Jf()
      eo = class {
        static init() {
          globalThis.__PIXI_APP_INIT__?.(this, mn)
        }
        static destroy() {}
      }
      eo.extension = b.Application
      ro = class {
        constructor(t) {
          this._renderer = t
        }
        init() {
          globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, mn)
        }
        destroy() {
          this._renderer = null
        }
      }
      ro.extension = { type: [b.WebGLSystem, b.WebGPUSystem], name: "initHook", priority: -10 }
    })
  var ed,
    rd,
    NS = p(() => {
      A()
      De()
      Ah()
      ed = class LS {
        constructor(t, e) {
          ;((this.state = Dt.for2d()),
            (this._batchersByInstructionSet = Object.create(null)),
            (this._activeBatches = Object.create(null)),
            (this.renderer = t),
            (this._adaptor = e),
            this._adaptor.init?.(this))
        }
        static getBatcher(t) {
          return new this._availableBatchers[t]()
        }
        buildStart(t) {
          let e = this._batchersByInstructionSet[t.uid]
          ;(e ||
            ((e = this._batchersByInstructionSet[t.uid] = Object.create(null)),
            e.default ||
              (e.default = new Ss({ maxTextures: this.renderer.limits.maxBatchableTextures }))),
            (this._activeBatches = e),
            (this._activeBatch = this._activeBatches.default))
          for (let i in this._activeBatches) this._activeBatches[i].begin()
        }
        addToBatch(t, e) {
          if (this._activeBatch.name !== t.batcherName) {
            this._activeBatch.break(e)
            let i = this._activeBatches[t.batcherName]
            ;(i ||
              ((i = this._activeBatches[t.batcherName] = LS.getBatcher(t.batcherName)), i.begin()),
              (this._activeBatch = i))
          }
          this._activeBatch.add(t)
        }
        break(t) {
          this._activeBatch.break(t)
        }
        buildEnd(t) {
          this._activeBatch.break(t)
          let e = this._activeBatches
          for (let i in e) {
            let n = e[i],
              s = n.geometry
            ;(s.indexBuffer.setDataWithSize(n.indexBuffer, n.indexSize, !0),
              s.buffers[0].setDataWithSize(n.attributeBuffer.float32View, n.attributeSize, !1))
          }
        }
        upload(t) {
          let e = this._batchersByInstructionSet[t.uid]
          for (let i in e) {
            let n = e[i],
              s = n.geometry
            n.dirty && ((n.dirty = !1), s.buffers[0].update(n.attributeSize * 4))
          }
        }
        execute(t) {
          if (t.action === "startBatch") {
            let e = t.batcher,
              i = e.geometry,
              n = e.shader
            this._adaptor.start(this, i, n)
          }
          this._adaptor.execute(this, t)
        }
        destroy() {
          ;((this.state = null), (this.renderer = null), (this._adaptor = null))
          for (let t in this._activeBatches) this._activeBatches[t].destroy()
          this._activeBatches = null
        }
      }
      ed.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "batch" }
      ed._availableBatchers = Object.create(null)
      rd = ed
      L.handleByMap(b.Batcher, rd._availableBatchers)
      L.add(Ss)
    })
  var HS,
    zS = p(() => {
      HS = `in vec2 vMaskCoord;
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform sampler2D uMaskTexture;

uniform float uAlpha;
uniform vec4 uMaskClamp;
uniform float uInverse;

out vec4 finalColor;

void main(void)
{
    float clip = step(3.5,
        step(uMaskClamp.x, vMaskCoord.x) +
        step(uMaskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, uMaskClamp.z) +
        step(vMaskCoord.y, uMaskClamp.w));

    // TODO look into why this is needed
    float npmAlpha = uAlpha;
    vec4 original = texture(uTexture, vTextureCoord);
    vec4 masky = texture(uMaskTexture, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    float a = alphaMul * masky.r * npmAlpha * clip;

    if (uInverse == 1.0) {
        a = 1.0 - a;
    }

    finalColor = original * a;
}
`
    })
  var WS,
    VS = p(() => {
      WS = `in vec2 aPosition;

out vec2 vTextureCoord;
out vec2 vMaskCoord;


uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;
uniform mat3 uFilterMatrix;

vec4 filterVertexPosition(  vec2 aPosition )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
       
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord(  vec2 aPosition )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

vec2 getFilterCoord( vec2 aPosition )
{
    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}   

void main(void)
{
    gl_Position = filterVertexPosition(aPosition);
    vTextureCoord = filterTextureCoord(aPosition);
    vMaskCoord = getFilterCoord(aPosition);
}
`
    })
  var id,
    $S = p(() => {
      id = `struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct MaskUniforms {
  uFilterMatrix:mat3x3<f32>,
  uMaskClamp:vec4<f32>,
  uAlpha:f32,
  uInverse:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;
@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) filterUv : vec2<f32>,
};

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);
}

fn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>
{
  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}

@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>,
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
   getFilterCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) filterUv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var maskClamp = filterUniforms.uMaskClamp;
    var uAlpha = filterUniforms.uAlpha;

    var clip = step(3.5,
      step(maskClamp.x, filterUv.x) +
      step(maskClamp.y, filterUv.y) +
      step(filterUv.x, maskClamp.z) +
      step(filterUv.y, maskClamp.w));

    var mask = textureSample(uMaskTexture, uSampler, filterUv);
    var source = textureSample(uTexture, uSampler, uv);
    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);

    var a: f32 = alphaMul * mask.r * uAlpha * clip;

    if (filterUniforms.uInverse == 1.0) {
        a = 1.0 - a;
    }

    return source * a;
}
`
    })
  var Zu,
    XS = p(() => {
      nt()
      oi()
      zi()
      re()
      Fc()
      xS()
      zS()
      VS()
      $S()
      Zu = class extends gS {
        constructor(t) {
          let { sprite: e, ...i } = t,
            n = new Bi(e.texture),
            s = new ht({
              uFilterMatrix: { value: new I(), type: "mat3x3<f32>" },
              uMaskClamp: { value: n.uClampFrame, type: "vec4<f32>" },
              uAlpha: { value: 1, type: "f32" },
              uInverse: { value: t.inverse ? 1 : 0, type: "f32" },
            }),
            o = be.from({
              vertex: { source: id, entryPoint: "mainVertex" },
              fragment: { source: id, entryPoint: "mainFragment" },
            }),
            a = ye.from({ vertex: WS, fragment: HS, name: "mask-filter" })
          ;(super({
            ...i,
            gpuProgram: o,
            glProgram: a,
            resources: { filterUniforms: s, uMaskTexture: e.texture.source },
          }),
            (this.sprite = e),
            (this._textureMatrix = n))
        }
        set inverse(t) {
          this.resources.filterUniforms.uniforms.uInverse = t ? 1 : 0
        }
        get inverse() {
          return this.resources.filterUniforms.uniforms.uInverse === 1
        }
        apply(t, e, i, n) {
          ;((this._textureMatrix.texture = this.sprite.texture),
            t
              .calculateSpriteMatrix(
                this.resources.filterUniforms.uniforms.uFilterMatrix,
                this.sprite,
              )
              .prepend(this._textureMatrix.mapCoord),
            (this.resources.uMaskTexture = this.sprite.texture.source),
            t.applyFilter(this, e, i, n))
        }
      }
    })
  var tP,
    nd,
    io,
    YS = p(() => {
      A()
      Fa()
      XS()
      se()
      Jn()
      th()
      Je()
      dt()
      _r()
      Le()
      ;((tP = new ct()),
        (nd = class extends tr {
          constructor() {
            ;(super(),
              (this.filters = [
                new Zu({
                  sprite: new ni(k.EMPTY),
                  inverse: !1,
                  resolution: "inherit",
                  antialias: "inherit",
                }),
              ]))
          }
          get sprite() {
            return this.filters[0].sprite
          }
          set sprite(t) {
            this.filters[0].sprite = t
          }
          get inverse() {
            return this.filters[0].inverse
          }
          set inverse(t) {
            this.filters[0].inverse = t
          }
        }),
        (io = class {
          constructor(t) {
            ;((this._activeMaskStage = []), (this._renderer = t))
          }
          push(t, e, i) {
            let n = this._renderer
            if (
              (n.renderPipes.batch.break(i),
              i.add({
                renderPipeId: "alphaMask",
                action: "pushMaskBegin",
                mask: t,
                inverse: e._maskOptions.inverse,
                canBundle: !1,
                maskedContainer: e,
              }),
              (t.inverse = e._maskOptions.inverse),
              t.renderMaskToTexture)
            ) {
              let s = t.mask
              ;((s.includeInBuild = !0), s.collectRenderables(i, n, null), (s.includeInBuild = !1))
            }
            ;(n.renderPipes.batch.break(i),
              i.add({
                renderPipeId: "alphaMask",
                action: "pushMaskEnd",
                mask: t,
                maskedContainer: e,
                inverse: e._maskOptions.inverse,
                canBundle: !1,
              }))
          }
          pop(t, e, i) {
            ;(this._renderer.renderPipes.batch.break(i),
              i.add({
                renderPipeId: "alphaMask",
                action: "popMaskEnd",
                mask: t,
                inverse: e._maskOptions.inverse,
                canBundle: !1,
              }))
          }
          execute(t) {
            let e = this._renderer,
              i = t.mask.renderMaskToTexture
            if (t.action === "pushMaskBegin") {
              let n = xt.get(nd)
              if (((n.inverse = t.inverse), i)) {
                t.mask.mask.measurable = !0
                let s = Di(t.mask.mask, !0, tP)
                ;((t.mask.mask.measurable = !1), s.ceil())
                let o = e.renderTarget.renderTarget.colorTexture.source,
                  a = St.getOptimalTexture(s.width, s.height, o._resolution, o.antialias)
                ;(e.renderTarget.push(a, !0),
                  e.globalUniforms.push({ offset: s, worldColor: 4294967295 }))
                let u = n.sprite
                ;((u.texture = a),
                  (u.worldTransform.tx = s.minX),
                  (u.worldTransform.ty = s.minY),
                  this._activeMaskStage.push({
                    filterEffect: n,
                    maskedContainer: t.maskedContainer,
                    filterTexture: a,
                  }))
              } else
                ((n.sprite = t.mask.mask),
                  this._activeMaskStage.push({
                    filterEffect: n,
                    maskedContainer: t.maskedContainer,
                  }))
            } else if (t.action === "pushMaskEnd") {
              let n = this._activeMaskStage[this._activeMaskStage.length - 1]
              ;(i &&
                (e.type === Bt.WEBGL && e.renderTarget.finishRenderPass(),
                e.renderTarget.pop(),
                e.globalUniforms.pop()),
                e.filter.push({
                  renderPipeId: "filter",
                  action: "pushFilter",
                  container: n.maskedContainer,
                  filterEffect: n.filterEffect,
                  canBundle: !1,
                }))
            } else if (t.action === "popMaskEnd") {
              e.filter.pop()
              let n = this._activeMaskStage.pop()
              ;(i && St.returnTexture(n.filterTexture), xt.return(n.filterEffect))
            }
          }
          destroy() {
            ;((this._renderer = null), (this._activeMaskStage = null))
          }
        }))
      io.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "alphaMask" }
    })
  var no,
    jS = p(() => {
      A()
      no = class {
        constructor(t) {
          ;((this._colorStack = []),
            (this._colorStackIndex = 0),
            (this._currentColor = 0),
            (this._renderer = t))
        }
        buildStart() {
          ;((this._colorStack[0] = 15), (this._colorStackIndex = 1), (this._currentColor = 15))
        }
        push(t, e, i) {
          this._renderer.renderPipes.batch.break(i)
          let s = this._colorStack
          s[this._colorStackIndex] = s[this._colorStackIndex - 1] & t.mask
          let o = this._colorStack[this._colorStackIndex]
          ;(o !== this._currentColor &&
            ((this._currentColor = o),
            i.add({ renderPipeId: "colorMask", colorMask: o, canBundle: !1 })),
            this._colorStackIndex++)
        }
        pop(t, e, i) {
          this._renderer.renderPipes.batch.break(i)
          let s = this._colorStack
          this._colorStackIndex--
          let o = s[this._colorStackIndex - 1]
          o !== this._currentColor &&
            ((this._currentColor = o),
            i.add({ renderPipeId: "colorMask", colorMask: o, canBundle: !1 }))
        }
        execute(t) {
          this._renderer.colorMask.setMask(t.colorMask)
        }
        destroy() {
          this._colorStack = null
        }
      }
      no.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "colorMask" }
    })
  var so,
    KS = p(() => {
      A()
      dn()
      si()
      so = class {
        constructor(t) {
          ;((this._maskStackHash = {}), (this._maskHash = new WeakMap()), (this._renderer = t))
        }
        push(t, e, i) {
          var n
          let s = t,
            o = this._renderer
          ;(o.renderPipes.batch.break(i),
            o.renderPipes.blendMode.setBlendMode(s.mask, "none", i),
            i.add({
              renderPipeId: "stencilMask",
              action: "pushMaskBegin",
              mask: t,
              inverse: e._maskOptions.inverse,
              canBundle: !1,
            }))
          let a = s.mask
          ;((a.includeInBuild = !0),
            this._maskHash.has(s) ||
              this._maskHash.set(s, { instructionsStart: 0, instructionsLength: 0 }))
          let u = this._maskHash.get(s)
          ;((u.instructionsStart = i.instructionSize),
            a.collectRenderables(i, o, null),
            (a.includeInBuild = !1),
            o.renderPipes.batch.break(i),
            i.add({
              renderPipeId: "stencilMask",
              action: "pushMaskEnd",
              mask: t,
              inverse: e._maskOptions.inverse,
              canBundle: !1,
            }))
          let l = i.instructionSize - u.instructionsStart - 1
          u.instructionsLength = l
          let c = o.renderTarget.renderTarget.uid
          ;(n = this._maskStackHash)[c] ?? (n[c] = 0)
        }
        pop(t, e, i) {
          let n = t,
            s = this._renderer
          ;(s.renderPipes.batch.break(i),
            s.renderPipes.blendMode.setBlendMode(n.mask, "none", i),
            i.add({
              renderPipeId: "stencilMask",
              action: "popMaskBegin",
              inverse: e._maskOptions.inverse,
              canBundle: !1,
            }))
          let o = this._maskHash.get(t)
          for (let a = 0; a < o.instructionsLength; a++)
            i.instructions[i.instructionSize++] = i.instructions[o.instructionsStart++]
          i.add({ renderPipeId: "stencilMask", action: "popMaskEnd", canBundle: !1 })
        }
        execute(t) {
          var e
          let i = this._renderer,
            n = i.renderTarget.renderTarget.uid,
            s = (e = this._maskStackHash)[n] ?? (e[n] = 0)
          ;(t.action === "pushMaskBegin"
            ? (i.renderTarget.ensureDepthStencil(),
              i.stencil.setStencilMode(mt.RENDERING_MASK_ADD, s),
              s++,
              i.colorMask.setMask(0))
            : t.action === "pushMaskEnd"
              ? (t.inverse
                  ? i.stencil.setStencilMode(mt.INVERSE_MASK_ACTIVE, s)
                  : i.stencil.setStencilMode(mt.MASK_ACTIVE, s),
                i.colorMask.setMask(15))
              : t.action === "popMaskBegin"
                ? (i.colorMask.setMask(0),
                  s !== 0
                    ? i.stencil.setStencilMode(mt.RENDERING_MASK_REMOVE, s)
                    : (i.renderTarget.clear(null, Ht.STENCIL),
                      i.stencil.setStencilMode(mt.DISABLED, s)),
                  s--)
                : t.action === "popMaskEnd" &&
                  (t.inverse
                    ? i.stencil.setStencilMode(mt.INVERSE_MASK_ACTIVE, s)
                    : i.stencil.setStencilMode(mt.MASK_ACTIVE, s),
                  i.colorMask.setMask(15)),
            (this._maskStackHash[n] = s))
        }
        destroy() {
          ;((this._renderer = null), (this._maskStackHash = null), (this._maskHash = null))
        }
      }
      so.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "stencilMask" }
    })
  var sd,
    ZS,
    QS = p(() => {
      Vt()
      A()
      ft()
      sd = class qS {
        constructor() {
          ;((this.clearBeforeRender = !0),
            (this._backgroundColor = new q(0)),
            (this.color = this._backgroundColor),
            (this.alpha = 1))
        }
        init(t) {
          ;((t = { ...qS.defaultOptions, ...t }),
            (this.clearBeforeRender = t.clearBeforeRender),
            (this.color = t.background || t.backgroundColor || this._backgroundColor),
            (this.alpha = t.backgroundAlpha),
            this._backgroundColor.setAlpha(t.backgroundAlpha))
        }
        get color() {
          return this._backgroundColor
        }
        set color(t) {
          ;(q.shared.setValue(t).alpha < 1 &&
            this._backgroundColor.alpha === 1 &&
            N(
              "Cannot set a transparent background on an opaque canvas. To enable transparency, set backgroundAlpha < 1 when initializing your Application.",
            ),
            this._backgroundColor.setValue(t))
        }
        get alpha() {
          return this._backgroundColor.alpha
        }
        set alpha(t) {
          this._backgroundColor.setAlpha(t)
        }
        get colorRgba() {
          return this._backgroundColor.toArray()
        }
        destroy() {}
      }
      sd.extension = {
        type: [b.WebGLSystem, b.WebGPUSystem, b.CanvasSystem],
        name: "background",
        priority: 0,
      }
      sd.defaultOptions = { backgroundAlpha: 1, backgroundColor: 0, clearBeforeRender: !0 }
      ZS = sd
    })
  var oo,
    ao,
    JS = p(() => {
      A()
      Fa()
      ft()
      oo = {}
      L.handle(
        b.BlendMode,
        (r) => {
          if (!r.name) throw new Error("BlendMode extension must have a name property")
          oo[r.name] = r.ref
        },
        (r) => {
          delete oo[r.name]
        },
      )
      ao = class {
        constructor(t) {
          ;((this._isAdvanced = !1),
            (this._filterHash = Object.create(null)),
            (this._renderer = t),
            this._renderer.runners.prerender.add(this))
        }
        prerender() {
          ;((this._activeBlendMode = "normal"), (this._isAdvanced = !1))
        }
        setBlendMode(t, e, i) {
          if (this._activeBlendMode === e) {
            this._isAdvanced && this._renderableList.push(t)
            return
          }
          ;((this._activeBlendMode = e),
            this._isAdvanced && this._endAdvancedBlendMode(i),
            (this._isAdvanced = !!oo[e]),
            this._isAdvanced && (this._beginAdvancedBlendMode(i), this._renderableList.push(t)))
        }
        _beginAdvancedBlendMode(t) {
          this._renderer.renderPipes.batch.break(t)
          let e = this._activeBlendMode
          if (!oo[e]) {
            N(
              `Unable to assign BlendMode: '${e}'. You may want to include: import 'pixi.js/advanced-blend-modes'`,
            )
            return
          }
          let i = this._filterHash[e]
          i || ((i = this._filterHash[e] = new tr()), (i.filters = [new oo[e]()]))
          let n = {
            renderPipeId: "filter",
            action: "pushFilter",
            renderables: [],
            filterEffect: i,
            canBundle: !1,
          }
          ;((this._renderableList = n.renderables), t.add(n))
        }
        _endAdvancedBlendMode(t) {
          ;((this._renderableList = null),
            this._renderer.renderPipes.batch.break(t),
            t.add({ renderPipeId: "filter", action: "popFilter", canBundle: !1 }))
        }
        buildStart() {
          this._isAdvanced = !1
        }
        buildEnd(t) {
          this._isAdvanced && this._endAdvancedBlendMode(t)
        }
        destroy() {
          ;((this._renderer = null), (this._renderableList = null))
          for (let t in this._filterHash) this._filterHash[t].destroy()
          this._filterHash = null
        }
      }
      ao.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "blendMode" }
    })
  var od,
    ad,
    eT,
    rT = p(() => {
      A()
      we()
      dt()
      ;((od = { png: "image/png", jpg: "image/jpeg", webp: "image/webp" }),
        (ad = class tT {
          constructor(t) {
            this._renderer = t
          }
          _normalizeOptions(t, e = {}) {
            return t instanceof pt || t instanceof k ? { target: t, ...e } : { ...e, ...t }
          }
          async image(t) {
            let e = new Image()
            return ((e.src = await this.base64(t)), e)
          }
          async base64(t) {
            t = this._normalizeOptions(t, tT.defaultImageOptions)
            let { format: e, quality: i } = t,
              n = this.canvas(t)
            if (n.toBlob !== void 0)
              return new Promise((s, o) => {
                n.toBlob(
                  (a) => {
                    if (!a) {
                      o(new Error("ICanvas.toBlob failed!"))
                      return
                    }
                    let u = new FileReader()
                    ;((u.onload = () => s(u.result)), (u.onerror = o), u.readAsDataURL(a))
                  },
                  od[e],
                  i,
                )
              })
            if (n.toDataURL !== void 0) return n.toDataURL(od[e], i)
            if (n.convertToBlob !== void 0) {
              let s = await n.convertToBlob({ type: od[e], quality: i })
              return new Promise((o, a) => {
                let u = new FileReader()
                ;((u.onload = () => o(u.result)), (u.onerror = a), u.readAsDataURL(s))
              })
            }
            throw new Error(
              "Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented",
            )
          }
          canvas(t) {
            t = this._normalizeOptions(t)
            let e = t.target,
              i = this._renderer
            if (e instanceof k) return i.texture.generateCanvas(e)
            let n = i.textureGenerator.generateTexture(t),
              s = i.texture.generateCanvas(n)
            return (n.destroy(!0), s)
          }
          pixels(t) {
            t = this._normalizeOptions(t)
            let e = t.target,
              i = this._renderer,
              n = e instanceof k ? e : i.textureGenerator.generateTexture(t),
              s = i.texture.getPixels(n)
            return (e instanceof pt && n.destroy(!0), s)
          }
          texture(t) {
            return (
              (t = this._normalizeOptions(t)),
              t.target instanceof k ? t.target : this._renderer.textureGenerator.generateTexture(t)
            )
          }
          download(t) {
            t = this._normalizeOptions(t)
            let e = this.canvas(t),
              i = document.createElement("a")
            ;((i.download = t.filename ?? "image.png"),
              (i.href = e.toDataURL("image/png")),
              document.body.appendChild(i),
              i.click(),
              document.body.removeChild(i))
          }
          log(t) {
            let e = t.width ?? 200
            t = this._normalizeOptions(t)
            let i = this.canvas(t),
              n = i.toDataURL()
            console.log(`[Pixi Texture] ${i.width}px ${i.height}px`)
            let s = [
              "font-size: 1px;",
              `padding: ${e}px 300px;`,
              `background: url(${n}) no-repeat;`,
              "background-size: contain;",
            ].join(" ")
            console.log("%c ", s)
          }
          destroy() {
            this._renderer = null
          }
        }))
      ad.extension = { type: [b.WebGLSystem, b.WebGPUSystem], name: "extract" }
      ad.defaultImageOptions = { format: "png", quality: 1 }
      eT = ad
    })
  var Qu,
    iT = p(() => {
      te()
      dt()
      Qu = class r extends k {
        static create(t) {
          return new r({ source: new ot(t) })
        }
        resize(t, e, i) {
          return (this.source.resize(t, e, i), this)
        }
      }
    })
  var eP,
    rP,
    iP,
    uo,
    nT = p(() => {
      Vt()
      A()
      nt()
      Lt()
      se()
      Ga()
      we()
      iT()
      ;((eP = new Q()),
        (rP = new ct()),
        (iP = [0, 0, 0, 0]),
        (uo = class {
          constructor(t) {
            this._renderer = t
          }
          generateTexture(t) {
            t instanceof pt &&
              (t = { target: t, frame: void 0, textureSourceOptions: {}, resolution: void 0 })
            let e = t.resolution || this._renderer.resolution,
              i = t.antialias || this._renderer.view.antialias,
              n = t.target,
              s = t.clearColor
            s
              ? (s = Array.isArray(s) && s.length === 4 ? s : q.shared.setValue(s).toArray())
              : (s = iP)
            let o = t.frame?.copyTo(eP) || Fi(n, rP).rectangle
            ;((o.width = Math.max(o.width, 1 / e) | 0), (o.height = Math.max(o.height, 1 / e) | 0))
            let a = Qu.create({
                ...t.textureSourceOptions,
                width: o.width,
                height: o.height,
                resolution: e,
                antialias: i,
              }),
              u = I.shared.translate(-o.x, -o.y)
            return (
              this._renderer.render({ container: n, transform: u, target: a, clearColor: s }),
              a.source.updateMipmaps(),
              a
            )
          }
          destroy() {
            this._renderer = null
          }
        }))
      uo.extension = { type: [b.WebGLSystem, b.WebGPUSystem], name: "textureGenerator" }
    })
  var lo,
    sT = p(() => {
      A()
      nt()
      Ee()
      Qi()
      Tr()
      Le()
      re()
      lo = class {
        constructor(t) {
          ;((this._stackIndex = 0),
            (this._globalUniformDataStack = []),
            (this._uniformsPool = []),
            (this._activeUniforms = []),
            (this._bindGroupPool = []),
            (this._activeBindGroups = []),
            (this._renderer = t))
        }
        reset() {
          this._stackIndex = 0
          for (let t = 0; t < this._activeUniforms.length; t++)
            this._uniformsPool.push(this._activeUniforms[t])
          for (let t = 0; t < this._activeBindGroups.length; t++)
            this._bindGroupPool.push(this._activeBindGroups[t])
          ;((this._activeUniforms.length = 0), (this._activeBindGroups.length = 0))
        }
        start(t) {
          ;(this.reset(), this.push(t))
        }
        bind({ size: t, projectionMatrix: e, worldTransformMatrix: i, worldColor: n, offset: s }) {
          let o = this._renderer.renderTarget.renderTarget,
            a = this._stackIndex
              ? this._globalUniformDataStack[this._stackIndex - 1]
              : {
                  projectionData: o,
                  worldTransformMatrix: new I(),
                  worldColor: 4294967295,
                  offset: new rt(),
                },
            u = {
              projectionMatrix: e || this._renderer.renderTarget.projectionMatrix,
              resolution: t || o.size,
              worldTransformMatrix: i || a.worldTransformMatrix,
              worldColor: n || a.worldColor,
              offset: s || a.offset,
              bindGroup: null,
            },
            l = this._uniformsPool.pop() || this._createUniforms()
          this._activeUniforms.push(l)
          let c = l.uniforms
          ;((c.uProjectionMatrix = u.projectionMatrix),
            (c.uResolution = u.resolution),
            c.uWorldTransformMatrix.copyFrom(u.worldTransformMatrix),
            (c.uWorldTransformMatrix.tx -= u.offset.x),
            (c.uWorldTransformMatrix.ty -= u.offset.y),
            Ne(u.worldColor, c.uWorldColorAlpha, 0),
            l.update())
          let h
          ;(this._renderer.renderPipes.uniformBatch
            ? (h = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(l, !1))
            : ((h = this._bindGroupPool.pop() || new Nt()),
              this._activeBindGroups.push(h),
              h.setResource(l, 0)),
            (u.bindGroup = h),
            (this._currentGlobalUniformData = u))
        }
        push(t) {
          ;(this.bind(t),
            (this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData))
        }
        pop() {
          ;((this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1]),
            this._renderer.type === Bt.WEBGL &&
              this._currentGlobalUniformData.bindGroup.resources[0].update())
        }
        get bindGroup() {
          return this._currentGlobalUniformData.bindGroup
        }
        get globalUniformData() {
          return this._currentGlobalUniformData
        }
        get uniformGroup() {
          return this._currentGlobalUniformData.bindGroup.resources[0]
        }
        _createUniforms() {
          return new ht(
            {
              uProjectionMatrix: { value: new I(), type: "mat3x3<f32>" },
              uWorldTransformMatrix: { value: new I(), type: "mat3x3<f32>" },
              uWorldColorAlpha: { value: new Float32Array(4), type: "vec4<f32>" },
              uResolution: { value: [0, 0], type: "vec2<f32>" },
            },
            { isStatic: !0 },
          )
        }
        destroy() {
          this._renderer = null
        }
      }
      lo.extension = {
        type: [b.WebGLSystem, b.WebGPUSystem, b.CanvasSystem],
        name: "globalUniforms",
      }
    })
  var nP,
    co,
    oT = p(() => {
      A()
      ss()
      ;((nP = 1),
        (co = class {
          constructor() {
            ;((this._tasks = []), (this._offset = 0))
          }
          init() {
            oe.system.add(this._update, this)
          }
          repeat(t, e, i = !0) {
            let n = nP++,
              s = 0
            return (
              i && ((this._offset += 1e3), (s = this._offset)),
              this._tasks.push({
                func: t,
                duration: e,
                start: performance.now(),
                offset: s,
                last: performance.now(),
                repeat: !0,
                id: n,
              }),
              n
            )
          }
          cancel(t) {
            for (let e = 0; e < this._tasks.length; e++)
              if (this._tasks[e].id === t) {
                this._tasks.splice(e, 1)
                return
              }
          }
          _update() {
            let t = performance.now()
            for (let e = 0; e < this._tasks.length; e++) {
              let i = this._tasks[e]
              if (t - i.offset - i.last >= i.duration) {
                let n = t - i.start
                ;(i.func(n), (i.last = t))
              }
            }
          }
          destroy() {
            ;(oe.system.remove(this._update, this), (this._tasks.length = 0))
          }
        }))
      co.extension = {
        type: [b.WebGLSystem, b.WebGPUSystem, b.CanvasSystem],
        name: "scheduler",
        priority: 0,
      }
    })
  function uT(r) {
    if (!aT) {
      if (Z.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
        let t = [
          `%c  %c  %c  %c  %c PixiJS %c v${mn} (${r}) http://www.pixijs.com/

`,
          "background: #E72264; padding:5px 0;",
          "background: #6CA2EA; padding:5px 0;",
          "background: #B5D33D; padding:5px 0;",
          "background: #FED23F; padding:5px 0;",
          "color: #FFFFFF; background: #E72264; padding:5px 0;",
          "color: #E72264; background: #FFFFFF; padding:5px 0;",
        ]
        globalThis.console.log(...t)
      } else
        globalThis.console && globalThis.console.log(`PixiJS ${mn} - ${r} - http://www.pixijs.com/`)
      aT = !0
    }
  }
  var aT,
    lT = p(() => {
      At()
      Jf()
      aT = !1
    })
  var gn,
    cT = p(() => {
      A()
      lT()
      Le()
      gn = class {
        constructor(t) {
          this._renderer = t
        }
        init(t) {
          if (t.hello) {
            let e = this._renderer.name
            ;(this._renderer.type === Bt.WEBGL && (e += ` ${this._renderer.context.webGLVersion}`),
              uT(e))
          }
        }
      }
      gn.extension = {
        type: [b.WebGLSystem, b.WebGPUSystem, b.CanvasSystem],
        name: "hello",
        priority: -2,
      }
      gn.defaultOptions = { hello: !1 }
    })
  function hT(r) {
    let t = !1
    for (let i in r)
      if (r[i] == null) {
        t = !0
        break
      }
    if (!t) return r
    let e = Object.create(null)
    for (let i in r) {
      let n = r[i]
      n && (e[i] = n)
    }
    return e
  }
  function fT(r) {
    let t = 0
    for (let e = 0; e < r.length; e++) r[e] == null ? t++ : (r[e - t] = r[e])
    return ((r.length -= t), r)
  }
  var dT = p(() => {
    "use strict"
  })
  var sP,
    ud,
    mT,
    gT = p(() => {
      A()
      dT()
      ;((sP = 0),
        (ud = class pT {
          constructor(t) {
            ;((this._managedRenderables = []),
              (this._managedHashes = []),
              (this._managedArrays = []),
              (this._renderer = t))
          }
          init(t) {
            ;((t = { ...pT.defaultOptions, ...t }),
              (this.maxUnusedTime = t.renderableGCMaxUnusedTime),
              (this._frequency = t.renderableGCFrequency),
              (this.enabled = t.renderableGCActive))
          }
          get enabled() {
            return !!this._handler
          }
          set enabled(t) {
            this.enabled !== t &&
              (t
                ? ((this._handler = this._renderer.scheduler.repeat(
                    () => this.run(),
                    this._frequency,
                    !1,
                  )),
                  (this._hashHandler = this._renderer.scheduler.repeat(() => {
                    for (let e of this._managedHashes) e.context[e.hash] = hT(e.context[e.hash])
                  }, this._frequency)),
                  (this._arrayHandler = this._renderer.scheduler.repeat(() => {
                    for (let e of this._managedArrays) fT(e.context[e.hash])
                  }, this._frequency)))
                : (this._renderer.scheduler.cancel(this._handler),
                  this._renderer.scheduler.cancel(this._hashHandler),
                  this._renderer.scheduler.cancel(this._arrayHandler)))
          }
          addManagedHash(t, e) {
            this._managedHashes.push({ context: t, hash: e })
          }
          addManagedArray(t, e) {
            this._managedArrays.push({ context: t, hash: e })
          }
          prerender({ container: t }) {
            ;((this._now = performance.now()),
              (t.renderGroup.gcTick = sP++),
              this._updateInstructionGCTick(t.renderGroup, t.renderGroup.gcTick))
          }
          addRenderable(t) {
            this.enabled &&
              (t._lastUsed === -1 &&
                (this._managedRenderables.push(t),
                t.once("destroyed", this._removeRenderable, this)),
              (t._lastUsed = this._now))
          }
          run() {
            let t = this._now,
              e = this._managedRenderables,
              i = this._renderer.renderPipes,
              n = 0
            for (let s = 0; s < e.length; s++) {
              let o = e[s]
              if (o === null) {
                n++
                continue
              }
              let a = o.renderGroup ?? o.parentRenderGroup,
                u = a?.instructionSet?.gcTick ?? -1
              if (
                ((a?.gcTick ?? 0) === u && (o._lastUsed = t), t - o._lastUsed > this.maxUnusedTime)
              ) {
                if (!o.destroyed) {
                  let l = i
                  ;(a && (a.structureDidChange = !0), l[o.renderPipeId].destroyRenderable(o))
                }
                ;((o._lastUsed = -1), n++, o.off("destroyed", this._removeRenderable, this))
              } else e[s - n] = o
            }
            e.length -= n
          }
          destroy() {
            ;((this.enabled = !1),
              (this._renderer = null),
              (this._managedRenderables.length = 0),
              (this._managedHashes.length = 0),
              (this._managedArrays.length = 0))
          }
          _removeRenderable(t) {
            let e = this._managedRenderables.indexOf(t)
            e >= 0 &&
              (t.off("destroyed", this._removeRenderable, this),
              (this._managedRenderables[e] = null))
          }
          _updateInstructionGCTick(t, e) {
            t.instructionSet.gcTick = e
            for (let i of t.renderGroupChildren) this._updateInstructionGCTick(i, e)
          }
        }))
      ud.extension = { type: [b.WebGLSystem, b.WebGPUSystem], name: "renderableGC", priority: 0 }
      ud.defaultOptions = {
        renderableGCActive: !0,
        renderableGCMaxUnusedTime: 6e4,
        renderableGCFrequency: 3e4,
      }
      mT = ud
    })
  var ld,
    _T,
    yT = p(() => {
      A()
      ld = class xT {
        constructor(t) {
          ;((this._renderer = t), (this.count = 0), (this.checkCount = 0))
        }
        init(t) {
          ;((t = { ...xT.defaultOptions, ...t }),
            (this.checkCountMax = t.textureGCCheckCountMax),
            (this.maxIdle = t.textureGCAMaxIdle ?? t.textureGCMaxIdle),
            (this.active = t.textureGCActive))
        }
        postrender() {
          this._renderer.renderingToScreen &&
            (this.count++,
            this.active &&
              (this.checkCount++,
              this.checkCount > this.checkCountMax && ((this.checkCount = 0), this.run())))
        }
        run() {
          let t = this._renderer.texture.managedTextures
          for (let e = 0; e < t.length; e++) {
            let i = t[e]
            i.autoGarbageCollect &&
              i.resource &&
              i._touched > -1 &&
              this.count - i._touched > this.maxIdle &&
              ((i._touched = -1), i.unload())
          }
        }
        destroy() {
          this._renderer = null
        }
      }
      ld.extension = { type: [b.WebGLSystem, b.WebGPUSystem], name: "textureGC" }
      ld.defaultOptions = {
        textureGCActive: !0,
        textureGCAMaxIdle: null,
        textureGCMaxIdle: 3600,
        textureGCCheckCountMax: 600,
      }
      _T = ld
    })
  var bT,
    ho,
    cd = p(() => {
      Ot()
      te()
      dt()
      bT = class vT {
        constructor(t = {}) {
          if (
            ((this.uid = J("renderTarget")),
            (this.colorTextures = []),
            (this.dirtyId = 0),
            (this.isRoot = !1),
            (this._size = new Float32Array(2)),
            (this._managedColorTextures = !1),
            (t = { ...vT.defaultOptions, ...t }),
            (this.stencil = t.stencil),
            (this.depth = t.depth),
            (this.isRoot = t.isRoot),
            typeof t.colorTextures == "number")
          ) {
            this._managedColorTextures = !0
            for (let e = 0; e < t.colorTextures; e++)
              this.colorTextures.push(
                new ot({
                  width: t.width,
                  height: t.height,
                  resolution: t.resolution,
                  antialias: t.antialias,
                }),
              )
          } else {
            this.colorTextures = [...t.colorTextures.map((i) => i.source)]
            let e = this.colorTexture.source
            this.resize(e.width, e.height, e._resolution)
          }
          ;(this.colorTexture.source.on("resize", this.onSourceResize, this),
            (t.depthStencilTexture || this.stencil) &&
              (t.depthStencilTexture instanceof k || t.depthStencilTexture instanceof ot
                ? (this.depthStencilTexture = t.depthStencilTexture.source)
                : this.ensureDepthStencilTexture()))
        }
        get size() {
          let t = this._size
          return ((t[0] = this.pixelWidth), (t[1] = this.pixelHeight), t)
        }
        get width() {
          return this.colorTexture.source.width
        }
        get height() {
          return this.colorTexture.source.height
        }
        get pixelWidth() {
          return this.colorTexture.source.pixelWidth
        }
        get pixelHeight() {
          return this.colorTexture.source.pixelHeight
        }
        get resolution() {
          return this.colorTexture.source._resolution
        }
        get colorTexture() {
          return this.colorTextures[0]
        }
        onSourceResize(t) {
          this.resize(t.width, t.height, t._resolution, !0)
        }
        ensureDepthStencilTexture() {
          this.depthStencilTexture ||
            (this.depthStencilTexture = new ot({
              width: this.width,
              height: this.height,
              resolution: this.resolution,
              format: "depth24plus-stencil8",
              autoGenerateMipmaps: !1,
              antialias: !1,
              mipLevelCount: 1,
            }))
        }
        resize(t, e, i = this.resolution, n = !1) {
          ;(this.dirtyId++,
            this.colorTextures.forEach((s, o) => {
              ;(n && o === 0) || s.source.resize(t, e, i)
            }),
            this.depthStencilTexture && this.depthStencilTexture.source.resize(t, e, i))
        }
        destroy() {
          ;(this.colorTexture.source.off("resize", this.onSourceResize, this),
            this._managedColorTextures &&
              this.colorTextures.forEach((t) => {
                t.destroy()
              }),
            this.depthStencilTexture &&
              (this.depthStencilTexture.destroy(), delete this.depthStencilTexture))
        }
      }
      bT.defaultOptions = {
        width: 0,
        height: 0,
        resolution: 1,
        colorTextures: 1,
        stencil: !1,
        depth: !1,
        antialias: !1,
        isRoot: !1,
      }
      ho = bT
    })
  function Ju(r, t) {
    if (!fo.has(r)) {
      let e = new k({ source: new Yt({ resource: r, ...t }) }),
        i = () => {
          fo.get(r) === e && fo.delete(r)
        }
      ;(e.once("destroy", i), e.source.once("destroy", i), fo.set(r, e))
    }
    return fo.get(r)
  }
  var fo,
    hd = p(() => {
      Ui()
      dt()
      fo = new Map()
    })
  var fd,
    TT,
    CT = p(() => {
      At()
      A()
      Lt()
      gt()
      cd()
      hd()
      fd = class ST {
        get autoDensity() {
          return this.texture.source.autoDensity
        }
        set autoDensity(t) {
          this.texture.source.autoDensity = t
        }
        get resolution() {
          return this.texture.source._resolution
        }
        set resolution(t) {
          this.texture.source.resize(this.texture.source.width, this.texture.source.height, t)
        }
        init(t) {
          ;((t = { ...ST.defaultOptions, ...t }),
            t.view &&
              (z(K, "ViewSystem.view has been renamed to ViewSystem.canvas"), (t.canvas = t.view)),
            (this.screen = new Q(0, 0, t.width, t.height)),
            (this.canvas = t.canvas || Z.get().createCanvas()),
            (this.antialias = !!t.antialias),
            (this.texture = Ju(this.canvas, t)),
            (this.renderTarget = new ho({
              colorTextures: [this.texture],
              depth: !!t.depth,
              isRoot: !0,
            })),
            (this.texture.source.transparent = t.backgroundAlpha < 1),
            (this.resolution = t.resolution))
        }
        resize(t, e, i) {
          ;(this.texture.source.resize(t, e, i),
            (this.screen.width = this.texture.frame.width),
            (this.screen.height = this.texture.frame.height))
        }
        destroy(t = !1) {
          ;(typeof t == "boolean" ? t : !!t?.removeView) &&
            this.canvas.parentNode &&
            this.canvas.parentNode.removeChild(this.canvas)
        }
      }
      fd.extension = {
        type: [b.WebGLSystem, b.WebGPUSystem, b.CanvasSystem],
        name: "view",
        priority: 0,
      }
      fd.defaultOptions = { width: 800, height: 600, autoDensity: !1, antialias: !1 }
      TT = fd
    })
  var tl,
    el,
    dd = p(() => {
      DS()
      PS()
      US()
      OS()
      td()
      NS()
      YS()
      jS()
      KS()
      QS()
      JS()
      rT()
      nT()
      sT()
      oT()
      cT()
      gT()
      yT()
      CT()
      ;((tl = [ZS, lo, gn, TT, Js, _T, uo, eT, ro, mT, co]),
        (el = [ao, rd, to, Zs, io, so, no, Ks]))
    })
  var po,
    ET = p(() => {
      A()
      po = class {
        constructor(t) {
          ;((this._hash = Object.create(null)),
            (this._renderer = t),
            this._renderer.renderableGC.addManagedHash(this, "_hash"))
        }
        contextChange(t) {
          this._gpu = t
        }
        getBindGroup(t, e, i) {
          return (t._updateKey(), this._hash[t._key] || this._createBindGroup(t, e, i))
        }
        _createBindGroup(t, e, i) {
          let n = this._gpu.device,
            s = e.layout[i],
            o = [],
            a = this._renderer
          for (let c in s) {
            let h = t.resources[c] ?? t.resources[s[c]],
              f
            if (h._resourceType === "uniformGroup") {
              let d = h
              a.ubo.updateUniformGroup(d)
              let g = d.buffer
              f = { buffer: a.buffer.getGPUBuffer(g), offset: 0, size: g.descriptor.size }
            } else if (h._resourceType === "buffer") {
              let d = h
              f = { buffer: a.buffer.getGPUBuffer(d), offset: 0, size: d.descriptor.size }
            } else if (h._resourceType === "bufferResource") {
              let d = h
              f = { buffer: a.buffer.getGPUBuffer(d.buffer), offset: d.offset, size: d.size }
            } else if (h._resourceType === "textureSampler") {
              let d = h
              f = a.texture.getGpuSampler(d)
            } else if (h._resourceType === "textureSource") {
              let d = h
              f = a.texture.getGpuSource(d).createView({})
            }
            o.push({ binding: s[c], resource: f })
          }
          let u = a.shader.getProgramData(e).bindGroups[i],
            l = n.createBindGroup({ layout: u, entries: o })
          return ((this._hash[t._key] = l), l)
        }
        destroy() {
          for (let t of Object.keys(this._hash)) this._hash[t] = null
          ;((this._hash = null), (this._renderer = null))
        }
      }
      po.extension = { type: [b.WebGPUSystem], name: "bindGroup" }
    })
  var mo,
    wT = p(() => {
      A()
      uh()
      mo = class {
        constructor(t) {
          ;((this._gpuBuffers = Object.create(null)),
            (this._managedBuffers = []),
            t.renderableGC.addManagedHash(this, "_gpuBuffers"))
        }
        contextChange(t) {
          this._gpu = t
        }
        getGPUBuffer(t) {
          return this._gpuBuffers[t.uid] || this.createGPUBuffer(t)
        }
        updateBuffer(t) {
          let e = this._gpuBuffers[t.uid] || this.createGPUBuffer(t),
            i = t.data
          return (
            t._updateID &&
              i &&
              ((t._updateID = 0),
              this._gpu.device.queue.writeBuffer(
                e,
                0,
                i.buffer,
                0,
                ((t._updateSize || i.byteLength) + 3) & -4,
              )),
            e
          )
        }
        destroyAll() {
          for (let t in this._gpuBuffers) this._gpuBuffers[t].destroy()
          this._gpuBuffers = {}
        }
        createGPUBuffer(t) {
          this._gpuBuffers[t.uid] ||
            (t.on("update", this.updateBuffer, this),
            t.on("change", this.onBufferChange, this),
            t.on("destroy", this.onBufferDestroy, this),
            this._managedBuffers.push(t))
          let e = this._gpu.device.createBuffer(t.descriptor)
          return (
            (t._updateID = 0),
            t.data && (gs(t.data.buffer, e.getMappedRange()), e.unmap()),
            (this._gpuBuffers[t.uid] = e),
            e
          )
        }
        onBufferChange(t) {
          ;(this._gpuBuffers[t.uid].destroy(),
            (t._updateID = 0),
            (this._gpuBuffers[t.uid] = this.createGPUBuffer(t)))
        }
        onBufferDestroy(t) {
          ;(this._managedBuffers.splice(this._managedBuffers.indexOf(t), 1), this._destroyBuffer(t))
        }
        destroy() {
          ;(this._managedBuffers.forEach((t) => this._destroyBuffer(t)),
            (this._managedBuffers = null),
            (this._gpuBuffers = null))
        }
        _destroyBuffer(t) {
          ;(this._gpuBuffers[t.uid].destroy(),
            t.off("update", this.updateBuffer, this),
            t.off("change", this.onBufferChange, this),
            t.off("destroy", this.onBufferDestroy, this),
            (this._gpuBuffers[t.uid] = null))
        }
      }
      mo.extension = { type: [b.WebGPUSystem], name: "buffer" }
    })
  var go,
    MT = p(() => {
      A()
      go = class {
        constructor(t) {
          ;((this._colorMaskCache = 15), (this._renderer = t))
        }
        setMask(t) {
          this._colorMaskCache !== t &&
            ((this._colorMaskCache = t), this._renderer.pipeline.setColorMask(t))
        }
        destroy() {
          ;((this._renderer = null), (this._colorMaskCache = null))
        }
      }
      go.extension = { type: [b.WebGPUSystem], name: "colorMask" }
    })
  var xn,
    AT = p(() => {
      At()
      A()
      xn = class {
        constructor(t) {
          this._renderer = t
        }
        async init(t) {
          return this._initPromise
            ? this._initPromise
            : ((this._initPromise = this._createDeviceAndAdaptor(t).then((e) => {
                ;((this.gpu = e), this._renderer.runners.contextChange.emit(this.gpu))
              })),
              this._initPromise)
        }
        contextChange(t) {
          this._renderer.gpu = t
        }
        async _createDeviceAndAdaptor(t) {
          let e = await Z.get()
              .getNavigator()
              .gpu.requestAdapter({
                powerPreference: t.powerPreference,
                forceFallbackAdapter: t.forceFallbackAdapter,
              }),
            i = [
              "texture-compression-bc",
              "texture-compression-astc",
              "texture-compression-etc2",
            ].filter((s) => e.features.has(s)),
            n = await e.requestDevice({ requiredFeatures: i })
          return { adapter: e, device: n }
        }
        destroy() {
          ;((this.gpu = null), (this._renderer = null))
        }
      }
      xn.extension = { type: [b.WebGPUSystem], name: "device" }
      xn.defaultOptions = { powerPreference: void 0, forceFallbackAdapter: !1 }
    })
  var xo,
    DT = p(() => {
      A()
      xo = class {
        constructor(t) {
          ;((this._boundBindGroup = Object.create(null)),
            (this._boundVertexBuffer = Object.create(null)),
            (this._renderer = t))
        }
        renderStart() {
          ;((this.commandFinished = new Promise((t) => {
            this._resolveCommandFinished = t
          })),
            (this.commandEncoder = this._renderer.gpu.device.createCommandEncoder()))
        }
        beginRenderPass(t) {
          ;(this.endRenderPass(),
            this._clearCache(),
            (this.renderPassEncoder = this.commandEncoder.beginRenderPass(t.descriptor)))
        }
        endRenderPass() {
          ;(this.renderPassEncoder && this.renderPassEncoder.end(), (this.renderPassEncoder = null))
        }
        setViewport(t) {
          this.renderPassEncoder.setViewport(t.x, t.y, t.width, t.height, 0, 1)
        }
        setPipelineFromGeometryProgramAndState(t, e, i, n) {
          let s = this._renderer.pipeline.getPipeline(t, e, i, n)
          this.setPipeline(s)
        }
        setPipeline(t) {
          this._boundPipeline !== t &&
            ((this._boundPipeline = t), this.renderPassEncoder.setPipeline(t))
        }
        _setVertexBuffer(t, e) {
          this._boundVertexBuffer[t] !== e &&
            ((this._boundVertexBuffer[t] = e),
            this.renderPassEncoder.setVertexBuffer(t, this._renderer.buffer.updateBuffer(e)))
        }
        _setIndexBuffer(t) {
          if (this._boundIndexBuffer === t) return
          this._boundIndexBuffer = t
          let e = t.data.BYTES_PER_ELEMENT === 2 ? "uint16" : "uint32"
          this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(t), e)
        }
        resetBindGroup(t) {
          this._boundBindGroup[t] = null
        }
        setBindGroup(t, e, i) {
          if (this._boundBindGroup[t] === e) return
          ;((this._boundBindGroup[t] = e), e._touch(this._renderer.textureGC.count))
          let n = this._renderer.bindGroup.getBindGroup(e, i, t)
          this.renderPassEncoder.setBindGroup(t, n)
        }
        setGeometry(t, e) {
          let i = this._renderer.pipeline.getBufferNamesToBind(t, e)
          for (let n in i) this._setVertexBuffer(n, t.attributes[i[n]].buffer)
          t.indexBuffer && this._setIndexBuffer(t.indexBuffer)
        }
        _setShaderBindGroups(t, e) {
          for (let i in t.groups) {
            let n = t.groups[i]
            ;(e || this._syncBindGroup(n), this.setBindGroup(i, n, t.gpuProgram))
          }
        }
        _syncBindGroup(t) {
          for (let e in t.resources) {
            let i = t.resources[e]
            i.isUniformGroup && this._renderer.ubo.updateUniformGroup(i)
          }
        }
        draw(t) {
          let {
            geometry: e,
            shader: i,
            state: n,
            topology: s,
            size: o,
            start: a,
            instanceCount: u,
            skipSync: l,
          } = t
          ;(this.setPipelineFromGeometryProgramAndState(e, i.gpuProgram, n, s),
            this.setGeometry(e, i.gpuProgram),
            this._setShaderBindGroups(i, l),
            e.indexBuffer
              ? this.renderPassEncoder.drawIndexed(
                  o || e.indexBuffer.data.length,
                  u ?? e.instanceCount,
                  a || 0,
                )
              : this.renderPassEncoder.draw(o || e.getSize(), u ?? e.instanceCount, a || 0))
        }
        finishRenderPass() {
          this.renderPassEncoder && (this.renderPassEncoder.end(), (this.renderPassEncoder = null))
        }
        postrender() {
          ;(this.finishRenderPass(),
            this._gpu.device.queue.submit([this.commandEncoder.finish()]),
            this._resolveCommandFinished(),
            (this.commandEncoder = null))
        }
        restoreRenderPass() {
          let t = this._renderer.renderTarget.adaptor.getDescriptor(
            this._renderer.renderTarget.renderTarget,
            !1,
            [0, 0, 0, 1],
          )
          this.renderPassEncoder = this.commandEncoder.beginRenderPass(t)
          let e = this._boundPipeline,
            i = { ...this._boundVertexBuffer },
            n = this._boundIndexBuffer,
            s = { ...this._boundBindGroup }
          this._clearCache()
          let o = this._renderer.renderTarget.viewport
          ;(this.renderPassEncoder.setViewport(o.x, o.y, o.width, o.height, 0, 1),
            this.setPipeline(e))
          for (let a in i) this._setVertexBuffer(a, i[a])
          for (let a in s) this.setBindGroup(a, s[a], null)
          this._setIndexBuffer(n)
        }
        _clearCache() {
          for (let t = 0; t < 16; t++)
            ((this._boundBindGroup[t] = null), (this._boundVertexBuffer[t] = null))
          ;((this._boundIndexBuffer = null), (this._boundPipeline = null))
        }
        destroy() {
          ;((this._renderer = null),
            (this._gpu = null),
            (this._boundBindGroup = null),
            (this._boundVertexBuffer = null),
            (this._boundIndexBuffer = null),
            (this._boundPipeline = null))
        }
        contextChange(t) {
          this._gpu = t
        }
      }
      xo.extension = { type: [b.WebGPUSystem], name: "encoder", priority: 1 }
    })
  var _o,
    PT = p(() => {
      A()
      _o = class {
        constructor(t) {
          this._renderer = t
        }
        contextChange() {
          ;((this.maxTextures =
            this._renderer.device.gpu.device.limits.maxSampledTexturesPerShaderStage),
            (this.maxBatchableTextures = this.maxTextures))
        }
        destroy() {}
      }
      _o.extension = { type: [b.WebGPUSystem], name: "limits" }
    })
  var yo,
    FT = p(() => {
      A()
      si()
      yo = class {
        constructor(t) {
          ;((this._renderTargetStencilState = Object.create(null)),
            (this._renderer = t),
            t.renderTarget.onRenderTargetChange.add(this))
        }
        onRenderTargetChange(t) {
          let e = this._renderTargetStencilState[t.uid]
          ;(e ||
            (e = this._renderTargetStencilState[t.uid] =
              { stencilMode: mt.DISABLED, stencilReference: 0 }),
            (this._activeRenderTarget = t),
            this.setStencilMode(e.stencilMode, e.stencilReference))
        }
        setStencilMode(t, e) {
          let i = this._renderTargetStencilState[this._activeRenderTarget.uid]
          ;((i.stencilMode = t), (i.stencilReference = e))
          let n = this._renderer
          ;(n.pipeline.setStencilMode(t), n.encoder.renderPassEncoder.setStencilReference(e))
        }
        destroy() {
          ;(this._renderer.renderTarget.onRenderTargetChange.remove(this),
            (this._renderer = null),
            (this._activeRenderTarget = null),
            (this._renderTargetStencilState = null))
        }
      }
      yo.extension = { type: [b.WebGPUSystem], name: "stencil" }
    })
  var _n,
    pd = p(() => {
      Yf()
      Cr()
      sr()
      _n = class {
        constructor(t) {
          ;((this._syncFunctionHash = Object.create(null)),
            (this._adaptor = t),
            this._systemCheck())
        }
        _systemCheck() {
          if (!Yu())
            throw new Error(
              "Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.",
            )
        }
        ensureUniformGroup(t) {
          let e = this.getUniformGroupData(t)
          t.buffer ||
            (t.buffer = new wt({
              data: new Float32Array(e.layout.size / 4),
              usage: tt.UNIFORM | tt.COPY_DST,
            }))
        }
        getUniformGroupData(t) {
          return this._syncFunctionHash[t._signature] || this._initUniformGroup(t)
        }
        _initUniformGroup(t) {
          let e = t._signature,
            i = this._syncFunctionHash[e]
          if (!i) {
            let n = Object.keys(t.uniformStructures).map((a) => t.uniformStructures[a]),
              s = this._adaptor.createUboElements(n),
              o = this._generateUboSync(s.uboElements)
            i = this._syncFunctionHash[e] = { layout: s, syncFunction: o }
          }
          return this._syncFunctionHash[e]
        }
        _generateUboSync(t) {
          return this._adaptor.generateUboSync(t)
        }
        syncUniformGroup(t, e, i) {
          let n = this.getUniformGroupData(t)
          t.buffer ||
            (t.buffer = new wt({
              data: new Float32Array(n.layout.size / 4),
              usage: tt.UNIFORM | tt.COPY_DST,
            }))
          let s = null
          return (
            e || ((e = t.buffer.data), (s = t.buffer.dataInt32)),
            i || (i = 0),
            n.syncFunction(t.uniforms, e, s, i),
            !0
          )
        }
        updateUniformGroup(t) {
          if (t.isStatic && !t._dirtyId) return !1
          t._dirtyId = 0
          let e = this.syncUniformGroup(t)
          return (t.buffer.update(), e)
        }
        destroy() {
          this._syncFunctionHash = null
        }
      }
    })
  function RT(r) {
    let t = r.map((i) => ({ data: i, offset: 0, size: 0 })),
      e = 0
    for (let i = 0; i < t.length; i++) {
      let n = t[i],
        s = bo[n.data.type].size,
        o = bo[n.data.type].align
      if (!bo[n.data.type])
        throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${n.data.type}`)
      ;(n.data.size > 1 && (s = Math.max(s, o) * n.data.size),
        (e = Math.ceil(e / o) * o),
        (n.size = s),
        (n.offset = e),
        (e += s))
    }
    return ((e = Math.ceil(e / 16) * 16), { uboElements: t, size: e })
  }
  var bo,
    md = p(() => {
      "use strict"
      bo = {
        i32: { align: 4, size: 4 },
        u32: { align: 4, size: 4 },
        f32: { align: 4, size: 4 },
        f16: { align: 2, size: 2 },
        "vec2<i32>": { align: 8, size: 8 },
        "vec2<u32>": { align: 8, size: 8 },
        "vec2<f32>": { align: 8, size: 8 },
        "vec2<f16>": { align: 4, size: 4 },
        "vec3<i32>": { align: 16, size: 12 },
        "vec3<u32>": { align: 16, size: 12 },
        "vec3<f32>": { align: 16, size: 12 },
        "vec3<f16>": { align: 8, size: 6 },
        "vec4<i32>": { align: 16, size: 16 },
        "vec4<u32>": { align: 16, size: 16 },
        "vec4<f32>": { align: 16, size: 16 },
        "vec4<f16>": { align: 8, size: 8 },
        "mat2x2<f32>": { align: 8, size: 16 },
        "mat2x2<f16>": { align: 4, size: 8 },
        "mat3x2<f32>": { align: 8, size: 24 },
        "mat3x2<f16>": { align: 4, size: 12 },
        "mat4x2<f32>": { align: 8, size: 32 },
        "mat4x2<f16>": { align: 4, size: 16 },
        "mat2x3<f32>": { align: 16, size: 32 },
        "mat2x3<f16>": { align: 8, size: 16 },
        "mat3x3<f32>": { align: 16, size: 48 },
        "mat3x3<f16>": { align: 8, size: 24 },
        "mat4x3<f32>": { align: 16, size: 64 },
        "mat4x3<f16>": { align: 8, size: 32 },
        "mat2x4<f32>": { align: 16, size: 32 },
        "mat2x4<f16>": { align: 8, size: 16 },
        "mat3x4<f32>": { align: 16, size: 48 },
        "mat3x4<f16>": { align: 8, size: 24 },
        "mat4x4<f32>": { align: 16, size: 64 },
        "mat4x4<f16>": { align: 8, size: 32 },
      }
    })
  var cr,
    gd = p(() => {
      "use strict"
      cr = [
        {
          type: "mat3x3<f32>",
          test: (r) => r.value.a !== void 0,
          ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,
          uniform: `
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `,
        },
        {
          type: "vec4<f32>",
          test: (r) => r.type === "vec4<f32>" && r.size === 1 && r.value.width !== void 0,
          ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,
          uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `,
        },
        {
          type: "vec2<f32>",
          test: (r) => r.type === "vec2<f32>" && r.size === 1 && r.value.x !== void 0,
          ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,
          uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `,
        },
        {
          type: "vec4<f32>",
          test: (r) => r.type === "vec4<f32>" && r.size === 1 && r.value.red !== void 0,
          ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,
          uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `,
        },
        {
          type: "vec3<f32>",
          test: (r) => r.type === "vec3<f32>" && r.size === 1 && r.value.red !== void 0,
          ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,
          uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `,
        },
      ]
    })
  function rl(r, t, e, i) {
    let n = [
        `
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `,
      ],
      s = 0
    for (let a = 0; a < r.length; a++) {
      let u = r[a],
        l = u.data.name,
        c = !1,
        h = 0
      for (let f = 0; f < cr.length; f++)
        if (cr[f].test(u.data)) {
          ;((h = u.offset / 4),
            n.push(`name = "${l}";`, `offset += ${h - s};`, cr[f][t] || cr[f].ubo),
            (c = !0))
          break
        }
      if (!c)
        if (u.data.size > 1) ((h = u.offset / 4), n.push(e(u, h - s)))
        else {
          let f = i[u.data.type]
          ;((h = u.offset / 4),
            n.push(`
                    v = uv.${l};
                    offset += ${h - s};
                    ${f};
                `))
        }
      s = h
    }
    let o = n.join(`
`)
    return new Function("uv", "data", "dataInt32", "offset", o)
  }
  var xd = p(() => {
    gd()
  })
  function yn(r, t) {
    return `
        for (let i = 0; i < ${r * t}; i++) {
            data[offset + (((i / ${r})|0) * 4) + (i % ${r})] = v[i];
        }
    `
  }
  var _d,
    BT,
    yd = p(() => {
      "use strict"
      ;((_d = {
        f32: `
        data[offset] = v;`,
        i32: `
        dataInt32[offset] = v;`,
        "vec2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];`,
        "vec3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,
        "vec4<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,
        "vec2<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];`,
        "vec3<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];`,
        "vec4<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];
        dataInt32[offset + 3] = v[3];`,
        "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,
        "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,
        "mat4x4<f32>": `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,
        "mat3x2<f32>": yn(3, 2),
        "mat4x2<f32>": yn(4, 2),
        "mat2x3<f32>": yn(2, 3),
        "mat4x3<f32>": yn(4, 3),
        "mat2x4<f32>": yn(2, 4),
        "mat3x4<f32>": yn(3, 4),
      }),
        (BT = {
          ..._d,
          "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `,
        }))
    })
  function IT(r, t) {
    let { size: e, align: i } = bo[r.data.type],
      n = (i - e) / 4,
      s = r.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data"
    return `
         v = uv.${r.data.name};
         ${t !== 0 ? `offset += ${t};` : ""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${r.data.size * (e / 4)}; i++)
         {
             for(var j = 0; j < ${e / 4}; j++)
             {
                 ${s}[arrayOffset++] = v[t++];
             }
             ${n !== 0 ? `arrayOffset += ${n};` : ""}
         }
     `
  }
  var kT = p(() => {
    md()
  })
  function GT(r) {
    return rl(r, "uboWgsl", IT, BT)
  }
  var UT = p(() => {
    xd()
    yd()
    kT()
  })
  var vo,
    OT = p(() => {
      A()
      pd()
      md()
      UT()
      vo = class extends _n {
        constructor() {
          super({ createUboElements: RT, generateUboSync: GT })
        }
      }
      vo.extension = { type: [b.WebGPUSystem], name: "ubo" }
    })
  var Rr,
    il = p(() => {
      Wt()
      Ot()
      Rr = class extends lt {
        constructor({ buffer: t, offset: e, size: i }) {
          ;(super(),
            (this.uid = J("buffer")),
            (this._resourceType = "bufferResource"),
            (this._touched = 0),
            (this._resourceId = J("resource")),
            (this._bufferResource = !0),
            (this.destroyed = !1),
            (this.buffer = t),
            (this.offset = e | 0),
            (this.size = i),
            this.buffer.on("change", this.onBufferChange, this))
        }
        onBufferChange() {
          ;((this._resourceId = J("resource")), this.emit("change", this))
        }
        destroy(t = !1) {
          ;((this.destroyed = !0),
            t && this.buffer.destroy(),
            this.emit("change", this),
            (this.buffer = null))
        }
      }
    })
  var nl,
    LT = p(() => {
      "use strict"
      nl = class {
        constructor({ minUniformOffsetAlignment: t }) {
          ;((this._minUniformOffsetAlignment = 256),
            (this.byteIndex = 0),
            (this._minUniformOffsetAlignment = t),
            (this.data = new Float32Array(65535)))
        }
        clear() {
          this.byteIndex = 0
        }
        addEmptyGroup(t) {
          if (t > this._minUniformOffsetAlignment / 4)
            throw new Error(`UniformBufferBatch: array is too large: ${t * 4}`)
          let e = this.byteIndex,
            i = e + t * 4
          if (
            ((i = Math.ceil(i / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment),
            i > this.data.length * 4)
          )
            throw new Error("UniformBufferBatch: ubo batch got too big")
          return ((this.byteIndex = i), e)
        }
        addGroup(t) {
          let e = this.addEmptyGroup(t.length)
          for (let i = 0; i < t.length; i++) this.data[e / 4 + i] = t[i]
          return e
        }
        destroy() {
          this.data = null
        }
      }
    })
  var Br,
    So,
    NT = p(() => {
      A()
      Cr()
      il()
      sr()
      LT()
      Tr()
      ;((Br = 128),
        (So = class {
          constructor(t) {
            ;((this._bindGroupHash = Object.create(null)),
              (this._buffers = []),
              (this._bindGroups = []),
              (this._bufferResources = []),
              (this._renderer = t),
              this._renderer.renderableGC.addManagedHash(this, "_bindGroupHash"),
              (this._batchBuffer = new nl({ minUniformOffsetAlignment: Br })))
            let e = 256 / Br
            for (let i = 0; i < e; i++) {
              let n = tt.UNIFORM | tt.COPY_DST
              ;(i === 0 && (n |= tt.COPY_SRC),
                this._buffers.push(new wt({ data: this._batchBuffer.data, usage: n })))
            }
          }
          renderEnd() {
            ;(this._uploadBindGroups(), this._resetBindGroups())
          }
          _resetBindGroups() {
            for (let t in this._bindGroupHash) this._bindGroupHash[t] = null
            this._batchBuffer.clear()
          }
          getUniformBindGroup(t, e) {
            if (!e && this._bindGroupHash[t.uid]) return this._bindGroupHash[t.uid]
            this._renderer.ubo.ensureUniformGroup(t)
            let i = t.buffer.data,
              n = this._batchBuffer.addEmptyGroup(i.length)
            return (
              this._renderer.ubo.syncUniformGroup(t, this._batchBuffer.data, n / 4),
              (this._bindGroupHash[t.uid] = this._getBindGroup(n / Br)),
              this._bindGroupHash[t.uid]
            )
          }
          getUboResource(t) {
            this._renderer.ubo.updateUniformGroup(t)
            let e = t.buffer.data,
              i = this._batchBuffer.addGroup(e)
            return this._getBufferResource(i / Br)
          }
          getArrayBindGroup(t) {
            let e = this._batchBuffer.addGroup(t)
            return this._getBindGroup(e / Br)
          }
          getArrayBufferResource(t) {
            let i = this._batchBuffer.addGroup(t) / Br
            return this._getBufferResource(i)
          }
          _getBufferResource(t) {
            if (!this._bufferResources[t]) {
              let e = this._buffers[t % 2]
              this._bufferResources[t] = new Rr({
                buffer: e,
                offset: ((t / 2) | 0) * 256,
                size: Br,
              })
            }
            return this._bufferResources[t]
          }
          _getBindGroup(t) {
            if (!this._bindGroups[t]) {
              let e = new Nt({ 0: this._getBufferResource(t) })
              this._bindGroups[t] = e
            }
            return this._bindGroups[t]
          }
          _uploadBindGroups() {
            let t = this._renderer.buffer,
              e = this._buffers[0]
            ;(e.update(this._batchBuffer.byteIndex), t.updateBuffer(e))
            let i = this._renderer.gpu.device.createCommandEncoder()
            for (let n = 1; n < this._buffers.length; n++) {
              let s = this._buffers[n]
              i.copyBufferToBuffer(
                t.getGPUBuffer(e),
                Br,
                t.getGPUBuffer(s),
                0,
                this._batchBuffer.byteIndex,
              )
            }
            this._renderer.gpu.device.queue.submit([i.finish()])
          }
          destroy() {
            for (let t = 0; t < this._bindGroups.length; t++) this._bindGroups[t].destroy()
            ;((this._bindGroups = null), (this._bindGroupHash = null))
            for (let t = 0; t < this._buffers.length; t++) this._buffers[t].destroy()
            this._buffers = null
            for (let t = 0; t < this._bufferResources.length; t++)
              this._bufferResources[t].destroy()
            ;((this._bufferResources = null),
              this._batchBuffer.destroy(),
              (this._bindGroupHash = null),
              (this._renderer = null))
          }
        }))
      So.extension = { type: [b.WebGPUPipes], name: "uniformBatch" }
    })
  function sl(r, t) {
    for (let e in r.attributes) {
      let i = r.attributes[e],
        n = t[e]
      n
        ? (i.format ?? (i.format = n.format),
          i.offset ?? (i.offset = n.offset),
          i.instance ?? (i.instance = n.instance))
        : N(
            `Attribute ${e} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`,
          )
    }
    oP(r)
  }
  function oP(r) {
    let { buffers: t, attributes: e } = r,
      i = {},
      n = {}
    for (let s in t) {
      let o = t[s]
      ;((i[o.uid] = 0), (n[o.uid] = 0))
    }
    for (let s in e) {
      let o = e[s]
      i[o.buffer.uid] += ae(o.format).stride
    }
    for (let s in e) {
      let o = e[s]
      ;(o.stride ?? (o.stride = i[o.buffer.uid]),
        o.start ?? (o.start = n[o.buffer.uid]),
        (n[o.buffer.uid] += ae(o.format).stride))
    }
  }
  var bd = p(() => {
    ft()
    ai()
  })
  var Ve,
    vd = p(() => {
      si()
      Ve = []
      Ve[mt.NONE] = void 0
      Ve[mt.DISABLED] = { stencilWriteMask: 0, stencilReadMask: 0 }
      Ve[mt.RENDERING_MASK_ADD] = {
        stencilFront: { compare: "equal", passOp: "increment-clamp" },
        stencilBack: { compare: "equal", passOp: "increment-clamp" },
      }
      Ve[mt.RENDERING_MASK_REMOVE] = {
        stencilFront: { compare: "equal", passOp: "decrement-clamp" },
        stencilBack: { compare: "equal", passOp: "decrement-clamp" },
      }
      Ve[mt.MASK_ACTIVE] = {
        stencilWriteMask: 0,
        stencilFront: { compare: "equal", passOp: "keep" },
        stencilBack: { compare: "equal", passOp: "keep" },
      }
      Ve[mt.INVERSE_MASK_ACTIVE] = {
        stencilWriteMask: 0,
        stencilFront: { compare: "not-equal", passOp: "keep" },
        stencilBack: { compare: "not-equal", passOp: "keep" },
      }
    })
  function uP(r, t, e, i, n) {
    return (r << 24) | (t << 16) | (e << 10) | (i << 5) | n
  }
  function lP(r, t, e, i) {
    return (e << 6) | (r << 3) | (i << 1) | t
  }
  var aP,
    To,
    HT = p(() => {
      A()
      ft()
      bd()
      si()
      ys()
      vd()
      aP = {
        "point-list": 0,
        "line-list": 1,
        "line-strip": 2,
        "triangle-list": 3,
        "triangle-strip": 4,
      }
      To = class {
        constructor(t) {
          ;((this._moduleCache = Object.create(null)),
            (this._bufferLayoutsCache = Object.create(null)),
            (this._bindingNamesCache = Object.create(null)),
            (this._pipeCache = Object.create(null)),
            (this._pipeStateCaches = Object.create(null)),
            (this._colorMask = 15),
            (this._multisampleCount = 1),
            (this._renderer = t))
        }
        contextChange(t) {
          ;((this._gpu = t), this.setStencilMode(mt.DISABLED), this._updatePipeHash())
        }
        setMultisampleCount(t) {
          this._multisampleCount !== t && ((this._multisampleCount = t), this._updatePipeHash())
        }
        setRenderTarget(t) {
          ;((this._multisampleCount = t.msaaSamples),
            (this._depthStencilAttachment = t.descriptor.depthStencilAttachment ? 1 : 0),
            this._updatePipeHash())
        }
        setColorMask(t) {
          this._colorMask !== t && ((this._colorMask = t), this._updatePipeHash())
        }
        setStencilMode(t) {
          this._stencilMode !== t &&
            ((this._stencilMode = t), (this._stencilState = Ve[t]), this._updatePipeHash())
        }
        setPipeline(t, e, i, n) {
          let s = this.getPipeline(t, e, i)
          n.setPipeline(s)
        }
        getPipeline(t, e, i, n) {
          ;(t._layoutKey || (sl(t, e.attributeData), this._generateBufferKey(t)),
            n || (n = t.topology))
          let s = uP(t._layoutKey, e._layoutKey, i.data, i._blendModeId, aP[n])
          return this._pipeCache[s]
            ? this._pipeCache[s]
            : ((this._pipeCache[s] = this._createPipeline(t, e, i, n)), this._pipeCache[s])
        }
        _createPipeline(t, e, i, n) {
          let s = this._gpu.device,
            o = this._createVertexBufferLayouts(t, e),
            a = this._renderer.state.getColorTargets(i)
          a[0].writeMask = this._stencilMode === mt.RENDERING_MASK_ADD ? 0 : this._colorMask
          let u = this._renderer.shader.getProgramData(e).pipeline,
            l = {
              vertex: {
                module: this._getModule(e.vertex.source),
                entryPoint: e.vertex.entryPoint,
                buffers: o,
              },
              fragment: {
                module: this._getModule(e.fragment.source),
                entryPoint: e.fragment.entryPoint,
                targets: a,
              },
              primitive: { topology: n, cullMode: i.cullMode },
              layout: u,
              multisample: { count: this._multisampleCount },
              label: "PIXI Pipeline",
            }
          return (
            this._depthStencilAttachment &&
              (l.depthStencil = {
                ...this._stencilState,
                format: "depth24plus-stencil8",
                depthWriteEnabled: i.depthTest,
                depthCompare: i.depthTest ? "less" : "always",
              }),
            s.createRenderPipeline(l)
          )
        }
        _getModule(t) {
          return this._moduleCache[t] || this._createModule(t)
        }
        _createModule(t) {
          let e = this._gpu.device
          return ((this._moduleCache[t] = e.createShaderModule({ code: t })), this._moduleCache[t])
        }
        _generateBufferKey(t) {
          let e = [],
            i = 0,
            n = Object.keys(t.attributes).sort()
          for (let o = 0; o < n.length; o++) {
            let a = t.attributes[n[o]]
            ;((e[i++] = a.offset), (e[i++] = a.format), (e[i++] = a.stride), (e[i++] = a.instance))
          }
          let s = e.join("|")
          return ((t._layoutKey = or(s, "geometry")), t._layoutKey)
        }
        _generateAttributeLocationsKey(t) {
          let e = [],
            i = 0,
            n = Object.keys(t.attributeData).sort()
          for (let o = 0; o < n.length; o++) {
            let a = t.attributeData[n[o]]
            e[i++] = a.location
          }
          let s = e.join("|")
          return ((t._attributeLocationsKey = or(s, "programAttributes")), t._attributeLocationsKey)
        }
        getBufferNamesToBind(t, e) {
          let i = (t._layoutKey << 16) | e._attributeLocationsKey
          if (this._bindingNamesCache[i]) return this._bindingNamesCache[i]
          let n = this._createVertexBufferLayouts(t, e),
            s = Object.create(null),
            o = e.attributeData
          for (let a = 0; a < n.length; a++) {
            let l = Object.values(n[a].attributes)[0].shaderLocation
            for (let c in o)
              if (o[c].location === l) {
                s[a] = c
                break
              }
          }
          return ((this._bindingNamesCache[i] = s), s)
        }
        _createVertexBufferLayouts(t, e) {
          e._attributeLocationsKey || this._generateAttributeLocationsKey(e)
          let i = (t._layoutKey << 16) | e._attributeLocationsKey
          if (this._bufferLayoutsCache[i]) return this._bufferLayoutsCache[i]
          let n = []
          return (
            t.buffers.forEach((s) => {
              let o = { arrayStride: 0, stepMode: "vertex", attributes: [] },
                a = o.attributes
              for (let u in e.attributeData) {
                let l = t.attributes[u]
                ;((l.divisor ?? 1) !== 1 &&
                  N(
                    `Attribute ${u} has an invalid divisor value of '${l.divisor}'. WebGPU only supports a divisor value of 1`,
                  ),
                  l.buffer === s &&
                    ((o.arrayStride = l.stride),
                    (o.stepMode = l.instance ? "instance" : "vertex"),
                    a.push({
                      shaderLocation: e.attributeData[u].location,
                      offset: l.offset,
                      format: l.format,
                    })))
              }
              a.length && n.push(o)
            }),
            (this._bufferLayoutsCache[i] = n),
            n
          )
        }
        _updatePipeHash() {
          let t = lP(
            this._stencilMode,
            this._multisampleCount,
            this._colorMask,
            this._depthStencilAttachment,
          )
          ;(this._pipeStateCaches[t] || (this._pipeStateCaches[t] = Object.create(null)),
            (this._pipeCache = this._pipeStateCaches[t]))
        }
        destroy() {
          ;((this._renderer = null), (this._bufferLayoutsCache = null))
        }
      }
      To.extension = { type: [b.WebGPUSystem], name: "pipeline" }
    })
  function zT(r, t, e, i, n, s) {
    let o = s ? 1 : -1
    return (
      r.identity(),
      (r.a = (1 / i) * 2),
      (r.d = o * ((1 / n) * 2)),
      (r.tx = -1 - t * r.a),
      (r.ty = -o - e * r.d),
      r
    )
  }
  var WT = p(() => {
    "use strict"
  })
  function VT(r) {
    let t = r.colorTexture.source.resource
    return (
      globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement && document.body.contains(t)
    )
  }
  var $T = p(() => {
    "use strict"
  })
  var bn,
    Sd = p(() => {
      nt()
      Lt()
      dn()
      WT()
      jf()
      Ui()
      te()
      dt()
      hd()
      $T()
      cd()
      bn = class {
        constructor(t) {
          ;((this.rootViewPort = new Q()),
            (this.viewport = new Q()),
            (this.onRenderTargetChange = new pn("onRenderTargetChange")),
            (this.projectionMatrix = new I()),
            (this.defaultClearColor = [0, 0, 0, 0]),
            (this._renderSurfaceToRenderTargetHash = new Map()),
            (this._gpuRenderTargetHash = Object.create(null)),
            (this._renderTargetStack = []),
            (this._renderer = t),
            t.renderableGC.addManagedHash(this, "_gpuRenderTargetHash"))
        }
        finishRenderPass() {
          this.adaptor.finishRenderPass(this.renderTarget)
        }
        renderStart({ target: t, clear: e, clearColor: i, frame: n }) {
          ;((this._renderTargetStack.length = 0),
            this.push(t, e, i, n),
            this.rootViewPort.copyFrom(this.viewport),
            (this.rootRenderTarget = this.renderTarget),
            (this.renderingToScreen = VT(this.rootRenderTarget)),
            this.adaptor.prerender?.(this.rootRenderTarget))
        }
        postrender() {
          this.adaptor.postrender?.(this.rootRenderTarget)
        }
        bind(t, e = !0, i, n) {
          let s = this.getRenderTarget(t),
            o = this.renderTarget !== s
          ;((this.renderTarget = s), (this.renderSurface = t))
          let a = this.getGpuRenderTarget(s)
          ;(s.pixelWidth !== a.width || s.pixelHeight !== a.height) &&
            (this.adaptor.resizeGpuRenderTarget(s),
            (a.width = s.pixelWidth),
            (a.height = s.pixelHeight))
          let u = s.colorTexture,
            l = this.viewport,
            c = u.pixelWidth,
            h = u.pixelHeight
          if ((!n && t instanceof k && (n = t.frame), n)) {
            let f = u._resolution
            ;((l.x = (n.x * f + 0.5) | 0),
              (l.y = (n.y * f + 0.5) | 0),
              (l.width = (n.width * f + 0.5) | 0),
              (l.height = (n.height * f + 0.5) | 0))
          } else ((l.x = 0), (l.y = 0), (l.width = c), (l.height = h))
          return (
            zT(
              this.projectionMatrix,
              0,
              0,
              l.width / u.resolution,
              l.height / u.resolution,
              !s.isRoot,
            ),
            this.adaptor.startRenderPass(s, e, i, l),
            o && this.onRenderTargetChange.emit(s),
            s
          )
        }
        clear(t, e = Ht.ALL, i) {
          e &&
            (t && (t = this.getRenderTarget(t)),
            this.adaptor.clear(t || this.renderTarget, e, i, this.viewport))
        }
        contextChange() {
          this._gpuRenderTargetHash = Object.create(null)
        }
        push(t, e = Ht.ALL, i, n) {
          let s = this.bind(t, e, i, n)
          return (this._renderTargetStack.push({ renderTarget: s, frame: n }), s)
        }
        pop() {
          this._renderTargetStack.pop()
          let t = this._renderTargetStack[this._renderTargetStack.length - 1]
          this.bind(t.renderTarget, !1, null, t.frame)
        }
        getRenderTarget(t) {
          return (
            t.isTexture && (t = t.source),
            this._renderSurfaceToRenderTargetHash.get(t) ?? this._initRenderTarget(t)
          )
        }
        copyToTexture(t, e, i, n, s) {
          ;(i.x < 0 && ((n.width += i.x), (s.x -= i.x), (i.x = 0)),
            i.y < 0 && ((n.height += i.y), (s.y -= i.y), (i.y = 0)))
          let { pixelWidth: o, pixelHeight: a } = t
          return (
            (n.width = Math.min(n.width, o - i.x)),
            (n.height = Math.min(n.height, a - i.y)),
            this.adaptor.copyToTexture(t, e, i, n, s)
          )
        }
        ensureDepthStencil() {
          this.renderTarget.stencil ||
            ((this.renderTarget.stencil = !0),
            this.adaptor.startRenderPass(this.renderTarget, !1, null, this.viewport))
        }
        destroy() {
          ;((this._renderer = null),
            this._renderSurfaceToRenderTargetHash.forEach((t, e) => {
              t !== e && t.destroy()
            }),
            this._renderSurfaceToRenderTargetHash.clear(),
            (this._gpuRenderTargetHash = Object.create(null)))
        }
        _initRenderTarget(t) {
          let e = null
          return (
            Yt.test(t) && (t = Ju(t).source),
            t instanceof ho
              ? (e = t)
              : t instanceof ot &&
                ((e = new ho({ colorTextures: [t] })),
                t.source instanceof Yt && (e.isRoot = !0),
                t.once("destroy", () => {
                  ;(e.destroy(), this._renderSurfaceToRenderTargetHash.delete(t))
                  let i = this._gpuRenderTargetHash[e.uid]
                  i &&
                    ((this._gpuRenderTargetHash[e.uid] = null),
                    this.adaptor.destroyGpuRenderTarget(i))
                })),
            this._renderSurfaceToRenderTargetHash.set(t, e),
            e
          )
        }
        getGpuRenderTarget(t) {
          return (
            this._gpuRenderTargetHash[t.uid] ||
            (this._gpuRenderTargetHash[t.uid] = this.adaptor.initGpuRenderTarget(t))
          )
        }
        resetState() {
          ;((this.renderTarget = null), (this.renderSurface = null))
        }
      }
    })
  var ol,
    XT = p(() => {
      "use strict"
      ol = class {
        constructor() {
          ;((this.contexts = []), (this.msaaTextures = []), (this.msaaSamples = 1))
        }
      }
    })
  var al,
    YT = p(() => {
      dn()
      Ui()
      te()
      XT()
      al = class {
        init(t, e) {
          ;((this._renderer = t), (this._renderTargetSystem = e))
        }
        copyToTexture(t, e, i, n, s) {
          let o = this._renderer,
            a = this._getGpuColorTexture(t),
            u = o.texture.getGpuSource(e.source)
          return (
            o.encoder.commandEncoder.copyTextureToTexture(
              { texture: a, origin: i },
              { texture: u, origin: s },
              n,
            ),
            e
          )
        }
        startRenderPass(t, e = !0, i, n) {
          let o = this._renderTargetSystem.getGpuRenderTarget(t),
            a = this.getDescriptor(t, e, i)
          ;((o.descriptor = a),
            this._renderer.pipeline.setRenderTarget(o),
            this._renderer.encoder.beginRenderPass(o),
            this._renderer.encoder.setViewport(n))
        }
        finishRenderPass() {
          this._renderer.encoder.endRenderPass()
        }
        _getGpuColorTexture(t) {
          let e = this._renderTargetSystem.getGpuRenderTarget(t)
          return e.contexts[0]
            ? e.contexts[0].getCurrentTexture()
            : this._renderer.texture.getGpuSource(t.colorTextures[0].source)
        }
        getDescriptor(t, e, i) {
          typeof e == "boolean" && (e = e ? Ht.ALL : Ht.NONE)
          let n = this._renderTargetSystem,
            s = n.getGpuRenderTarget(t),
            o = t.colorTextures.map((l, c) => {
              let h = s.contexts[c],
                f,
                d
              ;(h
                ? (f = h.getCurrentTexture().createView())
                : (f = this._renderer.texture.getGpuSource(l).createView({ mipLevelCount: 1 })),
                s.msaaTextures[c] &&
                  ((d = f), (f = this._renderer.texture.getTextureView(s.msaaTextures[c]))))
              let g = e & Ht.COLOR ? "clear" : "load"
              return (
                i ?? (i = n.defaultClearColor),
                { view: f, resolveTarget: d, clearValue: i, storeOp: "store", loadOp: g }
              )
            }),
            a
          if (
            ((t.stencil || t.depth) &&
              !t.depthStencilTexture &&
              (t.ensureDepthStencilTexture(),
              (t.depthStencilTexture.source.sampleCount = s.msaa ? 4 : 1)),
            t.depthStencilTexture)
          ) {
            let l = e & Ht.STENCIL ? "clear" : "load",
              c = e & Ht.DEPTH ? "clear" : "load"
            a = {
              view: this._renderer.texture.getGpuSource(t.depthStencilTexture.source).createView(),
              stencilStoreOp: "store",
              stencilLoadOp: l,
              depthClearValue: 1,
              depthLoadOp: c,
              depthStoreOp: "store",
            }
          }
          return { colorAttachments: o, depthStencilAttachment: a }
        }
        clear(t, e = !0, i, n) {
          if (!e) return
          let { gpu: s, encoder: o } = this._renderer,
            a = s.device
          if (o.commandEncoder === null) {
            let l = a.createCommandEncoder(),
              c = this.getDescriptor(t, e, i),
              h = l.beginRenderPass(c)
            ;(h.setViewport(n.x, n.y, n.width, n.height, 0, 1), h.end())
            let f = l.finish()
            a.queue.submit([f])
          } else this.startRenderPass(t, e, i, n)
        }
        initGpuRenderTarget(t) {
          t.isRoot = !0
          let e = new ol()
          return (
            t.colorTextures.forEach((i, n) => {
              if (i instanceof Yt) {
                let s = i.resource.getContext("webgpu"),
                  o = i.transparent ? "premultiplied" : "opaque"
                try {
                  s.configure({
                    device: this._renderer.gpu.device,
                    usage:
                      GPUTextureUsage.TEXTURE_BINDING |
                      GPUTextureUsage.COPY_DST |
                      GPUTextureUsage.RENDER_ATTACHMENT |
                      GPUTextureUsage.COPY_SRC,
                    format: "bgra8unorm",
                    alphaMode: o,
                  })
                } catch (a) {
                  console.error(a)
                }
                e.contexts[n] = s
              }
              if (((e.msaa = i.source.antialias), i.source.antialias)) {
                let s = new ot({ width: 0, height: 0, sampleCount: 4 })
                e.msaaTextures[n] = s
              }
            }),
            e.msaa &&
              ((e.msaaSamples = 4),
              t.depthStencilTexture && (t.depthStencilTexture.source.sampleCount = 4)),
            e
          )
        }
        destroyGpuRenderTarget(t) {
          ;(t.contexts.forEach((e) => {
            e.unconfigure()
          }),
            t.msaaTextures.forEach((e) => {
              e.destroy()
            }),
            (t.msaaTextures.length = 0),
            (t.contexts.length = 0))
        }
        ensureDepthStencilTexture(t) {
          let e = this._renderTargetSystem.getGpuRenderTarget(t)
          t.depthStencilTexture && e.msaa && (t.depthStencilTexture.source.sampleCount = 4)
        }
        resizeGpuRenderTarget(t) {
          let e = this._renderTargetSystem.getGpuRenderTarget(t)
          ;((e.width = t.width),
            (e.height = t.height),
            e.msaa &&
              t.colorTextures.forEach((i, n) => {
                e.msaaTextures[n]?.resize(i.source.width, i.source.height, i.source._resolution)
              }))
        }
      }
    })
  var Co,
    jT = p(() => {
      A()
      Sd()
      YT()
      Co = class extends bn {
        constructor(t) {
          ;(super(t), (this.adaptor = new al()), this.adaptor.init(t, this))
        }
      }
      Co.extension = { type: [b.WebGPUSystem], name: "renderTarget" }
    })
  var Eo,
    KT = p(() => {
      A()
      Eo = class {
        constructor() {
          this._gpuProgramData = Object.create(null)
        }
        contextChange(t) {
          this._gpu = t
        }
        getProgramData(t) {
          return this._gpuProgramData[t._layoutKey] || this._createGPUProgramData(t)
        }
        _createGPUProgramData(t) {
          let e = this._gpu.device,
            i = t.gpuLayout.map((s) => e.createBindGroupLayout({ entries: s })),
            n = { bindGroupLayouts: i }
          return (
            (this._gpuProgramData[t._layoutKey] = {
              bindGroups: i,
              pipeline: e.createPipelineLayout(n),
            }),
            this._gpuProgramData[t._layoutKey]
          )
        }
        destroy() {
          ;((this._gpu = null), (this._gpuProgramData = null))
        }
      }
      Eo.extension = { type: [b.WebGPUSystem], name: "shader" }
    })
  var ie,
    qT = p(() => {
      "use strict"
      ie = {}
      ie.normal = {
        alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" },
        color: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" },
      }
      ie.add = {
        alpha: { srcFactor: "src-alpha", dstFactor: "one-minus-src-alpha", operation: "add" },
        color: { srcFactor: "one", dstFactor: "one", operation: "add" },
      }
      ie.multiply = {
        alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" },
        color: { srcFactor: "dst", dstFactor: "one-minus-src-alpha", operation: "add" },
      }
      ie.screen = {
        alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" },
        color: { srcFactor: "one", dstFactor: "one-minus-src", operation: "add" },
      }
      ie.overlay = {
        alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" },
        color: { srcFactor: "one", dstFactor: "one-minus-src", operation: "add" },
      }
      ie.none = {
        alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" },
        color: { srcFactor: "zero", dstFactor: "zero", operation: "add" },
      }
      ie["normal-npm"] = {
        alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" },
        color: { srcFactor: "src-alpha", dstFactor: "one-minus-src-alpha", operation: "add" },
      }
      ie["add-npm"] = {
        alpha: { srcFactor: "one", dstFactor: "one", operation: "add" },
        color: { srcFactor: "src-alpha", dstFactor: "one", operation: "add" },
      }
      ie["screen-npm"] = {
        alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" },
        color: { srcFactor: "src-alpha", dstFactor: "one-minus-src", operation: "add" },
      }
      ie.erase = {
        alpha: { srcFactor: "zero", dstFactor: "one-minus-src-alpha", operation: "add" },
        color: { srcFactor: "zero", dstFactor: "one-minus-src", operation: "add" },
      }
      ie.min = {
        alpha: { srcFactor: "one", dstFactor: "one", operation: "min" },
        color: { srcFactor: "one", dstFactor: "one", operation: "min" },
      }
      ie.max = {
        alpha: { srcFactor: "one", dstFactor: "one", operation: "max" },
        color: { srcFactor: "one", dstFactor: "one", operation: "max" },
      }
    })
  var wo,
    ZT = p(() => {
      A()
      De()
      qT()
      wo = class {
        constructor() {
          ;((this.defaultState = new Dt()), (this.defaultState.blend = !0))
        }
        contextChange(t) {
          this.gpu = t
        }
        getColorTargets(t) {
          return [{ format: "bgra8unorm", writeMask: 0, blend: ie[t.blendMode] || ie.normal }]
        }
        destroy() {
          this.gpu = null
        }
      }
      wo.extension = { type: [b.WebGPUSystem], name: "state" }
    })
  var QT,
    JT = p(() => {
      "use strict"
      QT = {
        type: "image",
        upload(r, t, e) {
          let i = r.resource,
            n = (r.pixelWidth | 0) * (r.pixelHeight | 0),
            s = i.byteLength / n
          e.device.queue.writeTexture(
            { texture: t },
            i,
            { offset: 0, rowsPerImage: r.pixelHeight, bytesPerRow: r.pixelHeight * s },
            { width: r.pixelWidth, height: r.pixelHeight, depthOrArrayLayers: 1 },
          )
        },
      }
    })
  var Td,
    cP,
    tC,
    eC = p(() => {
      "use strict"
      ;((Td = {
        "bc1-rgba-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
        "bc2-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        "bc3-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        "bc7-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        "etc1-rgb-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
        "etc2-rgba8unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        "astc-4x4-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
      }),
        (cP = { blockBytes: 4, blockWidth: 1, blockHeight: 1 }),
        (tC = {
          type: "compressed",
          upload(r, t, e) {
            let i = r.pixelWidth,
              n = r.pixelHeight,
              s = Td[r.format] || cP
            for (let o = 0; o < r.resource.length; o++) {
              let a = r.resource[o],
                u = Math.ceil(i / s.blockWidth) * s.blockBytes
              ;(e.device.queue.writeTexture(
                { texture: t, mipLevel: o },
                a,
                { offset: 0, bytesPerRow: u },
                {
                  width: Math.ceil(i / s.blockWidth) * s.blockWidth,
                  height: Math.ceil(n / s.blockHeight) * s.blockHeight,
                  depthOrArrayLayers: 1,
                },
              ),
                (i = Math.max(i >> 1, 1)),
                (n = Math.max(n >> 1, 1)))
            }
          },
        }))
    })
  var ul,
    Cd = p(() => {
      At()
      ft()
      ul = {
        type: "image",
        upload(r, t, e) {
          let i = r.resource
          if (!i) return
          if (globalThis.HTMLImageElement && i instanceof HTMLImageElement) {
            let a = Z.get().createCanvas(i.width, i.height)
            ;(a.getContext("2d").drawImage(i, 0, 0, i.width, i.height),
              (r.resource = a),
              N("ImageSource: Image element passed, converting to canvas and replacing resource."))
          }
          let n = Math.min(t.width, r.resourceWidth || r.pixelWidth),
            s = Math.min(t.height, r.resourceHeight || r.pixelHeight),
            o = r.alphaMode === "premultiply-alpha-on-upload"
          e.device.queue.copyExternalImageToTexture(
            { source: i },
            { texture: t, premultipliedAlpha: o },
            { width: n, height: s },
          )
        },
      }
    })
  var rC,
    iC = p(() => {
      Cd()
      rC = {
        type: "video",
        upload(r, t, e) {
          ul.upload(r, t, e)
        },
      }
    })
  var ll,
    nC = p(() => {
      "use strict"
      ll = class {
        constructor(t) {
          ;((this.device = t),
            (this.sampler = t.createSampler({ minFilter: "linear" })),
            (this.pipelines = {}))
        }
        _getMipmapPipeline(t) {
          let e = this.pipelines[t]
          return (
            e ||
              (this.mipmapShaderModule ||
                (this.mipmapShaderModule = this.device.createShaderModule({
                  code: `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `,
                })),
              (e = this.device.createRenderPipeline({
                layout: "auto",
                vertex: { module: this.mipmapShaderModule, entryPoint: "vertexMain" },
                fragment: {
                  module: this.mipmapShaderModule,
                  entryPoint: "fragmentMain",
                  targets: [{ format: t }],
                },
              })),
              (this.pipelines[t] = e)),
            e
          )
        }
        generateMipmap(t) {
          let e = this._getMipmapPipeline(t.format)
          if (t.dimension === "3d" || t.dimension === "1d")
            throw new Error("Generating mipmaps for non-2d textures is currently unsupported!")
          let i = t,
            n = t.depthOrArrayLayers || 1,
            s = t.usage & GPUTextureUsage.RENDER_ATTACHMENT
          if (!s) {
            let u = {
              size: {
                width: Math.ceil(t.width / 2),
                height: Math.ceil(t.height / 2),
                depthOrArrayLayers: n,
              },
              format: t.format,
              usage:
                GPUTextureUsage.TEXTURE_BINDING |
                GPUTextureUsage.COPY_SRC |
                GPUTextureUsage.RENDER_ATTACHMENT,
              mipLevelCount: t.mipLevelCount - 1,
            }
            i = this.device.createTexture(u)
          }
          let o = this.device.createCommandEncoder({}),
            a = e.getBindGroupLayout(0)
          for (let u = 0; u < n; ++u) {
            let l = t.createView({
                baseMipLevel: 0,
                mipLevelCount: 1,
                dimension: "2d",
                baseArrayLayer: u,
                arrayLayerCount: 1,
              }),
              c = s ? 1 : 0
            for (let h = 1; h < t.mipLevelCount; ++h) {
              let f = i.createView({
                  baseMipLevel: c++,
                  mipLevelCount: 1,
                  dimension: "2d",
                  baseArrayLayer: u,
                  arrayLayerCount: 1,
                }),
                d = o.beginRenderPass({
                  colorAttachments: [
                    {
                      view: f,
                      storeOp: "store",
                      loadOp: "clear",
                      clearValue: { r: 0, g: 0, b: 0, a: 0 },
                    },
                  ],
                }),
                g = this.device.createBindGroup({
                  layout: a,
                  entries: [
                    { binding: 0, resource: this.sampler },
                    { binding: 1, resource: l },
                  ],
                })
              ;(d.setPipeline(e), d.setBindGroup(0, g), d.draw(3, 1, 0, 0), d.end(), (l = f))
            }
          }
          if (!s) {
            let u = {
              width: Math.ceil(t.width / 2),
              height: Math.ceil(t.height / 2),
              depthOrArrayLayers: n,
            }
            for (let l = 1; l < t.mipLevelCount; ++l)
              (o.copyTextureToTexture(
                { texture: i, mipLevel: l - 1 },
                { texture: t, mipLevel: l },
                u,
              ),
                (u.width = Math.ceil(u.width / 2)),
                (u.height = Math.ceil(u.height / 2)))
          }
          return (this.device.queue.submit([o.finish()]), s || i.destroy(), t)
        }
      }
    })
  var Mo,
    sC = p(() => {
      At()
      A()
      re()
      on()
      Tr()
      JT()
      eC()
      Cd()
      iC()
      nC()
      Mo = class {
        constructor(t) {
          ;((this.managedTextures = []),
            (this._gpuSources = Object.create(null)),
            (this._gpuSamplers = Object.create(null)),
            (this._bindGroupHash = Object.create(null)),
            (this._textureViewHash = Object.create(null)),
            (this._uploads = { image: ul, buffer: QT, video: rC, compressed: tC }),
            (this._renderer = t),
            t.renderableGC.addManagedHash(this, "_gpuSources"),
            t.renderableGC.addManagedHash(this, "_gpuSamplers"),
            t.renderableGC.addManagedHash(this, "_bindGroupHash"),
            t.renderableGC.addManagedHash(this, "_textureViewHash"))
        }
        contextChange(t) {
          this._gpu = t
        }
        initSource(t) {
          if (t.autoGenerateMipmaps) {
            let u = Math.max(t.pixelWidth, t.pixelHeight)
            t.mipLevelCount = Math.floor(Math.log2(u)) + 1
          }
          let e = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
          t.uploadMethodId !== "compressed" &&
            ((e |= GPUTextureUsage.RENDER_ATTACHMENT), (e |= GPUTextureUsage.COPY_SRC))
          let i = Td[t.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 },
            n = Math.ceil(t.pixelWidth / i.blockWidth) * i.blockWidth,
            s = Math.ceil(t.pixelHeight / i.blockHeight) * i.blockHeight,
            o = {
              label: t.label,
              size: { width: n, height: s },
              format: t.format,
              sampleCount: t.sampleCount,
              mipLevelCount: t.mipLevelCount,
              dimension: t.dimension,
              usage: e,
            },
            a = this._gpu.device.createTexture(o)
          return (
            (this._gpuSources[t.uid] = a),
            this.managedTextures.includes(t) ||
              (t.on("update", this.onSourceUpdate, this),
              t.on("resize", this.onSourceResize, this),
              t.on("destroy", this.onSourceDestroy, this),
              t.on("unload", this.onSourceUnload, this),
              t.on("updateMipmaps", this.onUpdateMipmaps, this),
              this.managedTextures.push(t)),
            this.onSourceUpdate(t),
            a
          )
        }
        onSourceUpdate(t) {
          let e = this.getGpuSource(t)
          e &&
            (this._uploads[t.uploadMethodId] &&
              this._uploads[t.uploadMethodId].upload(t, e, this._gpu),
            t.autoGenerateMipmaps && t.mipLevelCount > 1 && this.onUpdateMipmaps(t))
        }
        onSourceUnload(t) {
          let e = this._gpuSources[t.uid]
          e && ((this._gpuSources[t.uid] = null), e.destroy())
        }
        onUpdateMipmaps(t) {
          this._mipmapGenerator || (this._mipmapGenerator = new ll(this._gpu.device))
          let e = this.getGpuSource(t)
          this._mipmapGenerator.generateMipmap(e)
        }
        onSourceDestroy(t) {
          ;(t.off("update", this.onSourceUpdate, this),
            t.off("unload", this.onSourceUnload, this),
            t.off("destroy", this.onSourceDestroy, this),
            t.off("resize", this.onSourceResize, this),
            t.off("updateMipmaps", this.onUpdateMipmaps, this),
            this.managedTextures.splice(this.managedTextures.indexOf(t), 1),
            this.onSourceUnload(t))
        }
        onSourceResize(t) {
          let e = this._gpuSources[t.uid]
          e
            ? (e.width !== t.pixelWidth || e.height !== t.pixelHeight) &&
              ((this._textureViewHash[t.uid] = null),
              (this._bindGroupHash[t.uid] = null),
              this.onSourceUnload(t),
              this.initSource(t))
            : this.initSource(t)
        }
        _initSampler(t) {
          return (
            (this._gpuSamplers[t._resourceId] = this._gpu.device.createSampler(t)),
            this._gpuSamplers[t._resourceId]
          )
        }
        getGpuSampler(t) {
          return this._gpuSamplers[t._resourceId] || this._initSampler(t)
        }
        getGpuSource(t) {
          return this._gpuSources[t.uid] || this.initSource(t)
        }
        getTextureBindGroup(t) {
          return this._bindGroupHash[t.uid] ?? this._createTextureBindGroup(t)
        }
        _createTextureBindGroup(t) {
          let e = t.source
          return (
            (this._bindGroupHash[t.uid] = new Nt({
              0: e,
              1: e.style,
              2: new ht({
                uTextureMatrix: { type: "mat3x3<f32>", value: t.textureMatrix.mapCoord },
              }),
            })),
            this._bindGroupHash[t.uid]
          )
        }
        getTextureView(t) {
          let e = t.source
          return this._textureViewHash[e.uid] ?? this._createTextureView(e)
        }
        _createTextureView(t) {
          return (
            (this._textureViewHash[t.uid] = this.getGpuSource(t).createView()),
            this._textureViewHash[t.uid]
          )
        }
        generateCanvas(t) {
          let e = this._renderer,
            i = e.gpu.device.createCommandEncoder(),
            n = Z.get().createCanvas()
          ;((n.width = t.source.pixelWidth), (n.height = t.source.pixelHeight))
          let s = n.getContext("webgpu")
          return (
            s.configure({
              device: e.gpu.device,
              usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,
              format: Z.get().getNavigator().gpu.getPreferredCanvasFormat(),
              alphaMode: "premultiplied",
            }),
            i.copyTextureToTexture(
              { texture: e.texture.getGpuSource(t.source), origin: { x: 0, y: 0 } },
              { texture: s.getCurrentTexture() },
              { width: n.width, height: n.height },
            ),
            e.gpu.device.queue.submit([i.finish()]),
            n
          )
        }
        getPixels(t) {
          let e = this.generateCanvas(t),
            i = pe.getOptimalCanvasAndContext(e.width, e.height),
            n = i.context
          n.drawImage(e, 0, 0)
          let { width: s, height: o } = e,
            a = n.getImageData(0, 0, s, o),
            u = new Uint8ClampedArray(a.data.buffer)
          return (pe.returnCanvasAndContext(i), { pixels: u, width: s, height: o })
        }
        destroy() {
          ;(this.managedTextures.slice().forEach((t) => this.onSourceDestroy(t)),
            (this.managedTextures = null))
          for (let t of Object.keys(this._bindGroupHash)) {
            let e = Number(t)
            ;(this._bindGroupHash[e]?.destroy(), (this._bindGroupHash[e] = null))
          }
          ;((this._gpu = null),
            (this._mipmapGenerator = null),
            (this._gpuSources = null),
            (this._bindGroupHash = null),
            (this._textureViewHash = null),
            (this._gpuSamplers = null))
        }
      }
      Mo.extension = { type: [b.WebGPUSystem], name: "texture" }
    })
  var lC = {}
  Xd(lC, { WebGPURenderer: () => Ed })
  var hP,
    fP,
    dP,
    oC,
    aC,
    uC,
    Ed,
    cC = p(() => {
      A()
      CS()
      MS()
      AS()
      $s()
      dd()
      Le()
      ET()
      wT()
      MT()
      AT()
      DT()
      PT()
      FT()
      OT()
      NT()
      HT()
      jT()
      KT()
      ZT()
      sC()
      ;((hP = [...tl, vo, xo, xn, _o, mo, Mo, Co, Eo, wo, To, go, yo, po]),
        (fP = [...el, So]),
        (dP = [js, Ys, Xs]),
        (oC = []),
        (aC = []),
        (uC = []))
      L.handleByNamedList(b.WebGPUSystem, oC)
      L.handleByNamedList(b.WebGPUPipes, aC)
      L.handleByNamedList(b.WebGPUPipesAdaptor, uC)
      L.add(...hP, ...fP, ...dP)
      Ed = class extends Fr {
        constructor() {
          let t = {
            name: "webgpu",
            type: Bt.WEBGPU,
            systems: oC,
            renderPipes: aC,
            renderPipeAdaptors: uC,
          }
          super(t)
        }
      }
    })
  var Ao,
    hC = p(() => {
      A()
      nt()
      wr()
      bs()
      vs()
      fn()
      Mr()
      hu()
      Ae()
      re()
      Ao = class {
        contextChange(t) {
          let e = new ht({
              uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
              uTransformMatrix: { value: new I(), type: "mat3x3<f32>" },
              uRound: { value: 0, type: "f32" },
            }),
            i = t.limits.maxBatchableTextures,
            n = Ge({ name: "graphics", bits: [Vi, Xi(i), hn, Oe] })
          this.shader = new Mt({
            glProgram: n,
            resources: { localUniforms: e, batchSamplers: Yi(i) },
          })
        }
        execute(t, e) {
          let i = e.context,
            n = i.customShader || this.shader,
            s = t.renderer,
            o = s.graphicsContext,
            { batcher: a, instructions: u } = o.getContextRenderData(i)
          ;((n.groups[0] = s.globalUniforms.bindGroup),
            s.state.set(t.state),
            s.shader.bind(n),
            s.geometry.bind(a.geometry, n.glProgram))
          let l = u.instructions
          for (let c = 0; c < u.instructionSize; c++) {
            let h = l[c]
            if (h.size) {
              for (let f = 0; f < h.textures.count; f++) s.texture.bind(h.textures.textures[f], f)
              s.geometry.draw(h.topology, h.size, h.start)
            }
          }
        }
        destroy() {
          ;(this.shader.destroy(!0), (this.shader = null))
        }
      }
      Ao.extension = { type: [b.WebGLPipesAdaptor], name: "graphics" }
    })
  var Do,
    fC = p(() => {
      A()
      nt()
      wr()
      fn()
      Mr()
      Kf()
      Ae()
      dt()
      ft()
      Do = class {
        init() {
          let t = Ge({ name: "mesh", bits: [hn, wS, Oe] })
          this._shader = new Mt({
            glProgram: t,
            resources: {
              uTexture: k.EMPTY.source,
              textureUniforms: { uTextureMatrix: { type: "mat3x3<f32>", value: new I() } },
            },
          })
        }
        execute(t, e) {
          let i = t.renderer,
            n = e._shader
          if (n) {
            if (!n.glProgram) {
              N("Mesh shader has no glProgram", e.shader)
              return
            }
          } else {
            n = this._shader
            let s = e.texture,
              o = s.source
            ;((n.resources.uTexture = o),
              (n.resources.uSampler = o.style),
              (n.resources.textureUniforms.uniforms.uTextureMatrix = s.textureMatrix.mapCoord))
          }
          ;((n.groups[100] = i.globalUniforms.bindGroup),
            (n.groups[101] = t.localUniformsBindGroup),
            i.encoder.draw({ geometry: e._geometry, shader: n, state: e.state }))
        }
        destroy() {
          ;(this._shader.destroy(!0), (this._shader = null))
        }
      }
      Do.extension = { type: [b.WebGLPipesAdaptor], name: "mesh" }
    })
  var Po,
    dC = p(() => {
      A()
      De()
      Po = class {
        constructor() {
          ;((this._tempState = Dt.for2d()), (this._didUploadHash = {}))
        }
        init(t) {
          t.renderer.runners.contextChange.add(this)
        }
        contextChange() {
          this._didUploadHash = {}
        }
        start(t, e, i) {
          let n = t.renderer,
            s = this._didUploadHash[i.uid]
          ;(n.shader.bind(i, s),
            s || (this._didUploadHash[i.uid] = !0),
            n.shader.updateUniformGroup(n.globalUniforms.uniformGroup),
            n.geometry.bind(e, i.glProgram))
        }
        execute(t, e) {
          let i = t.renderer
          ;((this._tempState.blendMode = e.blendMode), i.state.set(this._tempState))
          let n = e.textures.textures
          for (let s = 0; s < e.textures.count; s++) i.texture.bind(n[s], s)
          i.geometry.draw(e.topology, e.size, e.start)
        }
      }
      Po.extension = { type: [b.WebGLPipesAdaptor], name: "batch" }
    })
  var Fo,
    pC = p(() => {
      "use strict"
      Fo = ((r) => (
        (r[(r.ELEMENT_ARRAY_BUFFER = 34963)] = "ELEMENT_ARRAY_BUFFER"),
        (r[(r.ARRAY_BUFFER = 34962)] = "ARRAY_BUFFER"),
        (r[(r.UNIFORM_BUFFER = 35345)] = "UNIFORM_BUFFER"),
        r
      ))(Fo || {})
    })
  var cl,
    mC = p(() => {
      "use strict"
      cl = class {
        constructor(t, e) {
          ;((this._lastBindBaseLocation = -1),
            (this._lastBindCallId = -1),
            (this.buffer = t || null),
            (this.updateID = -1),
            (this.byteLength = -1),
            (this.type = e))
        }
      }
    })
  var Ro,
    gC = p(() => {
      A()
      sr()
      pC()
      mC()
      Ro = class {
        constructor(t) {
          ;((this._gpuBuffers = Object.create(null)),
            (this._boundBufferBases = Object.create(null)),
            (this._minBaseLocation = 0),
            (this._nextBindBaseIndex = this._minBaseLocation),
            (this._bindCallId = 0),
            (this._renderer = t),
            this._renderer.renderableGC.addManagedHash(this, "_gpuBuffers"))
        }
        destroy() {
          ;((this._renderer = null),
            (this._gl = null),
            (this._gpuBuffers = null),
            (this._boundBufferBases = null))
        }
        contextChange() {
          ;((this._gl = this._renderer.gl),
            (this._gpuBuffers = Object.create(null)),
            (this._maxBindings = this._renderer.limits.maxUniformBindings))
        }
        getGlBuffer(t) {
          return this._gpuBuffers[t.uid] || this.createGLBuffer(t)
        }
        bind(t) {
          let { _gl: e } = this,
            i = this.getGlBuffer(t)
          e.bindBuffer(i.type, i.buffer)
        }
        bindBufferBase(t, e) {
          let { _gl: i } = this
          this._boundBufferBases[e] !== t &&
            ((this._boundBufferBases[e] = t),
            (t._lastBindBaseLocation = e),
            i.bindBufferBase(i.UNIFORM_BUFFER, e, t.buffer))
        }
        nextBindBase(t) {
          ;(this._bindCallId++,
            (this._minBaseLocation = 0),
            t &&
              ((this._boundBufferBases[0] = null),
              (this._minBaseLocation = 1),
              this._nextBindBaseIndex < 1 && (this._nextBindBaseIndex = 1)))
        }
        freeLocationForBufferBase(t) {
          let e = this.getLastBindBaseLocation(t)
          if (e >= this._minBaseLocation) return ((t._lastBindCallId = this._bindCallId), e)
          let i = 0,
            n = this._nextBindBaseIndex
          for (; i < 2; ) {
            n >= this._maxBindings && ((n = this._minBaseLocation), i++)
            let s = this._boundBufferBases[n]
            if (s && s._lastBindCallId === this._bindCallId) {
              n++
              continue
            }
            break
          }
          return (
            (e = n),
            (this._nextBindBaseIndex = n + 1),
            i >= 2
              ? -1
              : ((t._lastBindCallId = this._bindCallId), (this._boundBufferBases[e] = null), e)
          )
        }
        getLastBindBaseLocation(t) {
          let e = t._lastBindBaseLocation
          return this._boundBufferBases[e] === t ? e : -1
        }
        bindBufferRange(t, e, i, n) {
          let { _gl: s } = this
          ;(i || (i = 0),
            e || (e = 0),
            (this._boundBufferBases[e] = null),
            s.bindBufferRange(s.UNIFORM_BUFFER, e || 0, t.buffer, i * 256, n || 256))
        }
        updateBuffer(t) {
          let { _gl: e } = this,
            i = this.getGlBuffer(t)
          if (t._updateID === i.updateID) return i
          ;((i.updateID = t._updateID), e.bindBuffer(i.type, i.buffer))
          let n = t.data,
            s = t.descriptor.usage & tt.STATIC ? e.STATIC_DRAW : e.DYNAMIC_DRAW
          return (
            n
              ? i.byteLength >= n.byteLength
                ? e.bufferSubData(i.type, 0, n, 0, t._updateSize / n.BYTES_PER_ELEMENT)
                : ((i.byteLength = n.byteLength), e.bufferData(i.type, n, s))
              : ((i.byteLength = t.descriptor.size), e.bufferData(i.type, i.byteLength, s)),
            i
          )
        }
        destroyAll() {
          let t = this._gl
          for (let e in this._gpuBuffers) t.deleteBuffer(this._gpuBuffers[e].buffer)
          this._gpuBuffers = Object.create(null)
        }
        onBufferDestroy(t, e) {
          let i = this._gpuBuffers[t.uid],
            n = this._gl
          ;(e || n.deleteBuffer(i.buffer), (this._gpuBuffers[t.uid] = null))
        }
        createGLBuffer(t) {
          let { _gl: e } = this,
            i = Fo.ARRAY_BUFFER
          t.descriptor.usage & tt.INDEX
            ? (i = Fo.ELEMENT_ARRAY_BUFFER)
            : t.descriptor.usage & tt.UNIFORM && (i = Fo.UNIFORM_BUFFER)
          let n = new cl(e.createBuffer(), i)
          return ((this._gpuBuffers[t.uid] = n), t.on("destroy", this.onBufferDestroy, this), n)
        }
        resetState() {
          this._boundBufferBases = Object.create(null)
        }
      }
      Ro.extension = { type: [b.WebGLSystem], name: "buffer" }
    })
  var wd,
    _C,
    yC = p(() => {
      At()
      A()
      ft()
      wd = class xC {
        constructor(t) {
          ;((this.supports = {
            uint32Indices: !0,
            uniformBufferObject: !0,
            vertexArrayObject: !0,
            srgbTextures: !0,
            nonPowOf2wrapping: !0,
            msaa: !0,
            nonPowOf2mipmaps: !0,
          }),
            (this._renderer = t),
            (this.extensions = Object.create(null)),
            (this.handleContextLost = this.handleContextLost.bind(this)),
            (this.handleContextRestored = this.handleContextRestored.bind(this)))
        }
        get isLost() {
          return !this.gl || this.gl.isContextLost()
        }
        contextChange(t) {
          ;((this.gl = t), (this._renderer.gl = t))
        }
        init(t) {
          t = { ...xC.defaultOptions, ...t }
          let e = (this.multiView = t.multiView)
          if (
            (t.context &&
              e &&
              (N(
                "Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together.",
              ),
              (e = !1)),
            e
              ? (this.canvas = Z.get().createCanvas(
                  this._renderer.canvas.width,
                  this._renderer.canvas.height,
                ))
              : (this.canvas = this._renderer.view.canvas),
            t.context)
          )
            this.initFromContext(t.context)
          else {
            let i = this._renderer.background.alpha < 1,
              n = t.premultipliedAlpha ?? !0,
              s = t.antialias && !this._renderer.backBuffer.useBackBuffer
            this.createContext(t.preferWebGLVersion, {
              alpha: i,
              premultipliedAlpha: n,
              antialias: s,
              stencil: !0,
              preserveDrawingBuffer: t.preserveDrawingBuffer,
              powerPreference: t.powerPreference ?? "default",
            })
          }
        }
        ensureCanvasSize(t) {
          if (!this.multiView) {
            t !== this.canvas && N("multiView is disabled, but targetCanvas is not the main canvas")
            return
          }
          let { canvas: e } = this
          ;(e.width < t.width || e.height < t.height) &&
            ((e.width = Math.max(t.width, t.width)), (e.height = Math.max(t.height, t.height)))
        }
        initFromContext(t) {
          ;((this.gl = t),
            (this.webGLVersion = t instanceof Z.get().getWebGLRenderingContext() ? 1 : 2),
            this.getExtensions(),
            this.validateContext(t),
            this._renderer.runners.contextChange.emit(t))
          let e = this._renderer.view.canvas
          ;(e.addEventListener("webglcontextlost", this.handleContextLost, !1),
            e.addEventListener("webglcontextrestored", this.handleContextRestored, !1))
        }
        createContext(t, e) {
          let i,
            n = this.canvas
          if (
            (t === 2 && (i = n.getContext("webgl2", e)), !i && ((i = n.getContext("webgl", e)), !i))
          )
            throw new Error("This browser does not support WebGL. Try using the canvas renderer")
          ;((this.gl = i), this.initFromContext(this.gl))
        }
        getExtensions() {
          let { gl: t } = this,
            e = {
              anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"),
              floatTextureLinear: t.getExtension("OES_texture_float_linear"),
              s3tc: t.getExtension("WEBGL_compressed_texture_s3tc"),
              s3tc_sRGB: t.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
              etc: t.getExtension("WEBGL_compressed_texture_etc"),
              etc1: t.getExtension("WEBGL_compressed_texture_etc1"),
              pvrtc:
                t.getExtension("WEBGL_compressed_texture_pvrtc") ||
                t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
              atc: t.getExtension("WEBGL_compressed_texture_atc"),
              astc: t.getExtension("WEBGL_compressed_texture_astc"),
              bptc: t.getExtension("EXT_texture_compression_bptc"),
              rgtc: t.getExtension("EXT_texture_compression_rgtc"),
              loseContext: t.getExtension("WEBGL_lose_context"),
            }
          if (this.webGLVersion === 1)
            this.extensions = {
              ...e,
              drawBuffers: t.getExtension("WEBGL_draw_buffers"),
              depthTexture: t.getExtension("WEBGL_depth_texture"),
              vertexArrayObject:
                t.getExtension("OES_vertex_array_object") ||
                t.getExtension("MOZ_OES_vertex_array_object") ||
                t.getExtension("WEBKIT_OES_vertex_array_object"),
              uint32ElementIndex: t.getExtension("OES_element_index_uint"),
              floatTexture: t.getExtension("OES_texture_float"),
              floatTextureLinear: t.getExtension("OES_texture_float_linear"),
              textureHalfFloat: t.getExtension("OES_texture_half_float"),
              textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear"),
              vertexAttribDivisorANGLE: t.getExtension("ANGLE_instanced_arrays"),
              srgb: t.getExtension("EXT_sRGB"),
            }
          else {
            this.extensions = { ...e, colorBufferFloat: t.getExtension("EXT_color_buffer_float") }
            let i = t.getExtension("WEBGL_provoking_vertex")
            i && i.provokingVertexWEBGL(i.FIRST_VERTEX_CONVENTION_WEBGL)
          }
        }
        handleContextLost(t) {
          ;(t.preventDefault(),
            this._contextLossForced &&
              ((this._contextLossForced = !1),
              setTimeout(() => {
                this.gl.isContextLost() && this.extensions.loseContext?.restoreContext()
              }, 0)))
        }
        handleContextRestored() {
          ;(this.getExtensions(), this._renderer.runners.contextChange.emit(this.gl))
        }
        destroy() {
          let t = this._renderer.view.canvas
          ;((this._renderer = null),
            t.removeEventListener("webglcontextlost", this.handleContextLost),
            t.removeEventListener("webglcontextrestored", this.handleContextRestored),
            this.gl.useProgram(null),
            this.extensions.loseContext?.loseContext())
        }
        forceContextLoss() {
          ;(this.extensions.loseContext?.loseContext(), (this._contextLossForced = !0))
        }
        validateContext(t) {
          let e = t.getContextAttributes()
          e &&
            !e.stencil &&
            N(
              "Provided WebGL context does not have a stencil buffer, masks may not render correctly",
            )
          let i = this.supports,
            n = this.webGLVersion === 2,
            s = this.extensions
          ;((i.uint32Indices = n || !!s.uint32ElementIndex),
            (i.uniformBufferObject = n),
            (i.vertexArrayObject = n || !!s.vertexArrayObject),
            (i.srgbTextures = n || !!s.srgb),
            (i.nonPowOf2wrapping = n),
            (i.nonPowOf2mipmaps = n),
            (i.msaa = n),
            i.uint32Indices ||
              N(
                "Provided WebGL context does not support 32 index buffer, large scenes may not render correctly",
              ))
        }
      }
      wd.extension = { type: [b.WebGLSystem], name: "context" }
      wd.defaultOptions = {
        context: null,
        premultipliedAlpha: !0,
        preserveDrawingBuffer: !1,
        powerPreference: void 0,
        preferWebGLVersion: 2,
        multiView: !1,
      }
      _C = wd
    })
  var hl,
    Md,
    st,
    Ad = p(() => {
      "use strict"
      ;((hl = ((r) => (
        (r[(r.RGBA = 6408)] = "RGBA"),
        (r[(r.RGB = 6407)] = "RGB"),
        (r[(r.RG = 33319)] = "RG"),
        (r[(r.RED = 6403)] = "RED"),
        (r[(r.RGBA_INTEGER = 36249)] = "RGBA_INTEGER"),
        (r[(r.RGB_INTEGER = 36248)] = "RGB_INTEGER"),
        (r[(r.RG_INTEGER = 33320)] = "RG_INTEGER"),
        (r[(r.RED_INTEGER = 36244)] = "RED_INTEGER"),
        (r[(r.ALPHA = 6406)] = "ALPHA"),
        (r[(r.LUMINANCE = 6409)] = "LUMINANCE"),
        (r[(r.LUMINANCE_ALPHA = 6410)] = "LUMINANCE_ALPHA"),
        (r[(r.DEPTH_COMPONENT = 6402)] = "DEPTH_COMPONENT"),
        (r[(r.DEPTH_STENCIL = 34041)] = "DEPTH_STENCIL"),
        r
      ))(hl || {})),
        (Md = ((r) => (
          (r[(r.TEXTURE_2D = 3553)] = "TEXTURE_2D"),
          (r[(r.TEXTURE_CUBE_MAP = 34067)] = "TEXTURE_CUBE_MAP"),
          (r[(r.TEXTURE_2D_ARRAY = 35866)] = "TEXTURE_2D_ARRAY"),
          (r[(r.TEXTURE_CUBE_MAP_POSITIVE_X = 34069)] = "TEXTURE_CUBE_MAP_POSITIVE_X"),
          (r[(r.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070)] = "TEXTURE_CUBE_MAP_NEGATIVE_X"),
          (r[(r.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071)] = "TEXTURE_CUBE_MAP_POSITIVE_Y"),
          (r[(r.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072)] = "TEXTURE_CUBE_MAP_NEGATIVE_Y"),
          (r[(r.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073)] = "TEXTURE_CUBE_MAP_POSITIVE_Z"),
          (r[(r.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074)] = "TEXTURE_CUBE_MAP_NEGATIVE_Z"),
          r
        ))(Md || {})),
        (st = ((r) => (
          (r[(r.UNSIGNED_BYTE = 5121)] = "UNSIGNED_BYTE"),
          (r[(r.UNSIGNED_SHORT = 5123)] = "UNSIGNED_SHORT"),
          (r[(r.UNSIGNED_SHORT_5_6_5 = 33635)] = "UNSIGNED_SHORT_5_6_5"),
          (r[(r.UNSIGNED_SHORT_4_4_4_4 = 32819)] = "UNSIGNED_SHORT_4_4_4_4"),
          (r[(r.UNSIGNED_SHORT_5_5_5_1 = 32820)] = "UNSIGNED_SHORT_5_5_5_1"),
          (r[(r.UNSIGNED_INT = 5125)] = "UNSIGNED_INT"),
          (r[(r.UNSIGNED_INT_10F_11F_11F_REV = 35899)] = "UNSIGNED_INT_10F_11F_11F_REV"),
          (r[(r.UNSIGNED_INT_2_10_10_10_REV = 33640)] = "UNSIGNED_INT_2_10_10_10_REV"),
          (r[(r.UNSIGNED_INT_24_8 = 34042)] = "UNSIGNED_INT_24_8"),
          (r[(r.UNSIGNED_INT_5_9_9_9_REV = 35902)] = "UNSIGNED_INT_5_9_9_9_REV"),
          (r[(r.BYTE = 5120)] = "BYTE"),
          (r[(r.SHORT = 5122)] = "SHORT"),
          (r[(r.INT = 5124)] = "INT"),
          (r[(r.FLOAT = 5126)] = "FLOAT"),
          (r[(r.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269)] = "FLOAT_32_UNSIGNED_INT_24_8_REV"),
          (r[(r.HALF_FLOAT = 36193)] = "HALF_FLOAT"),
          r
        ))(st || {})))
    })
  function vC(r) {
    return bC[r] ?? bC.float32
  }
  var bC,
    SC = p(() => {
      Ad()
      bC = {
        uint8x2: st.UNSIGNED_BYTE,
        uint8x4: st.UNSIGNED_BYTE,
        sint8x2: st.BYTE,
        sint8x4: st.BYTE,
        unorm8x2: st.UNSIGNED_BYTE,
        unorm8x4: st.UNSIGNED_BYTE,
        snorm8x2: st.BYTE,
        snorm8x4: st.BYTE,
        uint16x2: st.UNSIGNED_SHORT,
        uint16x4: st.UNSIGNED_SHORT,
        sint16x2: st.SHORT,
        sint16x4: st.SHORT,
        unorm16x2: st.UNSIGNED_SHORT,
        unorm16x4: st.UNSIGNED_SHORT,
        snorm16x2: st.SHORT,
        snorm16x4: st.SHORT,
        float16x2: st.HALF_FLOAT,
        float16x4: st.HALF_FLOAT,
        float32: st.FLOAT,
        float32x2: st.FLOAT,
        float32x3: st.FLOAT,
        float32x4: st.FLOAT,
        uint32: st.UNSIGNED_INT,
        uint32x2: st.UNSIGNED_INT,
        uint32x3: st.UNSIGNED_INT,
        uint32x4: st.UNSIGNED_INT,
        sint32: st.INT,
        sint32x2: st.INT,
        sint32x3: st.INT,
        sint32x4: st.INT,
      }
    })
  var pP,
    Bo,
    TC = p(() => {
      A()
      ai()
      bd()
      SC()
      ;((pP = {
        "point-list": 0,
        "line-list": 1,
        "line-strip": 3,
        "triangle-list": 4,
        "triangle-strip": 5,
      }),
        (Bo = class {
          constructor(t) {
            ;((this._geometryVaoHash = Object.create(null)),
              (this._renderer = t),
              (this._activeGeometry = null),
              (this._activeVao = null),
              (this.hasVao = !0),
              (this.hasInstance = !0),
              this._renderer.renderableGC.addManagedHash(this, "_geometryVaoHash"))
          }
          contextChange() {
            let t = (this.gl = this._renderer.gl)
            if (!this._renderer.context.supports.vertexArrayObject)
              throw new Error("[PixiJS] Vertex Array Objects are not supported on this device")
            let e = this._renderer.context.extensions.vertexArrayObject
            e &&
              ((t.createVertexArray = () => e.createVertexArrayOES()),
              (t.bindVertexArray = (n) => e.bindVertexArrayOES(n)),
              (t.deleteVertexArray = (n) => e.deleteVertexArrayOES(n)))
            let i = this._renderer.context.extensions.vertexAttribDivisorANGLE
            ;(i &&
              ((t.drawArraysInstanced = (n, s, o, a) => {
                i.drawArraysInstancedANGLE(n, s, o, a)
              }),
              (t.drawElementsInstanced = (n, s, o, a, u) => {
                i.drawElementsInstancedANGLE(n, s, o, a, u)
              }),
              (t.vertexAttribDivisor = (n, s) => i.vertexAttribDivisorANGLE(n, s))),
              (this._activeGeometry = null),
              (this._activeVao = null),
              (this._geometryVaoHash = Object.create(null)))
          }
          bind(t, e) {
            let i = this.gl
            this._activeGeometry = t
            let n = this.getVao(t, e)
            ;(this._activeVao !== n && ((this._activeVao = n), i.bindVertexArray(n)),
              this.updateBuffers())
          }
          resetState() {
            this.unbind()
          }
          updateBuffers() {
            let t = this._activeGeometry,
              e = this._renderer.buffer
            for (let i = 0; i < t.buffers.length; i++) {
              let n = t.buffers[i]
              e.updateBuffer(n)
            }
          }
          checkCompatibility(t, e) {
            let i = t.attributes,
              n = e._attributeData
            for (let s in n)
              if (!i[s])
                throw new Error(
                  `shader and geometry incompatible, geometry missing the "${s}" attribute`,
                )
          }
          getSignature(t, e) {
            let i = t.attributes,
              n = e._attributeData,
              s = ["g", t.uid]
            for (let o in i) n[o] && s.push(o, n[o].location)
            return s.join("-")
          }
          getVao(t, e) {
            return this._geometryVaoHash[t.uid]?.[e._key] || this.initGeometryVao(t, e)
          }
          initGeometryVao(t, e, i = !0) {
            let n = this._renderer.gl,
              s = this._renderer.buffer
            ;(this._renderer.shader._getProgramData(e), this.checkCompatibility(t, e))
            let o = this.getSignature(t, e)
            this._geometryVaoHash[t.uid] ||
              ((this._geometryVaoHash[t.uid] = Object.create(null)),
              t.on("destroy", this.onGeometryDestroy, this))
            let a = this._geometryVaoHash[t.uid],
              u = a[o]
            if (u) return ((a[e._key] = u), u)
            sl(t, e._attributeData)
            let l = t.buffers
            ;((u = n.createVertexArray()), n.bindVertexArray(u))
            for (let c = 0; c < l.length; c++) {
              let h = l[c]
              s.bind(h)
            }
            return (this.activateVao(t, e), (a[e._key] = u), (a[o] = u), n.bindVertexArray(null), u)
          }
          onGeometryDestroy(t, e) {
            let i = this._geometryVaoHash[t.uid],
              n = this.gl
            if (i) {
              if (e)
                for (let s in i)
                  (this._activeVao !== i[s] && this.unbind(), n.deleteVertexArray(i[s]))
              this._geometryVaoHash[t.uid] = null
            }
          }
          destroyAll(t = !1) {
            let e = this.gl
            for (let i in this._geometryVaoHash) {
              if (t)
                for (let n in this._geometryVaoHash[i]) {
                  let s = this._geometryVaoHash[i]
                  ;(this._activeVao !== s && this.unbind(), e.deleteVertexArray(s[n]))
                }
              this._geometryVaoHash[i] = null
            }
          }
          activateVao(t, e) {
            let i = this._renderer.gl,
              n = this._renderer.buffer,
              s = t.attributes
            t.indexBuffer && n.bind(t.indexBuffer)
            let o = null
            for (let a in s) {
              let u = s[a],
                l = u.buffer,
                c = n.getGlBuffer(l),
                h = e._attributeData[a]
              if (h) {
                o !== c && (n.bind(l), (o = c))
                let f = h.location
                i.enableVertexAttribArray(f)
                let d = ae(u.format),
                  g = vC(u.format)
                if (
                  (h.format?.substring(1, 4) === "int"
                    ? i.vertexAttribIPointer(f, d.size, g, u.stride, u.offset)
                    : i.vertexAttribPointer(f, d.size, g, d.normalised, u.stride, u.offset),
                  u.instance)
                )
                  if (this.hasInstance) {
                    let x = u.divisor ?? 1
                    i.vertexAttribDivisor(f, x)
                  } else
                    throw new Error(
                      "geometry error, GPU Instancing is not supported on this device",
                    )
              }
            }
          }
          draw(t, e, i, n) {
            let { gl: s } = this._renderer,
              o = this._activeGeometry,
              a = pP[t || o.topology]
            if ((n ?? (n = o.instanceCount), o.indexBuffer)) {
              let u = o.indexBuffer.data.BYTES_PER_ELEMENT,
                l = u === 2 ? s.UNSIGNED_SHORT : s.UNSIGNED_INT
              n > 1
                ? s.drawElementsInstanced(a, e || o.indexBuffer.data.length, l, (i || 0) * u, n)
                : s.drawElements(a, e || o.indexBuffer.data.length, l, (i || 0) * u)
            } else
              n > 1
                ? s.drawArraysInstanced(a, i || 0, e || o.getSize(), n)
                : s.drawArrays(a, i || 0, e || o.getSize())
            return this
          }
          unbind() {
            ;(this.gl.bindVertexArray(null),
              (this._activeVao = null),
              (this._activeGeometry = null))
          }
          destroy() {
            ;((this._renderer = null),
              (this.gl = null),
              (this._activeVao = null),
              (this._activeGeometry = null))
          }
        }))
      Bo.extension = { type: [b.WebGLSystem], name: "geometry" }
    })
  var mP,
    Dd,
    EC,
    wC = p(() => {
      A()
      ft()
      Ni()
      Ae()
      De()
      te()
      dt()
      oi()
      ;((mP = new _e({ attributes: { aPosition: [-1, -1, 3, -1, -1, 3] } })),
        (Dd = class CC {
          constructor(t) {
            ;((this.useBackBuffer = !1), (this._useBackBufferThisRender = !1), (this._renderer = t))
          }
          init(t = {}) {
            let { useBackBuffer: e, antialias: i } = { ...CC.defaultOptions, ...t }
            ;((this.useBackBuffer = e),
              (this._antialias = i),
              this._renderer.context.supports.msaa ||
                (N("antialiasing, is not supported on when using the back buffer"),
                (this._antialias = !1)),
              (this._state = Dt.for2d()))
            let n = new ye({
              vertex: `
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`,
              fragment: `
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`,
              name: "big-triangle",
            })
            this._bigTriangleShader = new Mt({
              glProgram: n,
              resources: { uTexture: k.WHITE.source },
            })
          }
          renderStart(t) {
            let e = this._renderer.renderTarget.getRenderTarget(t.target)
            if (
              ((this._useBackBufferThisRender = this.useBackBuffer && !!e.isRoot),
              this._useBackBufferThisRender)
            ) {
              let i = this._renderer.renderTarget.getRenderTarget(t.target)
              ;((this._targetTexture = i.colorTexture),
                (t.target = this._getBackBufferTexture(i.colorTexture)))
            }
          }
          renderEnd() {
            this._presentBackBuffer()
          }
          _presentBackBuffer() {
            let t = this._renderer
            ;(t.renderTarget.finishRenderPass(),
              this._useBackBufferThisRender &&
                (t.renderTarget.bind(this._targetTexture, !1),
                (this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source),
                t.encoder.draw({
                  geometry: mP,
                  shader: this._bigTriangleShader,
                  state: this._state,
                })))
          }
          _getBackBufferTexture(t) {
            return (
              (this._backBufferTexture =
                this._backBufferTexture ||
                new k({
                  source: new ot({
                    width: t.width,
                    height: t.height,
                    resolution: t._resolution,
                    antialias: this._antialias,
                  }),
                })),
              this._backBufferTexture.source.resize(t.width, t.height, t._resolution),
              this._backBufferTexture
            )
          }
          destroy() {
            this._backBufferTexture &&
              (this._backBufferTexture.destroy(), (this._backBufferTexture = null))
          }
        }))
      Dd.extension = { type: [b.WebGLSystem], name: "backBuffer", priority: 1 }
      Dd.defaultOptions = { useBackBuffer: !1 }
      EC = Dd
    })
  var Io,
    MC = p(() => {
      A()
      Io = class {
        constructor(t) {
          ;((this._colorMaskCache = 15), (this._renderer = t))
        }
        setMask(t) {
          this._colorMaskCache !== t &&
            ((this._colorMaskCache = t),
            this._renderer.gl.colorMask(!!(t & 8), !!(t & 4), !!(t & 2), !!(t & 1)))
        }
      }
      Io.extension = { type: [b.WebGLSystem], name: "colorMask" }
    })
  var ko,
    AC = p(() => {
      A()
      ko = class {
        constructor(t) {
          ;((this.commandFinished = Promise.resolve()), (this._renderer = t))
        }
        setGeometry(t, e) {
          this._renderer.geometry.bind(t, e.glProgram)
        }
        finishRenderPass() {}
        draw(t) {
          let e = this._renderer,
            {
              geometry: i,
              shader: n,
              state: s,
              skipSync: o,
              topology: a,
              size: u,
              start: l,
              instanceCount: c,
            } = t
          ;(e.shader.bind(n, o),
            e.geometry.bind(i, e.shader._activeProgram),
            s && e.state.set(s),
            e.geometry.draw(a, u, l, c ?? i.instanceCount))
        }
        destroy() {
          this._renderer = null
        }
      }
      ko.extension = { type: [b.WebGLSystem], name: "encoder" }
    })
  var Go,
    DC = p(() => {
      A()
      ch()
      Go = class {
        constructor(t) {
          this._renderer = t
        }
        contextChange() {
          let t = this._renderer.gl
          ;((this.maxTextures = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)),
            (this.maxBatchableTextures = ou(this.maxTextures, t)),
            (this.maxUniformBindings = t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS)))
        }
        destroy() {}
      }
      Go.extension = { type: [b.WebGLSystem], name: "limits" }
    })
  var Uo,
    PC = p(() => {
      A()
      vd()
      si()
      Uo = class {
        constructor(t) {
          ;((this._stencilCache = { enabled: !1, stencilReference: 0, stencilMode: mt.NONE }),
            (this._renderTargetStencilState = Object.create(null)),
            t.renderTarget.onRenderTargetChange.add(this))
        }
        contextChange(t) {
          ;((this._gl = t),
            (this._comparisonFuncMapping = {
              always: t.ALWAYS,
              never: t.NEVER,
              equal: t.EQUAL,
              "not-equal": t.NOTEQUAL,
              less: t.LESS,
              "less-equal": t.LEQUAL,
              greater: t.GREATER,
              "greater-equal": t.GEQUAL,
            }),
            (this._stencilOpsMapping = {
              keep: t.KEEP,
              zero: t.ZERO,
              replace: t.REPLACE,
              invert: t.INVERT,
              "increment-clamp": t.INCR,
              "decrement-clamp": t.DECR,
              "increment-wrap": t.INCR_WRAP,
              "decrement-wrap": t.DECR_WRAP,
            }),
            this.resetState())
        }
        onRenderTargetChange(t) {
          if (this._activeRenderTarget === t) return
          this._activeRenderTarget = t
          let e = this._renderTargetStencilState[t.uid]
          ;(e ||
            (e = this._renderTargetStencilState[t.uid] =
              { stencilMode: mt.DISABLED, stencilReference: 0 }),
            this.setStencilMode(e.stencilMode, e.stencilReference))
        }
        resetState() {
          ;((this._stencilCache.enabled = !1),
            (this._stencilCache.stencilMode = mt.NONE),
            (this._stencilCache.stencilReference = 0))
        }
        setStencilMode(t, e) {
          let i = this._renderTargetStencilState[this._activeRenderTarget.uid],
            n = this._gl,
            s = Ve[t],
            o = this._stencilCache
          if (((i.stencilMode = t), (i.stencilReference = e), t === mt.DISABLED)) {
            this._stencilCache.enabled &&
              ((this._stencilCache.enabled = !1), n.disable(n.STENCIL_TEST))
            return
          }
          ;(this._stencilCache.enabled ||
            ((this._stencilCache.enabled = !0), n.enable(n.STENCIL_TEST)),
            (t !== o.stencilMode || o.stencilReference !== e) &&
              ((o.stencilMode = t),
              (o.stencilReference = e),
              n.stencilFunc(this._comparisonFuncMapping[s.stencilBack.compare], e, 255),
              n.stencilOp(n.KEEP, n.KEEP, this._stencilOpsMapping[s.stencilBack.passOp])))
        }
      }
      Uo.extension = { type: [b.WebGLSystem], name: "stencil" }
    })
  function FC(r) {
    let t = r.map((s) => ({ data: s, offset: 0, size: 0 })),
      e = 16,
      i = 0,
      n = 0
    for (let s = 0; s < t.length; s++) {
      let o = t[s]
      if (((i = Pd[o.data.type]), !i)) throw new Error(`Unknown type ${o.data.type}`)
      o.data.size > 1 && (i = Math.max(i, e) * o.data.size)
      let a = i === 12 ? 16 : i
      o.size = i
      let u = n % e
      ;(u > 0 && e - u < a ? (n += (e - u) % 16) : (n += (i - (u % i)) % i),
        (o.offset = n),
        (n += i))
    }
    return ((n = Math.ceil(n / 16) * 16), { uboElements: t, size: n })
  }
  var Pd,
    Fd = p(() => {
      "use strict"
      Pd = {
        f32: 4,
        i32: 4,
        "vec2<f32>": 8,
        "vec3<f32>": 12,
        "vec4<f32>": 16,
        "vec2<i32>": 8,
        "vec3<i32>": 12,
        "vec4<i32>": 16,
        "mat2x2<f32>": 32,
        "mat3x3<f32>": 48,
        "mat4x4<f32>": 64,
      }
    })
  function RC(r, t) {
    let e = Math.max(Pd[r.data.type] / 16, 1),
      i = r.data.value.length / r.data.size,
      n = (4 - (i % 4)) % 4,
      s = r.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data"
    return `
        v = uv.${r.data.name};
        offset += ${t};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${r.data.size * e}; i++)
        {
            for(var j = 0; j < ${i}; j++)
            {
                ${s}[arrayOffset++] = v[t++];
            }
            ${n !== 0 ? `arrayOffset += ${n};` : ""}
        }
    `
  }
  var BC = p(() => {
    Fd()
  })
  function IC(r) {
    return rl(r, "uboStd40", RC, _d)
  }
  var kC = p(() => {
    xd()
    yd()
    BC()
  })
  var Oo,
    GC = p(() => {
      A()
      pd()
      Fd()
      kC()
      Oo = class extends _n {
        constructor() {
          super({ createUboElements: FC, generateUboSync: IC })
        }
      }
      Oo.extension = { type: [b.WebGLSystem], name: "ubo" }
    })
  var fl,
    UC = p(() => {
      "use strict"
      fl = class {
        constructor() {
          ;((this.width = -1), (this.height = -1), (this.msaa = !1), (this.msaaRenderBuffer = []))
        }
      }
    })
  var dl,
    OC = p(() => {
      Lt()
      ft()
      Ui()
      dn()
      UC()
      dl = class {
        constructor() {
          ;((this._clearColorCache = [0, 0, 0, 0]), (this._viewPortCache = new Q()))
        }
        init(t, e) {
          ;((this._renderer = t), (this._renderTargetSystem = e), t.runners.contextChange.add(this))
        }
        contextChange() {
          ;((this._clearColorCache = [0, 0, 0, 0]), (this._viewPortCache = new Q()))
        }
        copyToTexture(t, e, i, n, s) {
          let o = this._renderTargetSystem,
            a = this._renderer,
            u = o.getGpuRenderTarget(t),
            l = a.gl
          return (
            this.finishRenderPass(t),
            l.bindFramebuffer(l.FRAMEBUFFER, u.resolveTargetFramebuffer),
            a.texture.bind(e, 0),
            l.copyTexSubImage2D(l.TEXTURE_2D, 0, s.x, s.y, i.x, i.y, n.width, n.height),
            e
          )
        }
        startRenderPass(t, e = !0, i, n) {
          let s = this._renderTargetSystem,
            o = t.colorTexture,
            a = s.getGpuRenderTarget(t),
            u = n.y
          ;(t.isRoot && (u = o.pixelHeight - n.height),
            t.colorTextures.forEach((h) => {
              this._renderer.texture.unbind(h)
            }))
          let l = this._renderer.gl
          l.bindFramebuffer(l.FRAMEBUFFER, a.framebuffer)
          let c = this._viewPortCache
          ;((c.x !== n.x || c.y !== u || c.width !== n.width || c.height !== n.height) &&
            ((c.x = n.x),
            (c.y = u),
            (c.width = n.width),
            (c.height = n.height),
            l.viewport(n.x, u, n.width, n.height)),
            !a.depthStencilRenderBuffer && (t.stencil || t.depth) && this._initStencil(a),
            this.clear(t, e, i))
        }
        finishRenderPass(t) {
          let i = this._renderTargetSystem.getGpuRenderTarget(t)
          if (!i.msaa) return
          let n = this._renderer.gl
          ;(n.bindFramebuffer(n.FRAMEBUFFER, i.resolveTargetFramebuffer),
            n.bindFramebuffer(n.READ_FRAMEBUFFER, i.framebuffer),
            n.blitFramebuffer(
              0,
              0,
              i.width,
              i.height,
              0,
              0,
              i.width,
              i.height,
              n.COLOR_BUFFER_BIT,
              n.NEAREST,
            ),
            n.bindFramebuffer(n.FRAMEBUFFER, i.framebuffer))
        }
        initGpuRenderTarget(t) {
          let i = this._renderer.gl,
            n = new fl()
          return t.colorTexture instanceof Yt
            ? (this._renderer.context.ensureCanvasSize(t.colorTexture.resource),
              (n.framebuffer = null),
              n)
            : (this._initColor(t, n), i.bindFramebuffer(i.FRAMEBUFFER, null), n)
        }
        destroyGpuRenderTarget(t) {
          let e = this._renderer.gl
          ;(t.framebuffer && (e.deleteFramebuffer(t.framebuffer), (t.framebuffer = null)),
            t.resolveTargetFramebuffer &&
              (e.deleteFramebuffer(t.resolveTargetFramebuffer),
              (t.resolveTargetFramebuffer = null)),
            t.depthStencilRenderBuffer &&
              (e.deleteRenderbuffer(t.depthStencilRenderBuffer),
              (t.depthStencilRenderBuffer = null)),
            t.msaaRenderBuffer.forEach((i) => {
              e.deleteRenderbuffer(i)
            }),
            (t.msaaRenderBuffer = null))
        }
        clear(t, e, i) {
          if (!e) return
          let n = this._renderTargetSystem
          typeof e == "boolean" && (e = e ? Ht.ALL : Ht.NONE)
          let s = this._renderer.gl
          if (e & Ht.COLOR) {
            i ?? (i = n.defaultClearColor)
            let o = this._clearColorCache,
              a = i
            ;(o[0] !== a[0] || o[1] !== a[1] || o[2] !== a[2] || o[3] !== a[3]) &&
              ((o[0] = a[0]),
              (o[1] = a[1]),
              (o[2] = a[2]),
              (o[3] = a[3]),
              s.clearColor(a[0], a[1], a[2], a[3]))
          }
          s.clear(e)
        }
        resizeGpuRenderTarget(t) {
          if (t.isRoot) return
          let i = this._renderTargetSystem.getGpuRenderTarget(t)
          ;(this._resizeColor(t, i), (t.stencil || t.depth) && this._resizeStencil(i))
        }
        _initColor(t, e) {
          let i = this._renderer,
            n = i.gl,
            s = n.createFramebuffer()
          if (
            ((e.resolveTargetFramebuffer = s),
            n.bindFramebuffer(n.FRAMEBUFFER, s),
            (e.width = t.colorTexture.source.pixelWidth),
            (e.height = t.colorTexture.source.pixelHeight),
            t.colorTextures.forEach((o, a) => {
              let u = o.source
              ;(u.antialias &&
                (i.context.supports.msaa
                  ? (e.msaa = !0)
                  : N("[RenderTexture] Antialiasing on textures is not supported in WebGL1")),
                i.texture.bindSource(u, 0))
              let c = i.texture.getGlSource(u).texture
              n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + a, 3553, c, 0)
            }),
            e.msaa)
          ) {
            let o = n.createFramebuffer()
            ;((e.framebuffer = o),
              n.bindFramebuffer(n.FRAMEBUFFER, o),
              t.colorTextures.forEach((a, u) => {
                let l = n.createRenderbuffer()
                e.msaaRenderBuffer[u] = l
              }))
          } else e.framebuffer = s
          this._resizeColor(t, e)
        }
        _resizeColor(t, e) {
          let i = t.colorTexture.source
          if (
            ((e.width = i.pixelWidth),
            (e.height = i.pixelHeight),
            t.colorTextures.forEach((n, s) => {
              s !== 0 && n.source.resize(i.width, i.height, i._resolution)
            }),
            e.msaa)
          ) {
            let n = this._renderer,
              s = n.gl,
              o = e.framebuffer
            ;(s.bindFramebuffer(s.FRAMEBUFFER, o),
              t.colorTextures.forEach((a, u) => {
                let l = a.source
                n.texture.bindSource(l, 0)
                let h = n.texture.getGlSource(l).internalFormat,
                  f = e.msaaRenderBuffer[u]
                ;(s.bindRenderbuffer(s.RENDERBUFFER, f),
                  s.renderbufferStorageMultisample(
                    s.RENDERBUFFER,
                    4,
                    h,
                    l.pixelWidth,
                    l.pixelHeight,
                  ),
                  s.framebufferRenderbuffer(
                    s.FRAMEBUFFER,
                    s.COLOR_ATTACHMENT0 + u,
                    s.RENDERBUFFER,
                    f,
                  ))
              }))
          }
        }
        _initStencil(t) {
          if (t.framebuffer === null) return
          let e = this._renderer.gl,
            i = e.createRenderbuffer()
          ;((t.depthStencilRenderBuffer = i),
            e.bindRenderbuffer(e.RENDERBUFFER, i),
            e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, i),
            this._resizeStencil(t))
        }
        _resizeStencil(t) {
          let e = this._renderer.gl
          ;(e.bindRenderbuffer(e.RENDERBUFFER, t.depthStencilRenderBuffer),
            t.msaa
              ? e.renderbufferStorageMultisample(
                  e.RENDERBUFFER,
                  4,
                  e.DEPTH24_STENCIL8,
                  t.width,
                  t.height,
                )
              : e.renderbufferStorage(
                  e.RENDERBUFFER,
                  this._renderer.context.webGLVersion === 2 ? e.DEPTH24_STENCIL8 : e.DEPTH_STENCIL,
                  t.width,
                  t.height,
                ))
        }
        prerender(t) {
          let e = t.colorTexture.resource
          this._renderer.context.multiView &&
            Yt.test(e) &&
            this._renderer.context.ensureCanvasSize(e)
        }
        postrender(t) {
          if (this._renderer.context.multiView && Yt.test(t.colorTexture.resource)) {
            let e = this._renderer.context.canvas,
              i = t.colorTexture
            i.context2D.drawImage(e, 0, i.pixelHeight - e.height)
          }
        }
      }
    })
  var Lo,
    LC = p(() => {
      A()
      Sd()
      OC()
      Lo = class extends bn {
        constructor(t) {
          ;(super(t), (this.adaptor = new dl()), this.adaptor.init(t, this))
        }
      }
      Lo.extension = { type: [b.WebGLSystem], name: "renderTarget" }
    })
  function NC(r, t) {
    let e = [],
      i = [
        `
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `,
      ],
      n = !1,
      s = 0,
      o = t._getProgramData(r.glProgram)
    for (let u in r.groups) {
      let l = r.groups[u]
      e.push(`
            resources = g[${u}].resources;
        `)
      for (let c in l.resources) {
        let h = l.resources[c]
        if (h instanceof ht)
          if (h.ubo) {
            let f = r._uniformBindMap[u][Number(c)]
            e.push(`
                        sS.bindUniformBlock(
                            resources[${c}],
                            '${f}',
                            ${r.glProgram._uniformBlockData[f].index}
                        );
                    `)
          } else
            e.push(`
                        ugS.updateUniformGroup(resources[${c}], p, sD);
                    `)
        else if (h instanceof Rr) {
          let f = r._uniformBindMap[u][Number(c)]
          e.push(`
                    sS.bindUniformBlock(
                        resources[${c}],
                        '${f}',
                        ${r.glProgram._uniformBlockData[f].index}
                    );
                `)
        } else if (h instanceof ot) {
          let f = r._uniformBindMap[u][c],
            d = o.uniformData[f]
          d &&
            (n ||
              ((n = !0),
              i.push(`
                        var tS = r.texture;
                        `)),
            t._gl.uniform1i(d.location, s),
            e.push(`
                        tS.bind(resources[${c}], ${s});
                    `),
            s++)
        }
      }
    }
    let a = [...i, ...e].join(`
`)
    return new Function("r", "s", "sD", a)
  }
  var HC = p(() => {
    il()
    re()
    te()
  })
  var pl,
    zC = p(() => {
      "use strict"
      pl = class {
        constructor(t, e) {
          ;((this.program = t),
            (this.uniformData = e),
            (this.uniformGroups = {}),
            (this.uniformDirtyGroups = {}),
            (this.uniformBlockBindings = {}))
        }
        destroy() {
          ;((this.uniformData = null),
            (this.uniformGroups = null),
            (this.uniformDirtyGroups = null),
            (this.uniformBlockBindings = null),
            (this.program = null))
        }
      }
    })
  function Rd(r, t, e) {
    let i = r.createShader(t)
    return (r.shaderSource(i, e), r.compileShader(i), i)
  }
  var WC = p(() => {
    "use strict"
  })
  function Bd(r) {
    let t = new Array(r)
    for (let e = 0; e < t.length; e++) t[e] = !1
    return t
  }
  function ml(r, t) {
    switch (r) {
      case "float":
        return 0
      case "vec2":
        return new Float32Array(2 * t)
      case "vec3":
        return new Float32Array(3 * t)
      case "vec4":
        return new Float32Array(4 * t)
      case "int":
      case "uint":
      case "sampler2D":
      case "sampler2DArray":
        return 0
      case "ivec2":
        return new Int32Array(2 * t)
      case "ivec3":
        return new Int32Array(3 * t)
      case "ivec4":
        return new Int32Array(4 * t)
      case "uvec2":
        return new Uint32Array(2 * t)
      case "uvec3":
        return new Uint32Array(3 * t)
      case "uvec4":
        return new Uint32Array(4 * t)
      case "bool":
        return !1
      case "bvec2":
        return Bd(2 * t)
      case "bvec3":
        return Bd(3 * t)
      case "bvec4":
        return Bd(4 * t)
      case "mat2":
        return new Float32Array([1, 0, 0, 1])
      case "mat3":
        return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1])
      case "mat4":
        return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
    }
    return null
  }
  var Id = p(() => {
    "use strict"
  })
  function kd(r, t) {
    if (!gl) {
      let e = Object.keys(VC)
      gl = {}
      for (let i = 0; i < e.length; ++i) {
        let n = e[i]
        gl[r[n]] = VC[n]
      }
    }
    return gl[t]
  }
  function $C(r, t) {
    let e = kd(r, t)
    return gP[e] || "float32"
  }
  var gl,
    VC,
    gP,
    Gd = p(() => {
      "use strict"
      ;((gl = null),
        (VC = {
          FLOAT: "float",
          FLOAT_VEC2: "vec2",
          FLOAT_VEC3: "vec3",
          FLOAT_VEC4: "vec4",
          INT: "int",
          INT_VEC2: "ivec2",
          INT_VEC3: "ivec3",
          INT_VEC4: "ivec4",
          UNSIGNED_INT: "uint",
          UNSIGNED_INT_VEC2: "uvec2",
          UNSIGNED_INT_VEC3: "uvec3",
          UNSIGNED_INT_VEC4: "uvec4",
          BOOL: "bool",
          BOOL_VEC2: "bvec2",
          BOOL_VEC3: "bvec3",
          BOOL_VEC4: "bvec4",
          FLOAT_MAT2: "mat2",
          FLOAT_MAT3: "mat3",
          FLOAT_MAT4: "mat4",
          SAMPLER_2D: "sampler2D",
          INT_SAMPLER_2D: "sampler2D",
          UNSIGNED_INT_SAMPLER_2D: "sampler2D",
          SAMPLER_CUBE: "samplerCube",
          INT_SAMPLER_CUBE: "samplerCube",
          UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
          SAMPLER_2D_ARRAY: "sampler2DArray",
          INT_SAMPLER_2D_ARRAY: "sampler2DArray",
          UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray",
        }),
        (gP = {
          float: "float32",
          vec2: "float32x2",
          vec3: "float32x3",
          vec4: "float32x4",
          int: "sint32",
          ivec2: "sint32x2",
          ivec3: "sint32x3",
          ivec4: "sint32x4",
          uint: "uint32",
          uvec2: "uint32x2",
          uvec3: "uint32x3",
          uvec4: "uint32x4",
          bool: "uint32",
          bvec2: "uint32x2",
          bvec3: "uint32x3",
          bvec4: "uint32x4",
        }))
    })
  function XC(r, t, e = !1) {
    let i = {},
      n = t.getProgramParameter(r, t.ACTIVE_ATTRIBUTES)
    for (let o = 0; o < n; o++) {
      let a = t.getActiveAttrib(r, o)
      if (a.name.startsWith("gl_")) continue
      let u = $C(t, a.type)
      i[a.name] = {
        location: 0,
        format: u,
        stride: ae(u).stride,
        offset: 0,
        instance: !1,
        start: 0,
      }
    }
    let s = Object.keys(i)
    if (e) {
      s.sort((o, a) => (o > a ? 1 : -1))
      for (let o = 0; o < s.length; o++) ((i[s[o]].location = o), t.bindAttribLocation(r, o, s[o]))
      t.linkProgram(r)
    } else for (let o = 0; o < s.length; o++) i[s[o]].location = t.getAttribLocation(r, s[o])
    return i
  }
  var YC = p(() => {
    ai()
    Gd()
  })
  function jC(r, t) {
    if (!t.ACTIVE_UNIFORM_BLOCKS) return {}
    let e = {},
      i = t.getProgramParameter(r, t.ACTIVE_UNIFORM_BLOCKS)
    for (let n = 0; n < i; n++) {
      let s = t.getActiveUniformBlockName(r, n),
        o = t.getUniformBlockIndex(r, s),
        a = t.getActiveUniformBlockParameter(r, n, t.UNIFORM_BLOCK_DATA_SIZE)
      e[s] = { name: s, index: o, size: a }
    }
    return e
  }
  var KC = p(() => {
    "use strict"
  })
  function qC(r, t) {
    let e = {},
      i = t.getProgramParameter(r, t.ACTIVE_UNIFORMS)
    for (let n = 0; n < i; n++) {
      let s = t.getActiveUniform(r, n),
        o = s.name.replace(/\[.*?\]$/, ""),
        a = !!s.name.match(/\[.*?\]$/),
        u = kd(t, s.type)
      e[o] = { name: o, index: n, type: u, size: s.size, isArray: a, value: ml(u, s.size) }
    }
    return e
  }
  var ZC = p(() => {
    Id()
    Gd()
  })
  function QC(r, t) {
    let e = r
        .getShaderSource(t)
        .split(
          `
`,
        )
        .map((l, c) => `${c}: ${l}`),
      i = r.getShaderInfoLog(t),
      n = i.split(`
`),
      s = {},
      o = n
        .map((l) => parseFloat(l.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1")))
        .filter((l) => (l && !s[l] ? ((s[l] = !0), !0) : !1)),
      a = [""]
    o.forEach((l) => {
      ;((e[l - 1] = `%c${e[l - 1]}%c`),
        a.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px"))
    })
    let u = e.join(`
`)
    ;((a[0] = u),
      console.error(i),
      console.groupCollapsed("click to view full shader code"),
      console.warn(...a),
      console.groupEnd())
  }
  function JC(r, t, e, i) {
    r.getProgramParameter(t, r.LINK_STATUS) ||
      (r.getShaderParameter(e, r.COMPILE_STATUS) || QC(r, e),
      r.getShaderParameter(i, r.COMPILE_STATUS) || QC(r, i),
      console.error("PixiJS Error: Could not initialize shader."),
      r.getProgramInfoLog(t) !== "" &&
        console.warn("PixiJS Warning: gl.getProgramInfoLog()", r.getProgramInfoLog(t)))
  }
  var tE = p(() => {
    "use strict"
  })
  function eE(r, t) {
    let e = Rd(r, r.VERTEX_SHADER, t.vertex),
      i = Rd(r, r.FRAGMENT_SHADER, t.fragment),
      n = r.createProgram()
    ;(r.attachShader(n, e), r.attachShader(n, i))
    let s = t.transformFeedbackVaryings
    ;(s &&
      (typeof r.transformFeedbackVaryings != "function"
        ? N("TransformFeedback is not supported but TransformFeedbackVaryings are given.")
        : r.transformFeedbackVaryings(
            n,
            s.names,
            s.bufferMode === "separate" ? r.SEPARATE_ATTRIBS : r.INTERLEAVED_ATTRIBS,
          )),
      r.linkProgram(n),
      r.getProgramParameter(n, r.LINK_STATUS) || JC(r, n, e, i),
      (t._attributeData = XC(
        n,
        r,
        !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(t.vertex),
      )),
      (t._uniformData = qC(n, r)),
      (t._uniformBlockData = jC(n, r)),
      r.deleteShader(e),
      r.deleteShader(i))
    let o = {}
    for (let u in t._uniformData) {
      let l = t._uniformData[u]
      o[u] = { location: r.getUniformLocation(n, u), value: ml(l.type, l.size) }
    }
    return new pl(n, o)
  }
  var rE = p(() => {
    ft()
    zC()
    WC()
    Id()
    YC()
    KC()
    ZC()
    tE()
  })
  var xl,
    No,
    iE = p(() => {
      A()
      HC()
      rE()
      ;((xl = { textureCount: 0, blockIndex: 0 }),
        (No = class {
          constructor(t) {
            ;((this._activeProgram = null),
              (this._programDataHash = Object.create(null)),
              (this._shaderSyncFunctions = Object.create(null)),
              (this._renderer = t),
              this._renderer.renderableGC.addManagedHash(this, "_programDataHash"))
          }
          contextChange(t) {
            ;((this._gl = t),
              (this._programDataHash = Object.create(null)),
              (this._shaderSyncFunctions = Object.create(null)),
              (this._activeProgram = null))
          }
          bind(t, e) {
            if ((this._setProgram(t.glProgram), e)) return
            ;((xl.textureCount = 0), (xl.blockIndex = 0))
            let i = this._shaderSyncFunctions[t.glProgram._key]
            ;(i ||
              (i = this._shaderSyncFunctions[t.glProgram._key] = this._generateShaderSync(t, this)),
              this._renderer.buffer.nextBindBase(!!t.glProgram.transformFeedbackVaryings),
              i(this._renderer, t, xl))
          }
          updateUniformGroup(t) {
            this._renderer.uniformGroup.updateUniformGroup(t, this._activeProgram, xl)
          }
          bindUniformBlock(t, e, i = 0) {
            let n = this._renderer.buffer,
              s = this._getProgramData(this._activeProgram),
              o = t._bufferResource
            o || this._renderer.ubo.updateUniformGroup(t)
            let a = t.buffer,
              u = n.updateBuffer(a),
              l = n.freeLocationForBufferBase(u)
            if (o) {
              let { offset: h, size: f } = t
              h === 0 && f === a.data.byteLength
                ? n.bindBufferBase(u, l)
                : n.bindBufferRange(u, l, h)
            } else n.getLastBindBaseLocation(u) !== l && n.bindBufferBase(u, l)
            let c = this._activeProgram._uniformBlockData[e].index
            s.uniformBlockBindings[i] !== l &&
              ((s.uniformBlockBindings[i] = l),
              this._renderer.gl.uniformBlockBinding(s.program, c, l))
          }
          _setProgram(t) {
            if (this._activeProgram === t) return
            this._activeProgram = t
            let e = this._getProgramData(t)
            this._gl.useProgram(e.program)
          }
          _getProgramData(t) {
            return this._programDataHash[t._key] || this._createProgramData(t)
          }
          _createProgramData(t) {
            let e = t._key
            return ((this._programDataHash[e] = eE(this._gl, t)), this._programDataHash[e])
          }
          destroy() {
            for (let t of Object.keys(this._programDataHash))
              (this._programDataHash[t].destroy(), (this._programDataHash[t] = null))
            this._programDataHash = null
          }
          _generateShaderSync(t, e) {
            return NC(t, e)
          }
          resetState() {
            this._activeProgram = null
          }
        }))
      No.extension = { type: [b.WebGLSystem], name: "shader" }
    })
  var nE,
    sE,
    oE = p(() => {
      "use strict"
      ;((nE = {
        f32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`,
        "vec2<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`,
        "vec3<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`,
        "vec4<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`,
        i32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
        "vec2<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
        "vec3<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
        "vec4<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
        u32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`,
        "vec2<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`,
        "vec3<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`,
        "vec4<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`,
        bool: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
        "vec2<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
        "vec3<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
        "vec4<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
        "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);",
        "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);",
        "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);",
      }),
        (sE = {
          f32: "gl.uniform1fv(location, v);",
          "vec2<f32>": "gl.uniform2fv(location, v);",
          "vec3<f32>": "gl.uniform3fv(location, v);",
          "vec4<f32>": "gl.uniform4fv(location, v);",
          "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);",
          "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);",
          "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);",
          i32: "gl.uniform1iv(location, v);",
          "vec2<i32>": "gl.uniform2iv(location, v);",
          "vec3<i32>": "gl.uniform3iv(location, v);",
          "vec4<i32>": "gl.uniform4iv(location, v);",
          u32: "gl.uniform1iv(location, v);",
          "vec2<u32>": "gl.uniform2iv(location, v);",
          "vec3<u32>": "gl.uniform3iv(location, v);",
          "vec4<u32>": "gl.uniform4iv(location, v);",
          bool: "gl.uniform1iv(location, v);",
          "vec2<bool>": "gl.uniform2iv(location, v);",
          "vec3<bool>": "gl.uniform3iv(location, v);",
          "vec4<bool>": "gl.uniform4iv(location, v);",
        }))
    })
  function aE(r, t) {
    let e = [
      `
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `,
    ]
    for (let i in r.uniforms) {
      if (!t[i]) {
        r.uniforms[i] instanceof ht
          ? r.uniforms[i].ubo
            ? e.push(`
                        renderer.shader.bindUniformBlock(uv.${i}, "${i}");
                    `)
            : e.push(`
                        renderer.shader.updateUniformGroup(uv.${i});
                    `)
          : r.uniforms[i] instanceof Rr &&
            e.push(`
                        renderer.shader.bindBufferResource(uv.${i}, "${i}");
                    `)
        continue
      }
      let n = r.uniformStructures[i],
        s = !1
      for (let o = 0; o < cr.length; o++) {
        let a = cr[o]
        if (n.type === a.type && a.test(n)) {
          ;(e.push(`name = "${i}";`, cr[o].uniform), (s = !0))
          break
        }
      }
      if (!s) {
        let a = (n.size === 1 ? nE : sE)[n.type].replace("location", `ud["${i}"].location`)
        e.push(`
            cu = ud["${i}"];
            cv = cu.value;
            v = uv["${i}"];
            ${a};`)
      }
    }
    return new Function(
      "ud",
      "uv",
      "renderer",
      "syncData",
      e.join(`
`),
    )
  }
  var uE = p(() => {
    il()
    re()
    gd()
    oE()
  })
  var Ho,
    lE = p(() => {
      A()
      uE()
      Ho = class {
        constructor(t) {
          ;((this._cache = {}),
            (this._uniformGroupSyncHash = {}),
            (this._renderer = t),
            (this.gl = null),
            (this._cache = {}))
        }
        contextChange(t) {
          this.gl = t
        }
        updateUniformGroup(t, e, i) {
          let n = this._renderer.shader._getProgramData(e)
          ;(!t.isStatic || t._dirtyId !== n.uniformDirtyGroups[t.uid]) &&
            ((n.uniformDirtyGroups[t.uid] = t._dirtyId),
            this._getUniformSyncFunction(t, e)(n.uniformData, t.uniforms, this._renderer, i))
        }
        _getUniformSyncFunction(t, e) {
          return (
            this._uniformGroupSyncHash[t._signature]?.[e._key] ||
            this._createUniformSyncFunction(t, e)
          )
        }
        _createUniformSyncFunction(t, e) {
          let i =
              this._uniformGroupSyncHash[t._signature] ||
              (this._uniformGroupSyncHash[t._signature] = {}),
            n = this._getSignature(t, e._uniformData, "u")
          return (
            this._cache[n] || (this._cache[n] = this._generateUniformsSync(t, e._uniformData)),
            (i[e._key] = this._cache[n]),
            i[e._key]
          )
        }
        _generateUniformsSync(t, e) {
          return aE(t, e)
        }
        _getSignature(t, e, i) {
          let n = t.uniforms,
            s = [`${i}-`]
          for (let o in n) (s.push(o), e[o] && s.push(e[o].type))
          return s.join("-")
        }
        destroy() {
          ;((this._renderer = null), (this._cache = null))
        }
      }
      Ho.extension = { type: [b.WebGLSystem], name: "uniformGroup" }
    })
  function cE(r) {
    let t = {}
    if (
      ((t.normal = [r.ONE, r.ONE_MINUS_SRC_ALPHA]),
      (t.add = [r.ONE, r.ONE]),
      (t.multiply = [r.DST_COLOR, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA]),
      (t.screen = [r.ONE, r.ONE_MINUS_SRC_COLOR, r.ONE, r.ONE_MINUS_SRC_ALPHA]),
      (t.none = [0, 0]),
      (t["normal-npm"] = [r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA]),
      (t["add-npm"] = [r.SRC_ALPHA, r.ONE, r.ONE, r.ONE]),
      (t["screen-npm"] = [r.SRC_ALPHA, r.ONE_MINUS_SRC_COLOR, r.ONE, r.ONE_MINUS_SRC_ALPHA]),
      (t.erase = [r.ZERO, r.ONE_MINUS_SRC_ALPHA]),
      !(r instanceof Z.get().getWebGLRenderingContext()))
    )
      ((t.min = [r.ONE, r.ONE, r.ONE, r.ONE, r.MIN, r.MIN]),
        (t.max = [r.ONE, r.ONE, r.ONE, r.ONE, r.MAX, r.MAX]))
    else {
      let i = r.getExtension("EXT_blend_minmax")
      i &&
        ((t.min = [r.ONE, r.ONE, r.ONE, r.ONE, i.MIN_EXT, i.MIN_EXT]),
        (t.max = [r.ONE, r.ONE, r.ONE, r.ONE, i.MAX_EXT, i.MAX_EXT]))
    }
    return t
  }
  var hE = p(() => {
    At()
  })
  var xP,
    _P,
    yP,
    bP,
    vP,
    SP,
    fE,
    dE,
    pE = p(() => {
      A()
      De()
      hE()
      ;((xP = 0),
        (_P = 1),
        (yP = 2),
        (bP = 3),
        (vP = 4),
        (SP = 5),
        (fE = class Ud {
          constructor(t) {
            ;((this._invertFrontFace = !1),
              (this.gl = null),
              (this.stateId = 0),
              (this.polygonOffset = 0),
              (this.blendMode = "none"),
              (this._blendEq = !1),
              (this.map = []),
              (this.map[xP] = this.setBlend),
              (this.map[_P] = this.setOffset),
              (this.map[yP] = this.setCullFace),
              (this.map[bP] = this.setDepthTest),
              (this.map[vP] = this.setFrontFace),
              (this.map[SP] = this.setDepthMask),
              (this.checks = []),
              (this.defaultState = Dt.for2d()),
              t.renderTarget.onRenderTargetChange.add(this))
          }
          onRenderTargetChange(t) {
            ;((this._invertFrontFace = !t.isRoot),
              this._cullFace ? this.setFrontFace(this._frontFace) : (this._frontFaceDirty = !0))
          }
          contextChange(t) {
            ;((this.gl = t), (this.blendModesMap = cE(t)), this.resetState())
          }
          set(t) {
            if ((t || (t = this.defaultState), this.stateId !== t.data)) {
              let e = this.stateId ^ t.data,
                i = 0
              for (; e; ) (e & 1 && this.map[i].call(this, !!(t.data & (1 << i))), (e >>= 1), i++)
              this.stateId = t.data
            }
            for (let e = 0; e < this.checks.length; e++) this.checks[e](this, t)
          }
          forceState(t) {
            t || (t = this.defaultState)
            for (let e = 0; e < this.map.length; e++) this.map[e].call(this, !!(t.data & (1 << e)))
            for (let e = 0; e < this.checks.length; e++) this.checks[e](this, t)
            this.stateId = t.data
          }
          setBlend(t) {
            ;(this._updateCheck(Ud._checkBlendMode, t),
              this.gl[t ? "enable" : "disable"](this.gl.BLEND))
          }
          setOffset(t) {
            ;(this._updateCheck(Ud._checkPolygonOffset, t),
              this.gl[t ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL))
          }
          setDepthTest(t) {
            this.gl[t ? "enable" : "disable"](this.gl.DEPTH_TEST)
          }
          setDepthMask(t) {
            this.gl.depthMask(t)
          }
          setCullFace(t) {
            ;((this._cullFace = t),
              this.gl[t ? "enable" : "disable"](this.gl.CULL_FACE),
              this._cullFace && this._frontFaceDirty && this.setFrontFace(this._frontFace))
          }
          setFrontFace(t) {
            ;((this._frontFace = t), (this._frontFaceDirty = !1))
            let e = this._invertFrontFace ? !t : t
            this._glFrontFace !== e &&
              ((this._glFrontFace = e), this.gl.frontFace(this.gl[e ? "CW" : "CCW"]))
          }
          setBlendMode(t) {
            if ((this.blendModesMap[t] || (t = "normal"), t === this.blendMode)) return
            this.blendMode = t
            let e = this.blendModesMap[t],
              i = this.gl
            ;(e.length === 2
              ? i.blendFunc(e[0], e[1])
              : i.blendFuncSeparate(e[0], e[1], e[2], e[3]),
              e.length === 6
                ? ((this._blendEq = !0), i.blendEquationSeparate(e[4], e[5]))
                : this._blendEq &&
                  ((this._blendEq = !1), i.blendEquationSeparate(i.FUNC_ADD, i.FUNC_ADD)))
          }
          setPolygonOffset(t, e) {
            this.gl.polygonOffset(t, e)
          }
          resetState() {
            ;((this._glFrontFace = !1),
              (this._frontFace = !1),
              (this._cullFace = !1),
              (this._frontFaceDirty = !1),
              (this._invertFrontFace = !1),
              this.gl.frontFace(this.gl.CCW),
              this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1),
              this.forceState(this.defaultState),
              (this._blendEq = !0),
              (this.blendMode = ""),
              this.setBlendMode("normal"))
          }
          _updateCheck(t, e) {
            let i = this.checks.indexOf(t)
            e && i === -1 ? this.checks.push(t) : !e && i !== -1 && this.checks.splice(i, 1)
          }
          static _checkBlendMode(t, e) {
            t.setBlendMode(e.blendMode)
          }
          static _checkPolygonOffset(t, e) {
            t.setPolygonOffset(1, e.polygonOffset)
          }
          destroy() {
            ;((this.gl = null), (this.checks.length = 0))
          }
        }))
      fE.extension = { type: [b.WebGLSystem], name: "state" }
      dE = fE
    })
  var _l,
    mE = p(() => {
      Ad()
      _l = class {
        constructor(t) {
          ;((this.target = Md.TEXTURE_2D),
            (this.texture = t),
            (this.width = -1),
            (this.height = -1),
            (this.type = st.UNSIGNED_BYTE),
            (this.internalFormat = hl.RGBA),
            (this.format = hl.RGBA),
            (this.samplerType = 0))
        }
      }
    })
  var gE,
    xE = p(() => {
      "use strict"
      gE = {
        id: "buffer",
        upload(r, t, e) {
          ;(t.width === r.width || t.height === r.height
            ? e.texSubImage2D(
                e.TEXTURE_2D,
                0,
                0,
                0,
                r.width,
                r.height,
                t.format,
                t.type,
                r.resource,
              )
            : e.texImage2D(
                t.target,
                0,
                t.internalFormat,
                r.width,
                r.height,
                0,
                t.format,
                t.type,
                r.resource,
              ),
            (t.width = r.width),
            (t.height = r.height))
        },
      }
    })
  var TP,
    _E,
    yE = p(() => {
      "use strict"
      ;((TP = {
        "bc1-rgba-unorm": !0,
        "bc1-rgba-unorm-srgb": !0,
        "bc2-rgba-unorm": !0,
        "bc2-rgba-unorm-srgb": !0,
        "bc3-rgba-unorm": !0,
        "bc3-rgba-unorm-srgb": !0,
        "bc4-r-unorm": !0,
        "bc4-r-snorm": !0,
        "bc5-rg-unorm": !0,
        "bc5-rg-snorm": !0,
        "bc6h-rgb-ufloat": !0,
        "bc6h-rgb-float": !0,
        "bc7-rgba-unorm": !0,
        "bc7-rgba-unorm-srgb": !0,
        "etc2-rgb8unorm": !0,
        "etc2-rgb8unorm-srgb": !0,
        "etc2-rgb8a1unorm": !0,
        "etc2-rgb8a1unorm-srgb": !0,
        "etc2-rgba8unorm": !0,
        "etc2-rgba8unorm-srgb": !0,
        "eac-r11unorm": !0,
        "eac-r11snorm": !0,
        "eac-rg11unorm": !0,
        "eac-rg11snorm": !0,
        "astc-4x4-unorm": !0,
        "astc-4x4-unorm-srgb": !0,
        "astc-5x4-unorm": !0,
        "astc-5x4-unorm-srgb": !0,
        "astc-5x5-unorm": !0,
        "astc-5x5-unorm-srgb": !0,
        "astc-6x5-unorm": !0,
        "astc-6x5-unorm-srgb": !0,
        "astc-6x6-unorm": !0,
        "astc-6x6-unorm-srgb": !0,
        "astc-8x5-unorm": !0,
        "astc-8x5-unorm-srgb": !0,
        "astc-8x6-unorm": !0,
        "astc-8x6-unorm-srgb": !0,
        "astc-8x8-unorm": !0,
        "astc-8x8-unorm-srgb": !0,
        "astc-10x5-unorm": !0,
        "astc-10x5-unorm-srgb": !0,
        "astc-10x6-unorm": !0,
        "astc-10x6-unorm-srgb": !0,
        "astc-10x8-unorm": !0,
        "astc-10x8-unorm-srgb": !0,
        "astc-10x10-unorm": !0,
        "astc-10x10-unorm-srgb": !0,
        "astc-12x10-unorm": !0,
        "astc-12x10-unorm-srgb": !0,
        "astc-12x12-unorm": !0,
        "astc-12x12-unorm-srgb": !0,
      }),
        (_E = {
          id: "compressed",
          upload(r, t, e) {
            e.pixelStorei(e.UNPACK_ALIGNMENT, 4)
            let i = r.pixelWidth,
              n = r.pixelHeight,
              s = !!TP[r.format]
            for (let o = 0; o < r.resource.length; o++) {
              let a = r.resource[o]
              ;(s
                ? e.compressedTexImage2D(e.TEXTURE_2D, o, t.internalFormat, i, n, 0, a)
                : e.texImage2D(e.TEXTURE_2D, o, t.internalFormat, i, n, 0, t.format, t.type, a),
                (i = Math.max(i >> 1, 1)),
                (n = Math.max(n >> 1, 1)))
            }
          },
        }))
    })
  var yl,
    Od = p(() => {
      "use strict"
      yl = {
        id: "image",
        upload(r, t, e, i) {
          let n = t.width,
            s = t.height,
            o = r.pixelWidth,
            a = r.pixelHeight,
            u = r.resourceWidth,
            l = r.resourceHeight
          ;(u < o || l < a
            ? ((n !== o || s !== a) &&
                e.texImage2D(t.target, 0, t.internalFormat, o, a, 0, t.format, t.type, null),
              i === 2
                ? e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, u, l, t.format, t.type, r.resource)
                : e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, t.format, t.type, r.resource))
            : n === o && s === a
              ? e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, t.format, t.type, r.resource)
              : i === 2
                ? e.texImage2D(t.target, 0, t.internalFormat, o, a, 0, t.format, t.type, r.resource)
                : e.texImage2D(t.target, 0, t.internalFormat, t.format, t.type, r.resource),
            (t.width = o),
            (t.height = a))
        },
      }
    })
  var bE,
    vE = p(() => {
      Od()
      bE = {
        id: "video",
        upload(r, t, e, i) {
          if (!r.isValid) {
            e.texImage2D(t.target, 0, t.internalFormat, 1, 1, 0, t.format, t.type, null)
            return
          }
          yl.upload(r, t, e, i)
        },
      }
    })
  var Ld,
    SE,
    bl,
    TE,
    CE = p(() => {
      "use strict"
      ;((Ld = { linear: 9729, nearest: 9728 }),
        (SE = {
          linear: { linear: 9987, nearest: 9985 },
          nearest: { linear: 9986, nearest: 9984 },
        }),
        (bl = { "clamp-to-edge": 33071, repeat: 10497, "mirror-repeat": 33648 }),
        (TE = {
          never: 512,
          less: 513,
          equal: 514,
          "less-equal": 515,
          greater: 516,
          "not-equal": 517,
          "greater-equal": 518,
          always: 519,
        }))
    })
  function Nd(r, t, e, i, n, s, o, a) {
    let u = s
    if (
      !a ||
      r.addressModeU !== "repeat" ||
      r.addressModeV !== "repeat" ||
      r.addressModeW !== "repeat"
    ) {
      let l = bl[o ? "clamp-to-edge" : r.addressModeU],
        c = bl[o ? "clamp-to-edge" : r.addressModeV],
        h = bl[o ? "clamp-to-edge" : r.addressModeW]
      ;(t[n](u, t.TEXTURE_WRAP_S, l),
        t[n](u, t.TEXTURE_WRAP_T, c),
        t.TEXTURE_WRAP_R && t[n](u, t.TEXTURE_WRAP_R, h))
    }
    if (((!a || r.magFilter !== "linear") && t[n](u, t.TEXTURE_MAG_FILTER, Ld[r.magFilter]), e)) {
      if (!a || r.mipmapFilter !== "linear") {
        let l = SE[r.minFilter][r.mipmapFilter]
        t[n](u, t.TEXTURE_MIN_FILTER, l)
      }
    } else t[n](u, t.TEXTURE_MIN_FILTER, Ld[r.minFilter])
    if (i && r.maxAnisotropy > 1) {
      let l = Math.min(r.maxAnisotropy, t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT))
      t[n](u, i.TEXTURE_MAX_ANISOTROPY_EXT, l)
    }
    r.compare && t[n](u, t.TEXTURE_COMPARE_FUNC, TE[r.compare])
  }
  var EE = p(() => {
    CE()
  })
  function wE(r) {
    return {
      r8unorm: r.RED,
      r8snorm: r.RED,
      r8uint: r.RED,
      r8sint: r.RED,
      r16uint: r.RED,
      r16sint: r.RED,
      r16float: r.RED,
      rg8unorm: r.RG,
      rg8snorm: r.RG,
      rg8uint: r.RG,
      rg8sint: r.RG,
      r32uint: r.RED,
      r32sint: r.RED,
      r32float: r.RED,
      rg16uint: r.RG,
      rg16sint: r.RG,
      rg16float: r.RG,
      rgba8unorm: r.RGBA,
      "rgba8unorm-srgb": r.RGBA,
      rgba8snorm: r.RGBA,
      rgba8uint: r.RGBA,
      rgba8sint: r.RGBA,
      bgra8unorm: r.RGBA,
      "bgra8unorm-srgb": r.RGBA,
      rgb9e5ufloat: r.RGB,
      rgb10a2unorm: r.RGBA,
      rg11b10ufloat: r.RGB,
      rg32uint: r.RG,
      rg32sint: r.RG,
      rg32float: r.RG,
      rgba16uint: r.RGBA,
      rgba16sint: r.RGBA,
      rgba16float: r.RGBA,
      rgba32uint: r.RGBA,
      rgba32sint: r.RGBA,
      rgba32float: r.RGBA,
      stencil8: r.STENCIL_INDEX8,
      depth16unorm: r.DEPTH_COMPONENT,
      depth24plus: r.DEPTH_COMPONENT,
      "depth24plus-stencil8": r.DEPTH_STENCIL,
      depth32float: r.DEPTH_COMPONENT,
      "depth32float-stencil8": r.DEPTH_STENCIL,
    }
  }
  var ME = p(() => {
    "use strict"
  })
  function AE(r, t) {
    let e = {},
      i = r.RGBA
    return (
      r instanceof Z.get().getWebGLRenderingContext()
        ? t.srgb &&
          (e = {
            "rgba8unorm-srgb": t.srgb.SRGB8_ALPHA8_EXT,
            "bgra8unorm-srgb": t.srgb.SRGB8_ALPHA8_EXT,
          })
        : ((e = { "rgba8unorm-srgb": r.SRGB8_ALPHA8, "bgra8unorm-srgb": r.SRGB8_ALPHA8 }),
          (i = r.RGBA8)),
      {
        r8unorm: r.R8,
        r8snorm: r.R8_SNORM,
        r8uint: r.R8UI,
        r8sint: r.R8I,
        r16uint: r.R16UI,
        r16sint: r.R16I,
        r16float: r.R16F,
        rg8unorm: r.RG8,
        rg8snorm: r.RG8_SNORM,
        rg8uint: r.RG8UI,
        rg8sint: r.RG8I,
        r32uint: r.R32UI,
        r32sint: r.R32I,
        r32float: r.R32F,
        rg16uint: r.RG16UI,
        rg16sint: r.RG16I,
        rg16float: r.RG16F,
        rgba8unorm: r.RGBA,
        ...e,
        rgba8snorm: r.RGBA8_SNORM,
        rgba8uint: r.RGBA8UI,
        rgba8sint: r.RGBA8I,
        bgra8unorm: i,
        rgb9e5ufloat: r.RGB9_E5,
        rgb10a2unorm: r.RGB10_A2,
        rg11b10ufloat: r.R11F_G11F_B10F,
        rg32uint: r.RG32UI,
        rg32sint: r.RG32I,
        rg32float: r.RG32F,
        rgba16uint: r.RGBA16UI,
        rgba16sint: r.RGBA16I,
        rgba16float: r.RGBA16F,
        rgba32uint: r.RGBA32UI,
        rgba32sint: r.RGBA32I,
        rgba32float: r.RGBA32F,
        stencil8: r.STENCIL_INDEX8,
        depth16unorm: r.DEPTH_COMPONENT16,
        depth24plus: r.DEPTH_COMPONENT24,
        "depth24plus-stencil8": r.DEPTH24_STENCIL8,
        depth32float: r.DEPTH_COMPONENT32F,
        "depth32float-stencil8": r.DEPTH32F_STENCIL8,
        ...(t.s3tc
          ? {
              "bc1-rgba-unorm": t.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,
              "bc2-rgba-unorm": t.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,
              "bc3-rgba-unorm": t.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT,
            }
          : {}),
        ...(t.s3tc_sRGB
          ? {
              "bc1-rgba-unorm-srgb": t.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
              "bc2-rgba-unorm-srgb": t.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
              "bc3-rgba-unorm-srgb": t.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,
            }
          : {}),
        ...(t.rgtc
          ? {
              "bc4-r-unorm": t.rgtc.COMPRESSED_RED_RGTC1_EXT,
              "bc4-r-snorm": t.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,
              "bc5-rg-unorm": t.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,
              "bc5-rg-snorm": t.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT,
            }
          : {}),
        ...(t.bptc
          ? {
              "bc6h-rgb-float": t.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
              "bc6h-rgb-ufloat": t.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
              "bc7-rgba-unorm": t.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
              "bc7-rgba-unorm-srgb": t.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT,
            }
          : {}),
        ...(t.etc
          ? {
              "etc2-rgb8unorm": t.etc.COMPRESSED_RGB8_ETC2,
              "etc2-rgb8unorm-srgb": t.etc.COMPRESSED_SRGB8_ETC2,
              "etc2-rgb8a1unorm": t.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
              "etc2-rgb8a1unorm-srgb": t.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
              "etc2-rgba8unorm": t.etc.COMPRESSED_RGBA8_ETC2_EAC,
              "etc2-rgba8unorm-srgb": t.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
              "eac-r11unorm": t.etc.COMPRESSED_R11_EAC,
              "eac-rg11unorm": t.etc.COMPRESSED_SIGNED_RG11_EAC,
            }
          : {}),
        ...(t.astc
          ? {
              "astc-4x4-unorm": t.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
              "astc-4x4-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
              "astc-5x4-unorm": t.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,
              "astc-5x4-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,
              "astc-5x5-unorm": t.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,
              "astc-5x5-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
              "astc-6x5-unorm": t.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,
              "astc-6x5-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
              "astc-6x6-unorm": t.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,
              "astc-6x6-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
              "astc-8x5-unorm": t.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,
              "astc-8x5-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
              "astc-8x6-unorm": t.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,
              "astc-8x6-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
              "astc-8x8-unorm": t.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,
              "astc-8x8-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
              "astc-10x5-unorm": t.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,
              "astc-10x5-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
              "astc-10x6-unorm": t.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,
              "astc-10x6-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
              "astc-10x8-unorm": t.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,
              "astc-10x8-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
              "astc-10x10-unorm": t.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,
              "astc-10x10-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
              "astc-12x10-unorm": t.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,
              "astc-12x10-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
              "astc-12x12-unorm": t.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,
              "astc-12x12-unorm-srgb": t.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR,
            }
          : {}),
      }
    )
  }
  var DE = p(() => {
    At()
  })
  function PE(r) {
    return {
      r8unorm: r.UNSIGNED_BYTE,
      r8snorm: r.BYTE,
      r8uint: r.UNSIGNED_BYTE,
      r8sint: r.BYTE,
      r16uint: r.UNSIGNED_SHORT,
      r16sint: r.SHORT,
      r16float: r.HALF_FLOAT,
      rg8unorm: r.UNSIGNED_BYTE,
      rg8snorm: r.BYTE,
      rg8uint: r.UNSIGNED_BYTE,
      rg8sint: r.BYTE,
      r32uint: r.UNSIGNED_INT,
      r32sint: r.INT,
      r32float: r.FLOAT,
      rg16uint: r.UNSIGNED_SHORT,
      rg16sint: r.SHORT,
      rg16float: r.HALF_FLOAT,
      rgba8unorm: r.UNSIGNED_BYTE,
      "rgba8unorm-srgb": r.UNSIGNED_BYTE,
      rgba8snorm: r.BYTE,
      rgba8uint: r.UNSIGNED_BYTE,
      rgba8sint: r.BYTE,
      bgra8unorm: r.UNSIGNED_BYTE,
      "bgra8unorm-srgb": r.UNSIGNED_BYTE,
      rgb9e5ufloat: r.UNSIGNED_INT_5_9_9_9_REV,
      rgb10a2unorm: r.UNSIGNED_INT_2_10_10_10_REV,
      rg11b10ufloat: r.UNSIGNED_INT_10F_11F_11F_REV,
      rg32uint: r.UNSIGNED_INT,
      rg32sint: r.INT,
      rg32float: r.FLOAT,
      rgba16uint: r.UNSIGNED_SHORT,
      rgba16sint: r.SHORT,
      rgba16float: r.HALF_FLOAT,
      rgba32uint: r.UNSIGNED_INT,
      rgba32sint: r.INT,
      rgba32float: r.FLOAT,
      stencil8: r.UNSIGNED_BYTE,
      depth16unorm: r.UNSIGNED_SHORT,
      depth24plus: r.UNSIGNED_INT,
      "depth24plus-stencil8": r.UNSIGNED_INT_24_8,
      depth32float: r.FLOAT,
      "depth32float-stencil8": r.FLOAT_32_UNSIGNED_INT_24_8_REV,
    }
  }
  var FE = p(() => {
    "use strict"
  })
  var CP,
    zo,
    RE = p(() => {
      At()
      A()
      dt()
      mE()
      xE()
      yE()
      Od()
      vE()
      EE()
      ME()
      DE()
      FE()
      ;((CP = 4),
        (zo = class {
          constructor(t) {
            ;((this.managedTextures = []),
              (this._glTextures = Object.create(null)),
              (this._glSamplers = Object.create(null)),
              (this._boundTextures = []),
              (this._activeTextureLocation = -1),
              (this._boundSamplers = Object.create(null)),
              (this._uploads = { image: yl, buffer: gE, video: bE, compressed: _E }),
              (this._premultiplyAlpha = !1),
              (this._useSeparateSamplers = !1),
              (this._renderer = t),
              this._renderer.renderableGC.addManagedHash(this, "_glTextures"),
              this._renderer.renderableGC.addManagedHash(this, "_glSamplers"))
          }
          contextChange(t) {
            ;((this._gl = t),
              this._mapFormatToInternalFormat ||
                ((this._mapFormatToInternalFormat = AE(t, this._renderer.context.extensions)),
                (this._mapFormatToType = PE(t)),
                (this._mapFormatToFormat = wE(t))),
              (this._glTextures = Object.create(null)),
              (this._glSamplers = Object.create(null)),
              (this._boundSamplers = Object.create(null)),
              (this._premultiplyAlpha = !1))
            for (let e = 0; e < 16; e++) this.bind(k.EMPTY, e)
          }
          initSource(t) {
            this.bind(t)
          }
          bind(t, e = 0) {
            let i = t.source
            t
              ? (this.bindSource(i, e), this._useSeparateSamplers && this._bindSampler(i.style, e))
              : (this.bindSource(null, e), this._useSeparateSamplers && this._bindSampler(null, e))
          }
          bindSource(t, e = 0) {
            let i = this._gl
            if (((t._touched = this._renderer.textureGC.count), this._boundTextures[e] !== t)) {
              ;((this._boundTextures[e] = t), this._activateLocation(e), t || (t = k.EMPTY.source))
              let n = this.getGlSource(t)
              i.bindTexture(n.target, n.texture)
            }
          }
          _bindSampler(t, e = 0) {
            let i = this._gl
            if (!t) {
              ;((this._boundSamplers[e] = null), i.bindSampler(e, null))
              return
            }
            let n = this._getGlSampler(t)
            this._boundSamplers[e] !== n && ((this._boundSamplers[e] = n), i.bindSampler(e, n))
          }
          unbind(t) {
            let e = t.source,
              i = this._boundTextures,
              n = this._gl
            for (let s = 0; s < i.length; s++)
              if (i[s] === e) {
                this._activateLocation(s)
                let o = this.getGlSource(e)
                ;(n.bindTexture(o.target, null), (i[s] = null))
              }
          }
          _activateLocation(t) {
            this._activeTextureLocation !== t &&
              ((this._activeTextureLocation = t), this._gl.activeTexture(this._gl.TEXTURE0 + t))
          }
          _initSource(t) {
            let e = this._gl,
              i = new _l(e.createTexture())
            if (
              ((i.type = this._mapFormatToType[t.format]),
              (i.internalFormat = this._mapFormatToInternalFormat[t.format]),
              (i.format = this._mapFormatToFormat[t.format]),
              t.autoGenerateMipmaps &&
                (this._renderer.context.supports.nonPowOf2mipmaps || t.isPowerOfTwo))
            ) {
              let n = Math.max(t.width, t.height)
              t.mipLevelCount = Math.floor(Math.log2(n)) + 1
            }
            return (
              (this._glTextures[t.uid] = i),
              this.managedTextures.includes(t) ||
                (t.on("update", this.onSourceUpdate, this),
                t.on("resize", this.onSourceUpdate, this),
                t.on("styleChange", this.onStyleChange, this),
                t.on("destroy", this.onSourceDestroy, this),
                t.on("unload", this.onSourceUnload, this),
                t.on("updateMipmaps", this.onUpdateMipmaps, this),
                this.managedTextures.push(t)),
              this.onSourceUpdate(t),
              this.updateStyle(t, !1),
              i
            )
          }
          onStyleChange(t) {
            this.updateStyle(t, !1)
          }
          updateStyle(t, e) {
            let i = this._gl,
              n = this.getGlSource(t)
            ;(i.bindTexture(i.TEXTURE_2D, n.texture),
              (this._boundTextures[this._activeTextureLocation] = t),
              Nd(
                t.style,
                i,
                t.mipLevelCount > 1,
                this._renderer.context.extensions.anisotropicFiltering,
                "texParameteri",
                i.TEXTURE_2D,
                !this._renderer.context.supports.nonPowOf2wrapping && !t.isPowerOfTwo,
                e,
              ))
          }
          onSourceUnload(t) {
            let e = this._glTextures[t.uid]
            e &&
              (this.unbind(t), (this._glTextures[t.uid] = null), this._gl.deleteTexture(e.texture))
          }
          onSourceUpdate(t) {
            let e = this._gl,
              i = this.getGlSource(t)
            ;(e.bindTexture(e.TEXTURE_2D, i.texture),
              (this._boundTextures[this._activeTextureLocation] = t))
            let n = t.alphaMode === "premultiply-alpha-on-upload"
            ;(this._premultiplyAlpha !== n &&
              ((this._premultiplyAlpha = n), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n)),
              this._uploads[t.uploadMethodId]
                ? this._uploads[t.uploadMethodId].upload(
                    t,
                    i,
                    e,
                    this._renderer.context.webGLVersion,
                  )
                : e.texImage2D(
                    e.TEXTURE_2D,
                    0,
                    e.RGBA,
                    t.pixelWidth,
                    t.pixelHeight,
                    0,
                    e.RGBA,
                    e.UNSIGNED_BYTE,
                    null,
                  ),
              t.autoGenerateMipmaps && t.mipLevelCount > 1 && this.onUpdateMipmaps(t, !1))
          }
          onUpdateMipmaps(t, e = !0) {
            e && this.bindSource(t, 0)
            let i = this.getGlSource(t)
            this._gl.generateMipmap(i.target)
          }
          onSourceDestroy(t) {
            ;(t.off("destroy", this.onSourceDestroy, this),
              t.off("update", this.onSourceUpdate, this),
              t.off("resize", this.onSourceUpdate, this),
              t.off("unload", this.onSourceUnload, this),
              t.off("styleChange", this.onStyleChange, this),
              t.off("updateMipmaps", this.onUpdateMipmaps, this),
              this.managedTextures.splice(this.managedTextures.indexOf(t), 1),
              this.onSourceUnload(t))
          }
          _initSampler(t) {
            let e = this._gl,
              i = this._gl.createSampler()
            return (
              (this._glSamplers[t._resourceId] = i),
              Nd(
                t,
                e,
                this._boundTextures[this._activeTextureLocation].mipLevelCount > 1,
                this._renderer.context.extensions.anisotropicFiltering,
                "samplerParameteri",
                i,
                !1,
                !0,
              ),
              this._glSamplers[t._resourceId]
            )
          }
          _getGlSampler(t) {
            return this._glSamplers[t._resourceId] || this._initSampler(t)
          }
          getGlSource(t) {
            return this._glTextures[t.uid] || this._initSource(t)
          }
          generateCanvas(t) {
            let { pixels: e, width: i, height: n } = this.getPixels(t),
              s = Z.get().createCanvas()
            ;((s.width = i), (s.height = n))
            let o = s.getContext("2d")
            if (o) {
              let a = o.createImageData(i, n)
              ;(a.data.set(e), o.putImageData(a, 0, 0))
            }
            return s
          }
          getPixels(t) {
            let e = t.source.resolution,
              i = t.frame,
              n = Math.max(Math.round(i.width * e), 1),
              s = Math.max(Math.round(i.height * e), 1),
              o = new Uint8Array(CP * n * s),
              a = this._renderer,
              u = a.renderTarget.getRenderTarget(t),
              l = a.renderTarget.getGpuRenderTarget(u),
              c = a.gl
            return (
              c.bindFramebuffer(c.FRAMEBUFFER, l.resolveTargetFramebuffer),
              c.readPixels(
                Math.round(i.x * e),
                Math.round(i.y * e),
                n,
                s,
                c.RGBA,
                c.UNSIGNED_BYTE,
                o,
              ),
              { pixels: new Uint8ClampedArray(o.buffer), width: n, height: s }
            )
          }
          destroy() {
            ;(this.managedTextures.slice().forEach((t) => this.onSourceDestroy(t)),
              (this.managedTextures = null),
              (this._renderer = null))
          }
          resetState() {
            ;((this._activeTextureLocation = -1),
              this._boundTextures.fill(k.EMPTY.source),
              (this._boundSamplers = Object.create(null)))
            let t = this._gl
            ;((this._premultiplyAlpha = !1),
              t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiplyAlpha))
          }
        }))
      zo.extension = { type: [b.WebGLSystem], name: "texture" }
    })
  var GE = {}
  Xd(GE, { WebGLRenderer: () => Hd })
  var EP,
    wP,
    MP,
    BE,
    IE,
    kE,
    Hd,
    UE = p(() => {
      A()
      hC()
      fC()
      dC()
      $s()
      dd()
      Le()
      gC()
      yC()
      TC()
      wC()
      MC()
      AC()
      DC()
      PC()
      GC()
      LC()
      iE()
      lE()
      pE()
      RE()
      ;((EP = [...tl, Oo, EC, _C, Go, Ro, zo, Lo, Bo, Ho, No, ko, dE, Uo, Io]),
        (wP = [...el]),
        (MP = [Po, Do, Ao]),
        (BE = []),
        (IE = []),
        (kE = []))
      L.handleByNamedList(b.WebGLSystem, BE)
      L.handleByNamedList(b.WebGLPipes, IE)
      L.handleByNamedList(b.WebGLPipesAdaptor, kE)
      L.add(...EP, ...wP, ...MP)
      Hd = class extends Fr {
        constructor() {
          let t = {
            name: "webgl",
            type: Bt.WEBGL,
            systems: BE,
            renderPipes: IE,
            renderPipeAdaptors: kE,
          }
          super(t)
        }
      }
    })
  var Ml = class r {
      static instance = null
      CACHE_PREFIXES = { content: "content_", link: "link_", search: "search_" }
      constructor() {}
      static getInstance() {
        return (r.instance || (r.instance = new r()), r.instance)
      }
      processURL(t, e = {}) {
        let {
          removeHash: i = !0,
          normalizePath: n = !0,
          validate: s = !0,
          cacheType: o = "content",
        } = e
        try {
          if (s && !this.isValidURL(t))
            return {
              original: t,
              processed: new URL("about:blank"),
              cacheKey: "",
              isValid: !1,
              error: "Invalid URL format",
            }
          let a = t
          i && (a = a.split("#")[0])
          let u = new URL(a)
          n && (u.pathname = this.normalizePath(u.pathname))
          let l = this.generateCacheKey(u.toString(), o)
          return (
            console.debug(`[URLHandler Debug] Cache Key: ${l}`),
            { original: t, processed: u, cacheKey: l, isValid: !0 }
          )
        } catch (a) {
          return {
            original: t,
            processed: new URL("about:blank"),
            cacheKey: "",
            isValid: !1,
            error: a.message,
          }
        }
      }
      getContentURL(t) {
        let e = this.processURL(t, {
          removeHash: !0,
          normalizePath: !0,
          validate: !0,
          cacheType: "content",
        })
        if (!e.isValid) throw new Error(`Invalid URL: ${t} - ${e.error}`)
        return e.processed
      }
      getCacheKey(t, e = "content") {
        return this.processURL(t, { cacheType: e }).cacheKey
      }
      processBatch(t, e = {}) {
        return t.map((i) => this.processURL(i, e))
      }
      isValidURL(t) {
        if (!t || typeof t != "string" || t.length === 0) return !1
        try {
          return (new URL(t), !0)
        } catch {
          return !1
        }
      }
      normalizePath(t) {
        if (
          (t.endsWith(".md") && (t = t.slice(0, -3)),
          t.endsWith("/index") && (t = t.slice(0, -6)),
          t.endsWith("/") && t.length > 1 && (t = t.slice(0, -1)),
          t === "")
        )
          return "/"
        let e = t.split("/").filter(Boolean),
          i = [],
          n = new Set()
        for (let o of e) n.has(o) || (n.add(o), i.push(o))
        return "/" + i.join("/")
      }
      generateCacheKey(t, e) {
        let i = encodeURIComponent(t)
        return `${this.CACHE_PREFIXES[e]}${i}`
      }
      isInternalLink(t) {
        try {
          return new URL(t).origin === window.location.origin
        } catch {
          return !1
        }
      }
      shouldPreload(t) {
        if (!this.isInternalLink(t)) return !1
        try {
          let e = new URL(t)
          return !(
            [".pdf", ".zip", ".rar", ".7z", ".tar", ".gz"].some((n) =>
              e.pathname.toLowerCase().endsWith(n),
            ) ||
            e.pathname.startsWith("/api/") ||
            e.pathname.startsWith("/admin/") ||
            (e.pathname === window.location.pathname && e.hash)
          )
        } catch {
          return !1
        }
      }
      isSamePage(t) {
        return t.origin === window.location.origin && t.pathname === window.location.pathname
      }
    },
    Al = Ml.getInstance()
  var Ur = (r) =>
      r
        ? r
            .toLowerCase()
            .replace(et.CONVENTIONS.FORBIDDEN_CHARS, "")
            .replace(/\s+/g, et.SEPARATOR)
            .replace(/_+/g, et.SEPARATOR)
            .replace(/^_|_$/g, "")
            .substring(0, et.CONVENTIONS.MAX_LENGTH)
        : "",
    _t = {
      generateContentKey: (r, t) => {
        let e = Al.processURL(r, { cacheType: "content" })
        if (!e.isValid)
          return (
            console.warn(`Invalid URL for cache key generation: ${r}`),
            `${et.PREFIXES.CONTENT}invalid_${Ur(r)}`
          )
        let i = e.cacheKey
        return t ? `${i}${et.SEPARATOR}${t}` : i
      },
      generateSearchKey: (r, t) => {
        let e = Ur(r)
        return t ? `${et.PREFIXES.SEARCH}${e}${et.SEPARATOR}${Ur(t)}` : `${et.PREFIXES.SEARCH}${e}`
      },
      generateUserKey: (r, t) => {
        let e = Ur(r)
        return t ? `${et.PREFIXES.USER}${t}${et.SEPARATOR}${e}` : `${et.PREFIXES.USER}${e}`
      },
      generateFontKey: (r, t) => {
        let e = Ur(r)
        return t ? `${et.PREFIXES.FONT}${e}${et.SEPARATOR}${t}` : `${et.PREFIXES.FONT}${e}`
      },
      generateSystemKey: (r, t) => {
        let e = Ur(r)
        return t ? `${et.PREFIXES.SYSTEM}${e}${et.SEPARATOR}${Ur(t)}` : `${et.PREFIXES.SYSTEM}${e}`
      },
      identifyType: (r) => {
        let t = Object.entries(et.PREFIXES)
        for (let [e, i] of t) if (r.startsWith(i)) return e
        return null
      },
      extractOriginalKey: (r) => {
        let t = Object.values(et.PREFIXES)
        for (let e of t) if (r.startsWith(e)) return r.substring(e.length)
        return r
      },
      generateStorageKey: (r, t) =>
        _t.identifyType(r)
          ? r
          : `${{ MEMORY: et.PREFIXES.CONTENT, SESSION: et.PREFIXES.CONTENT }[t] || et.PREFIXES.CONTENT}${r}`,
      validateKeyFormat: (r) => {
        let t = [],
          e = []
        return (
          (!r || r.length === 0) &&
            (t.push("\u952E\u4E0D\u80FD\u4E3A\u7A7A"),
            e.push("\u63D0\u4F9B\u4E00\u4E2A\u975E\u7A7A\u7684\u952E")),
          r.length > et.CONVENTIONS.MAX_LENGTH &&
            (t.push(`\u952E\u8FC7\u957F: ${r.length} > ${et.CONVENTIONS.MAX_LENGTH}`),
            e.push("\u7F29\u77ED\u952E\u540D\u6216\u4F7F\u7528\u54C8\u5E0C\u503C")),
          et.CONVENTIONS.FORBIDDEN_CHARS.test(r) &&
            (t.push("\u952E\u5305\u542B\u7981\u7528\u5B57\u7B26"),
            e.push("\u79FB\u9664\u952E\u4E2D\u7684\u7279\u6B8A\u5B57\u7B26")),
          _t.identifyType(r) ||
            (t.push("\u952E\u7F3A\u5C11\u5FC5\u9700\u7684\u524D\u7F00"),
            e.push("\u4E3A\u952E\u6DFB\u52A0\u9002\u5F53\u7684\u524D\u7F00")),
          { isValid: t.length === 0, issues: t, suggestions: e }
        )
      },
      parseKey: (r) => {
        let t = _t.identifyType(r),
          e = Object.values(et.PREFIXES).find((s) => r.startsWith(s)) || null,
          i = _t.extractOriginalKey(r),
          n = _t.validateKeyFormat(r)
        return { original: i, type: t, prefix: e, isValid: n.isValid }
      },
    },
    {
      generateContentKey: kP,
      generateSearchKey: GP,
      generateUserKey: UP,
      generateFontKey: OP,
      generateSystemKey: LP,
      identifyType: NP,
      extractOriginalKey: xi,
      generateStorageKey: Yd,
      validateKeyFormat: HP,
      parseKey: zP,
    } = _t,
    WP = {
      identifyType: _t.identifyType,
      extractOriginalKey: _t.extractOriginalKey,
      generateStorageKey: _t.generateStorageKey,
      validateKey: _t.validateKeyFormat,
      parseKey: _t.parseKey,
    }
  var et = {
      PREFIXES: {
        CONTENT: "content_",
        LINK: "link_",
        SEARCH: "search_",
        FONT: "font_",
        USER: "user_",
        SYSTEM: "sys_",
      },
      SEPARATOR: "_",
      CONVENTIONS: { CASE_STYLE: "snake_case", MAX_LENGTH: 100, FORBIDDEN_CHARS: /[^a-z0-9_-]/g },
    },
    Kd = {
      CONTENT: {
        capacity: 200,
        ttl: 900 * 1e3,
        maxMemoryMB: 30,
        warningThreshold: 160,
        description:
          "\u7EDF\u4E00\u5185\u5BB9\u7F13\u5B58\uFF0C\u652F\u6301\u9875\u9762\u548C\u5F39\u7A97\u5185\u5BB9",
        keyPrefix: et.PREFIXES.CONTENT,
        cleanupIntervalMs: 180 * 1e3,
        memoryThreshold: 0.85,
      },
      LINK: {
        capacity: 1e3,
        ttl: 3600 * 1e3,
        maxMemoryMB: 15,
        warningThreshold: 800,
        description: "\u94FE\u63A5\u6709\u6548\u6027\u548C\u5931\u8D25\u94FE\u63A5\u7F13\u5B58",
        keyPrefix: et.PREFIXES.LINK,
        cleanupIntervalMs: 600 * 1e3,
        memoryThreshold: 0.8,
      },
      SEARCH: {
        capacity: 500,
        ttl: 3600 * 1e3,
        maxMemoryMB: 50,
        warningThreshold: 400,
        description: "\u641C\u7D22\u7ED3\u679C\u548C\u5185\u5BB9\u9884\u89C8\u7F13\u5B58",
        keyPrefix: et.PREFIXES.SEARCH,
        cleanupIntervalMs: 300 * 1e3,
        memoryThreshold: 0.8,
      },
      USER: {
        capacity: 100,
        ttl: 1440 * 60 * 1e3,
        maxMemoryMB: 5,
        warningThreshold: 80,
        description: "\u7528\u6237\u504F\u597D\u548C\u8BBE\u7F6E\u7F13\u5B58",
        keyPrefix: et.PREFIXES.USER,
        cleanupIntervalMs: 1800 * 1e3,
        memoryThreshold: 0.9,
      },
      SYSTEM: {
        capacity: 200,
        ttl: 3600 * 1e3,
        maxMemoryMB: 10,
        warningThreshold: 160,
        description: "\u7CFB\u7EDF\u7EC4\u4EF6\u548C\u914D\u7F6E\u7F13\u5B58",
        keyPrefix: et.PREFIXES.SYSTEM,
        cleanupIntervalMs: 900 * 1e3,
        memoryThreshold: 0.8,
      },
      DEFAULT: {
        capacity: 100,
        ttl: 600 * 1e3,
        maxMemoryMB: 5,
        warningThreshold: 80,
        description: "\u9ED8\u8BA4\u7F13\u5B58\u914D\u7F6E",
        keyPrefix: et.PREFIXES.SYSTEM,
        cleanupIntervalMs: 300 * 1e3,
        memoryThreshold: 0.8,
      },
    }
  var qo = {
      MEMORY: {
        capacityRatio: 0.6,
        maxSizeKB: 500,
        priority: 3,
        description:
          "\u5185\u5B58\u5C42 - \u6700\u5FEB\u8BBF\u95EE\uFF0C\u5B58\u50A8\u70ED\u6570\u636E",
      },
      SESSION: {
        capacityRatio: 0.2,
        maxSizeKB: 1e3,
        priority: 2,
        description:
          "\u4F1A\u8BDD\u5C42 - \u9875\u9762\u5237\u65B0\u4FDD\u7559\uFF0C\u5B58\u50A8\u91CD\u8981\u6570\u636E",
      },
      LOCAL: {
        capacityRatio: 0.2,
        maxSizeKB: 1e3,
        priority: 2,
        description:
          "\u672C\u5730\u5C42 - \u957F\u671F\u5B58\u50A8\uFF0C\u5B58\u50A8\u957F\u671F\u6570\u636E",
      },
    },
    Zo = {
      LARGE_CONTENT_SIZE: 1024 * 1024,
      HUGE_CONTENT_SIZE: 5 * 1024 * 1024,
      MAX_MEMORY_USAGE: 50 * 1024 * 1024,
      MEMORY_CLEANUP_THRESHOLD: 0.8,
      SESSION_CLEANUP_THRESHOLD: 0.9,
      MAX_REFERENCE_COUNT: 1e3,
      HASH_COLLISION_THRESHOLD: 10,
    },
    XP = {
      MAX_KEY_LENGTH: 256,
      FORBIDDEN_CHARS: /[\s<>:"/\\|?*]/,
      REQUIRED_PREFIX: !0,
      MIN_CONTENT_LENGTH: 1,
      MAX_CONTENT_LENGTH: 10 * 1024 * 1024,
      KEY_FORMAT_REGEX: /^[a-z0-9_-]+$/,
    },
    qd = {
      BATCH_SIZE: 10,
      MAX_CONCURRENT_PRELOADS: 3,
      HIT_RATE_WARNING_THRESHOLD: 0.7,
      MEMORY_CHECK_INTERVAL: 30 * 1e3,
      AUTO_CLEANUP_THRESHOLD: 0.9,
      PRELOAD_STRATEGY: { enabled: !0, count: 5, delay: 100 },
      MONITORING: {
        ENABLE_MONITORING: !0,
        MONITOR_INTERVAL: 300 * 1e3,
        REPORT_INTERVAL: 1800 * 1e3,
        CONSOLE_WARNINGS: !0,
        ENABLE_KEY_VALIDATION: !0,
      },
    }
  function _i(r) {
    return Kd[r] || Kd.DEFAULT
  }
  var YP = {
      content: _t.generateContentKey,
      search: _t.generateSearchKey,
      font: _t.generateFontKey,
      user: _t.generateUserKey,
      system: _t.generateSystemKey,
    },
    fr = {
      ENABLE_MONITORING: !0,
      MONITOR_INTERVAL: 300 * 1e3,
      REPORT_INTERVAL: 1800 * 1e3,
      CONSOLE_WARNINGS: !0,
      ENABLE_KEY_VALIDATION: !0,
    }
  var Tn = class {
      constructor(t, e, i = null, n = null) {
        this.key = t
        this.value = e
        this.prev = i
        this.next = n
      }
    },
    Dl = class {
      constructor(t) {
        this.capacity = t
        ;((this.head = new Tn("__head__", {})),
          (this.tail = new Tn("__tail__", {})),
          (this.head.next = this.tail),
          (this.tail.prev = this.head))
      }
      cache = new Map()
      head
      tail
      addToHead(t) {
        ;((t.prev = this.head),
          (t.next = this.head.next),
          (this.head.next.prev = t),
          (this.head.next = t))
      }
      removeNode(t) {
        ;((t.prev.next = t.next), (t.next.prev = t.prev))
      }
      moveToHead(t) {
        ;(this.removeNode(t), this.addToHead(t))
      }
      removeTail() {
        let t = this.tail.prev
        return t === this.head ? null : (this.removeNode(t), t)
      }
      get(t) {
        let e = this.cache.get(t)
        return e ? (this.moveToHead(e), e.value) : null
      }
      set(t, e) {
        let i = this.cache.get(t)
        if (i) return ((i.value = e), this.moveToHead(i), null)
        let n = new Tn(t, e),
          s = null
        return (
          this.cache.size >= this.capacity &&
            ((s = this.removeTail()), s && this.cache.delete(s.key)),
          this.cache.set(t, n),
          this.addToHead(n),
          s
        )
      }
      delete(t) {
        let e = this.cache.get(t)
        return e ? (this.removeNode(e), this.cache.delete(t), e.value) : null
      }
      has(t) {
        return this.cache.has(t)
      }
      clear() {
        ;(this.cache.clear(), (this.head.next = this.tail), (this.tail.prev = this.head))
      }
      get size() {
        return this.cache.size
      }
      keys() {
        return Array.from(this.cache.keys())
      }
      values() {
        return Array.from(this.cache.values()).map((t) => t.value)
      }
    },
    Cn = class {
      cache
      config
      currentMemoryUsage = 0
      totalHits = 0
      totalRequests = 0
      cleanupInterval = null
      constructor(t) {
        let e = Object.fromEntries(Object.entries(t).filter(([, n]) => n !== void 0)),
          i = _i("DEFAULT")
        ;((this.config = {
          capacity: i.capacity,
          ttl: i.ttl,
          maxMemoryMB: i.maxMemoryMB,
          warningThreshold: i.warningThreshold,
          description: i.description,
          keyPrefix: i.keyPrefix,
          cleanupIntervalMs: i.cleanupIntervalMs,
          memoryThreshold: i.memoryThreshold,
          ...e,
        }),
          (this.cache = new Dl(this.config.capacity)),
          this.startPeriodicCleanup())
      }
      estimateSize(t) {
        if (t == null) return 8
        switch (typeof t) {
          case "string":
            return t.length * 2 + 24
          case "number":
            return 8
          case "boolean":
            return 4
          case "bigint":
            return t.toString().length + 16
          case "symbol":
            return 8
          case "function":
            return t.toString().length * 2 + 32
          case "object":
            if (t instanceof Date) return 24
            if (t instanceof RegExp) return t.source.length * 2 + 32
            if (Array.isArray(t)) return t.reduce((e, i) => e + this.estimateSize(i), 24)
            try {
              return JSON.stringify(t).length * 2 + 32
            } catch {
              return 1024
            }
          default:
            return 8
        }
      }
      startPeriodicCleanup() {
        typeof window > "u" ||
          (this.stopPeriodicCleanup(),
          (this.cleanupInterval = window.setInterval(() => {
            this.cleanup()
          }, this.config.cleanupIntervalMs)))
      }
      stopPeriodicCleanup() {
        this.cleanupInterval &&
          typeof window < "u" &&
          (clearInterval(this.cleanupInterval), (this.cleanupInterval = null))
      }
      set(t, e, i = 1800 * 1e3) {
        try {
          let n = this.estimateSize(e),
            s = this.config.maxMemoryMB * 1024 * 1024
          if (this.currentMemoryUsage + n > s && (this.cleanup(), this.currentMemoryUsage + n > s))
            return (
              console.warn(
                `\u7F13\u5B58\u5185\u5B58\u4E0D\u8DB3\uFF0C\u65E0\u6CD5\u6DFB\u52A0\u952E: ${t}\uFF0C\u9700\u8981 ${n} \u5B57\u8282`,
              ),
              !1
            )
          let o = { data: e, timestamp: Date.now(), ttl: i, size: n, accessCount: 0 },
            a = this.cache.set(t, o)
          if ((a && (this.currentMemoryUsage -= a.value.size), a))
            this.currentMemoryUsage -= a.value.size
          else {
            let u = this.cache.get(t)
            u && u !== o && (this.currentMemoryUsage -= u.size)
          }
          return ((this.currentMemoryUsage += n), !0)
        } catch (n) {
          return (
            console.error(`\u8BBE\u7F6E\u7F13\u5B58\u9879\u5931\u8D25\uFF0C\u952E: ${t}`, n),
            !1
          )
        }
      }
      get(t) {
        this.totalRequests++
        try {
          let e = this.cache.get(t)
          if (!e) return null
          if (Date.now() - e.timestamp > e.ttl) return (this.delete(t), null)
          let i = { ...e, accessCount: e.accessCount + 1 }
          return (this.cache.set(t, i), this.totalHits++, e.data)
        } catch (e) {
          return (
            console.error(`\u83B7\u53D6\u7F13\u5B58\u9879\u5931\u8D25\uFF0C\u952E: ${t}`, e),
            null
          )
        }
      }
      has(t) {
        try {
          let e = this.cache.get(t)
          return e ? (Date.now() - e.timestamp > e.ttl ? (this.delete(t), !1) : !0) : !1
        } catch (e) {
          return (
            console.error(`\u68C0\u67E5\u7F13\u5B58\u9879\u5931\u8D25\uFF0C\u952E: ${t}`, e),
            !1
          )
        }
      }
      delete(t) {
        try {
          let e = this.cache.delete(t)
          return e ? ((this.currentMemoryUsage -= e.size), !0) : !1
        } catch (e) {
          return (
            console.error(`\u5220\u9664\u7F13\u5B58\u9879\u5931\u8D25\uFF0C\u952E: ${t}`, e),
            !1
          )
        }
      }
      cleanup() {
        try {
          let t = Date.now(),
            e = this.config.maxMemoryMB * 1024 * 1024,
            i = e * this.config.memoryThreshold,
            n = 0,
            s = 0,
            o = []
          for (let a of this.cache.keys()) {
            let u = this.cache.get(a)
            u && t - u.timestamp > u.ttl && o.push(a)
          }
          for (let a of o) {
            let u = this.cache.delete(a)
            u && ((s += u.size), (this.currentMemoryUsage -= u.size), n++)
          }
          if (this.currentMemoryUsage > i) {
            let a = this.cache
              .values()
              .map((u, l) => ({
                key: this.cache.keys()[l],
                item: u,
                priority: u.size / Math.max(u.accessCount, 1),
              }))
              .sort((u, l) => l.priority - u.priority)
            for (let { key: u } of a) {
              if (this.currentMemoryUsage <= i) break
              let l = this.cache.delete(u)
              l && ((s += l.size), (this.currentMemoryUsage -= l.size), n++)
            }
          }
          n > 0 &&
            console.log(
              `\u7F13\u5B58\u6E05\u7406\u5B8C\u6210\uFF1A\u79FB\u9664 ${n} \u9879\uFF0C\u91CA\u653E ${(s / 1024).toFixed(2)} KB \u5185\u5B58\uFF0C\u5F53\u524D\u4F7F\u7528\u7387: ${((this.currentMemoryUsage / e) * 100).toFixed(1)}%`,
            )
        } catch (t) {
          console.error("\u7F13\u5B58\u6E05\u7406\u5931\u8D25:", t)
        }
      }
      getStats() {
        let t = this.config.maxMemoryMB * 1024 * 1024,
          e = this.totalRequests > 0 ? this.totalHits / this.totalRequests : 0
        return {
          size: this.cache.size,
          memoryUsage: this.currentMemoryUsage,
          maxMemoryUsage: t,
          memoryUsagePercentage: this.currentMemoryUsage / t,
          hitRate: e,
          keys: this.cache.keys(),
        }
      }
      getConfig() {
        return { ...this.config }
      }
      getItemInfo(t) {
        try {
          let e = this.cache.get(t)
          if (!e) return null
          let i = Date.now() - e.timestamp > e.ttl
          return { ...e, isExpired: i }
        } catch (e) {
          return (
            console.error(
              `\u83B7\u53D6\u7F13\u5B58\u9879\u4FE1\u606F\u5931\u8D25\uFF0C\u952E: ${t}`,
              e,
            ),
            null
          )
        }
      }
      clear() {
        try {
          ;(this.cache.clear(),
            (this.currentMemoryUsage = 0),
            (this.totalHits = 0),
            (this.totalRequests = 0),
            console.log("\u7F13\u5B58\u5DF2\u6E05\u7A7A"))
        } catch (t) {
          console.error("\u6E05\u7A7A\u7F13\u5B58\u5931\u8D25:", t)
        }
      }
      destroy() {
        try {
          ;(this.stopPeriodicCleanup(),
            this.clear(),
            console.log("\u7F13\u5B58\u7BA1\u7406\u5668\u5DF2\u9500\u6BC1"))
        } catch (t) {
          console.error("\u9500\u6BC1\u7F13\u5B58\u7BA1\u7406\u5668\u5931\u8D25:", t)
        }
      }
      forceCleanup() {
        this.cleanup()
      }
      resetStats() {
        ;((this.totalHits = 0), (this.totalRequests = 0))
      }
    }
  var En = class {
    observers = new Set()
    timers = new Set()
    eventListeners = []
    abortControllers = new Set()
    cleanupTasks = []
    registerIntersectionObserver(t) {
      return (this.observers.add(t), t)
    }
    registerMutationObserver(t) {
      return (this.observers.add(t), t)
    }
    registerResizeObserver(t) {
      return (this.observers.add(t), t)
    }
    registerObserver(t) {
      return (this.observers.add(t), t)
    }
    registerTimer(t) {
      return (this.timers.add(t), t)
    }
    setTimeout(t, e) {
      let i = window.setTimeout(() => {
        ;(this.timers.delete(i), t())
      }, e)
      return this.registerTimer(i)
    }
    setInterval(t, e) {
      let i = window.setInterval(t, e)
      return this.registerTimer(i)
    }
    addEventListener(t, e, i, n) {
      this.eventListeners.some((o) => o.element === t && o.type === e && o.listener === i) ||
        (t.addEventListener(e, i, n),
        this.eventListeners.push({ element: t, type: e, listener: i, options: n }))
    }
    createAbortController() {
      let t = new AbortController()
      return (this.abortControllers.add(t), t)
    }
    registerAbortController(t) {
      return (this.abortControllers.add(t), t)
    }
    removeObserver(t) {
      this.observers.has(t) && (t.disconnect(), this.observers.delete(t))
    }
    removeTimer(t) {
      this.timers.has(t) && (clearTimeout(t), clearInterval(t), this.timers.delete(t))
    }
    clearTimeout(t) {
      this.timers.has(t) && (clearTimeout(t), this.timers.delete(t))
    }
    clearInterval(t) {
      this.timers.has(t) && (clearInterval(t), this.timers.delete(t))
    }
    removeEventListener(t, e, i, n) {
      t.removeEventListener(e, i, n)
      let s = this.eventListeners.findIndex(
        (o) => o.element === t && o.type === e && o.listener === i,
      )
      s !== -1 && this.eventListeners.splice(s, 1)
    }
    abortController(t) {
      this.abortControllers.has(t) && (t.abort(), this.abortControllers.delete(t))
    }
    getStats() {
      let t = {}
      this.observers.forEach((i) => {
        let n = i.constructor.name
        t[n] = (t[n] || 0) + 1
      })
      let e = {}
      return (
        this.eventListeners.forEach(({ type: i }) => {
          e[i] = (e[i] || 0) + 1
        }),
        {
          observers: this.observers.size,
          timers: this.timers.size,
          eventListeners: this.eventListeners.length,
          abortControllers: this.abortControllers.size,
          details: { observerTypes: t, eventTypes: e },
        }
      )
    }
    cleanupObserversAndListeners() {
      ;(this.observers.forEach((t) => {
        try {
          t.disconnect()
        } catch (e) {
          console.error("\u6E05\u7406\u89C2\u5BDF\u5668\u65F6\u51FA\u9519:", e)
        }
      }),
        this.observers.clear(),
        this.timers.forEach((t) => {
          try {
            ;(clearTimeout(t), clearInterval(t))
          } catch (e) {
            console.error("\u6E05\u7406\u5B9A\u65F6\u5668\u65F6\u51FA\u9519:", e)
          }
        }),
        this.timers.clear(),
        this.eventListeners.forEach(({ element: t, type: e, listener: i, options: n }) => {
          try {
            t.removeEventListener(e, i, n)
          } catch (s) {
            console.error("\u6E05\u7406\u4E8B\u4EF6\u76D1\u542C\u5668\u65F6\u51FA\u9519:", s)
          }
        }),
        (this.eventListeners.length = 0),
        this.abortControllers.forEach((t) => {
          try {
            t.abort()
          } catch (e) {
            console.error("\u6E05\u7406 AbortController \u65F6\u51FA\u9519:", e)
          }
        }),
        this.abortControllers.clear())
    }
    cleanupNonCriticalResources() {
      ;(this.observers.forEach((n) => {
        try {
          n.disconnect()
        } catch (s) {
          console.error("\u6E05\u7406\u89C2\u5BDF\u5668\u65F6\u51FA\u9519:", s)
        }
      }),
        this.observers.clear(),
        this.timers.forEach((n) => {
          try {
            ;(clearTimeout(n), clearInterval(n))
          } catch (s) {
            console.error("\u6E05\u7406\u5B9A\u65F6\u5668\u65F6\u51FA\u9519:", s)
          }
        }),
        this.timers.clear())
      let t = ["click", "popstate"],
        e = [window, document],
        i = []
      ;(this.eventListeners.forEach(({ element: n, type: s, listener: o, options: a }) => {
        if (t.includes(s) && e.some((u) => u === n))
          (i.push({ element: n, type: s, listener: o, options: a }),
            console.log(
              `[SPA DEBUG] \u4FDD\u7559\u5173\u952E\u4E8B\u4EF6\u76D1\u542C\u5668: ${s} on ${n.constructor.name}`,
            ))
        else
          try {
            ;(n.removeEventListener(s, o, a),
              console.log(
                `[SPA DEBUG] \u6E05\u7406\u975E\u5173\u952E\u4E8B\u4EF6\u76D1\u542C\u5668: ${s} on ${n.constructor.name} (Tag: ${n instanceof HTMLElement ? n.tagName : "N/A"}, ID: ${n instanceof HTMLElement ? n.id : "N/A"}, Class: ${n instanceof HTMLElement ? n.className : "N/A"})`,
              ))
          } catch (u) {
            console.error("\u6E05\u7406\u4E8B\u4EF6\u76D1\u542C\u5668\u65F6\u51FA\u9519:", u)
          }
      }),
        (this.eventListeners.length = 0),
        this.eventListeners.push(...i),
        this.abortControllers.forEach((n) => {
          try {
            n.abort()
          } catch (s) {
            console.error("\u6E05\u7406 AbortController \u65F6\u51FA\u9519:", s)
          }
        }),
        this.abortControllers.clear())
    }
    cleanup() {
      ;(this.cleanupObserversAndListeners(),
        this.cleanupTasks.forEach((t) => {
          try {
            t()
          } catch (e) {
            console.error("\u6267\u884C\u6E05\u7406\u4EFB\u52A1\u65F6\u51FA\u9519:", e)
          }
        }),
        (this.cleanupTasks.length = 0))
    }
    addCleanupTask(t) {
      this.cleanupTasks.push(t)
    }
    hasActiveResources() {
      return (
        this.observers.size > 0 ||
        this.timers.size > 0 ||
        this.eventListeners.length > 0 ||
        this.abortControllers.size > 0
      )
    }
    getActiveResourcesDetails() {
      return {
        observers: Array.from(this.observers).map((t) => t.constructor.name),
        timers: Array.from(this.timers),
        eventListeners: this.eventListeners.map(({ element: t, type: e }) => ({
          element: t.constructor.name,
          type: e,
        })),
        abortControllers: this.abortControllers.size,
      }
    }
  }
  var wn = class r {
    static config = _i("DEFAULT")
    static DEFAULT_QUOTA = Zo.MAX_MEMORY_USAGE
    static async checkStorageQuota(t) {
      try {
        if (navigator.storage?.estimate) {
          let i = await navigator.storage.estimate(),
            n = i.usage || 0,
            s = i.quota || this.DEFAULT_QUOTA
          return { used: n, total: s, percentage: s > 0 ? n / s : 0, available: s - n }
        }
      } catch (i) {
        console.warn("\u65E0\u6CD5\u83B7\u53D6\u5B58\u50A8\u914D\u989D\u4FE1\u606F:", i)
      }
      let e = this.calculateStorageSize(t)
      return {
        used: e,
        total: this.DEFAULT_QUOTA,
        percentage: e / this.DEFAULT_QUOTA,
        available: this.DEFAULT_QUOTA - e,
      }
    }
    static calculateStorageSize(t) {
      let e = 0
      try {
        for (let i = 0; i < t.length; i++) {
          let n = t.key(i)
          if (n) {
            let s = t.getItem(n)
            e += (n.length + (s?.length || 0)) * 2
          }
        }
      } catch (i) {
        console.warn("\u65E0\u6CD5\u4F30\u7B97\u5B58\u50A8\u5927\u5C0F:", i)
      }
      return e
    }
    static async safeSetItem(t, e, i) {
      return (await this.checkAndCleanupIfNeeded(t), this.attemptSetItem(t, e, i))
    }
    static async checkAndCleanupIfNeeded(t) {
      try {
        let e = await this.checkStorageQuota(t),
          i = this.config.memoryThreshold || 0.9
        e.percentage > i &&
          (fr.CONSOLE_WARNINGS &&
            console.warn(
              "\u5B58\u50A8\u914D\u989D\u5373\u5C06\u8017\u5C3D\uFF0C\u6267\u884C\u6E05\u7406...",
            ),
          this.cleanupStorage(t),
          (await this.checkStorageQuota(t)).percentage > i &&
            (fr.CONSOLE_WARNINGS &&
              console.warn(
                "\u6E05\u7406\u540E\u914D\u989D\u4ECD\u7136\u4E0D\u8DB3\uFF0C\u6267\u884C\u7D27\u6025\u6E05\u7406...",
              ),
            this.emergencyCleanup(t)))
      } catch (e) {
        fr.CONSOLE_WARNINGS && console.warn("\u914D\u989D\u68C0\u67E5\u5931\u8D25:", e)
      }
    }
    static attemptSetItem(t, e, i) {
      try {
        return (t.setItem(e, i), !0)
      } catch (n) {
        return n instanceof DOMException && n.name === "QuotaExceededError"
          ? this.handleQuotaExceeded(t, e, i)
          : (console.error("\u8BBE\u7F6E\u5B58\u50A8\u9879\u5931\u8D25:", n), !1)
      }
    }
    static handleQuotaExceeded(t, e, i) {
      ;(console.warn(
        "\u5B58\u50A8\u914D\u989D\u8D85\u9650\uFF0C\u5C1D\u8BD5\u6E05\u7406\u540E\u91CD\u8BD5...",
      ),
        this.cleanupStorage(t))
      try {
        return (t.setItem(e, i), !0)
      } catch {
        ;(console.warn(
          "\u6E05\u7406\u540E\u91CD\u8BD5\u4ECD\u5931\u8D25\uFF0C\u6267\u884C\u7D27\u6025\u6E05\u7406...",
        ),
          this.emergencyCleanup(t))
        try {
          return (t.setItem(e, i), !0)
        } catch (s) {
          return (console.error("\u6700\u7EC8\u8BBE\u7F6E\u5931\u8D25:", s), !1)
        }
      }
    }
    static safeGetItem(t, e) {
      try {
        return t.getItem(e)
      } catch (i) {
        return (console.error("\u83B7\u53D6\u5B58\u50A8\u9879\u5931\u8D25:", i), null)
      }
    }
    static safeRemoveItem(t, e) {
      try {
        t.removeItem(e)
      } catch (i) {
        console.error("\u79FB\u9664\u5B58\u50A8\u9879\u5931\u8D25:", i)
      }
    }
    static cleanupStorage(t) {
      try {
        let e = this.findExpiredKeys(t)
        ;(this.removeKeys(t, e),
          fr.CONSOLE_WARNINGS &&
            e.length > 0 &&
            console.log(`\u6E05\u7406\u4E86 ${e.length} \u4E2A\u8FC7\u671F\u9879\u76EE`))
      } catch (e) {
        fr.CONSOLE_WARNINGS && console.error("\u6E05\u7406\u5B58\u50A8\u5931\u8D25:", e)
      }
    }
    static findExpiredKeys(t) {
      let e = [],
        i = Date.now()
      for (let n = 0; n < t.length; n++) {
        let s = t.key(n)
        if (!s || !Object.values(et.PREFIXES).some((u) => s.startsWith(u))) continue
        let a = t.getItem(s)
        a && this.isExpiredItem(a, i) && e.push(s)
      }
      return e
    }
    static isExpiredItem(t, e) {
      try {
        let i = JSON.parse(t)
        if (i && typeof i == "object" && i.timestamp) {
          let n = e - i.timestamp,
            s = (this.config.ttl || 1440 * 60) * 1e3
          return n > s
        }
      } catch {
        let i = new Blob([t]).size,
          n = (this.config.maxMemoryMB || Zo.LARGE_CONTENT_SIZE / 1024) * 1024
        return i > n
      }
      return !1
    }
    static removeKeys(t, e) {
      e.forEach((i) => {
        try {
          t.removeItem(i)
        } catch (n) {
          console.warn(`\u5220\u9664\u952E ${i} \u5931\u8D25:`, n)
        }
      })
    }
    static emergencyCleanup(t) {
      try {
        let e = [],
          i = this.config.keyPrefix || "sys_"
        for (let s = 0; s < t.length; s++) {
          let o = t.key(s)
          o && o.startsWith(i) && e.push(o)
        }
        let n = Math.ceil(e.length / 2)
        for (let s = 0; s < n; s++) t.removeItem(e[s])
        fr.CONSOLE_WARNINGS &&
          console.warn(
            `\u7D27\u6025\u6E05\u7406\uFF1A\u79FB\u9664\u4E86 ${n} \u4E2A\u5B58\u50A8\u9879`,
          )
      } catch (e) {
        fr.CONSOLE_WARNINGS && console.error("\u7D27\u6025\u6E05\u7406\u5931\u8D25:", e)
      }
    }
    async setSessionItem(t, e) {
      return r.safeSetItem(sessionStorage, t, e)
    }
    getSessionItem(t) {
      return r.safeGetItem(sessionStorage, t)
    }
    removeSessionItem(t) {
      r.safeRemoveItem(sessionStorage, t)
    }
    async setLocalItem(t, e) {
      return r.safeSetItem(localStorage, t, e)
    }
    getLocalItem(t) {
      return r.safeGetItem(localStorage, t)
    }
    removeLocalItem(t) {
      r.safeRemoveItem(localStorage, t)
    }
    async setItem(t, e, i) {
      return t === "local" ? this.setLocalItem(e, i) : this.setSessionItem(e, i)
    }
    getItem(t, e) {
      return t === "local" ? this.getLocalItem(e) : this.getSessionItem(e)
    }
    removeItem(t, e) {
      return t === "local" ? this.removeLocalItem(e) : this.removeSessionItem(e)
    }
    getStorageStats() {
      let t = (e) => {
        let i = 0,
          n = 0,
          s = r.config.keyPrefix || "sys_"
        for (let a = 0; a < e.length; a++) {
          let u = e.key(a)
          if (u && u.startsWith(s)) {
            let l = e.getItem(u)
            l && ((i += new Blob([u + l]).size), n++)
          }
        }
        let o = (r.config.capacity || Zo.HUGE_CONTENT_SIZE / (1024 * 1024)) * 1024 * 1024
        return { used: i, available: Math.max(0, o - i), itemCount: n }
      }
      return { localStorage: t(localStorage), sessionStorage: t(sessionStorage) }
    }
    cleanupAllStorage() {
      let t = Date.now(),
        e = (r.config.cleanupIntervalMs || 60) * 60 * 1e3,
        i = parseInt(this.getItem("local", "last_cleanup") || "0")
      t - i < e ||
        (r.cleanupStorage(localStorage),
        r.cleanupStorage(sessionStorage),
        this.setItem("local", "last_cleanup", t.toString()),
        document.dispatchEvent(new CustomEvent("cacheCleared", { detail: {} })))
    }
    cleanup() {
      this.cleanupAllStorage()
    }
    getStats() {
      let t = this.getStorageStats(),
        e = {
          localStorage: {
            used: t.localStorage.used,
            total: t.localStorage.used + t.localStorage.available,
            percentage: t.localStorage.used / (t.localStorage.used + t.localStorage.available),
          },
          sessionStorage: {
            used: t.sessionStorage.used,
            total: t.sessionStorage.used + t.sessionStorage.available,
            percentage:
              t.sessionStorage.used / (t.sessionStorage.used + t.sessionStorage.available),
          },
        }
      return Promise.resolve(e)
    }
  }
  var Mn = class r {
    memoryCache
    storageManager
    referenceMap = new Map()
    contentHashMap = new Map()
    stats = { totalRequests: 0, memoryHits: 0, sessionHits: 0, localHits: 0, duplicatesAvoided: 0 }
    static _initialized = !1
    constructor(t, e) {
      ;(console.log("UnifiedContentCacheManager constructor"),
        (this.memoryCache = t),
        (this.storageManager = e),
        r._initialized ||
          (console.log(
            "[UnifiedCache] Initializing UnifiedContentCacheManager from sessionStorage...",
          ),
          this.initializeFromStorage(),
          (r._initialized = !0)))
    }
    initializeFromStorage() {
      try {
        if (typeof window > "u") {
          console.warn(
            "[UnifiedCache] window \u5BF9\u8C61\u4E0D\u53EF\u7528\uFF0C\u8DF3\u8FC7\u521D\u59CB\u5316\u3002",
          )
          return
        }
        let t = { memory: 0, session: 0, local: 0 },
          e = (i, n, s) => {
            if (!i) {
              console.warn(
                `[UnifiedCache] ${s}Storage \u4E0D\u53EF\u7528\uFF0C\u8DF3\u8FC7\u521D\u59CB\u5316\u3002`,
              )
              return
            }
            for (let o = 0; o < i.length; o++) {
              let a = i.key(o)
              if (!a || !_t.identifyType(a)) continue
              let l = i.getItem(a)
              if (!l) continue
              let c = xi(a)
              if (!c || this.referenceMap.has(c)) continue
              let h = {
                storageLayer: n,
                storageKey: a,
                refCount: 0,
                lastAccessed: Date.now(),
                size: this.calculateSize(l),
              }
              this.referenceMap.set(c, h)
              let f = this.calculateHash(l)
              ;(this.contentHashMap.has(f) || this.contentHashMap.set(f, c), t[n]++)
            }
          }
        ;(e(window.sessionStorage, "SESSION", "session"),
          e(window.localStorage, "LOCAL", "local"),
          t.session > 0 || t.local > 0
            ? console.log(
                `[UnifiedCache] Successfully restored ${t.session} items from sessionStorage and ${t.local} items from localStorage.`,
              )
            : console.log(
                "[UnifiedCache] No items found in sessionStorage or localStorage to restore.",
              ))
      } catch (t) {
        console.warn("[UnifiedCache] Error initializing storage references:", t)
      }
    }
    get(t) {
      this.stats.totalRequests++
      let e = xi(t),
        i = this.referenceMap.get(e)
      if (!i) {
        if (
          (console.log(
            `[UnifiedCache] Cache miss for key: ${t}, originalKey: ${e}. referenceMap size: ${this.referenceMap.size}`,
          ),
          this.referenceMap.size > 0)
        ) {
          let n = Array.from(this.referenceMap.keys())
          console.debug("[UnifiedCache] Available keys in referenceMap:", n)
        }
        if (
          this.referenceMap.size === 0 &&
          typeof window < "u" &&
          window.sessionStorage &&
          window.sessionStorage.length > 0
        ) {
          this.forceReinitializeFromStorage()
          let n = this.referenceMap.get(e)
          if (n) return this.getContentFromReference(e, n)
        }
        return null
      }
      return this.getContentFromReference(e, i)
    }
    getContentFromReference(t, e) {
      ;((e.lastAccessed = Date.now()), e.refCount++)
      let i = null
      switch (e.storageLayer) {
        case "MEMORY":
          ;((i = this.memoryCache.get(e.storageKey) || null), i && this.stats.memoryHits++)
          break
        case "SESSION":
          ;((i = this.storageManager.getSessionItem(e.storageKey)), i && this.stats.sessionHits++)
          break
        case "LOCAL":
          ;((i = this.storageManager.getLocalItem(e.storageKey)), i && this.stats.localHits++)
          break
      }
      return (i || this.referenceMap.delete(t), i)
    }
    forceReinitializeFromStorage() {
      ;(this.referenceMap.clear(), this.contentHashMap.clear(), this.initializeFromStorage())
    }
    set(t, e, i = void 0) {
      let n = xi(t),
        s = this.calculateHash(e),
        o = this.contentHashMap.get(s)
      if (o && this.referenceMap.has(o)) {
        let c = this.referenceMap.get(o)
        ;(this.referenceMap.set(n, {
          storageLayer: c.storageLayer,
          storageKey: c.storageKey,
          refCount: 1,
          lastAccessed: Date.now(),
          size: c.size,
        }),
          this.stats.duplicatesAvoided++,
          console.log(`[UnifiedCache] Avoided duplicate storage for ${n}, referencing ${o}`))
        return
      }
      let a = this.selectOptimalLayer(e, i),
        u = Yd(t, a)
      if (this.storeContent(u, e, a)) {
        let c = {
          storageLayer: a,
          storageKey: u,
          refCount: 1,
          lastAccessed: Date.now(),
          size: this.calculateSize(e),
        }
        ;(this.referenceMap.set(n, c), this.contentHashMap.set(s, n))
      }
    }
    delete(t) {
      let e = xi(t),
        i = this.referenceMap.get(e)
      if (!i) return !1
      if ((i.refCount--, i.refCount <= 0)) {
        this.deleteFromStorage(i.storageKey, i.storageLayer)
        for (let [n, s] of this.contentHashMap.entries())
          if (s === e) {
            this.contentHashMap.delete(n)
            break
          }
      }
      return (this.referenceMap.delete(e), !0)
    }
    has(t) {
      let e = xi(t)
      return this.referenceMap.has(e)
    }
    clear() {
      ;(this.referenceMap.clear(), this.contentHashMap.clear(), this.memoryCache.clear())
    }
    getStats() {
      let t =
        ((this.stats.memoryHits + this.stats.sessionHits + this.stats.localHits) /
          this.stats.totalRequests) *
        100
      return {
        ...this.stats,
        hitRate: t,
        totalCacheEntries: this.referenceMap.size,
        uniqueContentCount: this.contentHashMap.size,
        memoryUsage: this.calculateTotalMemoryUsage(),
      }
    }
    cleanup() {
      let t = Date.now(),
        e = [],
        i = qd.MEMORY_CHECK_INTERVAL
      for (let [n, s] of this.referenceMap.entries()) t - s.lastAccessed > i && e.push(n)
      ;(e.forEach((n) => this.delete(n)),
        e.length > 0 && console.log(`[UnifiedCache] Cleaned up ${e.length} expired cache entries`))
    }
    selectOptimalLayer(t, e) {
      let i = this.calculateSize(t),
        n = qo.MEMORY,
        s = qo.SESSION,
        o = qo.LOCAL,
        a = [e, "MEMORY", "SESSION", "LOCAL"].filter(Boolean),
        u = [...new Set(a)]
      for (let l of u)
        switch (l) {
          case "MEMORY":
            if (i < n.maxSizeKB * 1024) return "MEMORY"
            break
          case "SESSION":
            if (i < s.maxSizeKB * 1024) return "SESSION"
            break
          case "LOCAL":
            if (i < o.maxSizeKB * 1024) return "LOCAL"
            break
        }
      return "MEMORY"
    }
    storeContent(t, e, i) {
      try {
        switch (i) {
          case "MEMORY":
            return (this.memoryCache.set(t, e), !0)
          case "SESSION":
            return (this.storageManager.setSessionItem(t, e), !0)
          case "LOCAL":
            return (this.storageManager.setLocalItem(t, e), !0)
          default:
            return !1
        }
      } catch (n) {
        return (console.warn(`[UnifiedCache] Failed to store content in ${i}:`, n), !1)
      }
    }
    deleteFromStorage(t, e) {
      try {
        switch (e) {
          case "MEMORY":
            this.memoryCache.delete(t)
            break
          case "SESSION":
            this.storageManager.removeSessionItem(t)
            break
          case "LOCAL":
            this.storageManager.removeLocalItem(t)
            break
        }
      } catch (i) {
        console.warn(`[UnifiedCache] Failed to delete from ${e}:`, i)
      }
    }
    calculateHash(t) {
      let e = 0
      for (let i = 0; i < t.length; i++) {
        let n = t.charCodeAt(i)
        ;((e = (e << 5) - e + n), (e = e & e))
      }
      return e.toString(36)
    }
    calculateSize(t) {
      return new Blob([t]).size
    }
    calculateTotalMemoryUsage() {
      let t = 0
      for (let e of this.referenceMap.values()) t += e.size
      return t
    }
    validateCacheKey(t) {
      let e = [],
        i = [],
        n = this.referenceMap.get(t)
      if (!n)
        return (
          e.push(`No reference found for key: ${t}`),
          i.push("Check if the key was properly stored"),
          { isValid: !1, issues: e, suggestions: i }
        )
      let s = !1
      switch (n.storageLayer) {
        case "MEMORY":
          s = this.memoryCache.has(n.storageKey)
          break
        case "SESSION":
          s = this.storageManager.getSessionItem(n.storageKey) !== null
          break
        case "LOCAL":
          s = this.storageManager.getLocalItem(n.storageKey) !== null
          break
      }
      return (
        s ||
          (e.push(`Content not found in ${n.storageLayer} layer with key: ${n.storageKey}`),
          i.push("The reference exists but the actual content is missing")),
        { isValid: s, issues: e, suggestions: i }
      )
    }
    repairCacheReference(t) {
      if (this.validateCacheKey(t).isValid) return !0
      this.referenceMap.delete(t)
      for (let [i, n] of this.contentHashMap.entries())
        if (n === t) {
          this.contentHashMap.delete(i)
          break
        }
      return !1
    }
    getCacheDiagnostics(t) {
      let e = this.referenceMap.get(t),
        i = this.validateCacheKey(t),
        n = {
          memory: this.memoryCache.has(t),
          session: this.storageManager.getSessionItem(t) !== null,
          local: this.storageManager.getLocalItem(t) !== null,
        }
      return {
        key: t,
        reference: e,
        validation: i,
        storageLayerInfo: n,
        availableKeys: Array.from(this.referenceMap.keys()),
      }
    }
    static resetSingleton() {
      r._initialized = !1
    }
  }
  var An = class {
    managers = new Map()
    register(t, e) {
      this.managers.set(t, e)
    }
    unregister(t) {
      this.managers.delete(t)
    }
    cleanup() {
      this.managers.forEach((t, e) => {
        try {
          t.cleanup()
        } catch (i) {
          console.error(`Error during cleanup of ${e}:`, i)
        }
      })
    }
    getAllStats() {
      let t = {}
      return (
        this.managers.forEach((e, i) => {
          e.getStats && (t[i] = e.getStats())
        }),
        t
      )
    }
    clear() {
      this.managers.clear()
    }
  }
  var ce = class {
      static instances = new Map()
      static cleanupManager = null
      static _createAndRegisterManager(t, e, i) {
        let n = `${t.type}_${t.identifier || "default"}`
        if (this.instances.has(n)) return this.instances.get(n)
        let s = e()
        return (
          this.instances.set(n, s),
          this.getCleanupManager().register(n, s),
          console.log(`[ManagerFactory] Created ${i}: ${n}`),
          s
        )
      }
      static createCacheManager(t) {
        return this._createAndRegisterManager(
          t,
          () => {
            let e = t.config?.cacheType || "DEFAULT",
              n = {
                ..._i(e),
                ...(t.config?.configOverride || {}),
                enableMemoryLayer: t.config?.enableMemoryLayer ?? !0,
                enableSessionLayer: t.config?.enableSessionLayer ?? !1,
              }
            return new Cn(n)
          },
          "CacheManager",
        )
      }
      static createResourceManager(t) {
        return this._createAndRegisterManager(t, () => new En(), "ResourceManager")
      }
      static createStorageManager(t) {
        return this._createAndRegisterManager(t, () => new wn(), "StorageManager")
      }
      static createUnifiedContentCacheManager(t) {
        return this._createAndRegisterManager(
          t,
          () => {
            let e = Lr.instance,
              i = yi.instance
            return new Mn(e, i)
          },
          "UnifiedContentCacheManager",
        )
      }
      static getCleanupManager() {
        return (
          this.cleanupManager ||
            ((this.cleanupManager = new An()),
            console.log("[ManagerFactory] Created CleanupManager singleton")),
          this.cleanupManager
        )
      }
      static cleanup() {
        ;(console.log("[ManagerFactory] Cleaning up all registered manager instances..."),
          this.instances.forEach((t, e) => {
            if (t && typeof t.cleanup == "function")
              try {
                ;(t.cleanup(), console.log(`[ManagerFactory] Cleaned up instance: ${e}`))
              } catch (i) {
                console.error(`[ManagerFactory] Error cleaning up instance ${e}:`, i)
              }
          }),
          console.log("[ManagerFactory] All registered manager instances cleaned up."))
      }
      static destroy() {
        ;(console.log("[ManagerFactory] Destroying all registered manager instances..."),
          this.instances.forEach((t, e) => {
            if (t && typeof t.destroy == "function")
              try {
                ;(t.destroy(), console.log(`[ManagerFactory] Destroyed instance: ${e}`))
              } catch (i) {
                console.error(`[ManagerFactory] Error destroying instance ${e}:`, i)
              }
            else if (t && typeof t.cleanup == "function")
              try {
                ;(t.cleanup(),
                  console.log(`[ManagerFactory] Cleaned up (as destroy) instance: ${e}`))
              } catch (i) {
                console.error(`[ManagerFactory] Error cleaning up (as destroy) instance ${e}:`, i)
              }
          }),
          this.instances.clear(),
          (this.cleanupManager = null),
          console.log(
            "[ManagerFactory] All registered manager instances destroyed and registry cleared.",
          ))
      }
      static getInstance(t, e = "default") {
        let i = `${t}_${e}`
        return this.instances.get(i) || null
      }
      static hasInstance(t, e = "default") {
        let i = `${t}_${e}`
        return this.instances.has(i)
      }
      static removeInstance(t, e = "default") {
        let i = `${t}_${e}`
        if (this.instances.has(i)) {
          let n = this.instances.get(i)
          if (
            (this.cleanupManager && this.cleanupManager.unregister(i),
            n && typeof n.cleanup == "function")
          )
            try {
              n.cleanup()
            } catch (s) {
              console.error(`[ManagerFactory] Error cleaning up ${i}:`, s)
            }
          return (
            this.instances.delete(i),
            console.log(`[ManagerFactory] Removed instance: ${i}`),
            !0
          )
        }
        return !1
      }
      static getStats() {
        let t = {}
        for (let e of this.instances.keys()) {
          let i = e.split("_")[0]
          t[i] = (t[i] || 0) + 1
        }
        return {
          totalInstances: this.instances.size,
          hasCleanupManager: this.cleanupManager !== null,
          instanceKeys: Array.from(this.instances.keys()),
          instancesByType: t,
        }
      }
    },
    bi = {
      globalCacheManager: {
        type: "CACHE",
        identifier: "global",
        config: { cacheType: "DEFAULT", enableMemoryLayer: !0, enableSessionLayer: !1 },
      },
      urlCacheManager: {
        type: "CACHE",
        identifier: "url",
        config: { cacheType: "LINK", enableMemoryLayer: !0, enableSessionLayer: !1 },
      },
      failedLinksManager: {
        type: "CACHE",
        identifier: "failedLinks",
        config: { cacheType: "LINK", enableMemoryLayer: !1, enableSessionLayer: !0 },
      },
      globalResourceManager: { type: "RESOURCE", identifier: "global" },
      globalStorageManager: { type: "STORAGE", identifier: "global" },
      globalUnifiedContentCache: {
        type: "UNIFIED_CONTENT_CACHE",
        identifier: "global",
        config: { cacheType: "CONTENT", enableMemoryLayer: !0, enableSessionLayer: !0 },
      },
    }
  var Pl = class {
      _initialized = !1
      _unifiedContentCache = null
      _linkCache = null
      _searchCache = null
      _userCache = null
      _systemCache = null
      _defaultCache = null
      _urlCacheManager = null
      _failedLinksManager = null
      _storageManager = null
      _resourceManager = null
      _cleanupManager = null
      get unifiedContentCache() {
        return (
          this._unifiedContentCache ||
            ((this._unifiedContentCache = ce.createUnifiedContentCacheManager(
              bi.globalUnifiedContentCache,
            )),
            console.log("[GlobalManagers] Initialized UnifiedContentCacheManager")),
          this._unifiedContentCache
        )
      }
      get linkCache() {
        return (
          this._linkCache ||
            ((this._linkCache = this.createCache("LINK")),
            console.log("[GlobalManagers] Initialized LinkCache")),
          this._linkCache
        )
      }
      get searchCache() {
        return (
          this._searchCache ||
            ((this._searchCache = this.createCache("SEARCH")),
            console.log("[GlobalManagers] Initialized SearchCache")),
          this._searchCache
        )
      }
      get userCache() {
        return (
          this._userCache ||
            ((this._userCache = this.createCache("USER")),
            console.log("[GlobalManagers] Initialized UserCache")),
          this._userCache
        )
      }
      get systemCache() {
        return (
          this._systemCache ||
            ((this._systemCache = this.createCache("SYSTEM")),
            console.log("[GlobalManagers] Initialized SystemCache")),
          this._systemCache
        )
      }
      get defaultCache() {
        return (
          this._defaultCache ||
            ((this._defaultCache = this.createCache("DEFAULT")),
            console.log("[GlobalManagers] Initialized DefaultCache")),
          this._defaultCache
        )
      }
      get urlCacheManager() {
        return (
          this._urlCacheManager ||
            ((this._urlCacheManager = ce.createCacheManager(bi.urlCacheManager)),
            console.log("[GlobalManagers] Initialized UrlCacheManager")),
          this._urlCacheManager
        )
      }
      get failedLinksManager() {
        return (
          this._failedLinksManager ||
            ((this._failedLinksManager = ce.createCacheManager(bi.failedLinksManager)),
            console.log("[GlobalManagers] Initialized FailedLinksManager")),
          this._failedLinksManager
        )
      }
      get storageManager() {
        return (
          this._storageManager ||
            ((this._storageManager = ce.createStorageManager(bi.globalStorageManager)),
            console.log("[GlobalManagers] Initialized StorageManager")),
          this._storageManager
        )
      }
      get resourceManager() {
        return (
          this._resourceManager ||
            ((this._resourceManager = ce.createResourceManager(bi.globalResourceManager)),
            console.log("[GlobalManagers] Initialized ResourceManager")),
          this._resourceManager
        )
      }
      get cleanupManager() {
        return (
          this._cleanupManager ||
            ((this._cleanupManager = ce.getCleanupManager()),
            console.log("[GlobalManagers] Initialized CleanupManager")),
          this._cleanupManager
        )
      }
      createCache(t) {
        return ce.createCacheManager({ type: "CACHE", identifier: t, config: { cacheType: t } })
      }
      initialize(t = !1) {
        if (this._initialized) {
          console.log("[GlobalManagers] Already initialized, skipping...")
          return
        }
        ;(console.log("[GlobalManagers] Initializing global manager instances..."),
          this.cleanupManager,
          this.unifiedContentCache,
          t &&
            (this.linkCache,
            this.searchCache,
            this.userCache,
            this.systemCache,
            this.defaultCache,
            this.storageManager,
            this.resourceManager,
            this.failedLinksManager,
            this.urlCacheManager,
            console.log("[GlobalManagers] All manager instances preloaded")),
          (this._initialized = !0),
          console.log("[GlobalManagers] Global manager instances initialized"))
      }
      cleanup() {
        ;(console.log("[GlobalManagers] Cleaning up all global manager instances..."),
          ce.cleanup(),
          console.log("[GlobalManagers] All global manager instances cleaned up"))
      }
      destroy() {
        ;(console.log("[GlobalManagers] Destroying all global manager instances..."),
          ce.destroy(),
          (this._initialized = !1),
          Object.keys(this).forEach((t) => {
            t.startsWith("_") && (this[t] = null)
          }),
          (this._initialized = !1),
          console.log("[GlobalManagers] All global manager instances destroyed"))
      }
    },
    Or = class {
      static _instance = new Pl()
      static get instance() {
        return this._instance
      }
      static initialize(t = !1) {
        this._instance.initialize(t)
      }
      static cleanup() {
        this._instance.cleanup()
      }
      static destroy() {
        this._instance.destroy()
      }
      static getInstance(t, e) {
        switch (t) {
          case "CACHE":
            return this.instance.defaultCache
          case "RESOURCE":
            return this.instance.resourceManager
          case "STORAGE":
            return this.instance.storageManager
          case "UNIFIED_CONTENT_CACHE":
            return this.instance.unifiedContentCache
          case "CLEANUP":
            return this.instance.cleanupManager
          default:
            throw new Error(`[GlobalManagerController] Unknown manager type: ${t}`)
        }
      }
    }
  var yi = {
      get instance() {
        return Or.instance.storageManager
      },
    },
    Ye = {
      get instance() {
        return Or.instance.resourceManager
      },
    }
  var Lr = {
    get instance() {
      return Or.instance.defaultCache
    },
  }
  typeof window < "u" &&
    ((window.__quartz = window.__quartz || {}),
    (window.__quartz.managers = window.__quartz.managers || {}),
    Ye.instance,
    (window.__quartz.managers.resourceManager = Ye.instance))
  var Qo = class {
      config
      state
      resourceManager = Ye.instance
      storageManager = yi.instance
      cacheManager = Lr.instance
      constructor(t) {
        ;((this.config = {
          debug: !1,
          cacheConfig: { prefix: t.name.toLowerCase(), ttl: 36e5 },
          ...t,
        }),
          (this.state = {
            initialized: !1,
            eventListenersSetup: !1,
            elements: new Set(),
            cleanupTasks: [],
          }),
          this.log("BaseComponentManager created"))
      }
      async initialize() {
        if (this.state.initialized) {
          this.log("Component already initialized, skipping")
          return
        }
        try {
          ;(this.log("Initializing component..."),
            this.validateGlobalInstances(),
            this.setupEventListeners(),
            await this.onInitialize(),
            this.setupPage(),
            (this.state.initialized = !0),
            this.log("Component initialized successfully"))
        } catch (t) {
          throw (console.error(`[${this.config.name}] Initialization failed:`, t), t)
        }
      }
      setupEventListeners() {
        if (!this.resourceManager)
          throw new Error(`[${this.config.name}] ResourceManager not available`)
        if (this.state.eventListenersSetup) {
          this.log("Event listeners already setup, skipping")
          return
        }
        ;(this.log("Setting up event listeners..."),
          this.resourceManager.addEventListener(document, "nav", () => this.setupPage()),
          this.resourceManager.addEventListener(document, "DOMContentLoaded", () =>
            this.setupPage(),
          ),
          this.resourceManager.addCleanupTask(() => {
            this.cleanup()
          }),
          this.onSetupEventListeners(),
          (this.state.eventListenersSetup = !0),
          this.log("Event listeners setup completed"))
      }
      setupPage() {
        try {
          this.log("Setting up page...")
          let t = this.findComponentElements()
          ;(this.state.elements.clear(),
            t.forEach((e) => this.state.elements.add(e)),
            this.onSetupPage(t),
            this.log(`Page setup completed, found ${t.length} elements`))
        } catch (t) {
          console.error(`[${this.config.name}] Page setup failed:`, t)
        }
      }
      cleanup() {
        this.log("Cleaning up component...")
        try {
          ;(this.onCleanup(),
            this.state.cleanupTasks.forEach((t) => {
              try {
                t()
              } catch (e) {
                console.error(`[${this.config.name}] Cleanup task failed:`, e)
              }
            }),
            this.state.elements.clear(),
            (this.state.cleanupTasks.length = 0),
            this.log("Component cleanup completed"))
        } catch (t) {
          console.error(`[${this.config.name}] Cleanup failed:`, t)
        }
      }
      generateCacheKey(...t) {
        return _t.generateSystemKey(this.config.cacheConfig.prefix, ...t)
      }
      generateUserCacheKey(t) {
        return _t.generateUserKey(this.config.cacheConfig.prefix, t)
      }
      generateContentCacheKey(t) {
        return _t.generateContentKey(t)
      }
      setStorageItem(t, e) {
        if (!this.storageManager)
          throw new Error(`[${this.config.name}] StorageManager not available`)
        this.storageManager.setItem("local", t, e)
      }
      getStorageItem(t, e) {
        if (!this.storageManager)
          throw new Error(`[${this.config.name}] StorageManager not available`)
        let i = this.storageManager.getItem("local", t)
        return i !== null ? i : (e ?? null)
      }
      setCacheItem(t, e, i) {
        if (!this.cacheManager) throw new Error(`[${this.config.name}] CacheManager not available`)
        this.cacheManager.set(t, e, i ?? this.config.cacheConfig.ttl)
      }
      getCacheItem(t) {
        if (!this.cacheManager) throw new Error(`[${this.config.name}] CacheManager not available`)
        return this.cacheManager.get(t)
      }
      addCleanupTask(t) {
        this.state.cleanupTasks.push(t)
      }
      addEventListener(t, e, i, n) {
        this.resourceManager
          ? this.resourceManager.addEventListener(t, e, i, n)
          : (t.addEventListener(e, i, n),
            this.addCleanupTask(() => {
              t.removeEventListener(e, i, n)
            }))
      }
      log(t, ...e) {
        this.config.debug && console.log(`[${this.config.name}] ${t}`, ...e)
      }
      error(t, ...e) {
        console.error(`[${this.config.name}] ${t}`, ...e)
      }
      validateGlobalInstances() {
        if (!this.resourceManager)
          throw new Error(`[${this.config.name}] ResourceManager not available`)
        if (!this.storageManager)
          throw new Error(`[${this.config.name}] StorageManager not available`)
        if (!this.cacheManager) throw new Error(`[${this.config.name}] CacheManager not available`)
      }
    },
    Dn = class {
      static instances = new Map()
      static register(t, e) {
        ;(this.instances.has(t) &&
          console.warn(`Component manager '${t}' already registered. Overwriting.`),
          this.instances.set(t, e))
      }
      static get(t) {
        return this.instances.get(t)
      }
      static async initialize(t) {
        let e = this.get(t)
        if (!e) throw new Error(`Component manager '${t}' not registered`)
        await e.initialize()
      }
      static async initializeAll() {
        let t = Array.from(this.instances.values()).map((e) =>
          e.initialize().catch((i) => {
            console.error("Component manager initialization failed:", i)
          }),
        )
        await Promise.all(t)
      }
      static getRegisteredComponents() {
        return Array.from(this.instances.keys())
      }
    }
  var WF = Object.hasOwnProperty
  var ep = wl(tp(), 1),
    h1 = (0, ep.default)()
  function Fl(r) {
    try {
      let t,
        e = "",
        i = ""
      if (r.startsWith("http") || r.startsWith("/"))
        if (r.startsWith("http"))
          try {
            let l = new URL(r)
            ;((t = l.pathname), (e = l.search), (i = l.hash))
          } catch (l) {
            return (console.warn(`Failed to parse URL in removeDuplicatePathSegments: ${r}`, l), r)
          }
        else {
          let l = r.split("#"),
            c = l[0]
          i = l[1] ? "#" + l[1] : ""
          let h = c.indexOf("?")
          h !== -1 ? ((t = c.substring(0, h)), (e = c.substring(h))) : (t = c)
        }
      else t = r
      let n = t.split("/").filter((l) => l.length > 0),
        s = [],
        o = new Set()
      for (let l of n) {
        let c = s.length > 0 && s[s.length - 1] === l,
          h = o.has(l)
        !c && !h && (s.push(l), o.add(l))
      }
      return (s.length > 0 ? "/" + s.join("/") : "/") + e + i
    } catch (t) {
      return (console.warn("Failed to clean duplicate path segments:", t), r)
    }
  }
  function Pn(r) {
    return r.document.body.dataset.slug
  }
  function Nr(r) {
    let t = rp(m1(r, "index"), !0)
    return t.length === 0 ? "/" : t
  }
  function f1(r) {
    let t = r
      .split("/")
      .filter((e) => e !== "")
      .slice(0, -1)
      .map((e) => "..")
      .join("/")
    return (t.length === 0 && (t = "."), t)
  }
  function Rl(r, t) {
    return d1(f1(r), Nr(t))
  }
  function d1(...r) {
    if (r.length === 0) return ""
    let t = r
      .filter((e) => e !== "" && e !== "/")
      .map((e) => rp(e))
      .join("/")
    return (
      r[0].startsWith("/") && (t = "/" + t),
      r[r.length - 1].endsWith("/") && (t = t + "/"),
      t
    )
  }
  function p1(r, t) {
    return r === t || r.endsWith("/" + t)
  }
  function m1(r, t) {
    return (p1(r, t) && (r = r.slice(0, -t.length)), r)
  }
  function rp(r, t) {
    return (
      r.startsWith("/") && (r = r.substring(1)),
      !t && r.endsWith("/") && (r = r.slice(0, -1)),
      r
    )
  }
  var g1 = { value: () => {} }
  function np() {
    for (var r = 0, t = arguments.length, e = {}, i; r < t; ++r) {
      if (!(i = arguments[r] + "") || i in e || /[\s.]/.test(i))
        throw new Error("illegal type: " + i)
      e[i] = []
    }
    return new Jo(e)
  }
  function Jo(r) {
    this._ = r
  }
  function x1(r, t) {
    return r
      .trim()
      .split(/^|\s+/)
      .map(function (e) {
        var i = "",
          n = e.indexOf(".")
        if ((n >= 0 && ((i = e.slice(n + 1)), (e = e.slice(0, n))), e && !t.hasOwnProperty(e)))
          throw new Error("unknown type: " + e)
        return { type: e, name: i }
      })
  }
  Jo.prototype = np.prototype = {
    constructor: Jo,
    on: function (r, t) {
      var e = this._,
        i = x1(r + "", e),
        n,
        s = -1,
        o = i.length
      if (arguments.length < 2) {
        for (; ++s < o; ) if ((n = (r = i[s]).type) && (n = _1(e[n], r.name))) return n
        return
      }
      if (t != null && typeof t != "function") throw new Error("invalid callback: " + t)
      for (; ++s < o; )
        if ((n = (r = i[s]).type)) e[n] = ip(e[n], r.name, t)
        else if (t == null) for (n in e) e[n] = ip(e[n], r.name, null)
      return this
    },
    copy: function () {
      var r = {},
        t = this._
      for (var e in t) r[e] = t[e].slice()
      return new Jo(r)
    },
    call: function (r, t) {
      if ((n = arguments.length - 2) > 0)
        for (var e = new Array(n), i = 0, n, s; i < n; ++i) e[i] = arguments[i + 2]
      if (!this._.hasOwnProperty(r)) throw new Error("unknown type: " + r)
      for (s = this._[r], i = 0, n = s.length; i < n; ++i) s[i].value.apply(t, e)
    },
    apply: function (r, t, e) {
      if (!this._.hasOwnProperty(r)) throw new Error("unknown type: " + r)
      for (var i = this._[r], n = 0, s = i.length; n < s; ++n) i[n].value.apply(t, e)
    },
  }
  function _1(r, t) {
    for (var e = 0, i = r.length, n; e < i; ++e) if ((n = r[e]).name === t) return n.value
  }
  function ip(r, t, e) {
    for (var i = 0, n = r.length; i < n; ++i)
      if (r[i].name === t) {
        ;((r[i] = g1), (r = r.slice(0, i).concat(r.slice(i + 1))))
        break
      }
    return (e != null && r.push({ name: t, value: e }), r)
  }
  var je = np
  var ta = "http://www.w3.org/1999/xhtml",
    Bl = {
      svg: "http://www.w3.org/2000/svg",
      xhtml: ta,
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/",
    }
  function Ke(r) {
    var t = (r += ""),
      e = t.indexOf(":")
    return (
      e >= 0 && (t = r.slice(0, e)) !== "xmlns" && (r = r.slice(e + 1)),
      Bl.hasOwnProperty(t) ? { space: Bl[t], local: r } : r
    )
  }
  function y1(r) {
    return function () {
      var t = this.ownerDocument,
        e = this.namespaceURI
      return e === ta && t.documentElement.namespaceURI === ta
        ? t.createElement(r)
        : t.createElementNS(e, r)
    }
  }
  function b1(r) {
    return function () {
      return this.ownerDocument.createElementNS(r.space, r.local)
    }
  }
  function ea(r) {
    var t = Ke(r)
    return (t.local ? b1 : y1)(t)
  }
  function v1() {}
  function Hr(r) {
    return r == null
      ? v1
      : function () {
          return this.querySelector(r)
        }
  }
  function sp(r) {
    typeof r != "function" && (r = Hr(r))
    for (var t = this._groups, e = t.length, i = new Array(e), n = 0; n < e; ++n)
      for (var s = t[n], o = s.length, a = (i[n] = new Array(o)), u, l, c = 0; c < o; ++c)
        (u = s[c]) &&
          (l = r.call(u, u.__data__, c, s)) &&
          ("__data__" in u && (l.__data__ = u.__data__), (a[c] = l))
    return new Et(i, this._parents)
  }
  function Il(r) {
    return r == null ? [] : Array.isArray(r) ? r : Array.from(r)
  }
  function S1() {
    return []
  }
  function Fn(r) {
    return r == null
      ? S1
      : function () {
          return this.querySelectorAll(r)
        }
  }
  function T1(r) {
    return function () {
      return Il(r.apply(this, arguments))
    }
  }
  function op(r) {
    typeof r == "function" ? (r = T1(r)) : (r = Fn(r))
    for (var t = this._groups, e = t.length, i = [], n = [], s = 0; s < e; ++s)
      for (var o = t[s], a = o.length, u, l = 0; l < a; ++l)
        (u = o[l]) && (i.push(r.call(u, u.__data__, l, o)), n.push(u))
    return new Et(i, n)
  }
  function Rn(r) {
    return function () {
      return this.matches(r)
    }
  }
  function ra(r) {
    return function (t) {
      return t.matches(r)
    }
  }
  var C1 = Array.prototype.find
  function E1(r) {
    return function () {
      return C1.call(this.children, r)
    }
  }
  function w1() {
    return this.firstElementChild
  }
  function ap(r) {
    return this.select(r == null ? w1 : E1(typeof r == "function" ? r : ra(r)))
  }
  var M1 = Array.prototype.filter
  function A1() {
    return Array.from(this.children)
  }
  function D1(r) {
    return function () {
      return M1.call(this.children, r)
    }
  }
  function up(r) {
    return this.selectAll(r == null ? A1 : D1(typeof r == "function" ? r : ra(r)))
  }
  function lp(r) {
    typeof r != "function" && (r = Rn(r))
    for (var t = this._groups, e = t.length, i = new Array(e), n = 0; n < e; ++n)
      for (var s = t[n], o = s.length, a = (i[n] = []), u, l = 0; l < o; ++l)
        (u = s[l]) && r.call(u, u.__data__, l, s) && a.push(u)
    return new Et(i, this._parents)
  }
  function ia(r) {
    return new Array(r.length)
  }
  function cp() {
    return new Et(this._enter || this._groups.map(ia), this._parents)
  }
  function Bn(r, t) {
    ;((this.ownerDocument = r.ownerDocument),
      (this.namespaceURI = r.namespaceURI),
      (this._next = null),
      (this._parent = r),
      (this.__data__ = t))
  }
  Bn.prototype = {
    constructor: Bn,
    appendChild: function (r) {
      return this._parent.insertBefore(r, this._next)
    },
    insertBefore: function (r, t) {
      return this._parent.insertBefore(r, t)
    },
    querySelector: function (r) {
      return this._parent.querySelector(r)
    },
    querySelectorAll: function (r) {
      return this._parent.querySelectorAll(r)
    },
  }
  function hp(r) {
    return function () {
      return r
    }
  }
  function P1(r, t, e, i, n, s) {
    for (var o = 0, a, u = t.length, l = s.length; o < l; ++o)
      (a = t[o]) ? ((a.__data__ = s[o]), (i[o] = a)) : (e[o] = new Bn(r, s[o]))
    for (; o < u; ++o) (a = t[o]) && (n[o] = a)
  }
  function F1(r, t, e, i, n, s, o) {
    var a,
      u,
      l = new Map(),
      c = t.length,
      h = s.length,
      f = new Array(c),
      d
    for (a = 0; a < c; ++a)
      (u = t[a]) &&
        ((f[a] = d = o.call(u, u.__data__, a, t) + ""), l.has(d) ? (n[a] = u) : l.set(d, u))
    for (a = 0; a < h; ++a)
      ((d = o.call(r, s[a], a, s) + ""),
        (u = l.get(d)) ? ((i[a] = u), (u.__data__ = s[a]), l.delete(d)) : (e[a] = new Bn(r, s[a])))
    for (a = 0; a < c; ++a) (u = t[a]) && l.get(f[a]) === u && (n[a] = u)
  }
  function R1(r) {
    return r.__data__
  }
  function fp(r, t) {
    if (!arguments.length) return Array.from(this, R1)
    var e = t ? F1 : P1,
      i = this._parents,
      n = this._groups
    typeof r != "function" && (r = hp(r))
    for (
      var s = n.length, o = new Array(s), a = new Array(s), u = new Array(s), l = 0;
      l < s;
      ++l
    ) {
      var c = i[l],
        h = n[l],
        f = h.length,
        d = B1(r.call(c, c && c.__data__, l, i)),
        g = d.length,
        x = (a[l] = new Array(g)),
        m = (o[l] = new Array(g)),
        _ = (u[l] = new Array(f))
      e(c, h, x, m, _, d, t)
      for (var v = 0, S = 0, y, M; v < g; ++v)
        if ((y = x[v])) {
          for (v >= S && (S = v + 1); !(M = m[S]) && ++S < g; );
          y._next = M || null
        }
    }
    return ((o = new Et(o, i)), (o._enter = a), (o._exit = u), o)
  }
  function B1(r) {
    return typeof r == "object" && "length" in r ? r : Array.from(r)
  }
  function dp() {
    return new Et(this._exit || this._groups.map(ia), this._parents)
  }
  function pp(r, t, e) {
    var i = this.enter(),
      n = this,
      s = this.exit()
    return (
      typeof r == "function" ? ((i = r(i)), i && (i = i.selection())) : (i = i.append(r + "")),
      t != null && ((n = t(n)), n && (n = n.selection())),
      e == null ? s.remove() : e(s),
      i && n ? i.merge(n).order() : n
    )
  }
  function mp(r) {
    for (
      var t = r.selection ? r.selection() : r,
        e = this._groups,
        i = t._groups,
        n = e.length,
        s = i.length,
        o = Math.min(n, s),
        a = new Array(n),
        u = 0;
      u < o;
      ++u
    )
      for (var l = e[u], c = i[u], h = l.length, f = (a[u] = new Array(h)), d, g = 0; g < h; ++g)
        (d = l[g] || c[g]) && (f[g] = d)
    for (; u < n; ++u) a[u] = e[u]
    return new Et(a, this._parents)
  }
  function gp() {
    for (var r = this._groups, t = -1, e = r.length; ++t < e; )
      for (var i = r[t], n = i.length - 1, s = i[n], o; --n >= 0; )
        (o = i[n]) &&
          (s && o.compareDocumentPosition(s) ^ 4 && s.parentNode.insertBefore(o, s), (s = o))
    return this
  }
  function xp(r) {
    r || (r = I1)
    function t(h, f) {
      return h && f ? r(h.__data__, f.__data__) : !h - !f
    }
    for (var e = this._groups, i = e.length, n = new Array(i), s = 0; s < i; ++s) {
      for (var o = e[s], a = o.length, u = (n[s] = new Array(a)), l, c = 0; c < a; ++c)
        (l = o[c]) && (u[c] = l)
      u.sort(t)
    }
    return new Et(n, this._parents).order()
  }
  function I1(r, t) {
    return r < t ? -1 : r > t ? 1 : r >= t ? 0 : NaN
  }
  function _p() {
    var r = arguments[0]
    return ((arguments[0] = this), r.apply(null, arguments), this)
  }
  function yp() {
    return Array.from(this)
  }
  function bp() {
    for (var r = this._groups, t = 0, e = r.length; t < e; ++t)
      for (var i = r[t], n = 0, s = i.length; n < s; ++n) {
        var o = i[n]
        if (o) return o
      }
    return null
  }
  function vp() {
    let r = 0
    for (let t of this) ++r
    return r
  }
  function Sp() {
    return !this.node()
  }
  function Tp(r) {
    for (var t = this._groups, e = 0, i = t.length; e < i; ++e)
      for (var n = t[e], s = 0, o = n.length, a; s < o; ++s)
        (a = n[s]) && r.call(a, a.__data__, s, n)
    return this
  }
  function k1(r) {
    return function () {
      this.removeAttribute(r)
    }
  }
  function G1(r) {
    return function () {
      this.removeAttributeNS(r.space, r.local)
    }
  }
  function U1(r, t) {
    return function () {
      this.setAttribute(r, t)
    }
  }
  function O1(r, t) {
    return function () {
      this.setAttributeNS(r.space, r.local, t)
    }
  }
  function L1(r, t) {
    return function () {
      var e = t.apply(this, arguments)
      e == null ? this.removeAttribute(r) : this.setAttribute(r, e)
    }
  }
  function N1(r, t) {
    return function () {
      var e = t.apply(this, arguments)
      e == null
        ? this.removeAttributeNS(r.space, r.local)
        : this.setAttributeNS(r.space, r.local, e)
    }
  }
  function Cp(r, t) {
    var e = Ke(r)
    if (arguments.length < 2) {
      var i = this.node()
      return e.local ? i.getAttributeNS(e.space, e.local) : i.getAttribute(e)
    }
    return this.each(
      (t == null
        ? e.local
          ? G1
          : k1
        : typeof t == "function"
          ? e.local
            ? N1
            : L1
          : e.local
            ? O1
            : U1)(e, t),
    )
  }
  function na(r) {
    return (r.ownerDocument && r.ownerDocument.defaultView) || (r.document && r) || r.defaultView
  }
  function H1(r) {
    return function () {
      this.style.removeProperty(r)
    }
  }
  function z1(r, t, e) {
    return function () {
      this.style.setProperty(r, t, e)
    }
  }
  function W1(r, t, e) {
    return function () {
      var i = t.apply(this, arguments)
      i == null ? this.style.removeProperty(r) : this.style.setProperty(r, i, e)
    }
  }
  function Ep(r, t, e) {
    return arguments.length > 1
      ? this.each((t == null ? H1 : typeof t == "function" ? W1 : z1)(r, t, e ?? ""))
      : dr(this.node(), r)
  }
  function dr(r, t) {
    return r.style.getPropertyValue(t) || na(r).getComputedStyle(r, null).getPropertyValue(t)
  }
  function V1(r) {
    return function () {
      delete this[r]
    }
  }
  function $1(r, t) {
    return function () {
      this[r] = t
    }
  }
  function X1(r, t) {
    return function () {
      var e = t.apply(this, arguments)
      e == null ? delete this[r] : (this[r] = e)
    }
  }
  function wp(r, t) {
    return arguments.length > 1
      ? this.each((t == null ? V1 : typeof t == "function" ? X1 : $1)(r, t))
      : this.node()[r]
  }
  function Mp(r) {
    return r.trim().split(/^|\s+/)
  }
  function kl(r) {
    return r.classList || new Ap(r)
  }
  function Ap(r) {
    ;((this._node = r), (this._names = Mp(r.getAttribute("class") || "")))
  }
  Ap.prototype = {
    add: function (r) {
      var t = this._names.indexOf(r)
      t < 0 && (this._names.push(r), this._node.setAttribute("class", this._names.join(" ")))
    },
    remove: function (r) {
      var t = this._names.indexOf(r)
      t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")))
    },
    contains: function (r) {
      return this._names.indexOf(r) >= 0
    },
  }
  function Dp(r, t) {
    for (var e = kl(r), i = -1, n = t.length; ++i < n; ) e.add(t[i])
  }
  function Pp(r, t) {
    for (var e = kl(r), i = -1, n = t.length; ++i < n; ) e.remove(t[i])
  }
  function Y1(r) {
    return function () {
      Dp(this, r)
    }
  }
  function j1(r) {
    return function () {
      Pp(this, r)
    }
  }
  function K1(r, t) {
    return function () {
      ;(t.apply(this, arguments) ? Dp : Pp)(this, r)
    }
  }
  function Fp(r, t) {
    var e = Mp(r + "")
    if (arguments.length < 2) {
      for (var i = kl(this.node()), n = -1, s = e.length; ++n < s; )
        if (!i.contains(e[n])) return !1
      return !0
    }
    return this.each((typeof t == "function" ? K1 : t ? Y1 : j1)(e, t))
  }
  function q1() {
    this.textContent = ""
  }
  function Z1(r) {
    return function () {
      this.textContent = r
    }
  }
  function Q1(r) {
    return function () {
      var t = r.apply(this, arguments)
      this.textContent = t ?? ""
    }
  }
  function Rp(r) {
    return arguments.length
      ? this.each(r == null ? q1 : (typeof r == "function" ? Q1 : Z1)(r))
      : this.node().textContent
  }
  function J1() {
    this.innerHTML = ""
  }
  function tw(r) {
    return function () {
      this.innerHTML = r
    }
  }
  function ew(r) {
    return function () {
      var t = r.apply(this, arguments)
      this.innerHTML = t ?? ""
    }
  }
  function Bp(r) {
    return arguments.length
      ? this.each(r == null ? J1 : (typeof r == "function" ? ew : tw)(r))
      : this.node().innerHTML
  }
  function rw() {
    this.nextSibling && this.parentNode.appendChild(this)
  }
  function Ip() {
    return this.each(rw)
  }
  function iw() {
    this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild)
  }
  function kp() {
    return this.each(iw)
  }
  function Gp(r) {
    var t = typeof r == "function" ? r : ea(r)
    return this.select(function () {
      return this.appendChild(t.apply(this, arguments))
    })
  }
  function nw() {
    return null
  }
  function Up(r, t) {
    var e = typeof r == "function" ? r : ea(r),
      i = t == null ? nw : typeof t == "function" ? t : Hr(t)
    return this.select(function () {
      return this.insertBefore(e.apply(this, arguments), i.apply(this, arguments) || null)
    })
  }
  function sw() {
    var r = this.parentNode
    r && r.removeChild(this)
  }
  function Op() {
    return this.each(sw)
  }
  function ow() {
    var r = this.cloneNode(!1),
      t = this.parentNode
    return t ? t.insertBefore(r, this.nextSibling) : r
  }
  function aw() {
    var r = this.cloneNode(!0),
      t = this.parentNode
    return t ? t.insertBefore(r, this.nextSibling) : r
  }
  function Lp(r) {
    return this.select(r ? aw : ow)
  }
  function Np(r) {
    return arguments.length ? this.property("__data__", r) : this.node().__data__
  }
  function uw(r) {
    return function (t) {
      r.call(this, t, this.__data__)
    }
  }
  function lw(r) {
    return r
      .trim()
      .split(/^|\s+/)
      .map(function (t) {
        var e = "",
          i = t.indexOf(".")
        return (i >= 0 && ((e = t.slice(i + 1)), (t = t.slice(0, i))), { type: t, name: e })
      })
  }
  function cw(r) {
    return function () {
      var t = this.__on
      if (t) {
        for (var e = 0, i = -1, n = t.length, s; e < n; ++e)
          ((s = t[e]),
            (!r.type || s.type === r.type) && s.name === r.name
              ? this.removeEventListener(s.type, s.listener, s.options)
              : (t[++i] = s))
        ++i ? (t.length = i) : delete this.__on
      }
    }
  }
  function hw(r, t, e) {
    return function () {
      var i = this.__on,
        n,
        s = uw(t)
      if (i) {
        for (var o = 0, a = i.length; o < a; ++o)
          if ((n = i[o]).type === r.type && n.name === r.name) {
            ;(this.removeEventListener(n.type, n.listener, n.options),
              this.addEventListener(n.type, (n.listener = s), (n.options = e)),
              (n.value = t))
            return
          }
      }
      ;(this.addEventListener(r.type, s, e),
        (n = { type: r.type, name: r.name, value: t, listener: s, options: e }),
        i ? i.push(n) : (this.__on = [n]))
    }
  }
  function Hp(r, t, e) {
    var i = lw(r + ""),
      n,
      s = i.length,
      o
    if (arguments.length < 2) {
      var a = this.node().__on
      if (a) {
        for (var u = 0, l = a.length, c; u < l; ++u)
          for (n = 0, c = a[u]; n < s; ++n)
            if ((o = i[n]).type === c.type && o.name === c.name) return c.value
      }
      return
    }
    for (a = t ? hw : cw, n = 0; n < s; ++n) this.each(a(i[n], t, e))
    return this
  }
  function zp(r, t, e) {
    var i = na(r),
      n = i.CustomEvent
    ;(typeof n == "function"
      ? (n = new n(t, e))
      : ((n = i.document.createEvent("Event")),
        e
          ? (n.initEvent(t, e.bubbles, e.cancelable), (n.detail = e.detail))
          : n.initEvent(t, !1, !1)),
      r.dispatchEvent(n))
  }
  function fw(r, t) {
    return function () {
      return zp(this, r, t)
    }
  }
  function dw(r, t) {
    return function () {
      return zp(this, r, t.apply(this, arguments))
    }
  }
  function Wp(r, t) {
    return this.each((typeof t == "function" ? dw : fw)(r, t))
  }
  function* Vp() {
    for (var r = this._groups, t = 0, e = r.length; t < e; ++t)
      for (var i = r[t], n = 0, s = i.length, o; n < s; ++n) (o = i[n]) && (yield o)
  }
  var Gl = [null]
  function Et(r, t) {
    ;((this._groups = r), (this._parents = t))
  }
  function $p() {
    return new Et([[document.documentElement]], Gl)
  }
  function pw() {
    return this
  }
  Et.prototype = $p.prototype = {
    constructor: Et,
    select: sp,
    selectAll: op,
    selectChild: ap,
    selectChildren: up,
    filter: lp,
    data: fp,
    enter: cp,
    exit: dp,
    join: pp,
    merge: mp,
    selection: pw,
    order: gp,
    sort: xp,
    call: _p,
    nodes: yp,
    node: bp,
    size: vp,
    empty: Sp,
    each: Tp,
    attr: Cp,
    style: Ep,
    property: wp,
    classed: Fp,
    text: Rp,
    html: Bp,
    raise: Ip,
    lower: kp,
    append: Gp,
    insert: Up,
    remove: Op,
    clone: Lp,
    datum: Np,
    on: Hp,
    dispatch: Wp,
    [Symbol.iterator]: Vp,
  }
  var qe = $p
  function $t(r) {
    return typeof r == "string"
      ? new Et([[document.querySelector(r)]], [document.documentElement])
      : new Et([[r]], Gl)
  }
  function Xp(r) {
    let t
    for (; (t = r.sourceEvent); ) r = t
    return r
  }
  function me(r, t) {
    if (((r = Xp(r)), t === void 0 && (t = r.currentTarget), t)) {
      var e = t.ownerSVGElement || t
      if (e.createSVGPoint) {
        var i = e.createSVGPoint()
        return (
          (i.x = r.clientX),
          (i.y = r.clientY),
          (i = i.matrixTransform(t.getScreenCTM().inverse())),
          [i.x, i.y]
        )
      }
      if (t.getBoundingClientRect) {
        var n = t.getBoundingClientRect()
        return [r.clientX - n.left - t.clientLeft, r.clientY - n.top - t.clientTop]
      }
    }
    return [r.pageX, r.pageY]
  }
  var Yp = { passive: !1 },
    zr = { capture: !0, passive: !1 }
  function sa(r) {
    r.stopImmediatePropagation()
  }
  function pr(r) {
    ;(r.preventDefault(), r.stopImmediatePropagation())
  }
  function In(r) {
    var t = r.document.documentElement,
      e = $t(r).on("dragstart.drag", pr, zr)
    "onselectstart" in t
      ? e.on("selectstart.drag", pr, zr)
      : ((t.__noselect = t.style.MozUserSelect), (t.style.MozUserSelect = "none"))
  }
  function kn(r, t) {
    var e = r.document.documentElement,
      i = $t(r).on("dragstart.drag", null)
    ;(t &&
      (i.on("click.drag", pr, zr),
      setTimeout(function () {
        i.on("click.drag", null)
      }, 0)),
      "onselectstart" in e
        ? i.on("selectstart.drag", null)
        : ((e.style.MozUserSelect = e.__noselect), delete e.__noselect))
  }
  var Gn = (r) => () => r
  function Un(
    r,
    {
      sourceEvent: t,
      subject: e,
      target: i,
      identifier: n,
      active: s,
      x: o,
      y: a,
      dx: u,
      dy: l,
      dispatch: c,
    },
  ) {
    Object.defineProperties(this, {
      type: { value: r, enumerable: !0, configurable: !0 },
      sourceEvent: { value: t, enumerable: !0, configurable: !0 },
      subject: { value: e, enumerable: !0, configurable: !0 },
      target: { value: i, enumerable: !0, configurable: !0 },
      identifier: { value: n, enumerable: !0, configurable: !0 },
      active: { value: s, enumerable: !0, configurable: !0 },
      x: { value: o, enumerable: !0, configurable: !0 },
      y: { value: a, enumerable: !0, configurable: !0 },
      dx: { value: u, enumerable: !0, configurable: !0 },
      dy: { value: l, enumerable: !0, configurable: !0 },
      _: { value: c },
    })
  }
  Un.prototype.on = function () {
    var r = this._.on.apply(this._, arguments)
    return r === this._ ? this : r
  }
  function mw(r) {
    return !r.ctrlKey && !r.button
  }
  function gw() {
    return this.parentNode
  }
  function xw(r, t) {
    return t ?? { x: r.x, y: r.y }
  }
  function _w() {
    return navigator.maxTouchPoints || "ontouchstart" in this
  }
  function Ul() {
    var r = mw,
      t = gw,
      e = xw,
      i = _w,
      n = {},
      s = je("start", "drag", "end"),
      o = 0,
      a,
      u,
      l,
      c,
      h = 0
    function f(y) {
      y.on("mousedown.drag", d)
        .filter(i)
        .on("touchstart.drag", m)
        .on("touchmove.drag", _, Yp)
        .on("touchend.drag touchcancel.drag", v)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)")
    }
    function d(y, M) {
      if (!(c || !r.call(this, y, M))) {
        var T = S(this, t.call(this, y, M), y, M, "mouse")
        T &&
          ($t(y.view).on("mousemove.drag", g, zr).on("mouseup.drag", x, zr),
          In(y.view),
          sa(y),
          (l = !1),
          (a = y.clientX),
          (u = y.clientY),
          T("start", y))
      }
    }
    function g(y) {
      if ((pr(y), !l)) {
        var M = y.clientX - a,
          T = y.clientY - u
        l = M * M + T * T > h
      }
      n.mouse("drag", y)
    }
    function x(y) {
      ;($t(y.view).on("mousemove.drag mouseup.drag", null), kn(y.view, l), pr(y), n.mouse("end", y))
    }
    function m(y, M) {
      if (r.call(this, y, M)) {
        var T = y.changedTouches,
          E = t.call(this, y, M),
          G = T.length,
          B,
          P
        for (B = 0; B < G; ++B)
          (P = S(this, E, y, M, T[B].identifier, T[B])) && (sa(y), P("start", y, T[B]))
      }
    }
    function _(y) {
      var M = y.changedTouches,
        T = M.length,
        E,
        G
      for (E = 0; E < T; ++E) (G = n[M[E].identifier]) && (pr(y), G("drag", y, M[E]))
    }
    function v(y) {
      var M = y.changedTouches,
        T = M.length,
        E,
        G
      for (
        c && clearTimeout(c),
          c = setTimeout(function () {
            c = null
          }, 500),
          E = 0;
        E < T;
        ++E
      )
        (G = n[M[E].identifier]) && (sa(y), G("end", y, M[E]))
    }
    function S(y, M, T, E, G, B) {
      var P = s.copy(),
        F = me(B || T, M),
        W,
        j,
        C
      if (
        (C = e.call(
          y,
          new Un("beforestart", {
            sourceEvent: T,
            target: f,
            identifier: G,
            active: o,
            x: F[0],
            y: F[1],
            dx: 0,
            dy: 0,
            dispatch: P,
          }),
          E,
        )) != null
      )
        return (
          (W = C.x - F[0] || 0),
          (j = C.y - F[1] || 0),
          function H(w, D, Y) {
            var O = F,
              X
            switch (w) {
              case "start":
                ;((n[G] = H), (X = o++))
                break
              case "end":
                ;(delete n[G], --o)
              case "drag":
                ;((F = me(Y || D, M)), (X = o))
                break
            }
            P.call(
              w,
              y,
              new Un(w, {
                sourceEvent: D,
                subject: C,
                target: f,
                identifier: G,
                active: X,
                x: F[0] + W,
                y: F[1] + j,
                dx: F[0] - O[0],
                dy: F[1] - O[1],
                dispatch: P,
              }),
              E,
            )
          }
        )
    }
    return (
      (f.filter = function (y) {
        return arguments.length ? ((r = typeof y == "function" ? y : Gn(!!y)), f) : r
      }),
      (f.container = function (y) {
        return arguments.length ? ((t = typeof y == "function" ? y : Gn(y)), f) : t
      }),
      (f.subject = function (y) {
        return arguments.length ? ((e = typeof y == "function" ? y : Gn(y)), f) : e
      }),
      (f.touchable = function (y) {
        return arguments.length ? ((i = typeof y == "function" ? y : Gn(!!y)), f) : i
      }),
      (f.on = function () {
        var y = s.on.apply(s, arguments)
        return y === s ? f : y
      }),
      (f.clickDistance = function (y) {
        return arguments.length ? ((h = (y = +y) * y), f) : Math.sqrt(h)
      }),
      f
    )
  }
  function oa(r, t, e) {
    ;((r.prototype = t.prototype = e), (e.constructor = r))
  }
  function Ol(r, t) {
    var e = Object.create(r.prototype)
    for (var i in t) e[i] = t[i]
    return e
  }
  function Nn() {}
  var On = 0.7,
    la = 1 / On,
    Si = "\\s*([+-]?\\d+)\\s*",
    Ln = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    Pe = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    yw = /^#([0-9a-f]{3,8})$/,
    bw = new RegExp(`^rgb\\(${Si},${Si},${Si}\\)$`),
    vw = new RegExp(`^rgb\\(${Pe},${Pe},${Pe}\\)$`),
    Sw = new RegExp(`^rgba\\(${Si},${Si},${Si},${Ln}\\)$`),
    Tw = new RegExp(`^rgba\\(${Pe},${Pe},${Pe},${Ln}\\)$`),
    Cw = new RegExp(`^hsl\\(${Ln},${Pe},${Pe}\\)$`),
    Ew = new RegExp(`^hsla\\(${Ln},${Pe},${Pe},${Ln}\\)$`),
    jp = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074,
    }
  oa(Nn, mr, {
    copy(r) {
      return Object.assign(new this.constructor(), this, r)
    },
    displayable() {
      return this.rgb().displayable()
    },
    hex: Kp,
    formatHex: Kp,
    formatHex8: ww,
    formatHsl: Mw,
    formatRgb: qp,
    toString: qp,
  })
  function Kp() {
    return this.rgb().formatHex()
  }
  function ww() {
    return this.rgb().formatHex8()
  }
  function Mw() {
    return rm(this).formatHsl()
  }
  function qp() {
    return this.rgb().formatRgb()
  }
  function mr(r) {
    var t, e
    return (
      (r = (r + "").trim().toLowerCase()),
      (t = yw.exec(r))
        ? ((e = t[1].length),
          (t = parseInt(t[1], 16)),
          e === 6
            ? Zp(t)
            : e === 3
              ? new ne(
                  ((t >> 8) & 15) | ((t >> 4) & 240),
                  ((t >> 4) & 15) | (t & 240),
                  ((t & 15) << 4) | (t & 15),
                  1,
                )
              : e === 8
                ? aa((t >> 24) & 255, (t >> 16) & 255, (t >> 8) & 255, (t & 255) / 255)
                : e === 4
                  ? aa(
                      ((t >> 12) & 15) | ((t >> 8) & 240),
                      ((t >> 8) & 15) | ((t >> 4) & 240),
                      ((t >> 4) & 15) | (t & 240),
                      (((t & 15) << 4) | (t & 15)) / 255,
                    )
                  : null)
        : (t = bw.exec(r))
          ? new ne(t[1], t[2], t[3], 1)
          : (t = vw.exec(r))
            ? new ne((t[1] * 255) / 100, (t[2] * 255) / 100, (t[3] * 255) / 100, 1)
            : (t = Sw.exec(r))
              ? aa(t[1], t[2], t[3], t[4])
              : (t = Tw.exec(r))
                ? aa((t[1] * 255) / 100, (t[2] * 255) / 100, (t[3] * 255) / 100, t[4])
                : (t = Cw.exec(r))
                  ? tm(t[1], t[2] / 100, t[3] / 100, 1)
                  : (t = Ew.exec(r))
                    ? tm(t[1], t[2] / 100, t[3] / 100, t[4])
                    : jp.hasOwnProperty(r)
                      ? Zp(jp[r])
                      : r === "transparent"
                        ? new ne(NaN, NaN, NaN, 0)
                        : null
    )
  }
  function Zp(r) {
    return new ne((r >> 16) & 255, (r >> 8) & 255, r & 255, 1)
  }
  function aa(r, t, e, i) {
    return (i <= 0 && (r = t = e = NaN), new ne(r, t, e, i))
  }
  function Aw(r) {
    return (
      r instanceof Nn || (r = mr(r)),
      r ? ((r = r.rgb()), new ne(r.r, r.g, r.b, r.opacity)) : new ne()
    )
  }
  function Ti(r, t, e, i) {
    return arguments.length === 1 ? Aw(r) : new ne(r, t, e, i ?? 1)
  }
  function ne(r, t, e, i) {
    ;((this.r = +r), (this.g = +t), (this.b = +e), (this.opacity = +i))
  }
  oa(
    ne,
    Ti,
    Ol(Nn, {
      brighter(r) {
        return (
          (r = r == null ? la : Math.pow(la, r)),
          new ne(this.r * r, this.g * r, this.b * r, this.opacity)
        )
      },
      darker(r) {
        return (
          (r = r == null ? On : Math.pow(On, r)),
          new ne(this.r * r, this.g * r, this.b * r, this.opacity)
        )
      },
      rgb() {
        return this
      },
      clamp() {
        return new ne(Vr(this.r), Vr(this.g), Vr(this.b), ca(this.opacity))
      },
      displayable() {
        return (
          -0.5 <= this.r &&
          this.r < 255.5 &&
          -0.5 <= this.g &&
          this.g < 255.5 &&
          -0.5 <= this.b &&
          this.b < 255.5 &&
          0 <= this.opacity &&
          this.opacity <= 1
        )
      },
      hex: Qp,
      formatHex: Qp,
      formatHex8: Dw,
      formatRgb: Jp,
      toString: Jp,
    }),
  )
  function Qp() {
    return `#${Wr(this.r)}${Wr(this.g)}${Wr(this.b)}`
  }
  function Dw() {
    return `#${Wr(this.r)}${Wr(this.g)}${Wr(this.b)}${Wr((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`
  }
  function Jp() {
    let r = ca(this.opacity)
    return `${r === 1 ? "rgb(" : "rgba("}${Vr(this.r)}, ${Vr(this.g)}, ${Vr(this.b)}${r === 1 ? ")" : `, ${r})`}`
  }
  function ca(r) {
    return isNaN(r) ? 1 : Math.max(0, Math.min(1, r))
  }
  function Vr(r) {
    return Math.max(0, Math.min(255, Math.round(r) || 0))
  }
  function Wr(r) {
    return ((r = Vr(r)), (r < 16 ? "0" : "") + r.toString(16))
  }
  function tm(r, t, e, i) {
    return (
      i <= 0 ? (r = t = e = NaN) : e <= 0 || e >= 1 ? (r = t = NaN) : t <= 0 && (r = NaN),
      new ve(r, t, e, i)
    )
  }
  function rm(r) {
    if (r instanceof ve) return new ve(r.h, r.s, r.l, r.opacity)
    if ((r instanceof Nn || (r = mr(r)), !r)) return new ve()
    if (r instanceof ve) return r
    r = r.rgb()
    var t = r.r / 255,
      e = r.g / 255,
      i = r.b / 255,
      n = Math.min(t, e, i),
      s = Math.max(t, e, i),
      o = NaN,
      a = s - n,
      u = (s + n) / 2
    return (
      a
        ? (t === s
            ? (o = (e - i) / a + (e < i) * 6)
            : e === s
              ? (o = (i - t) / a + 2)
              : (o = (t - e) / a + 4),
          (a /= u < 0.5 ? s + n : 2 - s - n),
          (o *= 60))
        : (a = u > 0 && u < 1 ? 0 : o),
      new ve(o, a, u, r.opacity)
    )
  }
  function im(r, t, e, i) {
    return arguments.length === 1 ? rm(r) : new ve(r, t, e, i ?? 1)
  }
  function ve(r, t, e, i) {
    ;((this.h = +r), (this.s = +t), (this.l = +e), (this.opacity = +i))
  }
  oa(
    ve,
    im,
    Ol(Nn, {
      brighter(r) {
        return (
          (r = r == null ? la : Math.pow(la, r)),
          new ve(this.h, this.s, this.l * r, this.opacity)
        )
      },
      darker(r) {
        return (
          (r = r == null ? On : Math.pow(On, r)),
          new ve(this.h, this.s, this.l * r, this.opacity)
        )
      },
      rgb() {
        var r = (this.h % 360) + (this.h < 0) * 360,
          t = isNaN(r) || isNaN(this.s) ? 0 : this.s,
          e = this.l,
          i = e + (e < 0.5 ? e : 1 - e) * t,
          n = 2 * e - i
        return new ne(
          Ll(r >= 240 ? r - 240 : r + 120, n, i),
          Ll(r, n, i),
          Ll(r < 120 ? r + 240 : r - 120, n, i),
          this.opacity,
        )
      },
      clamp() {
        return new ve(em(this.h), ua(this.s), ua(this.l), ca(this.opacity))
      },
      displayable() {
        return (
          ((0 <= this.s && this.s <= 1) || isNaN(this.s)) &&
          0 <= this.l &&
          this.l <= 1 &&
          0 <= this.opacity &&
          this.opacity <= 1
        )
      },
      formatHsl() {
        let r = ca(this.opacity)
        return `${r === 1 ? "hsl(" : "hsla("}${em(this.h)}, ${ua(this.s) * 100}%, ${ua(this.l) * 100}%${r === 1 ? ")" : `, ${r})`}`
      },
    }),
  )
  function em(r) {
    return ((r = (r || 0) % 360), r < 0 ? r + 360 : r)
  }
  function ua(r) {
    return Math.max(0, Math.min(1, r || 0))
  }
  function Ll(r, t, e) {
    return (
      (r < 60
        ? t + ((e - t) * r) / 60
        : r < 180
          ? e
          : r < 240
            ? t + ((e - t) * (240 - r)) / 60
            : t) * 255
    )
  }
  function Nl(r, t, e, i, n) {
    var s = r * r,
      o = s * r
    return (
      ((1 - 3 * r + 3 * s - o) * t +
        (4 - 6 * s + 3 * o) * e +
        (1 + 3 * r + 3 * s - 3 * o) * i +
        o * n) /
      6
    )
  }
  function nm(r) {
    var t = r.length - 1
    return function (e) {
      var i = e <= 0 ? (e = 0) : e >= 1 ? ((e = 1), t - 1) : Math.floor(e * t),
        n = r[i],
        s = r[i + 1],
        o = i > 0 ? r[i - 1] : 2 * n - s,
        a = i < t - 1 ? r[i + 2] : 2 * s - n
      return Nl((e - i / t) * t, o, n, s, a)
    }
  }
  function sm(r) {
    var t = r.length
    return function (e) {
      var i = Math.floor(((e %= 1) < 0 ? ++e : e) * t),
        n = r[(i + t - 1) % t],
        s = r[i % t],
        o = r[(i + 1) % t],
        a = r[(i + 2) % t]
      return Nl((e - i / t) * t, n, s, o, a)
    }
  }
  var Hl = (r) => () => r
  function Pw(r, t) {
    return function (e) {
      return r + e * t
    }
  }
  function Fw(r, t, e) {
    return (
      (r = Math.pow(r, e)),
      (t = Math.pow(t, e) - r),
      (e = 1 / e),
      function (i) {
        return Math.pow(r + i * t, e)
      }
    )
  }
  function om(r) {
    return (r = +r) == 1
      ? ha
      : function (t, e) {
          return e - t ? Fw(t, e, r) : Hl(isNaN(t) ? e : t)
        }
  }
  function ha(r, t) {
    var e = t - r
    return e ? Pw(r, e) : Hl(isNaN(r) ? t : r)
  }
  var fa = (function r(t) {
    var e = om(t)
    function i(n, s) {
      var o = e((n = Ti(n)).r, (s = Ti(s)).r),
        a = e(n.g, s.g),
        u = e(n.b, s.b),
        l = ha(n.opacity, s.opacity)
      return function (c) {
        return ((n.r = o(c)), (n.g = a(c)), (n.b = u(c)), (n.opacity = l(c)), n + "")
      }
    }
    return ((i.gamma = r), i)
  })(1)
  function am(r) {
    return function (t) {
      var e = t.length,
        i = new Array(e),
        n = new Array(e),
        s = new Array(e),
        o,
        a
      for (o = 0; o < e; ++o)
        ((a = Ti(t[o])), (i[o] = a.r || 0), (n[o] = a.g || 0), (s[o] = a.b || 0))
      return (
        (i = r(i)),
        (n = r(n)),
        (s = r(s)),
        (a.opacity = 1),
        function (u) {
          return ((a.r = i(u)), (a.g = n(u)), (a.b = s(u)), a + "")
        }
      )
    }
  }
  var Rw = am(nm),
    Bw = am(sm)
  function ge(r, t) {
    return (
      (r = +r),
      (t = +t),
      function (e) {
        return r * (1 - e) + t * e
      }
    )
  }
  var Wl = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    zl = new RegExp(Wl.source, "g")
  function Iw(r) {
    return function () {
      return r
    }
  }
  function kw(r) {
    return function (t) {
      return r(t) + ""
    }
  }
  function Vl(r, t) {
    var e = (Wl.lastIndex = zl.lastIndex = 0),
      i,
      n,
      s,
      o = -1,
      a = [],
      u = []
    for (r = r + "", t = t + ""; (i = Wl.exec(r)) && (n = zl.exec(t)); )
      ((s = n.index) > e && ((s = t.slice(e, s)), a[o] ? (a[o] += s) : (a[++o] = s)),
        (i = i[0]) === (n = n[0])
          ? a[o]
            ? (a[o] += n)
            : (a[++o] = n)
          : ((a[++o] = null), u.push({ i: o, x: ge(i, n) })),
        (e = zl.lastIndex))
    return (
      e < t.length && ((s = t.slice(e)), a[o] ? (a[o] += s) : (a[++o] = s)),
      a.length < 2
        ? u[0]
          ? kw(u[0].x)
          : Iw(t)
        : ((t = u.length),
          function (l) {
            for (var c = 0, h; c < t; ++c) a[(h = u[c]).i] = h.x(l)
            return a.join("")
          })
    )
  }
  var um = 180 / Math.PI,
    da = { translateX: 0, translateY: 0, rotate: 0, skewX: 0, scaleX: 1, scaleY: 1 }
  function $l(r, t, e, i, n, s) {
    var o, a, u
    return (
      (o = Math.sqrt(r * r + t * t)) && ((r /= o), (t /= o)),
      (u = r * e + t * i) && ((e -= r * u), (i -= t * u)),
      (a = Math.sqrt(e * e + i * i)) && ((e /= a), (i /= a), (u /= a)),
      r * i < t * e && ((r = -r), (t = -t), (u = -u), (o = -o)),
      {
        translateX: n,
        translateY: s,
        rotate: Math.atan2(t, r) * um,
        skewX: Math.atan(u) * um,
        scaleX: o,
        scaleY: a,
      }
    )
  }
  var pa
  function lm(r) {
    let t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(r + "")
    return t.isIdentity ? da : $l(t.a, t.b, t.c, t.d, t.e, t.f)
  }
  function cm(r) {
    return r == null
      ? da
      : (pa || (pa = document.createElementNS("http://www.w3.org/2000/svg", "g")),
        pa.setAttribute("transform", r),
        (r = pa.transform.baseVal.consolidate())
          ? ((r = r.matrix), $l(r.a, r.b, r.c, r.d, r.e, r.f))
          : da)
  }
  function hm(r, t, e, i) {
    function n(l) {
      return l.length ? l.pop() + " " : ""
    }
    function s(l, c, h, f, d, g) {
      if (l !== h || c !== f) {
        var x = d.push("translate(", null, t, null, e)
        g.push({ i: x - 4, x: ge(l, h) }, { i: x - 2, x: ge(c, f) })
      } else (h || f) && d.push("translate(" + h + t + f + e)
    }
    function o(l, c, h, f) {
      l !== c
        ? (l - c > 180 ? (c += 360) : c - l > 180 && (l += 360),
          f.push({ i: h.push(n(h) + "rotate(", null, i) - 2, x: ge(l, c) }))
        : c && h.push(n(h) + "rotate(" + c + i)
    }
    function a(l, c, h, f) {
      l !== c
        ? f.push({ i: h.push(n(h) + "skewX(", null, i) - 2, x: ge(l, c) })
        : c && h.push(n(h) + "skewX(" + c + i)
    }
    function u(l, c, h, f, d, g) {
      if (l !== h || c !== f) {
        var x = d.push(n(d) + "scale(", null, ",", null, ")")
        g.push({ i: x - 4, x: ge(l, h) }, { i: x - 2, x: ge(c, f) })
      } else (h !== 1 || f !== 1) && d.push(n(d) + "scale(" + h + "," + f + ")")
    }
    return function (l, c) {
      var h = [],
        f = []
      return (
        (l = r(l)),
        (c = r(c)),
        s(l.translateX, l.translateY, c.translateX, c.translateY, h, f),
        o(l.rotate, c.rotate, h, f),
        a(l.skewX, c.skewX, h, f),
        u(l.scaleX, l.scaleY, c.scaleX, c.scaleY, h, f),
        (l = c = null),
        function (d) {
          for (var g = -1, x = f.length, m; ++g < x; ) h[(m = f[g]).i] = m.x(d)
          return h.join("")
        }
      )
    }
  }
  var Xl = hm(lm, "px, ", "px)", "deg)"),
    Yl = hm(cm, ", ", ")", ")")
  var Gw = 1e-12
  function fm(r) {
    return ((r = Math.exp(r)) + 1 / r) / 2
  }
  function Uw(r) {
    return ((r = Math.exp(r)) - 1 / r) / 2
  }
  function Ow(r) {
    return ((r = Math.exp(2 * r)) - 1) / (r + 1)
  }
  var jl = (function r(t, e, i) {
    function n(s, o) {
      var a = s[0],
        u = s[1],
        l = s[2],
        c = o[0],
        h = o[1],
        f = o[2],
        d = c - a,
        g = h - u,
        x = d * d + g * g,
        m,
        _
      if (x < Gw)
        ((_ = Math.log(f / l) / t),
          (m = function (E) {
            return [a + E * d, u + E * g, l * Math.exp(t * E * _)]
          }))
      else {
        var v = Math.sqrt(x),
          S = (f * f - l * l + i * x) / (2 * l * e * v),
          y = (f * f - l * l - i * x) / (2 * f * e * v),
          M = Math.log(Math.sqrt(S * S + 1) - S),
          T = Math.log(Math.sqrt(y * y + 1) - y)
        ;((_ = (T - M) / t),
          (m = function (E) {
            var G = E * _,
              B = fm(M),
              P = (l / (e * v)) * (B * Ow(t * G + M) - Uw(M))
            return [a + P * d, u + P * g, (l * B) / fm(t * G + M)]
          }))
      }
      return ((m.duration = (_ * 1e3 * t) / Math.SQRT2), m)
    }
    return (
      (n.rho = function (s) {
        var o = Math.max(0.001, +s),
          a = o * o,
          u = a * a
        return r(o, a, u)
      }),
      n
    )
  })(Math.SQRT2, 2, 4)
  var Ci = 0,
    zn = 0,
    Hn = 0,
    pm = 1e3,
    ma,
    Wn,
    ga = 0,
    $r = 0,
    xa = 0,
    Vn = typeof performance == "object" && performance.now ? performance : Date,
    mm =
      typeof window == "object" && window.requestAnimationFrame
        ? window.requestAnimationFrame.bind(window)
        : function (r) {
            setTimeout(r, 17)
          }
  function Xn() {
    return $r || (mm(Lw), ($r = Vn.now() + xa))
  }
  function Lw() {
    $r = 0
  }
  function $n() {
    this._call = this._time = this._next = null
  }
  $n.prototype = Ei.prototype = {
    constructor: $n,
    restart: function (r, t, e) {
      if (typeof r != "function") throw new TypeError("callback is not a function")
      ;((e = (e == null ? Xn() : +e) + (t == null ? 0 : +t)),
        !this._next && Wn !== this && (Wn ? (Wn._next = this) : (ma = this), (Wn = this)),
        (this._call = r),
        (this._time = e),
        Kl())
    },
    stop: function () {
      this._call && ((this._call = null), (this._time = 1 / 0), Kl())
    },
  }
  function Ei(r, t, e) {
    var i = new $n()
    return (i.restart(r, t, e), i)
  }
  function gm() {
    ;(Xn(), ++Ci)
    for (var r = ma, t; r; ) ((t = $r - r._time) >= 0 && r._call.call(void 0, t), (r = r._next))
    --Ci
  }
  function dm() {
    ;(($r = (ga = Vn.now()) + xa), (Ci = zn = 0))
    try {
      gm()
    } finally {
      ;((Ci = 0), Hw(), ($r = 0))
    }
  }
  function Nw() {
    var r = Vn.now(),
      t = r - ga
    t > pm && ((xa -= t), (ga = r))
  }
  function Hw() {
    for (var r, t = ma, e, i = 1 / 0; t; )
      t._call
        ? (i > t._time && (i = t._time), (r = t), (t = t._next))
        : ((e = t._next), (t._next = null), (t = r ? (r._next = e) : (ma = e)))
    ;((Wn = r), Kl(i))
  }
  function Kl(r) {
    if (!Ci) {
      zn && (zn = clearTimeout(zn))
      var t = r - $r
      t > 24
        ? (r < 1 / 0 && (zn = setTimeout(dm, r - Vn.now() - xa)), Hn && (Hn = clearInterval(Hn)))
        : (Hn || ((ga = Vn.now()), (Hn = setInterval(Nw, pm))), (Ci = 1), mm(dm))
    }
  }
  function _a(r, t, e) {
    var i = new $n()
    return (
      (t = t == null ? 0 : +t),
      i.restart(
        (n) => {
          ;(i.stop(), r(n + t))
        },
        t,
        e,
      ),
      i
    )
  }
  var zw = je("start", "end", "cancel", "interrupt"),
    Ww = [],
    ym = 0,
    xm = 1,
    ba = 2,
    ya = 3,
    _m = 4,
    va = 5,
    Yn = 6
  function gr(r, t, e, i, n, s) {
    var o = r.__transition
    if (!o) r.__transition = {}
    else if (e in o) return
    Vw(r, e, {
      name: t,
      index: i,
      group: n,
      on: zw,
      tween: Ww,
      time: s.time,
      delay: s.delay,
      duration: s.duration,
      ease: s.ease,
      timer: null,
      state: ym,
    })
  }
  function jn(r, t) {
    var e = kt(r, t)
    if (e.state > ym) throw new Error("too late; already scheduled")
    return e
  }
  function zt(r, t) {
    var e = kt(r, t)
    if (e.state > ya) throw new Error("too late; already running")
    return e
  }
  function kt(r, t) {
    var e = r.__transition
    if (!e || !(e = e[t])) throw new Error("transition not found")
    return e
  }
  function Vw(r, t, e) {
    var i = r.__transition,
      n
    ;((i[t] = e), (e.timer = Ei(s, 0, e.time)))
    function s(l) {
      ;((e.state = xm), e.timer.restart(o, e.delay, e.time), e.delay <= l && o(l - e.delay))
    }
    function o(l) {
      var c, h, f, d
      if (e.state !== xm) return u()
      for (c in i)
        if (((d = i[c]), d.name === e.name)) {
          if (d.state === ya) return _a(o)
          d.state === _m
            ? ((d.state = Yn),
              d.timer.stop(),
              d.on.call("interrupt", r, r.__data__, d.index, d.group),
              delete i[c])
            : +c < t &&
              ((d.state = Yn),
              d.timer.stop(),
              d.on.call("cancel", r, r.__data__, d.index, d.group),
              delete i[c])
        }
      if (
        (_a(function () {
          e.state === ya && ((e.state = _m), e.timer.restart(a, e.delay, e.time), a(l))
        }),
        (e.state = ba),
        e.on.call("start", r, r.__data__, e.index, e.group),
        e.state === ba)
      ) {
        for (e.state = ya, n = new Array((f = e.tween.length)), c = 0, h = -1; c < f; ++c)
          (d = e.tween[c].value.call(r, r.__data__, e.index, e.group)) && (n[++h] = d)
        n.length = h + 1
      }
    }
    function a(l) {
      for (
        var c =
            l < e.duration
              ? e.ease.call(null, l / e.duration)
              : (e.timer.restart(u), (e.state = va), 1),
          h = -1,
          f = n.length;
        ++h < f;

      )
        n[h].call(r, c)
      e.state === va && (e.on.call("end", r, r.__data__, e.index, e.group), u())
    }
    function u() {
      ;((e.state = Yn), e.timer.stop(), delete i[t])
      for (var l in i) return
      delete r.__transition
    }
  }
  function xr(r, t) {
    var e = r.__transition,
      i,
      n,
      s = !0,
      o
    if (e) {
      t = t == null ? null : t + ""
      for (o in e) {
        if ((i = e[o]).name !== t) {
          s = !1
          continue
        }
        ;((n = i.state > ba && i.state < va),
          (i.state = Yn),
          i.timer.stop(),
          i.on.call(n ? "interrupt" : "cancel", r, r.__data__, i.index, i.group),
          delete e[o])
      }
      s && delete r.__transition
    }
  }
  function bm(r) {
    return this.each(function () {
      xr(this, r)
    })
  }
  function $w(r, t) {
    var e, i
    return function () {
      var n = zt(this, r),
        s = n.tween
      if (s !== e) {
        i = e = s
        for (var o = 0, a = i.length; o < a; ++o)
          if (i[o].name === t) {
            ;((i = i.slice()), i.splice(o, 1))
            break
          }
      }
      n.tween = i
    }
  }
  function Xw(r, t, e) {
    var i, n
    if (typeof e != "function") throw new Error()
    return function () {
      var s = zt(this, r),
        o = s.tween
      if (o !== i) {
        n = (i = o).slice()
        for (var a = { name: t, value: e }, u = 0, l = n.length; u < l; ++u)
          if (n[u].name === t) {
            n[u] = a
            break
          }
        u === l && n.push(a)
      }
      s.tween = n
    }
  }
  function vm(r, t) {
    var e = this._id
    if (((r += ""), arguments.length < 2)) {
      for (var i = kt(this.node(), e).tween, n = 0, s = i.length, o; n < s; ++n)
        if ((o = i[n]).name === r) return o.value
      return null
    }
    return this.each((t == null ? $w : Xw)(e, r, t))
  }
  function wi(r, t, e) {
    var i = r._id
    return (
      r.each(function () {
        var n = zt(this, i)
        ;(n.value || (n.value = {}))[t] = e.apply(this, arguments)
      }),
      function (n) {
        return kt(n, i).value[t]
      }
    )
  }
  function Sa(r, t) {
    var e
    return (typeof t == "number" ? ge : t instanceof mr ? fa : (e = mr(t)) ? ((t = e), fa) : Vl)(
      r,
      t,
    )
  }
  function Yw(r) {
    return function () {
      this.removeAttribute(r)
    }
  }
  function jw(r) {
    return function () {
      this.removeAttributeNS(r.space, r.local)
    }
  }
  function Kw(r, t, e) {
    var i,
      n = e + "",
      s
    return function () {
      var o = this.getAttribute(r)
      return o === n ? null : o === i ? s : (s = t((i = o), e))
    }
  }
  function qw(r, t, e) {
    var i,
      n = e + "",
      s
    return function () {
      var o = this.getAttributeNS(r.space, r.local)
      return o === n ? null : o === i ? s : (s = t((i = o), e))
    }
  }
  function Zw(r, t, e) {
    var i, n, s
    return function () {
      var o,
        a = e(this),
        u
      return a == null
        ? void this.removeAttribute(r)
        : ((o = this.getAttribute(r)),
          (u = a + ""),
          o === u ? null : o === i && u === n ? s : ((n = u), (s = t((i = o), a))))
    }
  }
  function Qw(r, t, e) {
    var i, n, s
    return function () {
      var o,
        a = e(this),
        u
      return a == null
        ? void this.removeAttributeNS(r.space, r.local)
        : ((o = this.getAttributeNS(r.space, r.local)),
          (u = a + ""),
          o === u ? null : o === i && u === n ? s : ((n = u), (s = t((i = o), a))))
    }
  }
  function Sm(r, t) {
    var e = Ke(r),
      i = e === "transform" ? Yl : Sa
    return this.attrTween(
      r,
      typeof t == "function"
        ? (e.local ? Qw : Zw)(e, i, wi(this, "attr." + r, t))
        : t == null
          ? (e.local ? jw : Yw)(e)
          : (e.local ? qw : Kw)(e, i, t),
    )
  }
  function Jw(r, t) {
    return function (e) {
      this.setAttribute(r, t.call(this, e))
    }
  }
  function tM(r, t) {
    return function (e) {
      this.setAttributeNS(r.space, r.local, t.call(this, e))
    }
  }
  function eM(r, t) {
    var e, i
    function n() {
      var s = t.apply(this, arguments)
      return (s !== i && (e = (i = s) && tM(r, s)), e)
    }
    return ((n._value = t), n)
  }
  function rM(r, t) {
    var e, i
    function n() {
      var s = t.apply(this, arguments)
      return (s !== i && (e = (i = s) && Jw(r, s)), e)
    }
    return ((n._value = t), n)
  }
  function Tm(r, t) {
    var e = "attr." + r
    if (arguments.length < 2) return (e = this.tween(e)) && e._value
    if (t == null) return this.tween(e, null)
    if (typeof t != "function") throw new Error()
    var i = Ke(r)
    return this.tween(e, (i.local ? eM : rM)(i, t))
  }
  function iM(r, t) {
    return function () {
      jn(this, r).delay = +t.apply(this, arguments)
    }
  }
  function nM(r, t) {
    return (
      (t = +t),
      function () {
        jn(this, r).delay = t
      }
    )
  }
  function Cm(r) {
    var t = this._id
    return arguments.length
      ? this.each((typeof r == "function" ? iM : nM)(t, r))
      : kt(this.node(), t).delay
  }
  function sM(r, t) {
    return function () {
      zt(this, r).duration = +t.apply(this, arguments)
    }
  }
  function oM(r, t) {
    return (
      (t = +t),
      function () {
        zt(this, r).duration = t
      }
    )
  }
  function Em(r) {
    var t = this._id
    return arguments.length
      ? this.each((typeof r == "function" ? sM : oM)(t, r))
      : kt(this.node(), t).duration
  }
  function aM(r, t) {
    if (typeof t != "function") throw new Error()
    return function () {
      zt(this, r).ease = t
    }
  }
  function wm(r) {
    var t = this._id
    return arguments.length ? this.each(aM(t, r)) : kt(this.node(), t).ease
  }
  function uM(r, t) {
    return function () {
      var e = t.apply(this, arguments)
      if (typeof e != "function") throw new Error()
      zt(this, r).ease = e
    }
  }
  function Mm(r) {
    if (typeof r != "function") throw new Error()
    return this.each(uM(this._id, r))
  }
  function Am(r) {
    typeof r != "function" && (r = Rn(r))
    for (var t = this._groups, e = t.length, i = new Array(e), n = 0; n < e; ++n)
      for (var s = t[n], o = s.length, a = (i[n] = []), u, l = 0; l < o; ++l)
        (u = s[l]) && r.call(u, u.__data__, l, s) && a.push(u)
    return new Kt(i, this._parents, this._name, this._id)
  }
  function Dm(r) {
    if (r._id !== this._id) throw new Error()
    for (
      var t = this._groups,
        e = r._groups,
        i = t.length,
        n = e.length,
        s = Math.min(i, n),
        o = new Array(i),
        a = 0;
      a < s;
      ++a
    )
      for (var u = t[a], l = e[a], c = u.length, h = (o[a] = new Array(c)), f, d = 0; d < c; ++d)
        (f = u[d] || l[d]) && (h[d] = f)
    for (; a < i; ++a) o[a] = t[a]
    return new Kt(o, this._parents, this._name, this._id)
  }
  function lM(r) {
    return (r + "")
      .trim()
      .split(/^|\s+/)
      .every(function (t) {
        var e = t.indexOf(".")
        return (e >= 0 && (t = t.slice(0, e)), !t || t === "start")
      })
  }
  function cM(r, t, e) {
    var i,
      n,
      s = lM(t) ? jn : zt
    return function () {
      var o = s(this, r),
        a = o.on
      ;(a !== i && (n = (i = a).copy()).on(t, e), (o.on = n))
    }
  }
  function Pm(r, t) {
    var e = this._id
    return arguments.length < 2 ? kt(this.node(), e).on.on(r) : this.each(cM(e, r, t))
  }
  function hM(r) {
    return function () {
      var t = this.parentNode
      for (var e in this.__transition) if (+e !== r) return
      t && t.removeChild(this)
    }
  }
  function Fm() {
    return this.on("end.remove", hM(this._id))
  }
  function Rm(r) {
    var t = this._name,
      e = this._id
    typeof r != "function" && (r = Hr(r))
    for (var i = this._groups, n = i.length, s = new Array(n), o = 0; o < n; ++o)
      for (var a = i[o], u = a.length, l = (s[o] = new Array(u)), c, h, f = 0; f < u; ++f)
        (c = a[f]) &&
          (h = r.call(c, c.__data__, f, a)) &&
          ("__data__" in c && (h.__data__ = c.__data__), (l[f] = h), gr(l[f], t, e, f, l, kt(c, e)))
    return new Kt(s, this._parents, t, e)
  }
  function Bm(r) {
    var t = this._name,
      e = this._id
    typeof r != "function" && (r = Fn(r))
    for (var i = this._groups, n = i.length, s = [], o = [], a = 0; a < n; ++a)
      for (var u = i[a], l = u.length, c, h = 0; h < l; ++h)
        if ((c = u[h])) {
          for (
            var f = r.call(c, c.__data__, h, u), d, g = kt(c, e), x = 0, m = f.length;
            x < m;
            ++x
          )
            (d = f[x]) && gr(d, t, e, x, f, g)
          ;(s.push(f), o.push(c))
        }
    return new Kt(s, o, t, e)
  }
  var fM = qe.prototype.constructor
  function Im() {
    return new fM(this._groups, this._parents)
  }
  function dM(r, t) {
    var e, i, n
    return function () {
      var s = dr(this, r),
        o = (this.style.removeProperty(r), dr(this, r))
      return s === o ? null : s === e && o === i ? n : (n = t((e = s), (i = o)))
    }
  }
  function km(r) {
    return function () {
      this.style.removeProperty(r)
    }
  }
  function pM(r, t, e) {
    var i,
      n = e + "",
      s
    return function () {
      var o = dr(this, r)
      return o === n ? null : o === i ? s : (s = t((i = o), e))
    }
  }
  function mM(r, t, e) {
    var i, n, s
    return function () {
      var o = dr(this, r),
        a = e(this),
        u = a + ""
      return (
        a == null && (u = a = (this.style.removeProperty(r), dr(this, r))),
        o === u ? null : o === i && u === n ? s : ((n = u), (s = t((i = o), a)))
      )
    }
  }
  function gM(r, t) {
    var e,
      i,
      n,
      s = "style." + t,
      o = "end." + s,
      a
    return function () {
      var u = zt(this, r),
        l = u.on,
        c = u.value[s] == null ? a || (a = km(t)) : void 0
      ;((l !== e || n !== c) && (i = (e = l).copy()).on(o, (n = c)), (u.on = i))
    }
  }
  function Gm(r, t, e) {
    var i = (r += "") == "transform" ? Xl : Sa
    return t == null
      ? this.styleTween(r, dM(r, i)).on("end.style." + r, km(r))
      : typeof t == "function"
        ? this.styleTween(r, mM(r, i, wi(this, "style." + r, t))).each(gM(this._id, r))
        : this.styleTween(r, pM(r, i, t), e).on("end.style." + r, null)
  }
  function xM(r, t, e) {
    return function (i) {
      this.style.setProperty(r, t.call(this, i), e)
    }
  }
  function _M(r, t, e) {
    var i, n
    function s() {
      var o = t.apply(this, arguments)
      return (o !== n && (i = (n = o) && xM(r, o, e)), i)
    }
    return ((s._value = t), s)
  }
  function Um(r, t, e) {
    var i = "style." + (r += "")
    if (arguments.length < 2) return (i = this.tween(i)) && i._value
    if (t == null) return this.tween(i, null)
    if (typeof t != "function") throw new Error()
    return this.tween(i, _M(r, t, e ?? ""))
  }
  function yM(r) {
    return function () {
      this.textContent = r
    }
  }
  function bM(r) {
    return function () {
      var t = r(this)
      this.textContent = t ?? ""
    }
  }
  function Om(r) {
    return this.tween(
      "text",
      typeof r == "function" ? bM(wi(this, "text", r)) : yM(r == null ? "" : r + ""),
    )
  }
  function vM(r) {
    return function (t) {
      this.textContent = r.call(this, t)
    }
  }
  function SM(r) {
    var t, e
    function i() {
      var n = r.apply(this, arguments)
      return (n !== e && (t = (e = n) && vM(n)), t)
    }
    return ((i._value = r), i)
  }
  function Lm(r) {
    var t = "text"
    if (arguments.length < 1) return (t = this.tween(t)) && t._value
    if (r == null) return this.tween(t, null)
    if (typeof r != "function") throw new Error()
    return this.tween(t, SM(r))
  }
  function Nm() {
    for (
      var r = this._name, t = this._id, e = Ta(), i = this._groups, n = i.length, s = 0;
      s < n;
      ++s
    )
      for (var o = i[s], a = o.length, u, l = 0; l < a; ++l)
        if ((u = o[l])) {
          var c = kt(u, t)
          gr(u, r, e, l, o, {
            time: c.time + c.delay + c.duration,
            delay: 0,
            duration: c.duration,
            ease: c.ease,
          })
        }
    return new Kt(i, this._parents, r, e)
  }
  function Hm() {
    var r,
      t,
      e = this,
      i = e._id,
      n = e.size()
    return new Promise(function (s, o) {
      var a = { value: o },
        u = {
          value: function () {
            --n === 0 && s()
          },
        }
      ;(e.each(function () {
        var l = zt(this, i),
          c = l.on
        ;(c !== r &&
          ((t = (r = c).copy()), t._.cancel.push(a), t._.interrupt.push(a), t._.end.push(u)),
          (l.on = t))
      }),
        n === 0 && s())
    })
  }
  var TM = 0
  function Kt(r, t, e, i) {
    ;((this._groups = r), (this._parents = t), (this._name = e), (this._id = i))
  }
  function zm(r) {
    return qe().transition(r)
  }
  function Ta() {
    return ++TM
  }
  var Ze = qe.prototype
  Kt.prototype = zm.prototype = {
    constructor: Kt,
    select: Rm,
    selectAll: Bm,
    selectChild: Ze.selectChild,
    selectChildren: Ze.selectChildren,
    filter: Am,
    merge: Dm,
    selection: Im,
    transition: Nm,
    call: Ze.call,
    nodes: Ze.nodes,
    node: Ze.node,
    size: Ze.size,
    empty: Ze.empty,
    each: Ze.each,
    on: Pm,
    attr: Sm,
    attrTween: Tm,
    style: Gm,
    styleTween: Um,
    text: Om,
    textTween: Lm,
    remove: Fm,
    tween: vm,
    delay: Cm,
    duration: Em,
    ease: wm,
    easeVarying: Mm,
    end: Hm,
    [Symbol.iterator]: Ze[Symbol.iterator],
  }
  function Ca(r) {
    return ((r *= 2) <= 1 ? r * r * r : (r -= 2) * r * r + 2) / 2
  }
  var CM = { time: null, delay: 0, duration: 250, ease: Ca }
  function EM(r, t) {
    for (var e; !(e = r.__transition) || !(e = e[t]); )
      if (!(r = r.parentNode)) throw new Error(`transition ${t} not found`)
    return e
  }
  function Wm(r) {
    var t, e
    r instanceof Kt
      ? ((t = r._id), (r = r._name))
      : ((t = Ta()), ((e = CM).time = Xn()), (r = r == null ? null : r + ""))
    for (var i = this._groups, n = i.length, s = 0; s < n; ++s)
      for (var o = i[s], a = o.length, u, l = 0; l < a; ++l)
        (u = o[l]) && gr(u, r, t, l, o, e || EM(u, t))
    return new Kt(i, this._parents, r, t)
  }
  qe.prototype.interrupt = bm
  qe.prototype.transition = Wm
  var { abs: mG, max: gG, min: xG } = Math
  function Vm(r) {
    return [+r[0], +r[1]]
  }
  function wM(r) {
    return [Vm(r[0]), Vm(r[1])]
  }
  var _G = {
      name: "x",
      handles: ["w", "e"].map(ql),
      input: function (r, t) {
        return r == null
          ? null
          : [
              [+r[0], t[0][1]],
              [+r[1], t[1][1]],
            ]
      },
      output: function (r) {
        return r && [r[0][0], r[1][0]]
      },
    },
    yG = {
      name: "y",
      handles: ["n", "s"].map(ql),
      input: function (r, t) {
        return r == null
          ? null
          : [
              [t[0][0], +r[0]],
              [t[1][0], +r[1]],
            ]
      },
      output: function (r) {
        return r && [r[0][1], r[1][1]]
      },
    },
    bG = {
      name: "xy",
      handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(ql),
      input: function (r) {
        return r == null ? null : wM(r)
      },
      output: function (r) {
        return r
      },
    }
  function ql(r) {
    return { type: r }
  }
  function Zl(r, t) {
    var e,
      i = 1
    ;(r == null && (r = 0), t == null && (t = 0))
    function n() {
      var s,
        o = e.length,
        a,
        u = 0,
        l = 0
      for (s = 0; s < o; ++s) ((a = e[s]), (u += a.x), (l += a.y))
      for (u = (u / o - r) * i, l = (l / o - t) * i, s = 0; s < o; ++s)
        ((a = e[s]), (a.x -= u), (a.y -= l))
    }
    return (
      (n.initialize = function (s) {
        e = s
      }),
      (n.x = function (s) {
        return arguments.length ? ((r = +s), n) : r
      }),
      (n.y = function (s) {
        return arguments.length ? ((t = +s), n) : t
      }),
      (n.strength = function (s) {
        return arguments.length ? ((i = +s), n) : i
      }),
      n
    )
  }
  function $m(r) {
    let t = +this._x.call(null, r),
      e = +this._y.call(null, r)
    return Xm(this.cover(t, e), t, e, r)
  }
  function Xm(r, t, e, i) {
    if (isNaN(t) || isNaN(e)) return r
    var n,
      s = r._root,
      o = { data: i },
      a = r._x0,
      u = r._y0,
      l = r._x1,
      c = r._y1,
      h,
      f,
      d,
      g,
      x,
      m,
      _,
      v
    if (!s) return ((r._root = o), r)
    for (; s.length; )
      if (
        ((x = t >= (h = (a + l) / 2)) ? (a = h) : (l = h),
        (m = e >= (f = (u + c) / 2)) ? (u = f) : (c = f),
        (n = s),
        !(s = s[(_ = (m << 1) | x)]))
      )
        return ((n[_] = o), r)
    if (((d = +r._x.call(null, s.data)), (g = +r._y.call(null, s.data)), t === d && e === g))
      return ((o.next = s), n ? (n[_] = o) : (r._root = o), r)
    do
      ((n = n ? (n[_] = new Array(4)) : (r._root = new Array(4))),
        (x = t >= (h = (a + l) / 2)) ? (a = h) : (l = h),
        (m = e >= (f = (u + c) / 2)) ? (u = f) : (c = f))
    while ((_ = (m << 1) | x) === (v = ((g >= f) << 1) | (d >= h)))
    return ((n[v] = s), (n[_] = o), r)
  }
  function Ym(r) {
    var t,
      e,
      i = r.length,
      n,
      s,
      o = new Array(i),
      a = new Array(i),
      u = 1 / 0,
      l = 1 / 0,
      c = -1 / 0,
      h = -1 / 0
    for (e = 0; e < i; ++e)
      isNaN((n = +this._x.call(null, (t = r[e])))) ||
        isNaN((s = +this._y.call(null, t))) ||
        ((o[e] = n),
        (a[e] = s),
        n < u && (u = n),
        n > c && (c = n),
        s < l && (l = s),
        s > h && (h = s))
    if (u > c || l > h) return this
    for (this.cover(u, l).cover(c, h), e = 0; e < i; ++e) Xm(this, o[e], a[e], r[e])
    return this
  }
  function jm(r, t) {
    if (isNaN((r = +r)) || isNaN((t = +t))) return this
    var e = this._x0,
      i = this._y0,
      n = this._x1,
      s = this._y1
    if (isNaN(e)) ((n = (e = Math.floor(r)) + 1), (s = (i = Math.floor(t)) + 1))
    else {
      for (var o = n - e || 1, a = this._root, u, l; e > r || r >= n || i > t || t >= s; )
        switch (
          ((l = ((t < i) << 1) | (r < e)), (u = new Array(4)), (u[l] = a), (a = u), (o *= 2), l)
        ) {
          case 0:
            ;((n = e + o), (s = i + o))
            break
          case 1:
            ;((e = n - o), (s = i + o))
            break
          case 2:
            ;((n = e + o), (i = s - o))
            break
          case 3:
            ;((e = n - o), (i = s - o))
            break
        }
      this._root && this._root.length && (this._root = a)
    }
    return ((this._x0 = e), (this._y0 = i), (this._x1 = n), (this._y1 = s), this)
  }
  function Km() {
    var r = []
    return (
      this.visit(function (t) {
        if (!t.length)
          do r.push(t.data)
          while ((t = t.next))
      }),
      r
    )
  }
  function qm(r) {
    return arguments.length
      ? this.cover(+r[0][0], +r[0][1]).cover(+r[1][0], +r[1][1])
      : isNaN(this._x0)
        ? void 0
        : [
            [this._x0, this._y0],
            [this._x1, this._y1],
          ]
  }
  function Gt(r, t, e, i, n) {
    ;((this.node = r), (this.x0 = t), (this.y0 = e), (this.x1 = i), (this.y1 = n))
  }
  function Zm(r, t, e) {
    var i,
      n = this._x0,
      s = this._y0,
      o,
      a,
      u,
      l,
      c = this._x1,
      h = this._y1,
      f = [],
      d = this._root,
      g,
      x
    for (
      d && f.push(new Gt(d, n, s, c, h)),
        e == null ? (e = 1 / 0) : ((n = r - e), (s = t - e), (c = r + e), (h = t + e), (e *= e));
      (g = f.pop());

    )
      if (!(!(d = g.node) || (o = g.x0) > c || (a = g.y0) > h || (u = g.x1) < n || (l = g.y1) < s))
        if (d.length) {
          var m = (o + u) / 2,
            _ = (a + l) / 2
          ;(f.push(
            new Gt(d[3], m, _, u, l),
            new Gt(d[2], o, _, m, l),
            new Gt(d[1], m, a, u, _),
            new Gt(d[0], o, a, m, _),
          ),
            (x = ((t >= _) << 1) | (r >= m)) &&
              ((g = f[f.length - 1]),
              (f[f.length - 1] = f[f.length - 1 - x]),
              (f[f.length - 1 - x] = g)))
        } else {
          var v = r - +this._x.call(null, d.data),
            S = t - +this._y.call(null, d.data),
            y = v * v + S * S
          if (y < e) {
            var M = Math.sqrt((e = y))
            ;((n = r - M), (s = t - M), (c = r + M), (h = t + M), (i = d.data))
          }
        }
    return i
  }
  function Qm(r) {
    if (isNaN((c = +this._x.call(null, r))) || isNaN((h = +this._y.call(null, r)))) return this
    var t,
      e = this._root,
      i,
      n,
      s,
      o = this._x0,
      a = this._y0,
      u = this._x1,
      l = this._y1,
      c,
      h,
      f,
      d,
      g,
      x,
      m,
      _
    if (!e) return this
    if (e.length)
      for (;;) {
        if (
          ((g = c >= (f = (o + u) / 2)) ? (o = f) : (u = f),
          (x = h >= (d = (a + l) / 2)) ? (a = d) : (l = d),
          (t = e),
          !(e = e[(m = (x << 1) | g)]))
        )
          return this
        if (!e.length) break
        ;(t[(m + 1) & 3] || t[(m + 2) & 3] || t[(m + 3) & 3]) && ((i = t), (_ = m))
      }
    for (; e.data !== r; ) if (((n = e), !(e = e.next))) return this
    return (
      (s = e.next) && delete e.next,
      n
        ? (s ? (n.next = s) : delete n.next, this)
        : t
          ? (s ? (t[m] = s) : delete t[m],
            (e = t[0] || t[1] || t[2] || t[3]) &&
              e === (t[3] || t[2] || t[1] || t[0]) &&
              !e.length &&
              (i ? (i[_] = e) : (this._root = e)),
            this)
          : ((this._root = s), this)
    )
  }
  function Jm(r) {
    for (var t = 0, e = r.length; t < e; ++t) this.remove(r[t])
    return this
  }
  function tg() {
    return this._root
  }
  function eg() {
    var r = 0
    return (
      this.visit(function (t) {
        if (!t.length)
          do ++r
          while ((t = t.next))
      }),
      r
    )
  }
  function rg(r) {
    var t = [],
      e,
      i = this._root,
      n,
      s,
      o,
      a,
      u
    for (i && t.push(new Gt(i, this._x0, this._y0, this._x1, this._y1)); (e = t.pop()); )
      if (!r((i = e.node), (s = e.x0), (o = e.y0), (a = e.x1), (u = e.y1)) && i.length) {
        var l = (s + a) / 2,
          c = (o + u) / 2
        ;((n = i[3]) && t.push(new Gt(n, l, c, a, u)),
          (n = i[2]) && t.push(new Gt(n, s, c, l, u)),
          (n = i[1]) && t.push(new Gt(n, l, o, a, c)),
          (n = i[0]) && t.push(new Gt(n, s, o, l, c)))
      }
    return this
  }
  function ig(r) {
    var t = [],
      e = [],
      i
    for (
      this._root && t.push(new Gt(this._root, this._x0, this._y0, this._x1, this._y1));
      (i = t.pop());

    ) {
      var n = i.node
      if (n.length) {
        var s,
          o = i.x0,
          a = i.y0,
          u = i.x1,
          l = i.y1,
          c = (o + u) / 2,
          h = (a + l) / 2
        ;((s = n[0]) && t.push(new Gt(s, o, a, c, h)),
          (s = n[1]) && t.push(new Gt(s, c, a, u, h)),
          (s = n[2]) && t.push(new Gt(s, o, h, c, l)),
          (s = n[3]) && t.push(new Gt(s, c, h, u, l)))
      }
      e.push(i)
    }
    for (; (i = e.pop()); ) r(i.node, i.x0, i.y0, i.x1, i.y1)
    return this
  }
  function ng(r) {
    return r[0]
  }
  function sg(r) {
    return arguments.length ? ((this._x = r), this) : this._x
  }
  function og(r) {
    return r[1]
  }
  function ag(r) {
    return arguments.length ? ((this._y = r), this) : this._y
  }
  function Xr(r, t, e) {
    var i = new Ql(t ?? ng, e ?? og, NaN, NaN, NaN, NaN)
    return r == null ? i : i.addAll(r)
  }
  function Ql(r, t, e, i, n, s) {
    ;((this._x = r),
      (this._y = t),
      (this._x0 = e),
      (this._y0 = i),
      (this._x1 = n),
      (this._y1 = s),
      (this._root = void 0))
  }
  function ug(r) {
    for (var t = { data: r.data }, e = t; (r = r.next); ) e = e.next = { data: r.data }
    return t
  }
  var qt = (Xr.prototype = Ql.prototype)
  qt.copy = function () {
    var r = new Ql(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      t = this._root,
      e,
      i
    if (!t) return r
    if (!t.length) return ((r._root = ug(t)), r)
    for (e = [{ source: t, target: (r._root = new Array(4)) }]; (t = e.pop()); )
      for (var n = 0; n < 4; ++n)
        (i = t.source[n]) &&
          (i.length
            ? e.push({ source: i, target: (t.target[n] = new Array(4)) })
            : (t.target[n] = ug(i)))
    return r
  }
  qt.add = $m
  qt.addAll = Ym
  qt.cover = jm
  qt.data = Km
  qt.extent = qm
  qt.find = Zm
  qt.remove = Qm
  qt.removeAll = Jm
  qt.root = tg
  qt.size = eg
  qt.visit = rg
  qt.visitAfter = ig
  qt.x = sg
  qt.y = ag
  function Zt(r) {
    return function () {
      return r
    }
  }
  function Se(r) {
    return (r() - 0.5) * 1e-6
  }
  function MM(r) {
    return r.x + r.vx
  }
  function AM(r) {
    return r.y + r.vy
  }
  function Jl(r) {
    var t,
      e,
      i,
      n = 1,
      s = 1
    typeof r != "function" && (r = Zt(r == null ? 1 : +r))
    function o() {
      for (var l, c = t.length, h, f, d, g, x, m, _ = 0; _ < s; ++_)
        for (h = Xr(t, MM, AM).visitAfter(a), l = 0; l < c; ++l)
          ((f = t[l]),
            (x = e[f.index]),
            (m = x * x),
            (d = f.x + f.vx),
            (g = f.y + f.vy),
            h.visit(v))
      function v(S, y, M, T, E) {
        var G = S.data,
          B = S.r,
          P = x + B
        if (G) {
          if (G.index > f.index) {
            var F = d - G.x - G.vx,
              W = g - G.y - G.vy,
              j = F * F + W * W
            j < P * P &&
              (F === 0 && ((F = Se(i)), (j += F * F)),
              W === 0 && ((W = Se(i)), (j += W * W)),
              (j = ((P - (j = Math.sqrt(j))) / j) * n),
              (f.vx += (F *= j) * (P = (B *= B) / (m + B))),
              (f.vy += (W *= j) * P),
              (G.vx -= F * (P = 1 - P)),
              (G.vy -= W * P))
          }
          return
        }
        return y > d + P || T < d - P || M > g + P || E < g - P
      }
    }
    function a(l) {
      if (l.data) return (l.r = e[l.data.index])
      for (var c = (l.r = 0); c < 4; ++c) l[c] && l[c].r > l.r && (l.r = l[c].r)
    }
    function u() {
      if (t) {
        var l,
          c = t.length,
          h
        for (e = new Array(c), l = 0; l < c; ++l) ((h = t[l]), (e[h.index] = +r(h, l, t)))
      }
    }
    return (
      (o.initialize = function (l, c) {
        ;((t = l), (i = c), u())
      }),
      (o.iterations = function (l) {
        return arguments.length ? ((s = +l), o) : s
      }),
      (o.strength = function (l) {
        return arguments.length ? ((n = +l), o) : n
      }),
      (o.radius = function (l) {
        return arguments.length ? ((r = typeof l == "function" ? l : Zt(+l)), u(), o) : r
      }),
      o
    )
  }
  function DM(r) {
    return r.index
  }
  function lg(r, t) {
    var e = r.get(t)
    if (!e) throw new Error("node not found: " + t)
    return e
  }
  function tc(r) {
    var t = DM,
      e = h,
      i,
      n = Zt(30),
      s,
      o,
      a,
      u,
      l,
      c = 1
    r == null && (r = [])
    function h(m) {
      return 1 / Math.min(a[m.source.index], a[m.target.index])
    }
    function f(m) {
      for (var _ = 0, v = r.length; _ < c; ++_)
        for (var S = 0, y, M, T, E, G, B, P; S < v; ++S)
          ((y = r[S]),
            (M = y.source),
            (T = y.target),
            (E = T.x + T.vx - M.x - M.vx || Se(l)),
            (G = T.y + T.vy - M.y - M.vy || Se(l)),
            (B = Math.sqrt(E * E + G * G)),
            (B = ((B - s[S]) / B) * m * i[S]),
            (E *= B),
            (G *= B),
            (T.vx -= E * (P = u[S])),
            (T.vy -= G * P),
            (M.vx += E * (P = 1 - P)),
            (M.vy += G * P))
    }
    function d() {
      if (o) {
        var m,
          _ = o.length,
          v = r.length,
          S = new Map(o.map((M, T) => [t(M, T, o), M])),
          y
        for (m = 0, a = new Array(_); m < v; ++m)
          ((y = r[m]),
            (y.index = m),
            typeof y.source != "object" && (y.source = lg(S, y.source)),
            typeof y.target != "object" && (y.target = lg(S, y.target)),
            (a[y.source.index] = (a[y.source.index] || 0) + 1),
            (a[y.target.index] = (a[y.target.index] || 0) + 1))
        for (m = 0, u = new Array(v); m < v; ++m)
          ((y = r[m]), (u[m] = a[y.source.index] / (a[y.source.index] + a[y.target.index])))
        ;((i = new Array(v)), g(), (s = new Array(v)), x())
      }
    }
    function g() {
      if (o) for (var m = 0, _ = r.length; m < _; ++m) i[m] = +e(r[m], m, r)
    }
    function x() {
      if (o) for (var m = 0, _ = r.length; m < _; ++m) s[m] = +n(r[m], m, r)
    }
    return (
      (f.initialize = function (m, _) {
        ;((o = m), (l = _), d())
      }),
      (f.links = function (m) {
        return arguments.length ? ((r = m), d(), f) : r
      }),
      (f.id = function (m) {
        return arguments.length ? ((t = m), f) : t
      }),
      (f.iterations = function (m) {
        return arguments.length ? ((c = +m), f) : c
      }),
      (f.strength = function (m) {
        return arguments.length ? ((e = typeof m == "function" ? m : Zt(+m)), g(), f) : e
      }),
      (f.distance = function (m) {
        return arguments.length ? ((n = typeof m == "function" ? m : Zt(+m)), x(), f) : n
      }),
      f
    )
  }
  function cg() {
    let r = 1
    return () => (r = (1664525 * r + 1013904223) % 4294967296) / 4294967296
  }
  function hg(r) {
    return r.x
  }
  function fg(r) {
    return r.y
  }
  var PM = 10,
    FM = Math.PI * (3 - Math.sqrt(5))
  function ec(r) {
    var t,
      e = 1,
      i = 0.001,
      n = 1 - Math.pow(i, 1 / 300),
      s = 0,
      o = 0.6,
      a = new Map(),
      u = Ei(h),
      l = je("tick", "end"),
      c = cg()
    r == null && (r = [])
    function h() {
      ;(f(), l.call("tick", t), e < i && (u.stop(), l.call("end", t)))
    }
    function f(x) {
      var m,
        _ = r.length,
        v
      x === void 0 && (x = 1)
      for (var S = 0; S < x; ++S)
        for (
          e += (s - e) * n,
            a.forEach(function (y) {
              y(e)
            }),
            m = 0;
          m < _;
          ++m
        )
          ((v = r[m]),
            v.fx == null ? (v.x += v.vx *= o) : ((v.x = v.fx), (v.vx = 0)),
            v.fy == null ? (v.y += v.vy *= o) : ((v.y = v.fy), (v.vy = 0)))
      return t
    }
    function d() {
      for (var x = 0, m = r.length, _; x < m; ++x) {
        if (
          ((_ = r[x]),
          (_.index = x),
          _.fx != null && (_.x = _.fx),
          _.fy != null && (_.y = _.fy),
          isNaN(_.x) || isNaN(_.y))
        ) {
          var v = PM * Math.sqrt(0.5 + x),
            S = x * FM
          ;((_.x = v * Math.cos(S)), (_.y = v * Math.sin(S)))
        }
        ;(isNaN(_.vx) || isNaN(_.vy)) && (_.vx = _.vy = 0)
      }
    }
    function g(x) {
      return (x.initialize && x.initialize(r, c), x)
    }
    return (
      d(),
      (t = {
        tick: f,
        restart: function () {
          return (u.restart(h), t)
        },
        stop: function () {
          return (u.stop(), t)
        },
        nodes: function (x) {
          return arguments.length ? ((r = x), d(), a.forEach(g), t) : r
        },
        alpha: function (x) {
          return arguments.length ? ((e = +x), t) : e
        },
        alphaMin: function (x) {
          return arguments.length ? ((i = +x), t) : i
        },
        alphaDecay: function (x) {
          return arguments.length ? ((n = +x), t) : +n
        },
        alphaTarget: function (x) {
          return arguments.length ? ((s = +x), t) : s
        },
        velocityDecay: function (x) {
          return arguments.length ? ((o = 1 - x), t) : 1 - o
        },
        randomSource: function (x) {
          return arguments.length ? ((c = x), a.forEach(g), t) : c
        },
        force: function (x, m) {
          return arguments.length > 1 ? (m == null ? a.delete(x) : a.set(x, g(m)), t) : a.get(x)
        },
        find: function (x, m, _) {
          var v = 0,
            S = r.length,
            y,
            M,
            T,
            E,
            G
          for (_ == null ? (_ = 1 / 0) : (_ *= _), v = 0; v < S; ++v)
            ((E = r[v]),
              (y = x - E.x),
              (M = m - E.y),
              (T = y * y + M * M),
              T < _ && ((G = E), (_ = T)))
          return G
        },
        on: function (x, m) {
          return arguments.length > 1 ? (l.on(x, m), t) : l.on(x)
        },
      })
    )
  }
  function rc() {
    var r,
      t,
      e,
      i,
      n = Zt(-30),
      s,
      o = 1,
      a = 1 / 0,
      u = 0.81
    function l(d) {
      var g,
        x = r.length,
        m = Xr(r, hg, fg).visitAfter(h)
      for (i = d, g = 0; g < x; ++g) ((t = r[g]), m.visit(f))
    }
    function c() {
      if (r) {
        var d,
          g = r.length,
          x
        for (s = new Array(g), d = 0; d < g; ++d) ((x = r[d]), (s[x.index] = +n(x, d, r)))
      }
    }
    function h(d) {
      var g = 0,
        x,
        m,
        _ = 0,
        v,
        S,
        y
      if (d.length) {
        for (v = S = y = 0; y < 4; ++y)
          (x = d[y]) &&
            (m = Math.abs(x.value)) &&
            ((g += x.value), (_ += m), (v += m * x.x), (S += m * x.y))
        ;((d.x = v / _), (d.y = S / _))
      } else {
        ;((x = d), (x.x = x.data.x), (x.y = x.data.y))
        do g += s[x.data.index]
        while ((x = x.next))
      }
      d.value = g
    }
    function f(d, g, x, m) {
      if (!d.value) return !0
      var _ = d.x - t.x,
        v = d.y - t.y,
        S = m - g,
        y = _ * _ + v * v
      if ((S * S) / u < y)
        return (
          y < a &&
            (_ === 0 && ((_ = Se(e)), (y += _ * _)),
            v === 0 && ((v = Se(e)), (y += v * v)),
            y < o && (y = Math.sqrt(o * y)),
            (t.vx += (_ * d.value * i) / y),
            (t.vy += (v * d.value * i) / y)),
          !0
        )
      if (d.length || y >= a) return
      ;(d.data !== t || d.next) &&
        (_ === 0 && ((_ = Se(e)), (y += _ * _)),
        v === 0 && ((v = Se(e)), (y += v * v)),
        y < o && (y = Math.sqrt(o * y)))
      do d.data !== t && ((S = (s[d.data.index] * i) / y), (t.vx += _ * S), (t.vy += v * S))
      while ((d = d.next))
    }
    return (
      (l.initialize = function (d, g) {
        ;((r = d), (e = g), c())
      }),
      (l.strength = function (d) {
        return arguments.length ? ((n = typeof d == "function" ? d : Zt(+d)), c(), l) : n
      }),
      (l.distanceMin = function (d) {
        return arguments.length ? ((o = d * d), l) : Math.sqrt(o)
      }),
      (l.distanceMax = function (d) {
        return arguments.length ? ((a = d * d), l) : Math.sqrt(a)
      }),
      (l.theta = function (d) {
        return arguments.length ? ((u = d * d), l) : Math.sqrt(u)
      }),
      l
    )
  }
  function ic(r, t, e) {
    var i,
      n = Zt(0.1),
      s,
      o
    ;(typeof r != "function" && (r = Zt(+r)), t == null && (t = 0), e == null && (e = 0))
    function a(l) {
      for (var c = 0, h = i.length; c < h; ++c) {
        var f = i[c],
          d = f.x - t || 1e-6,
          g = f.y - e || 1e-6,
          x = Math.sqrt(d * d + g * g),
          m = ((o[c] - x) * s[c] * l) / x
        ;((f.vx += d * m), (f.vy += g * m))
      }
    }
    function u() {
      if (i) {
        var l,
          c = i.length
        for (s = new Array(c), o = new Array(c), l = 0; l < c; ++l)
          ((o[l] = +r(i[l], l, i)), (s[l] = isNaN(o[l]) ? 0 : +n(i[l], l, i)))
      }
    }
    return (
      (a.initialize = function (l) {
        ;((i = l), u())
      }),
      (a.strength = function (l) {
        return arguments.length ? ((n = typeof l == "function" ? l : Zt(+l)), u(), a) : n
      }),
      (a.radius = function (l) {
        return arguments.length ? ((r = typeof l == "function" ? l : Zt(+l)), u(), a) : r
      }),
      (a.x = function (l) {
        return arguments.length ? ((t = +l), a) : t
      }),
      (a.y = function (l) {
        return arguments.length ? ((e = +l), a) : e
      }),
      a
    )
  }
  var Kn = (r) => () => r
  function nc(r, { sourceEvent: t, target: e, transform: i, dispatch: n }) {
    Object.defineProperties(this, {
      type: { value: r, enumerable: !0, configurable: !0 },
      sourceEvent: { value: t, enumerable: !0, configurable: !0 },
      target: { value: e, enumerable: !0, configurable: !0 },
      transform: { value: i, enumerable: !0, configurable: !0 },
      _: { value: n },
    })
  }
  function Te(r, t, e) {
    ;((this.k = r), (this.x = t), (this.y = e))
  }
  Te.prototype = {
    constructor: Te,
    scale: function (r) {
      return r === 1 ? this : new Te(this.k * r, this.x, this.y)
    },
    translate: function (r, t) {
      return (r === 0) & (t === 0) ? this : new Te(this.k, this.x + this.k * r, this.y + this.k * t)
    },
    apply: function (r) {
      return [r[0] * this.k + this.x, r[1] * this.k + this.y]
    },
    applyX: function (r) {
      return r * this.k + this.x
    },
    applyY: function (r) {
      return r * this.k + this.y
    },
    invert: function (r) {
      return [(r[0] - this.x) / this.k, (r[1] - this.y) / this.k]
    },
    invertX: function (r) {
      return (r - this.x) / this.k
    },
    invertY: function (r) {
      return (r - this.y) / this.k
    },
    rescaleX: function (r) {
      return r.copy().domain(r.range().map(this.invertX, this).map(r.invert, r))
    },
    rescaleY: function (r) {
      return r.copy().domain(r.range().map(this.invertY, this).map(r.invert, r))
    },
    toString: function () {
      return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")"
    },
  }
  var Yr = new Te(1, 0, 0)
  sc.prototype = Te.prototype
  function sc(r) {
    for (; !r.__zoom; ) if (!(r = r.parentNode)) return Yr
    return r.__zoom
  }
  function Ea(r) {
    r.stopImmediatePropagation()
  }
  function Mi(r) {
    ;(r.preventDefault(), r.stopImmediatePropagation())
  }
  function RM(r) {
    return (!r.ctrlKey || r.type === "wheel") && !r.button
  }
  function BM() {
    var r = this
    return r instanceof SVGElement
      ? ((r = r.ownerSVGElement || r),
        r.hasAttribute("viewBox")
          ? ((r = r.viewBox.baseVal),
            [
              [r.x, r.y],
              [r.x + r.width, r.y + r.height],
            ])
          : [
              [0, 0],
              [r.width.baseVal.value, r.height.baseVal.value],
            ])
      : [
          [0, 0],
          [r.clientWidth, r.clientHeight],
        ]
  }
  function dg() {
    return this.__zoom || Yr
  }
  function IM(r) {
    return -r.deltaY * (r.deltaMode === 1 ? 0.05 : r.deltaMode ? 1 : 0.002) * (r.ctrlKey ? 10 : 1)
  }
  function kM() {
    return navigator.maxTouchPoints || "ontouchstart" in this
  }
  function GM(r, t, e) {
    var i = r.invertX(t[0][0]) - e[0][0],
      n = r.invertX(t[1][0]) - e[1][0],
      s = r.invertY(t[0][1]) - e[0][1],
      o = r.invertY(t[1][1]) - e[1][1]
    return r.translate(
      n > i ? (i + n) / 2 : Math.min(0, i) || Math.max(0, n),
      o > s ? (s + o) / 2 : Math.min(0, s) || Math.max(0, o),
    )
  }
  function oc() {
    var r = RM,
      t = BM,
      e = GM,
      i = IM,
      n = kM,
      s = [0, 1 / 0],
      o = [
        [-1 / 0, -1 / 0],
        [1 / 0, 1 / 0],
      ],
      a = 250,
      u = jl,
      l = je("start", "zoom", "end"),
      c,
      h,
      f,
      d = 500,
      g = 150,
      x = 0,
      m = 10
    function _(C) {
      C.property("__zoom", dg)
        .on("wheel.zoom", G, { passive: !1 })
        .on("mousedown.zoom", B)
        .on("dblclick.zoom", P)
        .filter(n)
        .on("touchstart.zoom", F)
        .on("touchmove.zoom", W)
        .on("touchend.zoom touchcancel.zoom", j)
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)")
    }
    ;((_.transform = function (C, H, w, D) {
      var Y = C.selection ? C.selection() : C
      ;(Y.property("__zoom", dg),
        C !== Y
          ? M(C, H, w, D)
          : Y.interrupt().each(function () {
              T(this, arguments)
                .event(D)
                .start()
                .zoom(null, typeof H == "function" ? H.apply(this, arguments) : H)
                .end()
            }))
    }),
      (_.scaleBy = function (C, H, w, D) {
        _.scaleTo(
          C,
          function () {
            var Y = this.__zoom.k,
              O = typeof H == "function" ? H.apply(this, arguments) : H
            return Y * O
          },
          w,
          D,
        )
      }),
      (_.scaleTo = function (C, H, w, D) {
        _.transform(
          C,
          function () {
            var Y = t.apply(this, arguments),
              O = this.__zoom,
              X = w == null ? y(Y) : typeof w == "function" ? w.apply(this, arguments) : w,
              it = O.invert(X),
              ut = typeof H == "function" ? H.apply(this, arguments) : H
            return e(S(v(O, ut), X, it), Y, o)
          },
          w,
          D,
        )
      }),
      (_.translateBy = function (C, H, w, D) {
        _.transform(
          C,
          function () {
            return e(
              this.__zoom.translate(
                typeof H == "function" ? H.apply(this, arguments) : H,
                typeof w == "function" ? w.apply(this, arguments) : w,
              ),
              t.apply(this, arguments),
              o,
            )
          },
          null,
          D,
        )
      }),
      (_.translateTo = function (C, H, w, D, Y) {
        _.transform(
          C,
          function () {
            var O = t.apply(this, arguments),
              X = this.__zoom,
              it = D == null ? y(O) : typeof D == "function" ? D.apply(this, arguments) : D
            return e(
              Yr.translate(it[0], it[1])
                .scale(X.k)
                .translate(
                  typeof H == "function" ? -H.apply(this, arguments) : -H,
                  typeof w == "function" ? -w.apply(this, arguments) : -w,
                ),
              O,
              o,
            )
          },
          D,
          Y,
        )
      }))
    function v(C, H) {
      return ((H = Math.max(s[0], Math.min(s[1], H))), H === C.k ? C : new Te(H, C.x, C.y))
    }
    function S(C, H, w) {
      var D = H[0] - w[0] * C.k,
        Y = H[1] - w[1] * C.k
      return D === C.x && Y === C.y ? C : new Te(C.k, D, Y)
    }
    function y(C) {
      return [(+C[0][0] + +C[1][0]) / 2, (+C[0][1] + +C[1][1]) / 2]
    }
    function M(C, H, w, D) {
      C.on("start.zoom", function () {
        T(this, arguments).event(D).start()
      })
        .on("interrupt.zoom end.zoom", function () {
          T(this, arguments).event(D).end()
        })
        .tween("zoom", function () {
          var Y = this,
            O = arguments,
            X = T(Y, O).event(D),
            it = t.apply(Y, O),
            ut = w == null ? y(it) : typeof w == "function" ? w.apply(Y, O) : w,
            It = Math.max(it[1][0] - it[0][0], it[1][1] - it[0][1]),
            vt = Y.__zoom,
            U = typeof H == "function" ? H.apply(Y, O) : H,
            R = u(vt.invert(ut).concat(It / vt.k), U.invert(ut).concat(It / U.k))
          return function (V) {
            if (V === 1) V = U
            else {
              var at = R(V),
                Ct = It / at[2]
              V = new Te(Ct, ut[0] - at[0] * Ct, ut[1] - at[1] * Ct)
            }
            X.zoom(null, V)
          }
        })
    }
    function T(C, H, w) {
      return (!w && C.__zooming) || new E(C, H)
    }
    function E(C, H) {
      ;((this.that = C),
        (this.args = H),
        (this.active = 0),
        (this.sourceEvent = null),
        (this.extent = t.apply(C, H)),
        (this.taps = 0))
    }
    E.prototype = {
      event: function (C) {
        return (C && (this.sourceEvent = C), this)
      },
      start: function () {
        return (++this.active === 1 && ((this.that.__zooming = this), this.emit("start")), this)
      },
      zoom: function (C, H) {
        return (
          this.mouse && C !== "mouse" && (this.mouse[1] = H.invert(this.mouse[0])),
          this.touch0 && C !== "touch" && (this.touch0[1] = H.invert(this.touch0[0])),
          this.touch1 && C !== "touch" && (this.touch1[1] = H.invert(this.touch1[0])),
          (this.that.__zoom = H),
          this.emit("zoom"),
          this
        )
      },
      end: function () {
        return (--this.active === 0 && (delete this.that.__zooming, this.emit("end")), this)
      },
      emit: function (C) {
        var H = $t(this.that).datum()
        l.call(
          C,
          this.that,
          new nc(C, {
            sourceEvent: this.sourceEvent,
            target: _,
            type: C,
            transform: this.that.__zoom,
            dispatch: l,
          }),
          H,
        )
      },
    }
    function G(C, ...H) {
      if (!r.apply(this, arguments)) return
      var w = T(this, H).event(C),
        D = this.__zoom,
        Y = Math.max(s[0], Math.min(s[1], D.k * Math.pow(2, i.apply(this, arguments)))),
        O = me(C)
      if (w.wheel)
        ((w.mouse[0][0] !== O[0] || w.mouse[0][1] !== O[1]) &&
          (w.mouse[1] = D.invert((w.mouse[0] = O))),
          clearTimeout(w.wheel))
      else {
        if (D.k === Y) return
        ;((w.mouse = [O, D.invert(O)]), xr(this), w.start())
      }
      ;(Mi(C),
        (w.wheel = setTimeout(X, g)),
        w.zoom("mouse", e(S(v(D, Y), w.mouse[0], w.mouse[1]), w.extent, o)))
      function X() {
        ;((w.wheel = null), w.end())
      }
    }
    function B(C, ...H) {
      if (f || !r.apply(this, arguments)) return
      var w = C.currentTarget,
        D = T(this, H, !0).event(C),
        Y = $t(C.view).on("mousemove.zoom", ut, !0).on("mouseup.zoom", It, !0),
        O = me(C, w),
        X = C.clientX,
        it = C.clientY
      ;(In(C.view), Ea(C), (D.mouse = [O, this.__zoom.invert(O)]), xr(this), D.start())
      function ut(vt) {
        if ((Mi(vt), !D.moved)) {
          var U = vt.clientX - X,
            R = vt.clientY - it
          D.moved = U * U + R * R > x
        }
        D.event(vt).zoom(
          "mouse",
          e(S(D.that.__zoom, (D.mouse[0] = me(vt, w)), D.mouse[1]), D.extent, o),
        )
      }
      function It(vt) {
        ;(Y.on("mousemove.zoom mouseup.zoom", null),
          kn(vt.view, D.moved),
          Mi(vt),
          D.event(vt).end())
      }
    }
    function P(C, ...H) {
      if (r.apply(this, arguments)) {
        var w = this.__zoom,
          D = me(C.changedTouches ? C.changedTouches[0] : C, this),
          Y = w.invert(D),
          O = w.k * (C.shiftKey ? 0.5 : 2),
          X = e(S(v(w, O), D, Y), t.apply(this, H), o)
        ;(Mi(C),
          a > 0
            ? $t(this).transition().duration(a).call(M, X, D, C)
            : $t(this).call(_.transform, X, D, C))
      }
    }
    function F(C, ...H) {
      if (r.apply(this, arguments)) {
        var w = C.touches,
          D = w.length,
          Y = T(this, H, C.changedTouches.length === D).event(C),
          O,
          X,
          it,
          ut
        for (Ea(C), X = 0; X < D; ++X)
          ((it = w[X]),
            (ut = me(it, this)),
            (ut = [ut, this.__zoom.invert(ut), it.identifier]),
            Y.touch0
              ? !Y.touch1 && Y.touch0[2] !== ut[2] && ((Y.touch1 = ut), (Y.taps = 0))
              : ((Y.touch0 = ut), (O = !0), (Y.taps = 1 + !!c)))
        ;(c && (c = clearTimeout(c)),
          O &&
            (Y.taps < 2 &&
              ((h = ut[0]),
              (c = setTimeout(function () {
                c = null
              }, d))),
            xr(this),
            Y.start()))
      }
    }
    function W(C, ...H) {
      if (this.__zooming) {
        var w = T(this, H).event(C),
          D = C.changedTouches,
          Y = D.length,
          O,
          X,
          it,
          ut
        for (Mi(C), O = 0; O < Y; ++O)
          ((X = D[O]),
            (it = me(X, this)),
            w.touch0 && w.touch0[2] === X.identifier
              ? (w.touch0[0] = it)
              : w.touch1 && w.touch1[2] === X.identifier && (w.touch1[0] = it))
        if (((X = w.that.__zoom), w.touch1)) {
          var It = w.touch0[0],
            vt = w.touch0[1],
            U = w.touch1[0],
            R = w.touch1[1],
            V = (V = U[0] - It[0]) * V + (V = U[1] - It[1]) * V,
            at = (at = R[0] - vt[0]) * at + (at = R[1] - vt[1]) * at
          ;((X = v(X, Math.sqrt(V / at))),
            (it = [(It[0] + U[0]) / 2, (It[1] + U[1]) / 2]),
            (ut = [(vt[0] + R[0]) / 2, (vt[1] + R[1]) / 2]))
        } else if (w.touch0) ((it = w.touch0[0]), (ut = w.touch0[1]))
        else return
        w.zoom("touch", e(S(X, it, ut), w.extent, o))
      }
    }
    function j(C, ...H) {
      if (this.__zooming) {
        var w = T(this, H).event(C),
          D = C.changedTouches,
          Y = D.length,
          O,
          X
        for (
          Ea(C),
            f && clearTimeout(f),
            f = setTimeout(function () {
              f = null
            }, d),
            O = 0;
          O < Y;
          ++O
        )
          ((X = D[O]),
            w.touch0 && w.touch0[2] === X.identifier
              ? delete w.touch0
              : w.touch1 && w.touch1[2] === X.identifier && delete w.touch1)
        if ((w.touch1 && !w.touch0 && ((w.touch0 = w.touch1), delete w.touch1), w.touch0))
          w.touch0[1] = this.__zoom.invert(w.touch0[0])
        else if (
          (w.end(), w.taps === 2 && ((X = me(X, this)), Math.hypot(h[0] - X[0], h[1] - X[1]) < m))
        ) {
          var it = $t(this).on("dblclick.zoom")
          it && it.apply(this, arguments)
        }
      }
    }
    return (
      (_.wheelDelta = function (C) {
        return arguments.length ? ((i = typeof C == "function" ? C : Kn(+C)), _) : i
      }),
      (_.filter = function (C) {
        return arguments.length ? ((r = typeof C == "function" ? C : Kn(!!C)), _) : r
      }),
      (_.touchable = function (C) {
        return arguments.length ? ((n = typeof C == "function" ? C : Kn(!!C)), _) : n
      }),
      (_.extent = function (C) {
        return arguments.length
          ? ((t =
              typeof C == "function"
                ? C
                : Kn([
                    [+C[0][0], +C[0][1]],
                    [+C[1][0], +C[1][1]],
                  ])),
            _)
          : t
      }),
      (_.scaleExtent = function (C) {
        return arguments.length ? ((s[0] = +C[0]), (s[1] = +C[1]), _) : [s[0], s[1]]
      }),
      (_.translateExtent = function (C) {
        return arguments.length
          ? ((o[0][0] = +C[0][0]),
            (o[1][0] = +C[1][0]),
            (o[0][1] = +C[0][1]),
            (o[1][1] = +C[1][1]),
            _)
          : [
              [o[0][0], o[0][1]],
              [o[1][0], o[1][1]],
            ]
      }),
      (_.constrain = function (C) {
        return arguments.length ? ((e = C), _) : e
      }),
      (_.duration = function (C) {
        return arguments.length ? ((a = +C), _) : a
      }),
      (_.interpolate = function (C) {
        return arguments.length ? ((u = C), _) : u
      }),
      (_.on = function () {
        var C = l.on.apply(l, arguments)
        return C === l ? _ : C
      }),
      (_.clickDistance = function (C) {
        return arguments.length ? ((x = (C = +C) * C), _) : Math.sqrt(x)
      }),
      (_.tapDistance = function (C) {
        return arguments.length ? ((m = +C), _) : m
      }),
      _
    )
  }
  A()
  var fS = {
    extension: { type: b.Environment, name: "browser", priority: -1 },
    test: () => !0,
    load: async () => {
      await Promise.resolve().then(() => (hS(), YD))
    },
  }
  A()
  var pS = {
    extension: { type: b.Environment, name: "webworker", priority: 0 },
    test: () => typeof self < "u" && self.WorkerGlobalScope !== void 0,
    load: async () => {
      await Promise.resolve().then(() => (dS(), jD))
    },
  }
  A()
  ru()
  qa()
  A()
  At()
  $s()
  var ju
  function SS(r) {
    return (
      ju !== void 0 ||
        (ju = (() => {
          let t = {
            stencil: !0,
            failIfMajorPerformanceCaveat: r ?? Fr.defaultOptions.failIfMajorPerformanceCaveat,
          }
          try {
            if (!Z.get().getWebGLRenderingContext()) return !1
            let i = Z.get().createCanvas().getContext("webgl", t),
              n = !!i?.getContextAttributes()?.stencil
            if (i) {
              let s = i.getExtension("WEBGL_lose_context")
              s && s.loseContext()
            }
            return ((i = null), n)
          } catch {
            return !1
          }
        })()),
      ju
    )
  }
  At()
  var Ku
  async function TS(r = {}) {
    return (
      Ku !== void 0 ||
        (Ku = await (async () => {
          let t = Z.get().getNavigator().gpu
          if (!t) return !1
          try {
            return (await (await t.requestAdapter(r)).requestDevice(), !0)
          } catch {
            return !1
          }
        })()),
      Ku
    )
  }
  $s()
  var OE = ["webgl", "webgpu", "canvas"]
  async function LE(r) {
    let t = []
    r.preference
      ? (t.push(r.preference),
        OE.forEach((s) => {
          s !== r.preference && t.push(s)
        }))
      : (t = OE.slice())
    let e,
      i = {}
    for (let s = 0; s < t.length; s++) {
      let o = t[s]
      if (o === "webgpu" && (await TS())) {
        let { WebGPURenderer: a } = await Promise.resolve().then(() => (cC(), lC))
        ;((e = a), (i = { ...r, ...r.webgpu }))
        break
      } else if (
        o === "webgl" &&
        SS(r.failIfMajorPerformanceCaveat ?? Fr.defaultOptions.failIfMajorPerformanceCaveat)
      ) {
        let { WebGLRenderer: a } = await Promise.resolve().then(() => (UE(), GE))
        ;((e = a), (i = { ...r, ...r.webgl }))
        break
      } else if (o === "canvas")
        throw ((i = { ...r }), new Error("CanvasRenderer is not yet implemented"))
    }
    if ((delete i.webgpu, delete i.webgl, !e))
      throw new Error("No available renderer for the current environment")
    let n = new e()
    return (await n.init(i), n)
  }
  we()
  td()
  gt()
  var NE = class zd {
    constructor(...t) {
      ;((this.stage = new pt()),
        t[0] !== void 0 &&
          z(
            K,
            "Application constructor options are deprecated, please use Application.init() instead.",
          ))
    }
    async init(t) {
      ;((t = { ...t }),
        (this.renderer = await LE(t)),
        zd._plugins.forEach((e) => {
          e.init.call(this, t)
        }))
    }
    render() {
      this.renderer.render({ container: this.stage })
    }
    get canvas() {
      return this.renderer.canvas
    }
    get view() {
      return (
        z(K, "Application.view is deprecated, please use Application.canvas instead."),
        this.renderer.canvas
      )
    }
    get screen() {
      return this.renderer.screen
    }
    destroy(t = !1, e = !1) {
      let i = zd._plugins.slice(0)
      ;(i.reverse(),
        i.forEach((n) => {
          n.destroy.call(this)
        }),
        this.stage.destroy(e),
        (this.stage = null),
        this.renderer.destroy(t),
        (this.renderer = null))
    }
  }
  NE._plugins = []
  var vl = NE
  L.handleByList(b.Application, vl._plugins)
  L.add(eo)
  qr()
  Da()
  gt()
  Ka()
  var Sl = class extends vr {
    constructor(t, e) {
      let {
        text: i,
        resolution: n,
        style: s,
        anchor: o,
        width: a,
        height: u,
        roundPixels: l,
        ...c
      } = t
      ;(super({ ...c }),
        (this.batched = !0),
        (this._resolution = null),
        (this._autoResolution = !0),
        (this._didTextUpdate = !0),
        (this._styleClass = e),
        (this.text = i ?? ""),
        (this.style = s),
        (this.resolution = n ?? null),
        (this.allowChildren = !1),
        (this._anchor = new Pt({
          _onUpdate: () => {
            this.onViewUpdate()
          },
        })),
        o && (this.anchor = o),
        (this.roundPixels = l ?? !1),
        a !== void 0 && (this.width = a),
        u !== void 0 && (this.height = u))
    }
    get anchor() {
      return this._anchor
    }
    set anchor(t) {
      typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t)
    }
    set text(t) {
      ;((t = t.toString()), this._text !== t && ((this._text = t), this.onViewUpdate()))
    }
    get text() {
      return this._text
    }
    set resolution(t) {
      ;((this._autoResolution = t === null), (this._resolution = t), this.onViewUpdate())
    }
    get resolution() {
      return this._resolution
    }
    get style() {
      return this._style
    }
    set style(t) {
      ;(t || (t = {}),
        this._style?.off("update", this.onViewUpdate, this),
        t instanceof this._styleClass ? (this._style = t) : (this._style = new this._styleClass(t)),
        this._style.on("update", this.onViewUpdate, this),
        this.onViewUpdate())
    }
    get width() {
      return Math.abs(this.scale.x) * this.bounds.width
    }
    set width(t) {
      this._setWidth(t, this.bounds.width)
    }
    get height() {
      return Math.abs(this.scale.y) * this.bounds.height
    }
    set height(t) {
      this._setHeight(t, this.bounds.height)
    }
    getSize(t) {
      return (
        t || (t = {}),
        (t.width = Math.abs(this.scale.x) * this.bounds.width),
        (t.height = Math.abs(this.scale.y) * this.bounds.height),
        t
      )
    }
    setSize(t, e) {
      ;(typeof t == "object" ? ((e = t.height ?? t.width), (t = t.width)) : (e ?? (e = t)),
        t !== void 0 && this._setWidth(t, this.bounds.width),
        e !== void 0 && this._setHeight(e, this.bounds.height))
    }
    containsPoint(t) {
      let e = this.bounds.width,
        i = this.bounds.height,
        n = -e * this.anchor.x,
        s = 0
      return t.x >= n && t.x <= n + e && ((s = -i * this.anchor.y), t.y >= s && t.y <= s + i)
    }
    onViewUpdate() {
      ;(this.didViewUpdate || (this._didTextUpdate = !0), super.onViewUpdate())
    }
    destroy(t = !1) {
      ;(super.destroy(t),
        (this.owner = null),
        (this._bounds = null),
        (this._anchor = null),
        (typeof t == "boolean" ? t : t?.style) && this._style.destroy(t),
        (this._style = null),
        (this._text = null))
    }
  }
  function HE(r, t) {
    let e = r[0] ?? {}
    return (
      (typeof e == "string" || r[1]) &&
        (z(K, `use new ${t}({ text: "hi!", style }) instead`), (e = { text: e, style: r[1] })),
      e
    )
  }
  Cf()
  an()
  sn()
  var Wo = class extends Sl {
    constructor(...t) {
      let e = HE(t, "Text")
      ;(super(e, le),
        (this.renderPipeId = "text"),
        e.textureStyle &&
          (this.textureStyle =
            e.textureStyle instanceof Jt ? e.textureStyle : new Jt(e.textureStyle)))
    }
    updateBounds() {
      let t = this._bounds,
        e = this._anchor,
        i = 0,
        n = 0
      if (this._style.trim) {
        let { frame: s, canvasAndContext: o } = mi.getCanvasAndContext({
          text: this.text,
          style: this._style,
          resolution: 1,
        })
        ;(mi.returnCanvasAndContext(o), (i = s.width), (n = s.height))
      } else {
        let s = jt.measureText(this._text, this._style)
        ;((i = s.width), (n = s.height))
      }
      ;((t.minX = -e._x * i), (t.maxX = t.minX + i), (t.minY = -e._y * n), (t.maxY = t.minY + n))
    }
  }
  rf()
  oh()
  we()
  wf()
  Wt()
  L.add(fS, pS)
  var $o = Object.freeze({
      Linear: Object.freeze({
        None: function (r) {
          return r
        },
        In: function (r) {
          return r
        },
        Out: function (r) {
          return r
        },
        InOut: function (r) {
          return r
        },
      }),
      Quadratic: Object.freeze({
        In: function (r) {
          return r * r
        },
        Out: function (r) {
          return r * (2 - r)
        },
        InOut: function (r) {
          return (r *= 2) < 1 ? 0.5 * r * r : -0.5 * (--r * (r - 2) - 1)
        },
      }),
      Cubic: Object.freeze({
        In: function (r) {
          return r * r * r
        },
        Out: function (r) {
          return --r * r * r + 1
        },
        InOut: function (r) {
          return (r *= 2) < 1 ? 0.5 * r * r * r : 0.5 * ((r -= 2) * r * r + 2)
        },
      }),
      Quartic: Object.freeze({
        In: function (r) {
          return r * r * r * r
        },
        Out: function (r) {
          return 1 - --r * r * r * r
        },
        InOut: function (r) {
          return (r *= 2) < 1 ? 0.5 * r * r * r * r : -0.5 * ((r -= 2) * r * r * r - 2)
        },
      }),
      Quintic: Object.freeze({
        In: function (r) {
          return r * r * r * r * r
        },
        Out: function (r) {
          return --r * r * r * r * r + 1
        },
        InOut: function (r) {
          return (r *= 2) < 1 ? 0.5 * r * r * r * r * r : 0.5 * ((r -= 2) * r * r * r * r + 2)
        },
      }),
      Sinusoidal: Object.freeze({
        In: function (r) {
          return 1 - Math.sin(((1 - r) * Math.PI) / 2)
        },
        Out: function (r) {
          return Math.sin((r * Math.PI) / 2)
        },
        InOut: function (r) {
          return 0.5 * (1 - Math.sin(Math.PI * (0.5 - r)))
        },
      }),
      Exponential: Object.freeze({
        In: function (r) {
          return r === 0 ? 0 : Math.pow(1024, r - 1)
        },
        Out: function (r) {
          return r === 1 ? 1 : 1 - Math.pow(2, -10 * r)
        },
        InOut: function (r) {
          return r === 0
            ? 0
            : r === 1
              ? 1
              : (r *= 2) < 1
                ? 0.5 * Math.pow(1024, r - 1)
                : 0.5 * (-Math.pow(2, -10 * (r - 1)) + 2)
        },
      }),
      Circular: Object.freeze({
        In: function (r) {
          return 1 - Math.sqrt(1 - r * r)
        },
        Out: function (r) {
          return Math.sqrt(1 - --r * r)
        },
        InOut: function (r) {
          return (r *= 2) < 1
            ? -0.5 * (Math.sqrt(1 - r * r) - 1)
            : 0.5 * (Math.sqrt(1 - (r -= 2) * r) + 1)
        },
      }),
      Elastic: Object.freeze({
        In: function (r) {
          return r === 0
            ? 0
            : r === 1
              ? 1
              : -Math.pow(2, 10 * (r - 1)) * Math.sin((r - 1.1) * 5 * Math.PI)
        },
        Out: function (r) {
          return r === 0
            ? 0
            : r === 1
              ? 1
              : Math.pow(2, -10 * r) * Math.sin((r - 0.1) * 5 * Math.PI) + 1
        },
        InOut: function (r) {
          return r === 0
            ? 0
            : r === 1
              ? 1
              : ((r *= 2),
                r < 1
                  ? -0.5 * Math.pow(2, 10 * (r - 1)) * Math.sin((r - 1.1) * 5 * Math.PI)
                  : 0.5 * Math.pow(2, -10 * (r - 1)) * Math.sin((r - 1.1) * 5 * Math.PI) + 1)
        },
      }),
      Back: Object.freeze({
        In: function (r) {
          var t = 1.70158
          return r === 1 ? 1 : r * r * ((t + 1) * r - t)
        },
        Out: function (r) {
          var t = 1.70158
          return r === 0 ? 0 : --r * r * ((t + 1) * r + t) + 1
        },
        InOut: function (r) {
          var t = 2.5949095
          return (r *= 2) < 1
            ? 0.5 * (r * r * ((t + 1) * r - t))
            : 0.5 * ((r -= 2) * r * ((t + 1) * r + t) + 2)
        },
      }),
      Bounce: Object.freeze({
        In: function (r) {
          return 1 - $o.Bounce.Out(1 - r)
        },
        Out: function (r) {
          return r < 0.36363636363636365
            ? 7.5625 * r * r
            : r < 0.7272727272727273
              ? 7.5625 * (r -= 0.5454545454545454) * r + 0.75
              : r < 0.9090909090909091
                ? 7.5625 * (r -= 0.8181818181818182) * r + 0.9375
                : 7.5625 * (r -= 0.9545454545454546) * r + 0.984375
        },
        InOut: function (r) {
          return r < 0.5 ? $o.Bounce.In(r * 2) * 0.5 : $o.Bounce.Out(r * 2 - 1) * 0.5 + 0.5
        },
      }),
      generatePow: function (r) {
        return (
          r === void 0 && (r = 4),
          (r = r < Number.EPSILON ? Number.EPSILON : r),
          (r = r > 1e4 ? 1e4 : r),
          {
            In: function (t) {
              return Math.pow(t, r)
            },
            Out: function (t) {
              return 1 - Math.pow(1 - t, r)
            },
            InOut: function (t) {
              return t < 0.5 ? Math.pow(t * 2, r) / 2 : (1 - Math.pow(2 - t * 2, r)) / 2 + 0.5
            },
          }
        )
      },
    }),
    Vo = function () {
      return performance.now()
    },
    Xo = (function () {
      function r() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e]
        ;((this._tweens = {}), (this._tweensAddedDuringUpdate = {}), this.add.apply(this, t))
      }
      return (
        (r.prototype.getAll = function () {
          var t = this
          return Object.keys(this._tweens).map(function (e) {
            return t._tweens[e]
          })
        }),
        (r.prototype.removeAll = function () {
          this._tweens = {}
        }),
        (r.prototype.add = function () {
          for (var t, e = [], i = 0; i < arguments.length; i++) e[i] = arguments[i]
          for (var n = 0, s = e; n < s.length; n++) {
            var o = s[n]
            ;((t = o._group) === null || t === void 0 || t.remove(o),
              (o._group = this),
              (this._tweens[o.getId()] = o),
              (this._tweensAddedDuringUpdate[o.getId()] = o))
          }
        }),
        (r.prototype.remove = function () {
          for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e]
          for (var i = 0, n = t; i < n.length; i++) {
            var s = n[i]
            ;((s._group = void 0),
              delete this._tweens[s.getId()],
              delete this._tweensAddedDuringUpdate[s.getId()])
          }
        }),
        (r.prototype.allStopped = function () {
          return this.getAll().every(function (t) {
            return !t.isPlaying()
          })
        }),
        (r.prototype.update = function (t, e) {
          ;(t === void 0 && (t = Vo()), e === void 0 && (e = !0))
          var i = Object.keys(this._tweens)
          if (i.length !== 0)
            for (; i.length > 0; ) {
              this._tweensAddedDuringUpdate = {}
              for (var n = 0; n < i.length; n++) {
                var s = this._tweens[i[n]],
                  o = !e
                s && s.update(t, o) === !1 && !e && this.remove(s)
              }
              i = Object.keys(this._tweensAddedDuringUpdate)
            }
        }),
        r
      )
    })(),
    vn = {
      Linear: function (r, t) {
        var e = r.length - 1,
          i = e * t,
          n = Math.floor(i),
          s = vn.Utils.Linear
        return t < 0
          ? s(r[0], r[1], i)
          : t > 1
            ? s(r[e], r[e - 1], e - i)
            : s(r[n], r[n + 1 > e ? e : n + 1], i - n)
      },
      Bezier: function (r, t) {
        for (var e = 0, i = r.length - 1, n = Math.pow, s = vn.Utils.Bernstein, o = 0; o <= i; o++)
          e += n(1 - t, i - o) * n(t, o) * r[o] * s(i, o)
        return e
      },
      CatmullRom: function (r, t) {
        var e = r.length - 1,
          i = e * t,
          n = Math.floor(i),
          s = vn.Utils.CatmullRom
        return r[0] === r[e]
          ? (t < 0 && (n = Math.floor((i = e * (1 + t)))),
            s(r[(n - 1 + e) % e], r[n], r[(n + 1) % e], r[(n + 2) % e], i - n))
          : t < 0
            ? r[0] - (s(r[0], r[0], r[1], r[1], -i) - r[0])
            : t > 1
              ? r[e] - (s(r[e], r[e], r[e - 1], r[e - 1], i - e) - r[e])
              : s(r[n ? n - 1 : 0], r[n], r[e < n + 1 ? e : n + 1], r[e < n + 2 ? e : n + 2], i - n)
      },
      Utils: {
        Linear: function (r, t, e) {
          return (t - r) * e + r
        },
        Bernstein: function (r, t) {
          var e = vn.Utils.Factorial
          return e(r) / e(t) / e(r - t)
        },
        Factorial: (function () {
          var r = [1]
          return function (t) {
            var e = 1
            if (r[t]) return r[t]
            for (var i = t; i > 1; i--) e *= i
            return ((r[t] = e), e)
          }
        })(),
        CatmullRom: function (r, t, e, i, n) {
          var s = (e - r) * 0.5,
            o = (i - t) * 0.5,
            a = n * n,
            u = n * a
          return (2 * t - 2 * e + s + o) * u + (-3 * t + 3 * e - 2 * s - o) * a + s * n + t
        },
      },
    },
    zE = (function () {
      function r() {}
      return (
        (r.nextId = function () {
          return r._nextId++
        }),
        (r._nextId = 0),
        r
      )
    })(),
    Wd = new Xo(),
    Yo = (function () {
      function r(t, e) {
        ;((this._isPaused = !1),
          (this._pauseStart = 0),
          (this._valuesStart = {}),
          (this._valuesEnd = {}),
          (this._valuesStartRepeat = {}),
          (this._duration = 1e3),
          (this._isDynamic = !1),
          (this._initialRepeat = 0),
          (this._repeat = 0),
          (this._yoyo = !1),
          (this._isPlaying = !1),
          (this._reversed = !1),
          (this._delayTime = 0),
          (this._startTime = 0),
          (this._easingFunction = $o.Linear.None),
          (this._interpolationFunction = vn.Linear),
          (this._chainedTweens = []),
          (this._onStartCallbackFired = !1),
          (this._onEveryStartCallbackFired = !1),
          (this._id = zE.nextId()),
          (this._isChainStopped = !1),
          (this._propertiesAreSetUp = !1),
          (this._goToEnd = !1),
          (this._object = t),
          typeof e == "object"
            ? ((this._group = e), e.add(this))
            : e === !0 && ((this._group = Wd), Wd.add(this)))
      }
      return (
        (r.prototype.getId = function () {
          return this._id
        }),
        (r.prototype.isPlaying = function () {
          return this._isPlaying
        }),
        (r.prototype.isPaused = function () {
          return this._isPaused
        }),
        (r.prototype.getDuration = function () {
          return this._duration
        }),
        (r.prototype.to = function (t, e) {
          if ((e === void 0 && (e = 1e3), this._isPlaying))
            throw new Error(
              "Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.",
            )
          return (
            (this._valuesEnd = t),
            (this._propertiesAreSetUp = !1),
            (this._duration = e < 0 ? 0 : e),
            this
          )
        }),
        (r.prototype.duration = function (t) {
          return (t === void 0 && (t = 1e3), (this._duration = t < 0 ? 0 : t), this)
        }),
        (r.prototype.dynamic = function (t) {
          return (t === void 0 && (t = !1), (this._isDynamic = t), this)
        }),
        (r.prototype.start = function (t, e) {
          if ((t === void 0 && (t = Vo()), e === void 0 && (e = !1), this._isPlaying)) return this
          if (((this._repeat = this._initialRepeat), this._reversed)) {
            this._reversed = !1
            for (var i in this._valuesStartRepeat)
              (this._swapEndStartRepeatValues(i),
                (this._valuesStart[i] = this._valuesStartRepeat[i]))
          }
          if (
            ((this._isPlaying = !0),
            (this._isPaused = !1),
            (this._onStartCallbackFired = !1),
            (this._onEveryStartCallbackFired = !1),
            (this._isChainStopped = !1),
            (this._startTime = t),
            (this._startTime += this._delayTime),
            !this._propertiesAreSetUp || e)
          ) {
            if (((this._propertiesAreSetUp = !0), !this._isDynamic)) {
              var n = {}
              for (var s in this._valuesEnd) n[s] = this._valuesEnd[s]
              this._valuesEnd = n
            }
            this._setupProperties(
              this._object,
              this._valuesStart,
              this._valuesEnd,
              this._valuesStartRepeat,
              e,
            )
          }
          return this
        }),
        (r.prototype.startFromCurrentValues = function (t) {
          return this.start(t, !0)
        }),
        (r.prototype._setupProperties = function (t, e, i, n, s) {
          for (var o in i) {
            var a = t[o],
              u = Array.isArray(a),
              l = u ? "array" : typeof a,
              c = !u && Array.isArray(i[o])
            if (!(l === "undefined" || l === "function")) {
              if (c) {
                var h = i[o]
                if (h.length === 0) continue
                for (var f = [a], d = 0, g = h.length; d < g; d += 1) {
                  var x = this._handleRelativeValue(a, h[d])
                  if (isNaN(x)) {
                    ;((c = !1), console.warn("Found invalid interpolation list. Skipping."))
                    break
                  }
                  f.push(x)
                }
                c && (i[o] = f)
              }
              if ((l === "object" || u) && a && !c) {
                e[o] = u ? [] : {}
                var m = a
                for (var _ in m) e[o][_] = m[_]
                n[o] = u ? [] : {}
                var h = i[o]
                if (!this._isDynamic) {
                  var v = {}
                  for (var _ in h) v[_] = h[_]
                  i[o] = h = v
                }
                this._setupProperties(m, e[o], h, n[o], s)
              } else
                ((typeof e[o] > "u" || s) && (e[o] = a),
                  u || (e[o] *= 1),
                  c ? (n[o] = i[o].slice().reverse()) : (n[o] = e[o] || 0))
            }
          }
        }),
        (r.prototype.stop = function () {
          return (
            this._isChainStopped || ((this._isChainStopped = !0), this.stopChainedTweens()),
            this._isPlaying
              ? ((this._isPlaying = !1),
                (this._isPaused = !1),
                this._onStopCallback && this._onStopCallback(this._object),
                this)
              : this
          )
        }),
        (r.prototype.end = function () {
          return ((this._goToEnd = !0), this.update(this._startTime + this._duration), this)
        }),
        (r.prototype.pause = function (t) {
          return (
            t === void 0 && (t = Vo()),
            this._isPaused || !this._isPlaying
              ? this
              : ((this._isPaused = !0), (this._pauseStart = t), this)
          )
        }),
        (r.prototype.resume = function (t) {
          return (
            t === void 0 && (t = Vo()),
            !this._isPaused || !this._isPlaying
              ? this
              : ((this._isPaused = !1),
                (this._startTime += t - this._pauseStart),
                (this._pauseStart = 0),
                this)
          )
        }),
        (r.prototype.stopChainedTweens = function () {
          for (var t = 0, e = this._chainedTweens.length; t < e; t++) this._chainedTweens[t].stop()
          return this
        }),
        (r.prototype.group = function (t) {
          return t
            ? (t.add(this), this)
            : (console.warn(
                "tween.group() without args has been removed, use group.add(tween) instead.",
              ),
              this)
        }),
        (r.prototype.remove = function () {
          var t
          return ((t = this._group) === null || t === void 0 || t.remove(this), this)
        }),
        (r.prototype.delay = function (t) {
          return (t === void 0 && (t = 0), (this._delayTime = t), this)
        }),
        (r.prototype.repeat = function (t) {
          return (t === void 0 && (t = 0), (this._initialRepeat = t), (this._repeat = t), this)
        }),
        (r.prototype.repeatDelay = function (t) {
          return ((this._repeatDelayTime = t), this)
        }),
        (r.prototype.yoyo = function (t) {
          return (t === void 0 && (t = !1), (this._yoyo = t), this)
        }),
        (r.prototype.easing = function (t) {
          return (t === void 0 && (t = $o.Linear.None), (this._easingFunction = t), this)
        }),
        (r.prototype.interpolation = function (t) {
          return (t === void 0 && (t = vn.Linear), (this._interpolationFunction = t), this)
        }),
        (r.prototype.chain = function () {
          for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e]
          return ((this._chainedTweens = t), this)
        }),
        (r.prototype.onStart = function (t) {
          return ((this._onStartCallback = t), this)
        }),
        (r.prototype.onEveryStart = function (t) {
          return ((this._onEveryStartCallback = t), this)
        }),
        (r.prototype.onUpdate = function (t) {
          return ((this._onUpdateCallback = t), this)
        }),
        (r.prototype.onRepeat = function (t) {
          return ((this._onRepeatCallback = t), this)
        }),
        (r.prototype.onComplete = function (t) {
          return ((this._onCompleteCallback = t), this)
        }),
        (r.prototype.onStop = function (t) {
          return ((this._onStopCallback = t), this)
        }),
        (r.prototype.update = function (t, e) {
          var i = this,
            n
          if (
            (t === void 0 && (t = Vo()), e === void 0 && (e = r.autoStartOnUpdate), this._isPaused)
          )
            return !0
          var s
          if (!this._goToEnd && !this._isPlaying)
            if (e) this.start(t, !0)
            else return !1
          if (((this._goToEnd = !1), t < this._startTime)) return !0
          ;(this._onStartCallbackFired === !1 &&
            (this._onStartCallback && this._onStartCallback(this._object),
            (this._onStartCallbackFired = !0)),
            this._onEveryStartCallbackFired === !1 &&
              (this._onEveryStartCallback && this._onEveryStartCallback(this._object),
              (this._onEveryStartCallbackFired = !0)))
          var o = t - this._startTime,
            a =
              this._duration +
              ((n = this._repeatDelayTime) !== null && n !== void 0 ? n : this._delayTime),
            u = this._duration + this._repeat * a,
            l = function () {
              if (i._duration === 0 || o > u) return 1
              var x = Math.trunc(o / a),
                m = o - x * a,
                _ = Math.min(m / i._duration, 1)
              return _ === 0 && o === i._duration ? 1 : _
            },
            c = l(),
            h = this._easingFunction(c)
          if (
            (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, h),
            this._onUpdateCallback && this._onUpdateCallback(this._object, c),
            this._duration === 0 || o >= this._duration)
          )
            if (this._repeat > 0) {
              var f = Math.min(Math.trunc((o - this._duration) / a) + 1, this._repeat)
              isFinite(this._repeat) && (this._repeat -= f)
              for (s in this._valuesStartRepeat)
                (!this._yoyo &&
                  typeof this._valuesEnd[s] == "string" &&
                  (this._valuesStartRepeat[s] =
                    this._valuesStartRepeat[s] + parseFloat(this._valuesEnd[s])),
                  this._yoyo && this._swapEndStartRepeatValues(s),
                  (this._valuesStart[s] = this._valuesStartRepeat[s]))
              return (
                this._yoyo && (this._reversed = !this._reversed),
                (this._startTime += a * f),
                this._onRepeatCallback && this._onRepeatCallback(this._object),
                (this._onEveryStartCallbackFired = !1),
                !0
              )
            } else {
              this._onCompleteCallback && this._onCompleteCallback(this._object)
              for (var d = 0, g = this._chainedTweens.length; d < g; d++)
                this._chainedTweens[d].start(this._startTime + this._duration, !1)
              return ((this._isPlaying = !1), !1)
            }
          return !0
        }),
        (r.prototype._updateProperties = function (t, e, i, n) {
          for (var s in i)
            if (e[s] !== void 0) {
              var o = e[s] || 0,
                a = i[s],
                u = Array.isArray(t[s]),
                l = Array.isArray(a),
                c = !u && l
              c
                ? (t[s] = this._interpolationFunction(a, n))
                : typeof a == "object" && a
                  ? this._updateProperties(t[s], o, a, n)
                  : ((a = this._handleRelativeValue(o, a)),
                    typeof a == "number" && (t[s] = o + (a - o) * n))
            }
        }),
        (r.prototype._handleRelativeValue = function (t, e) {
          return typeof e != "string"
            ? e
            : e.charAt(0) === "+" || e.charAt(0) === "-"
              ? t + parseFloat(e)
              : parseFloat(e)
        }),
        (r.prototype._swapEndStartRepeatValues = function (t) {
          var e = this._valuesStartRepeat[t],
            i = this._valuesEnd[t]
          ;(typeof i == "string"
            ? (this._valuesStartRepeat[t] = this._valuesStartRepeat[t] + parseFloat(i))
            : (this._valuesStartRepeat[t] = this._valuesEnd[t]),
            (this._valuesEnd[t] = e))
        }),
        (r.autoStartOnUpdate = !1),
        r
      )
    })()
  var pnt = zE.nextId,
    $e = Wd,
    mnt = $e.getAll.bind($e),
    gnt = $e.removeAll.bind($e),
    xnt = $e.add.bind($e),
    _nt = $e.remove.bind($e),
    ynt = $e.update.bind($e)
  function WE(r, t) {
    if (!r) return
    function e(n) {
      n.target === this && (n.preventDefault(), n.stopPropagation(), t())
    }
    function i(n) {
      n.key.startsWith("Esc") && (n.preventDefault(), t())
    }
    ;(r?.addEventListener("click", e),
      Ye.instance.addCleanupTask(() => r?.removeEventListener("click", e)),
      document.addEventListener("keydown", i),
      Ye.instance.addCleanupTask(() => document.removeEventListener("keydown", i)))
  }
  function VE(r) {
    for (; r.firstChild; ) r.removeChild(r.firstChild)
  }
  var Vd = "quartz-graph-visited"
  function AP() {
    return new Set(JSON.parse(localStorage.getItem(Vd) ?? "[]"))
  }
  function $E(r) {
    let t = AP()
    ;(t.add(r), localStorage.setItem(Vd, JSON.stringify([...t])))
  }
  async function XE() {
    let r = await navigator.gpu?.requestAdapter().catch(() => null)
    return r && r.features.has("float32-blendable") ? "webgpu" : "webgl"
  }
  async function jo(r, t, e) {
    let i = Nr(t),
      { depth: n, showTags: s, removeTags: o } = JSON.parse(r.dataset.cfg),
      a = new Map(Object.entries(await e).map(([g, x]) => [Nr(g), x])),
      u = [],
      l = [],
      c = new Set(a.keys())
    for (let [g, x] of a.entries()) {
      let m = x.links ?? []
      for (let _ of m) c.has(_) && u.push({ source: g, target: _ })
      if (s) {
        let _ = x.tags.filter((v) => !o.includes(v)).map((v) => Nr("tags/" + v))
        l.push(..._.filter((v) => !l.includes(v)))
        for (let v of _) u.push({ source: g, target: v })
      }
    }
    let h = new Set(),
      f = [i, "__SENTINEL"]
    if (n >= 0)
      for (; n >= 0 && f.length > 0; ) {
        let g = f.shift()
        if (g === "__SENTINEL") (n--, f.push("__SENTINEL"))
        else {
          h.add(g)
          let x = u.filter((_) => _.source === g),
            m = u.filter((_) => _.target === g)
          f.push(...x.map((_) => _.target), ...m.map((_) => _.source))
        }
      }
    else (c.forEach((g) => h.add(g)), s && l.forEach((g) => h.add(g)))
    let d = [...h].map((g) => {
      let x = g.startsWith("tags/") ? "#" + g.substring(5) : (a.get(g)?.title ?? g)
      return { id: g, text: x, tags: a.get(g)?.tags ?? [] }
    })
    return {
      nodes: d,
      links: u
        .filter((g) => h.has(g.source) && h.has(g.target))
        .map((g) => ({
          source: d.find((x) => x.id === g.source),
          target: d.find((x) => x.id === g.target),
        })),
    }
  }
  async function Ko(r, t, e) {
    VE(r)
    let {
      drag: i,
      zoom: n,
      repelForce: s,
      centerForce: o,
      linkDistance: a,
      fontSize: u,
      opacityScale: l,
      focusOnHover: c,
      enableRadial: h,
    } = JSON.parse(r.dataset.cfg)
    n = Number(n)
    let f = r.offsetWidth,
      d = Math.max(r.offsetHeight, 250),
      g = ec(e.nodes)
        .force("charge", rc().strength(-100 * s))
        .force("center", Zl().strength(o))
        .force("link", tc(e.links).distance(a))
        .force("collide", Jl((U) => S(U)).iterations(3)),
      x = (Math.min(f, d) / 2) * 0.8
    h && g.force("radial", ic(x).strength(0.2))
    let _ = [
        "--secondary",
        "--tertiary",
        "--gray",
        "--light",
        "--lightgray",
        "--dark",
        "--darkgray",
        "--bodyFont",
      ].reduce(
        (U, R) => ((U[R] = getComputedStyle(document.documentElement).getPropertyValue(R)), U),
        {},
      ),
      v = (U) =>
        U.id === Nr(t) ? _["--secondary"] : U.id.startsWith("tags/") ? _["--tertiary"] : _["--gray"]
    function S(U) {
      let R = e.links.filter((V) => V.source.id === U.id || V.target.id === U.id).length
      return 2 + Math.sqrt(R)
    }
    let y = null,
      M = new Set(),
      T = [],
      E = []
    function G(U) {
      if (((y = U), U === null)) {
        M = new Set()
        for (let R of E) R.active = !1
        for (let R of T) R.active = !1
      } else {
        M = new Set()
        for (let R of T) {
          let V = R.simulationData
          ;((V.source.id === U || V.target.id === U) && (M.add(V.source.id), M.add(V.target.id)),
            (R.active = V.source.id === U || V.target.id === U))
        }
        for (let R of E) R.active = M.has(R.simulationData.id)
      }
    }
    let B = 0,
      P = !1,
      F = new Map()
    function W() {
      F.get("link")?.stop()
      let U = new Xo()
      for (let R of T) {
        let V = 1
        ;(y && (V = R.active ? 1 : 0.2),
          (R.color = R.active ? _["--gray"] : _["--lightgray"]),
          U.add(new Yo(R).to({ alpha: V }, 200)))
      }
      ;(U.getAll().forEach((R) => R.start()),
        F.set("link", {
          update: U.update.bind(U),
          stop() {
            U.getAll().forEach((R) => R.stop())
          },
        }))
    }
    function j() {
      F.get("label")?.stop()
      let U = new Xo(),
        R = 1 / n,
        V = R * 1.1
      for (let at of E) {
        let Ct = at.simulationData.id
        y === Ct
          ? U.add(new Yo(at.label).to({ alpha: 1, scale: { x: V, y: V } }, 100))
          : U.add(new Yo(at.label).to({ alpha: at.label.alpha, scale: { x: R, y: R } }, 100))
      }
      ;(U.getAll().forEach((at) => at.start()),
        F.set("label", {
          update: U.update.bind(U),
          stop() {
            U.getAll().forEach((at) => at.stop())
          },
        }))
    }
    function C() {
      F.get("hover")?.stop()
      let U = new Xo()
      for (let R of E) {
        let V = 1
        ;(y !== null && c && (V = R.active ? 1 : 0.2),
          U.add(new Yo(R.gfx, U).to({ alpha: V }, 200)))
      }
      ;(U.getAll().forEach((R) => R.start()),
        F.set("hover", {
          update: U.update.bind(U),
          stop() {
            U.getAll().forEach((R) => R.stop())
          },
        }))
    }
    function H() {
      ;(C(), W(), j())
    }
    ;(F.forEach((U) => U.stop()), F.clear())
    let w = await XE(),
      D = new vl()
    ;(await D.init({
      width: f,
      height: d,
      antialias: !0,
      autoStart: !1,
      autoDensity: !0,
      backgroundAlpha: 0,
      preference: w,
      resolution: window.devicePixelRatio,
      eventMode: "static",
    }),
      r.appendChild(D.canvas))
    let Y = D.stage
    Y.interactive = !1
    let O = new pt({ zIndex: 3, isRenderGroup: !0 }),
      X = new pt({ zIndex: 2, isRenderGroup: !0 }),
      it = new pt({ zIndex: 1, isRenderGroup: !0 })
    Y.addChild(X, O, it)
    for (let U of e.nodes) {
      let R = U.id,
        V = new Wo({
          interactive: !1,
          eventMode: "none",
          text: U.text,
          alpha: 0,
          anchor: { x: 0.5, y: 1.2 },
          style: { fontSize: u * 15, fill: _["--dark"], fontFamily: _["--bodyFont"] },
          resolution: window.devicePixelRatio * 4,
        })
      V.scale.set(1 / n)
      let at = 0,
        Ct = R.startsWith("tags/"),
        hr = new Pr({
          interactive: !0,
          label: R,
          eventMode: "static",
          hitArea: new hi(0, 0, S(U)),
          cursor: "pointer",
        })
          .circle(0, 0, S(U))
          .fill({ color: Ct ? _["--light"] : v(U) })
          .on("pointerover", (Xe) => {
            ;(G(Xe.target.label), (at = V.alpha), P || H())
          })
          .on("pointerleave", () => {
            ;(G(null), (V.alpha = at), P || H())
          })
      ;(Ct && hr.stroke({ width: 2, color: _["--tertiary"] }), X.addChild(hr), O.addChild(V))
      let Sn = { simulationData: U, gfx: hr, label: V, color: v(U), alpha: 1, active: !1 }
      E.push(Sn)
    }
    for (let U of e.links) {
      let R = new Pr({ interactive: !1, eventMode: "none" })
      it.addChild(R)
      let V = { simulationData: U, gfx: R, color: _["--lightgray"], alpha: 1, active: !1 }
      T.push(V)
    }
    let ut = Yr
    if (i)
      $t(D.canvas).call(
        Ul()
          .container(() => D.canvas)
          .subject(() => e.nodes.find((U) => U.id === y))
          .on("start", function (R) {
            ;(R.active || g.alphaTarget(1).restart(),
              (R.subject.fx = R.subject.x),
              (R.subject.fy = R.subject.y),
              (R.subject.__initialDragPos = {
                x: R.subject.x,
                y: R.subject.y,
                fx: R.subject.fx,
                fy: R.subject.fy,
              }),
              (B = Date.now()),
              (P = !0))
          })
          .on("drag", function (R) {
            let V = R.subject.__initialDragPos
            ;((R.subject.fx = V.x + (R.x - V.x) / ut.k), (R.subject.fy = V.y + (R.y - V.y) / ut.k))
          })
          .on("end", function (R) {
            if (
              (R.active || g.alphaTarget(0),
              (R.subject.fx = null),
              (R.subject.fy = null),
              (P = !1),
              Date.now() - B < 500)
            ) {
              let V = e.nodes.find((Ct) => Ct.id === R.subject.id),
                at = Fl(Rl(t, V.id))
              window.spaNavigate(at)
            }
          }),
      )
    else
      for (let U of E)
        U.gfx.on("click", () => {
          let R = Fl(Rl(t, U.simulationData.id))
          window.spaNavigate(R)
        })
    n &&
      $t(D.canvas).call(
        oc()
          .extent([
            [0, 0],
            [f, d],
          ])
          .scaleExtent([0.25, 4])
          .on("zoom", ({ transform: U }) => {
            ;((ut = U), Y.scale.set(U.k, U.k), Y.position.set(U.x, U.y))
            let R = U.k * l,
              V = Math.max((R - 1) / 3.75, 0),
              at = E.filter((Ct) => Ct.active).flatMap((Ct) => Ct.label)
            for (let Ct of O.children) at.includes(Ct) || (Ct.alpha = V)
          }),
      )
    let It = !1
    function vt(U) {
      if (!It) {
        for (let R of E) {
          let { x: V, y: at } = R.simulationData
          !V ||
            !at ||
            (R.gfx.position.set(V + f / 2, at + d / 2),
            R.label && R.label.position.set(V + f / 2, at + d / 2))
        }
        for (let R of T) {
          let V = R.simulationData
          ;(R.gfx.clear(),
            R.gfx.moveTo(V.source.x + f / 2, V.source.y + d / 2),
            R.gfx
              .lineTo(V.target.x + f / 2, V.target.y + d / 2)
              .stroke({ alpha: R.alpha, width: 1, color: R.color }))
        }
        ;(F.forEach((R) => R.update(U)), D.renderer.render(Y), requestAnimationFrame(vt))
      }
    }
    return (
      requestAnimationFrame(vt),
      () => {
        ;((It = !0), D.destroy())
      }
    )
  }
  function YE(r, t) {
    let e = [],
      i = []
    function n() {
      for (let o of e) o()
      e = []
    }
    function s() {
      for (let o of i) o()
      i = []
    }
    document.addEventListener("nav", async (o) => {
      let a = o.detail.url
      async function u() {
        n()
        let x = document.getElementsByClassName("graph-container")
        for (let m of x) e.push(await r(m, a))
      }
      await u()
      let l = () => {
        u()
      }
      ;(document.addEventListener("themechange", l),
        window.addCleanup(() => {
          document.removeEventListener("themechange", l)
        }))
      let c = [...document.getElementsByClassName("global-graph-outer")]
      async function h() {
        let x = Pn(window)
        for (let m of c) {
          m.classList.add("active")
          let _ = m.closest(".sidebar")
          _ && (_.style.zIndex = "1")
          let v = m.querySelector(".global-graph-container")
          ;(WE(m, () => f()), v && i.push(await t(v, x)))
        }
      }
      function f() {
        s()
        for (let x of c) {
          x.classList.remove("active")
          let m = x.closest(".sidebar")
          m && (m.style.zIndex = "")
        }
      }
      async function d(x) {
        x.key === "g" &&
          (x.ctrlKey || x.metaKey) &&
          !x.shiftKey &&
          (x.preventDefault(), c.some((_) => _.classList.contains("active")) ? f() : h())
      }
      let g = document.querySelector("#global-graph")
      if (g) {
        let x = () => {
          c.some((_) => _.classList.contains("active")) ? f() : h()
        }
        ;(g.addEventListener("click", x),
          window.addCleanup(() => g.removeEventListener("click", x)))
      }
      ;(document.addEventListener("keydown", d),
        window.addCleanup(() => {
          ;(document.removeEventListener("keydown", d), n(), s())
        }))
    })
  }
  var Tl = class extends Qo {
    async onInitialize() {
      let t =
        document.querySelector(".graph-container") ??
        document.querySelector(".global-graph-container")
      if (t) {
        let e = Pn(window)
        await this.renderAndCleanupGraph(t, e)
      }
    }
    onSetupEventListeners() {
      ;(YE(
        async (t, e) => {
          let i = fetch("/.data/contentIndex.json").then((s) => s.json()),
            n = await jo(t, e, i)
          return Ko(t, e, n)
        },
        async (t, e) => {
          let i = fetch("/.data/contentIndex.json").then((s) => s.json()),
            n = await jo(t, e, i)
          return Ko(t, e, n)
        },
      ),
        document.addEventListener("reinit-graph", async (t) => {
          console.log("reinit-graph", t)
          let e = document.getElementById("graph-container")
          if (e) {
            let i = t.detail.url,
              n = fetch("/.data/contentIndex.json").then((o) => o.json()),
              s = await jo(e, i, n)
            await Ko(e, i, s)
          }
        }),
        document.addEventListener("nav", (t) => {
          $E(t.detail.url)
        }))
    }
    findComponentElements() {
      return Array.from(document.querySelectorAll(".graph-container"))
    }
    onCleanup() {}
    onSetupPage(t) {
      t.forEach((e) => {
        let i = Pn(window)
        this.renderAndCleanupGraph(e, i)
      })
    }
    async renderAndCleanupGraph(t, e) {
      let i = fetch("/.data/contentIndex.json").then((o) => o.json()),
        n = await jo(t, e, i),
        s = await Ko(t, e, n)
      this.state.cleanupTasks.push(s)
    }
  }
  var DP = new Tl({
    name: "graph",
    debug: !0,
    enableLazyLoad: !0,
    lazyLoadRootMargin: "50px",
    enablePreload: !0,
    preloadDelay: 2e3,
  })
  Dn.register("graph", DP)
  Dn.initialize("graph").catch((r) => {
    console.error("Graph component initialization failed:", r)
  })
})()
